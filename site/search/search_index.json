{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Welcome"},{"location":"libs/","text":"Libraries Index \u00b6","title":"Libraries Index"},{"location":"libs/#libraries-index","text":"","title":"Libraries Index"},{"location":"reference/","text":"Tech Index \u00b6","title":"Index"},{"location":"reference/#tech-index","text":"","title":"Tech Index"},{"location":"4zp/","text":"Welcome to 4ZeroPlatform \u00b6 4ZeroPlatform is a plug-and-play data gathering, processing, and reporting solution for small and large enterprises who need to achieve full visibility and optimization of Industrial Processes. 4zeroPlatform is composed of: 4ZeroBox, a versatile data acquisition unit, based on 32-bit microcontroller programmable in Python thanks to Zerynth; while allowing to acquire data from the PLC via digital ports, filtering the data onboard to avoid bandwidth overload and waste of cloud resources \u2013 it also enables the installation and management of external sensors, for a full Industrial IoT experience; The 4ZeroManager is a Cloud or \u201con-premise\u201d system for device and data management and integration with ERP, MES and BI tools; it allows to provision each device for a correct configuration, to send commands or firmware updates over the air (FOTA), to receive data for aggregation and subsequent analysis, and to foward data and events to third party services based on Azure, IBM cloud, Google IoT and others. 4ZeroPlatform is a tool designed for Industry 4.0 solution providers and thanks to its versatility it can be adapted to any industrial context. 4ZeroPlatform lets the user choose the best installation strategy, adapting it to the specific industrial environment. 4ZeroPlatform Configurator \u00b6 The 4ZeroPlatform Configurator is the tool that guides you during the installation of all the required software, drivers, libraries and tools needed for programming the 4ZeroBox and using the 4ZeroManager. Download the 4ZeroPlatform Configurator and start the setup procedure by visiting: getting-started . 4ZeroBox \u00b6 The 4ZeroBox is a modular hardware electronic unit that simplifies the development of Industrial IoT applications allowing rapid integration with sensors, actuators, and Cloud services. 4ZeroBox mounts a powerful ESP32 Microcontroller by Espressif Systems (240MHz, 4Mb Flash, 512KB SRAM) and provides many onboard features like: a DIN-rail mountable case with industrial grade sensor channels, support for Wi-fi, Bluetooth, Ethernet, LoRa, CAN, RS485, RS232, SD Card, JTAG, I2C, SPI; last but not least, there are 2 on-board MikroBUS sockets to extend the 4ZeroBox with hundreds of MikroElektronika click boards (see \u201cMikroBus Slots\u201d section). You can find more info about 4ZeroBox here . 4ZeroManager \u00b6 The 4ZeroManager is a device management service for organizing, monitoring, and remotely updating connected devices at scale. The 4ZeroManager includes a web interface for the control of connected devices and for the customization of data forwarding toward other services (e.i. MES, ERP, BI tools, etc.) via REST API or MQTT connection. The 4ZeroManager can be also extended on request with dedicated data processing services and visualization dashboards. You can find more info about how to use 4ZeroManager here . Programming Suite \u00b6 The 4ZeroBox official programming framework is Zerynth . Zerynth allows programming the 4ZeroBox applications in Python (or hybrid C/Python). Zerynth includes a compiler, debugger, and an editor, alongside tutorials and example projects for an easy learning experience. The 4ZeroBox includes a Zerynth\u00ae Virtual Machine Premium License, thus it is programmable in Zerynth free and without limitations. Zerynth\u00ae and all the required libraries will be installed by the 4ZeroPlatform Configurator during the setup phase. API \u00b6 Our services expose some RESTful API for developing external tools and platforms and integrate them with the 4ZeroPlatform. The full documentation can be found here .","title":"Index"},{"location":"4zp/#welcome-to-4zeroplatform","text":"4ZeroPlatform is a plug-and-play data gathering, processing, and reporting solution for small and large enterprises who need to achieve full visibility and optimization of Industrial Processes. 4zeroPlatform is composed of: 4ZeroBox, a versatile data acquisition unit, based on 32-bit microcontroller programmable in Python thanks to Zerynth; while allowing to acquire data from the PLC via digital ports, filtering the data onboard to avoid bandwidth overload and waste of cloud resources \u2013 it also enables the installation and management of external sensors, for a full Industrial IoT experience; The 4ZeroManager is a Cloud or \u201con-premise\u201d system for device and data management and integration with ERP, MES and BI tools; it allows to provision each device for a correct configuration, to send commands or firmware updates over the air (FOTA), to receive data for aggregation and subsequent analysis, and to foward data and events to third party services based on Azure, IBM cloud, Google IoT and others. 4ZeroPlatform is a tool designed for Industry 4.0 solution providers and thanks to its versatility it can be adapted to any industrial context. 4ZeroPlatform lets the user choose the best installation strategy, adapting it to the specific industrial environment.","title":"Welcome to 4ZeroPlatform"},{"location":"4zp/#4zeroplatform-configurator","text":"The 4ZeroPlatform Configurator is the tool that guides you during the installation of all the required software, drivers, libraries and tools needed for programming the 4ZeroBox and using the 4ZeroManager. Download the 4ZeroPlatform Configurator and start the setup procedure by visiting: getting-started .","title":"4ZeroPlatform Configurator"},{"location":"4zp/#4zerobox","text":"The 4ZeroBox is a modular hardware electronic unit that simplifies the development of Industrial IoT applications allowing rapid integration with sensors, actuators, and Cloud services. 4ZeroBox mounts a powerful ESP32 Microcontroller by Espressif Systems (240MHz, 4Mb Flash, 512KB SRAM) and provides many onboard features like: a DIN-rail mountable case with industrial grade sensor channels, support for Wi-fi, Bluetooth, Ethernet, LoRa, CAN, RS485, RS232, SD Card, JTAG, I2C, SPI; last but not least, there are 2 on-board MikroBUS sockets to extend the 4ZeroBox with hundreds of MikroElektronika click boards (see \u201cMikroBus Slots\u201d section). You can find more info about 4ZeroBox here .","title":"4ZeroBox"},{"location":"4zp/#4zeromanager","text":"The 4ZeroManager is a device management service for organizing, monitoring, and remotely updating connected devices at scale. The 4ZeroManager includes a web interface for the control of connected devices and for the customization of data forwarding toward other services (e.i. MES, ERP, BI tools, etc.) via REST API or MQTT connection. The 4ZeroManager can be also extended on request with dedicated data processing services and visualization dashboards. You can find more info about how to use 4ZeroManager here .","title":"4ZeroManager"},{"location":"4zp/#programming-suite","text":"The 4ZeroBox official programming framework is Zerynth . Zerynth allows programming the 4ZeroBox applications in Python (or hybrid C/Python). Zerynth includes a compiler, debugger, and an editor, alongside tutorials and example projects for an easy learning experience. The 4ZeroBox includes a Zerynth\u00ae Virtual Machine Premium License, thus it is programmable in Zerynth free and without limitations. Zerynth\u00ae and all the required libraries will be installed by the 4ZeroPlatform Configurator during the setup phase.","title":"Programming Suite"},{"location":"4zp/#api","text":"Our services expose some RESTful API for developing external tools and platforms and integrate them with the 4ZeroPlatform. The full documentation can be found here .","title":"API"},{"location":"4zp/4ZeroBox/","text":"4ZeroBox device \u00b6 A machine-to-cloud interface that can be plugged into old and modern industrial machines. Pin mapping \u00b6 Interrupts \u00b6 It\u2019s possible to use interrupts to register callback functions to be called when a certain pin change status from HIGH to LOW (pin fall ) or from LOW to HIGH (pin rise ). Pins that can be used in this way are D16 (MikroBUS Slot1), D34 and D39 (MikroBUS Slot1 or J4). Refer to the official Zerynth example to learn how to use them. Flash Layout \u00b6 The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved Device Summary \u00b6 Analog and digital ports for connection to industrial sensors and PLC. Modular hardware with infinite configuration. Multi-connectivity: GSM, Wi-Fi, Bluetooth, LoRa, Ethernet. Can retain and store data locally when disconnected. Secure hardware encryption and Blockchain-ready. Python-programmable thanks to Zerynth technology. Power \u00b6 When programming, power to the 4ZeroBox is supplied via the on-board USB Micro B connector, and the jumper JP1 must be set to U5V position. When not programming, external power supply it\u2019s possible from 24 VDC, setting the JP1 jumper to E5V position. There is also a JST connector for LiPo 3.7/4.2V batteries with charger circuit integrated. Note The jumper JP1 select from USB or external 24 VDC power supply, but the switch to battery is done automatically. Connect, Register, Virtualize and Program \u00b6 The 4ZeroBox comes with a serial-to-usb chip on board that allows programming and opening the UART of the ESP32 module. The CH340 USB to UART chip is also connected to the boot pins of the module, allowing for a seamless virtualization of the device. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the 4ZeroBox device is recognized by Zerynth Studio. The next steps are: Select the 4ZeroBox on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. After virtualization, the 4ZeroBox is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Resources \u00b6 For more infos about electrical connections, and how to use 4ZeroBox with sensors and other hardware, see the user manual. Other useful documents are: Datasheet Quick Guide Firmware Over the Air update (FOTA) \u00b6 FOTA updates are supported, including this library in a Zerynth project automatically set up all the needed informations and nothing else must be done for using them. Please refer to this section for learning how to flash a new firmware remotely. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) Secure Firmware \u00b6 The VM includes some safety measures to avoid malfunctioning. A hardware watchdog is present on the ESP32 microcontroller and must be set up and kicked in a loop to avoid board resets. Check the examples included to see how to properly kick the watchdog. Missing features \u00b6 Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support 4ZeroBox library \u00b6 This documentations refers to the Zerynth library used in programming a 4ZeroBox. This module exports a FourZeroBox class containing all the available methods for controlling onboard devices of a 4ZeroBox (e.g. leds, relays, I2C, \u2026). Warning This library is using the Zerynth conditional compilation feature. This means that some of the methods documented below must be explicitly enabled in a separate configuration file called project.yml . A default configuration file is included within the examples, structured like this: # project.yml config : # fourzerobox defines # enable ethernet connection NETWORK_ETH : null # enable wifi connection NETWORK_WIFI : true # enable ADC 0-10v/4-20mA peripheral ADC_010_420 : null # enable ADC resistive peripheral ADC_RESISTIVE : null # enable ADC current peripheral ADC_CURRENT : null # enable can peripheral CAN_ENABLE : null # enable RS485 peripheral RS485_ENABLE : null # enable RS232 peripheral RS232_ENABLE : null # fourzeroplatform defines # enable HW crypto ZERYNTH_HWCRYPTO_ATECCx08A : true # enable stored certificate CERT_STORED : true # enable provate key and certificate from resources CERT_SOURCE : null # enable DEBUG for fourzerobox DEBUG_FZB : null # enable DEBUG for fourzeromanager DEBUG_FZM : null # enable SD Card SDCARD_ENABLED : null Default sinks and relays status \u00b6 At startup, every sink and relay is set to a default LOW state. Be sure to read the 4ZeroBox user manual to check available peripherals. FourZeroBox class \u00b6 Class for controlling a 4ZeroBox. Initialize it with: from fourzerobox import FourZeroBox box = FourZeroBox () Available methods \u00b6 Constructor __init__ ( i2c_clk = 400000 , spi_clk = 1000000 ) Initialize the class specifying what features must be enabled and configuring the clock speed of I2C and SPI protocols. Parameters: i2c_clk \u2013 Clock for connected I2C devices, in Hz. (D=400000) spi_clk \u2013 Clock for connected SPI devices, in Hz. (D=1000000) config_adc_010_420(ch, pga, sps) This method configure one of the four 0-10V/4-20mA ADC channels (chosen using the ch parameter). Parameters: ch \u2013 Chose the channel to be configured (can be 1, 2, 3, 4). pga \u2013 Set the PGA Gain. sps \u2013 Set the samples-per-second data rate. set_conversion_010_420(ch, y_min, y_max, offset=0, under_x=None, over_x=None) Set the conversion method to be applied for the data read from the 0-10V/4-20mA ADC. The conversion scale can be configured using the y_min and y_max parameters, and optionally it can also be set an offset and tresholds for the input data. Parameters: ch \u2013 Chose the channel to be configured (can be 1, 2, 3, 4). y_min \u2013 Set the minimum value for the linear scale. y_max \u2013 Set the maximum value for the linear scale. offset \u2013 Optionally set an offset to be applied. (D=0) under_x \u2013 Optionally set a minimum treshold. (D=None) over_x \u2013 Optionally set a maximum treshold. (D=None) config_adc_resistive(ch, pga, sps) This method configure one of the four resistive ADC channels (chosen using the ch parameter). Parameters: ch \u2013 Chose the channel to be configured (can be 1, 2, 3, 4). pga \u2013 Set the PGA Gain. sps \u2013 Set the samples-per-second data rate. set_conversion_resistive(ch, v_min, ref_table, delta, offset=0, out_of_range=None) Set the conversion method to be applied for the data read from the resistive ADC. The conversion table can be configured using the v_min , ref_table and delta parameters. out_of_range is the value returned when the conversion exceed the bounds of the lookup table, defaults to None. Parameters: ch \u2013 Chose the channel to be configured (can be 1, 2, 3, 4). v_min \u2013 Set the minimum value of the table. ref_table \u2013 List of numbers representing the lookup table values to be used for scale. delta \u2013 Step between two adjacent element of the table. offset \u2013 Optionally set an offset to be applied. (D=0) out_of_range \u2013 Value returned if a value can\u2019t be found on the table. (D=None) config_adc_current(ch, pga, sps) This method configure one of the three current ADC channels. Parameters: ch \u2013 Chose the channel to be configured (can be 1, 2, 3). pga \u2013 Set the PGA Gain. sps \u2013 Set the samples-per-second data rate. set_conversion_current(ch, n_samples=400, ncoil=1, ratio=2000, voltage=220, offset=0) This method set the conversion parameters of a channel of the current ADC. It is possible to configure the numbr of samples that must be acquired, the number of coils done around the sensor, the ratio of the external sensor, and an offset. Parameters: ch \u2013 Chose the channel to be configured (can be 1, 2, 3). n_samples \u2013 Set the number of samples to be read before conversion. (D=400) ncoil \u2013 Set the number of coils around the sensor. (D=1) ratio \u2013 Set the ratio current acquired by the sensor. (D=2000) voltage \u2013 Set the voltage of the current. (D=220) offset \u2013 Set an offset for the read data. (D=0) set_led(color) Set the LED status to a custom color. Parameters: color \u2013 Character representing a color, see the table below. Available colors \u00b6 Char Color R Red G Green B Blue M Magenta Y Yellow C Cyan W White clear_led() Clear LED status. pulse(color, duration) Turn on the LED with the chosen color, then turn it off after the specified amount of time. Parameters: color \u2013 Char representing a color. See set_led for a list. duration \u2013 Amount of time in milliseconds. reverse_pulse(color, duration) Wait the specified amount of time, the turn the LED on with the selected color. Parameters: color \u2013 Char representing a color. See set_led for a list. duration \u2013 Amount of time in milliseconds. error_sys() Set the LED status to a system error. error_connect() Set the LED status to a net connection error. error_cloud() Set the LED status to a cloud connection error. error_custom() Set the LED status to a custom error, specifying color, duration, and the numer of pulses. Parameters: color \u2013 Char representing a color. See set_led for a list. duration \u2013 Amount of time in milliseconds for each pulse. n_pulses \u2013 Number of performed pulses. shut_down() Turn off every external peripheral of the board. This includes the the three ADC, etc. power_on() Turn back on the external peripherals, such as ADCs. relay_on(n_rel) Switch the selected relay ON, COM contact is closed on NO contact. Parameters: n_rel \u2013 Relay to be turned on, possible values are 1 or 2. relay_off(n_rel) Switch the selected relay OFF, COM contact is closed on NC contact. Parameters: n_rel \u2013 Relay to be turned off, possible values are 1 or 2. sink_on(n_snk) Switch the selected sink ON, Sink channel is shorted to GND. Parameters: n_snk \u2013 Sink to be turned on, possible values are 1 or 2. sink_off(n_snk) Switch the selected sink OFF, Sink channel is shorted to GND. Parameters: n_snk \u2013 Sink to be turned off, possible values are 1 or 2. get_opto(n_opto) Get the value read from the selected opto. Parameters: n_opto \u2013 Opto to read data from. Possible values are 1 or 2. get_battery_status() If alimented by a battery, return the current status as string that can be one of \u201ccharged\u201d, \u201ccharging\u201d, or \u201cdischarging\u201d. get_power_source() Get a string representing the alimentation source for the box. The returned string can be one of \u201cexternal\u201d or \u201cbattery\u201d. read_010(ch, raw=False, electric_value=False) Read value from the 0-10V ADC. It is possible to get the raw data from the ADC, or the electric value of the read signal. Parameters: ch \u2013 Select the ADC channel to read from. Can be one of 1, 2, 3, 4. raw \u2013 If set, the raw data of the ADC is returned. (D=False) electric_value \u2013 If set, the electric value is returned. (D=False) read_420(ch, raw=False, electric_value=False) Read value from the 4-20mA ADC. It is possible to get the raw data from the ADC, or the electric value of the read signal, or by default it is converted with the rules defined using set_conversion_010_420 method. Parameters: ch \u2013 Select the ADC channel to read from. Can be one of 1, 2, 3, 4. raw \u2013 If set, the raw data of the ADC is returned. (D=False) electric_value \u2013 If set, the electric value is returned. (D=False) read_resistive(ch, raw=False, electric_value=False) Read value from the resistive ADC. It is possible to get the raw data from the ADC, or the electric value of the read signal, or by default it is converted with the rules defined using set_conversion_resistive method. Parameters: ch \u2013 Select the ADC channel to read from. Can be one of 1, 2, 3, 4. raw \u2013 If set, the raw data of the ADC is returned. (D=False) electric_value \u2013 If set, the electric value is returned. (D=False) read_power(ch, raw=False, electric_value=False) Read value from the power ADC. It is possible to get the raw data from the ADC, or the electric value of the read signal, or by default it is converted with the rules defined using set_conversion_current method. Parameters: ch \u2013 Select the ADC channel to read from. Can be one of 1, 2, 3. raw \u2013 If set, the raw data of the ADC is returned. (D=False) electric_value \u2013 If set, the electric value is returned. (D=False) net_init(static_ip=None, static_mask=None, static_gateway=None, static_dns=None) Initialize network driver. Optionally a static ip address, subnet mask, gateway address, and a DNS server address can be configured, otherwise they are obtained using DHCP. Parameters: static_ip \u2013 Static IP address of the device. (D=None) static_mask \u2013 Static subnet mask. (D=None) static_gateway \u2013 Static gateway address. (D=None) static_dns \u2013 Static DNS server address. (D=None) net_connect() \u2013 Ethernet Connect to the network using the Ethernet interface. This method is enabled at compilation time using the NETWORK_ETH flag. Warning Use only one of NETWORK_ETH , NETWORK_WIFI . net_connect(ssid, password, keying=net.WIFI_WPA2) \u2013 Wi-Fi Connect to the network using the Wi-Fi interface. This method is enabled at compilation time using the NETWORK_WIFI flag. Warning Use only one of NETWORK_ETH , NETWORK_WIFI . Parameters: ssid \u2013 SSID of the Wi-fi network to connect to. password \u2013 Password of the Wi-Fi network. keying \u2013 Encryption type. (D=net.WIFI_WPA2) get_rssi() Get RSSI of the current wireless connection. read_rs485(timeout=3000) Read from the RS485 peripheral (it must be enabled in the class constructor). After the timeout expires, None is returned. Parameters: timeout \u2013 Maximum timeout to wait for a message in milliseconds. (D=3000) write_rs485(msg) Write to the RS485 peripheral (it must be enabled in the class constructor). Parameters: msg \u2013 Message to be sent. read_rs232(timeout=3000) Read from the RS232 peripheral (it must be enabled in the class constructor). After the timeout expires, None is returned. Parameters: timeout \u2013 Maximum timeout to wait for a message in milliseconds. (D=3000) write_rs232(msg) Write to the RS232 peripheral (it must be enabled in the class constructor). Parameters: msg \u2013 Message to be sent. can_init(idmode, speed, clock) Initialize the CAN interface. Parameters: idmode \u2013 Set the RX buffer id mode (selectable from mcp2515.MCP_STDEXT, mcp2515.MCP_STD, mcp2515.MCP_EXT, or mcp2515.MCP_ANY. speed \u2013 Set the speed of the CAN communication. clock \u2013 Set the clock of the CAN Communication. set_can_mode(mode) Set CAN to the specified mode. Parameters: mode \u2013 The mode to be set. One of (\u201cNORMAL\u201d, \u201cSLEEP\u201d, \u201cLOOPBACK\u201d, \u201cLISTENONLY\u201d, \u201cCONFIG\u201d, \u201cPOWERUP\u201d, \u201cONE_SHOT\u201d). can_init_mask(num, data, ext) Init masks. Parameters: num \u2013 0 to set mask 0 on RX buffer, 1 to set mask 1 on RX buffer data \u2013 Data mask. ext \u2013 0 for standard ID, 1 for Extended ID. can_init_filter(num, data, ext) Init filters. Parameters: num \u2013 Number of filter to be set in RX buffer (from 0 to 5). data \u2013 Data filter. ext \u2013 0 for standard ID, 1 for Extended ID. can_send(canid, data, ext=None) Sends CAN messages. Parameters: canid \u2013 ID of the CAN message (bytearray of 4 bytes). data \u2013 Data to be sent (list of 8 bytes). ext \u2013 0 for standard ID, 1 for Extended ID (D=None, auto detected) can_receive() Receives CAN messages returning CAN id value and related data message. sd_init(mode) Initialize a SD card, using the SPI slot or the SD slot. Parameters: mode \u2013 One of \u201cSD\u201d, \u201cSPI\u201d. flash_load(start_address, tot_size, rjson=False) Load a file from the internal flash memory. Parameters: start_address \u2013 The address of the file beginning. tot_size \u2013 The size of the file to be read. r_json \u2013 If set, the file is parsed as a JSON and a dict return. (D=False) flash_write_buff(start_address, tot_size, buff, seek=None) Write a buffer in the internal flash memory, at the specified address. Parameters: start_address \u2013 Initial address of the memory to be written. tot_size \u2013 Total size of the data to be written. buff \u2013 Buffer of data to be written. seek \u2013 Optional seek destionation to be done before writing. (D=None) flash_read_buff(start_address, tot_size) Return a buffer of data read at the specified start address. Parameters: start_address \u2013 Initial address to read from. tot_size \u2013 Total size of data to be read.","title":"4ZeroBox"},{"location":"4zp/4ZeroBox/#4zerobox-device","text":"A machine-to-cloud interface that can be plugged into old and modern industrial machines.","title":"4ZeroBox device"},{"location":"4zp/4ZeroBox/#pin-mapping","text":"","title":"Pin mapping"},{"location":"4zp/4ZeroBox/#interrupts","text":"It\u2019s possible to use interrupts to register callback functions to be called when a certain pin change status from HIGH to LOW (pin fall ) or from LOW to HIGH (pin rise ). Pins that can be used in this way are D16 (MikroBUS Slot1), D34 and D39 (MikroBUS Slot1 or J4). Refer to the official Zerynth example to learn how to use them.","title":"Interrupts"},{"location":"4zp/4ZeroBox/#flash-layout","text":"The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved","title":"Flash Layout"},{"location":"4zp/4ZeroBox/#device-summary","text":"Analog and digital ports for connection to industrial sensors and PLC. Modular hardware with infinite configuration. Multi-connectivity: GSM, Wi-Fi, Bluetooth, LoRa, Ethernet. Can retain and store data locally when disconnected. Secure hardware encryption and Blockchain-ready. Python-programmable thanks to Zerynth technology.","title":"Device Summary"},{"location":"4zp/4ZeroBox/#power","text":"When programming, power to the 4ZeroBox is supplied via the on-board USB Micro B connector, and the jumper JP1 must be set to U5V position. When not programming, external power supply it\u2019s possible from 24 VDC, setting the JP1 jumper to E5V position. There is also a JST connector for LiPo 3.7/4.2V batteries with charger circuit integrated. Note The jumper JP1 select from USB or external 24 VDC power supply, but the switch to battery is done automatically.","title":"Power"},{"location":"4zp/4ZeroBox/#connect-register-virtualize-and-program","text":"The 4ZeroBox comes with a serial-to-usb chip on board that allows programming and opening the UART of the ESP32 module. The CH340 USB to UART chip is also connected to the boot pins of the module, allowing for a seamless virtualization of the device. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the 4ZeroBox device is recognized by Zerynth Studio. The next steps are: Select the 4ZeroBox on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. After virtualization, the 4ZeroBox is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio.","title":"Connect, Register, Virtualize and Program"},{"location":"4zp/4ZeroBox/#resources","text":"For more infos about electrical connections, and how to use 4ZeroBox with sensors and other hardware, see the user manual. Other useful documents are: Datasheet Quick Guide","title":"Resources"},{"location":"4zp/4ZeroBox/#firmware-over-the-air-update-fota","text":"FOTA updates are supported, including this library in a Zerynth project automatically set up all the needed informations and nothing else must be done for using them. Please refer to this section for learning how to flash a new firmware remotely. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1)","title":"Firmware Over the Air update (FOTA)"},{"location":"4zp/4ZeroBox/#secure-firmware","text":"The VM includes some safety measures to avoid malfunctioning. A hardware watchdog is present on the ESP32 microcontroller and must be set up and kicked in a loop to avoid board resets. Check the examples included to see how to properly kick the watchdog.","title":"Secure Firmware"},{"location":"4zp/4ZeroBox/#missing-features","text":"Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"Missing features"},{"location":"4zp/4ZeroBox/#4zerobox-library","text":"This documentations refers to the Zerynth library used in programming a 4ZeroBox. This module exports a FourZeroBox class containing all the available methods for controlling onboard devices of a 4ZeroBox (e.g. leds, relays, I2C, \u2026). Warning This library is using the Zerynth conditional compilation feature. This means that some of the methods documented below must be explicitly enabled in a separate configuration file called project.yml . A default configuration file is included within the examples, structured like this: # project.yml config : # fourzerobox defines # enable ethernet connection NETWORK_ETH : null # enable wifi connection NETWORK_WIFI : true # enable ADC 0-10v/4-20mA peripheral ADC_010_420 : null # enable ADC resistive peripheral ADC_RESISTIVE : null # enable ADC current peripheral ADC_CURRENT : null # enable can peripheral CAN_ENABLE : null # enable RS485 peripheral RS485_ENABLE : null # enable RS232 peripheral RS232_ENABLE : null # fourzeroplatform defines # enable HW crypto ZERYNTH_HWCRYPTO_ATECCx08A : true # enable stored certificate CERT_STORED : true # enable provate key and certificate from resources CERT_SOURCE : null # enable DEBUG for fourzerobox DEBUG_FZB : null # enable DEBUG for fourzeromanager DEBUG_FZM : null # enable SD Card SDCARD_ENABLED : null","title":"4ZeroBox library"},{"location":"4zp/4ZeroBox/#default-sinks-and-relays-status","text":"At startup, every sink and relay is set to a default LOW state. Be sure to read the 4ZeroBox user manual to check available peripherals.","title":"Default sinks and relays status"},{"location":"4zp/4ZeroBox/#fourzerobox-class","text":"Class for controlling a 4ZeroBox. Initialize it with: from fourzerobox import FourZeroBox box = FourZeroBox ()","title":"FourZeroBox class"},{"location":"4zp/4ZeroBox/#available-methods","text":"Constructor __init__ ( i2c_clk = 400000 , spi_clk = 1000000 ) Initialize the class specifying what features must be enabled and configuring the clock speed of I2C and SPI protocols. Parameters: i2c_clk \u2013 Clock for connected I2C devices, in Hz. (D=400000) spi_clk \u2013 Clock for connected SPI devices, in Hz. (D=1000000) config_adc_010_420(ch, pga, sps) This method configure one of the four 0-10V/4-20mA ADC channels (chosen using the ch parameter). Parameters: ch \u2013 Chose the channel to be configured (can be 1, 2, 3, 4). pga \u2013 Set the PGA Gain. sps \u2013 Set the samples-per-second data rate. set_conversion_010_420(ch, y_min, y_max, offset=0, under_x=None, over_x=None) Set the conversion method to be applied for the data read from the 0-10V/4-20mA ADC. The conversion scale can be configured using the y_min and y_max parameters, and optionally it can also be set an offset and tresholds for the input data. Parameters: ch \u2013 Chose the channel to be configured (can be 1, 2, 3, 4). y_min \u2013 Set the minimum value for the linear scale. y_max \u2013 Set the maximum value for the linear scale. offset \u2013 Optionally set an offset to be applied. (D=0) under_x \u2013 Optionally set a minimum treshold. (D=None) over_x \u2013 Optionally set a maximum treshold. (D=None) config_adc_resistive(ch, pga, sps) This method configure one of the four resistive ADC channels (chosen using the ch parameter). Parameters: ch \u2013 Chose the channel to be configured (can be 1, 2, 3, 4). pga \u2013 Set the PGA Gain. sps \u2013 Set the samples-per-second data rate. set_conversion_resistive(ch, v_min, ref_table, delta, offset=0, out_of_range=None) Set the conversion method to be applied for the data read from the resistive ADC. The conversion table can be configured using the v_min , ref_table and delta parameters. out_of_range is the value returned when the conversion exceed the bounds of the lookup table, defaults to None. Parameters: ch \u2013 Chose the channel to be configured (can be 1, 2, 3, 4). v_min \u2013 Set the minimum value of the table. ref_table \u2013 List of numbers representing the lookup table values to be used for scale. delta \u2013 Step between two adjacent element of the table. offset \u2013 Optionally set an offset to be applied. (D=0) out_of_range \u2013 Value returned if a value can\u2019t be found on the table. (D=None) config_adc_current(ch, pga, sps) This method configure one of the three current ADC channels. Parameters: ch \u2013 Chose the channel to be configured (can be 1, 2, 3). pga \u2013 Set the PGA Gain. sps \u2013 Set the samples-per-second data rate. set_conversion_current(ch, n_samples=400, ncoil=1, ratio=2000, voltage=220, offset=0) This method set the conversion parameters of a channel of the current ADC. It is possible to configure the numbr of samples that must be acquired, the number of coils done around the sensor, the ratio of the external sensor, and an offset. Parameters: ch \u2013 Chose the channel to be configured (can be 1, 2, 3). n_samples \u2013 Set the number of samples to be read before conversion. (D=400) ncoil \u2013 Set the number of coils around the sensor. (D=1) ratio \u2013 Set the ratio current acquired by the sensor. (D=2000) voltage \u2013 Set the voltage of the current. (D=220) offset \u2013 Set an offset for the read data. (D=0) set_led(color) Set the LED status to a custom color. Parameters: color \u2013 Character representing a color, see the table below.","title":"Available methods"},{"location":"4zp/4ZeroBox/#available-colors","text":"Char Color R Red G Green B Blue M Magenta Y Yellow C Cyan W White clear_led() Clear LED status. pulse(color, duration) Turn on the LED with the chosen color, then turn it off after the specified amount of time. Parameters: color \u2013 Char representing a color. See set_led for a list. duration \u2013 Amount of time in milliseconds. reverse_pulse(color, duration) Wait the specified amount of time, the turn the LED on with the selected color. Parameters: color \u2013 Char representing a color. See set_led for a list. duration \u2013 Amount of time in milliseconds. error_sys() Set the LED status to a system error. error_connect() Set the LED status to a net connection error. error_cloud() Set the LED status to a cloud connection error. error_custom() Set the LED status to a custom error, specifying color, duration, and the numer of pulses. Parameters: color \u2013 Char representing a color. See set_led for a list. duration \u2013 Amount of time in milliseconds for each pulse. n_pulses \u2013 Number of performed pulses. shut_down() Turn off every external peripheral of the board. This includes the the three ADC, etc. power_on() Turn back on the external peripherals, such as ADCs. relay_on(n_rel) Switch the selected relay ON, COM contact is closed on NO contact. Parameters: n_rel \u2013 Relay to be turned on, possible values are 1 or 2. relay_off(n_rel) Switch the selected relay OFF, COM contact is closed on NC contact. Parameters: n_rel \u2013 Relay to be turned off, possible values are 1 or 2. sink_on(n_snk) Switch the selected sink ON, Sink channel is shorted to GND. Parameters: n_snk \u2013 Sink to be turned on, possible values are 1 or 2. sink_off(n_snk) Switch the selected sink OFF, Sink channel is shorted to GND. Parameters: n_snk \u2013 Sink to be turned off, possible values are 1 or 2. get_opto(n_opto) Get the value read from the selected opto. Parameters: n_opto \u2013 Opto to read data from. Possible values are 1 or 2. get_battery_status() If alimented by a battery, return the current status as string that can be one of \u201ccharged\u201d, \u201ccharging\u201d, or \u201cdischarging\u201d. get_power_source() Get a string representing the alimentation source for the box. The returned string can be one of \u201cexternal\u201d or \u201cbattery\u201d. read_010(ch, raw=False, electric_value=False) Read value from the 0-10V ADC. It is possible to get the raw data from the ADC, or the electric value of the read signal. Parameters: ch \u2013 Select the ADC channel to read from. Can be one of 1, 2, 3, 4. raw \u2013 If set, the raw data of the ADC is returned. (D=False) electric_value \u2013 If set, the electric value is returned. (D=False) read_420(ch, raw=False, electric_value=False) Read value from the 4-20mA ADC. It is possible to get the raw data from the ADC, or the electric value of the read signal, or by default it is converted with the rules defined using set_conversion_010_420 method. Parameters: ch \u2013 Select the ADC channel to read from. Can be one of 1, 2, 3, 4. raw \u2013 If set, the raw data of the ADC is returned. (D=False) electric_value \u2013 If set, the electric value is returned. (D=False) read_resistive(ch, raw=False, electric_value=False) Read value from the resistive ADC. It is possible to get the raw data from the ADC, or the electric value of the read signal, or by default it is converted with the rules defined using set_conversion_resistive method. Parameters: ch \u2013 Select the ADC channel to read from. Can be one of 1, 2, 3, 4. raw \u2013 If set, the raw data of the ADC is returned. (D=False) electric_value \u2013 If set, the electric value is returned. (D=False) read_power(ch, raw=False, electric_value=False) Read value from the power ADC. It is possible to get the raw data from the ADC, or the electric value of the read signal, or by default it is converted with the rules defined using set_conversion_current method. Parameters: ch \u2013 Select the ADC channel to read from. Can be one of 1, 2, 3. raw \u2013 If set, the raw data of the ADC is returned. (D=False) electric_value \u2013 If set, the electric value is returned. (D=False) net_init(static_ip=None, static_mask=None, static_gateway=None, static_dns=None) Initialize network driver. Optionally a static ip address, subnet mask, gateway address, and a DNS server address can be configured, otherwise they are obtained using DHCP. Parameters: static_ip \u2013 Static IP address of the device. (D=None) static_mask \u2013 Static subnet mask. (D=None) static_gateway \u2013 Static gateway address. (D=None) static_dns \u2013 Static DNS server address. (D=None) net_connect() \u2013 Ethernet Connect to the network using the Ethernet interface. This method is enabled at compilation time using the NETWORK_ETH flag. Warning Use only one of NETWORK_ETH , NETWORK_WIFI . net_connect(ssid, password, keying=net.WIFI_WPA2) \u2013 Wi-Fi Connect to the network using the Wi-Fi interface. This method is enabled at compilation time using the NETWORK_WIFI flag. Warning Use only one of NETWORK_ETH , NETWORK_WIFI . Parameters: ssid \u2013 SSID of the Wi-fi network to connect to. password \u2013 Password of the Wi-Fi network. keying \u2013 Encryption type. (D=net.WIFI_WPA2) get_rssi() Get RSSI of the current wireless connection. read_rs485(timeout=3000) Read from the RS485 peripheral (it must be enabled in the class constructor). After the timeout expires, None is returned. Parameters: timeout \u2013 Maximum timeout to wait for a message in milliseconds. (D=3000) write_rs485(msg) Write to the RS485 peripheral (it must be enabled in the class constructor). Parameters: msg \u2013 Message to be sent. read_rs232(timeout=3000) Read from the RS232 peripheral (it must be enabled in the class constructor). After the timeout expires, None is returned. Parameters: timeout \u2013 Maximum timeout to wait for a message in milliseconds. (D=3000) write_rs232(msg) Write to the RS232 peripheral (it must be enabled in the class constructor). Parameters: msg \u2013 Message to be sent. can_init(idmode, speed, clock) Initialize the CAN interface. Parameters: idmode \u2013 Set the RX buffer id mode (selectable from mcp2515.MCP_STDEXT, mcp2515.MCP_STD, mcp2515.MCP_EXT, or mcp2515.MCP_ANY. speed \u2013 Set the speed of the CAN communication. clock \u2013 Set the clock of the CAN Communication. set_can_mode(mode) Set CAN to the specified mode. Parameters: mode \u2013 The mode to be set. One of (\u201cNORMAL\u201d, \u201cSLEEP\u201d, \u201cLOOPBACK\u201d, \u201cLISTENONLY\u201d, \u201cCONFIG\u201d, \u201cPOWERUP\u201d, \u201cONE_SHOT\u201d). can_init_mask(num, data, ext) Init masks. Parameters: num \u2013 0 to set mask 0 on RX buffer, 1 to set mask 1 on RX buffer data \u2013 Data mask. ext \u2013 0 for standard ID, 1 for Extended ID. can_init_filter(num, data, ext) Init filters. Parameters: num \u2013 Number of filter to be set in RX buffer (from 0 to 5). data \u2013 Data filter. ext \u2013 0 for standard ID, 1 for Extended ID. can_send(canid, data, ext=None) Sends CAN messages. Parameters: canid \u2013 ID of the CAN message (bytearray of 4 bytes). data \u2013 Data to be sent (list of 8 bytes). ext \u2013 0 for standard ID, 1 for Extended ID (D=None, auto detected) can_receive() Receives CAN messages returning CAN id value and related data message. sd_init(mode) Initialize a SD card, using the SPI slot or the SD slot. Parameters: mode \u2013 One of \u201cSD\u201d, \u201cSPI\u201d. flash_load(start_address, tot_size, rjson=False) Load a file from the internal flash memory. Parameters: start_address \u2013 The address of the file beginning. tot_size \u2013 The size of the file to be read. r_json \u2013 If set, the file is parsed as a JSON and a dict return. (D=False) flash_write_buff(start_address, tot_size, buff, seek=None) Write a buffer in the internal flash memory, at the specified address. Parameters: start_address \u2013 Initial address of the memory to be written. tot_size \u2013 Total size of the data to be written. buff \u2013 Buffer of data to be written. seek \u2013 Optional seek destionation to be done before writing. (D=None) flash_read_buff(start_address, tot_size) Return a buffer of data read at the specified start address. Parameters: start_address \u2013 Initial address to read from. tot_size \u2013 Total size of data to be read.","title":"Available colors"},{"location":"4zp/4ZeroManager/","text":"4ZeroManager library \u00b6 This library is used for interfacing a device with the 4ZeroPlatform. Default available RPCs \u00b6 There are some RPC available by default that can be called without any further configuration after this library is imported. RPC name Description reset_mcu Trigger a full reset of the microcontroller. rpc_list RPC outputs and results. check_jobs Internal use only. This is triggered by a FOTA update. MQTT \u00b6 MQTT is a protocol made with IoT devices in mind. It\u2019s simple and with a low impact on required bandwidth and computational power. Every message is published to a certain topic . MQTT is being used by the 4ZeroPlatform for sending RPC to the device and eventually get the result of it, but also for sending any kind of sensor reading. The topics that are currently used are: | Topic | Description | |---------|----------------------------------------------| | adm_in | Trigger a full reset of the microcontroller. | | adm_out | RPC outputs and results. | | sink | Readings and data sent by the device. | Readings and data sent by the device. From the 4ZeroManager you can find a list of available MQTT urls for your device, already configured in the standard format :@host:port . FourZeroManager class \u00b6 A class called FourZeroManager is exported for managing a connection to the 4ZeroPlatform. Tipically it should be used like this: from fourzerobox import FourZeroBox from fourzeromanager import FourZeroManager my_box = FourZeroBox () manager = FourZeroManager ( my_box ) manager . config () manager . connect () Available methods \u00b6 Constructor __init__ ( fzbox , endpoint = None , project = None , thingname = None , rpc = None ) Init the class providing a FourZeroBox instance. The rpc optional parameter is a dictionary containing names and methods to be called, e.g.: def do_something (): return True rpc = { \"my_custom_rpc\" : do_something , } Optionally, some configuration variables such as the project and the device name, and the MQTT endpoint URL can be manually specified, otherwise they are read from the device flash memory. Parameters: fzbox \u2013 Instance of FourZeroBox . endpoint \u2013 AWS endpoint, provided by the 4ZeroPlatform. (D=None) project \u2013 Name of the project, must match the one in 4ZeroPlatform. (D=None) thingname \u2013 Name of the device, must match the one in 4ZeroPlatform. (D=None) rpc \u2013 Dict containing RPC names as keys and the functions to be called as values. (D=None) config() This method should be called after the class initialization, it registers a hander to be called for every MQTT message, and sends to the cloud the informations needed for a future FOTA update. connect() Wait for a connection to the MQTT server, then subscribe to the device channel. This method should be called after config() . publish(topic=None, data=None) Publish to the device MQTT topic some data. This method should be used when defining its own RPC methods, for sending results and data via internet. Parameters: topic \u2013 Optional, the destination topic. (D=None) data \u2013 Data to be sent. (D=None)","title":"4ZeroManager"},{"location":"4zp/4ZeroManager/#4zeromanager-library","text":"This library is used for interfacing a device with the 4ZeroPlatform.","title":"4ZeroManager library"},{"location":"4zp/4ZeroManager/#default-available-rpcs","text":"There are some RPC available by default that can be called without any further configuration after this library is imported. RPC name Description reset_mcu Trigger a full reset of the microcontroller. rpc_list RPC outputs and results. check_jobs Internal use only. This is triggered by a FOTA update.","title":"Default available RPCs"},{"location":"4zp/4ZeroManager/#mqtt","text":"MQTT is a protocol made with IoT devices in mind. It\u2019s simple and with a low impact on required bandwidth and computational power. Every message is published to a certain topic . MQTT is being used by the 4ZeroPlatform for sending RPC to the device and eventually get the result of it, but also for sending any kind of sensor reading. The topics that are currently used are: | Topic | Description | |---------|----------------------------------------------| | adm_in | Trigger a full reset of the microcontroller. | | adm_out | RPC outputs and results. | | sink | Readings and data sent by the device. | Readings and data sent by the device. From the 4ZeroManager you can find a list of available MQTT urls for your device, already configured in the standard format :@host:port .","title":"MQTT"},{"location":"4zp/4ZeroManager/#fourzeromanager-class","text":"A class called FourZeroManager is exported for managing a connection to the 4ZeroPlatform. Tipically it should be used like this: from fourzerobox import FourZeroBox from fourzeromanager import FourZeroManager my_box = FourZeroBox () manager = FourZeroManager ( my_box ) manager . config () manager . connect ()","title":"FourZeroManager class"},{"location":"4zp/4ZeroManager/#available-methods","text":"Constructor __init__ ( fzbox , endpoint = None , project = None , thingname = None , rpc = None ) Init the class providing a FourZeroBox instance. The rpc optional parameter is a dictionary containing names and methods to be called, e.g.: def do_something (): return True rpc = { \"my_custom_rpc\" : do_something , } Optionally, some configuration variables such as the project and the device name, and the MQTT endpoint URL can be manually specified, otherwise they are read from the device flash memory. Parameters: fzbox \u2013 Instance of FourZeroBox . endpoint \u2013 AWS endpoint, provided by the 4ZeroPlatform. (D=None) project \u2013 Name of the project, must match the one in 4ZeroPlatform. (D=None) thingname \u2013 Name of the device, must match the one in 4ZeroPlatform. (D=None) rpc \u2013 Dict containing RPC names as keys and the functions to be called as values. (D=None) config() This method should be called after the class initialization, it registers a hander to be called for every MQTT message, and sends to the cloud the informations needed for a future FOTA update. connect() Wait for a connection to the MQTT server, then subscribe to the device channel. This method should be called after config() . publish(topic=None, data=None) Publish to the device MQTT topic some data. This method should be used when defining its own RPC methods, for sending results and data via internet. Parameters: topic \u2013 Optional, the destination topic. (D=None) data \u2013 Data to be sent. (D=None)","title":"Available methods"},{"location":"4zp/4ZeroPlatform/","text":"Welcome to 4ZeroPlatform \u00b6 4ZeroPlatform is a plug-and-play data gathering, processing, and reporting solution for small and large enterprises who need to achieve full visibility and optimization of Industrial Processes. 4zeroPlatform is composed of: 4ZeroBox, a versatile data acquisition unit, based on 32-bit microcontroller programmable in Python thanks to Zerynth; while allowing to acquire data from the PLC via digital ports, filtering the data onboard to avoid bandwidth overload and waste of cloud resources \u2013 it also enables the installation and management of external sensors, for a full Industrial IoT experience; The 4ZeroManager is a Cloud or \u201con-premise\u201d system for device and data management and integration with ERP, MES and BI tools; it allows to provision each device for a correct configuration, to send commands or firmware updates over the air (FOTA), to receive data for aggregation and subsequent analysis, and to foward data and events to third party services based on Azure, IBM cloud, Google IoT and others. 4ZeroPlatform is a tool designed for Industry 4.0 solution providers and thanks to its versatility it can be adapted to any industrial context. 4ZeroPlatform lets the user choose the best installation strategy, adapting it to the specific industrial environment. 4ZeroPlatform Configurator \u00b6 The 4ZeroPlatform Configurator is the tool that guides you during the installation of all the required software, drivers, libraries and tools needed for programming the 4ZeroBox and using the 4ZeroManager. Download the 4ZeroPlatform Configurator and start the setup procedure by visiting: getting-started . 4ZeroBox \u00b6 The 4ZeroBox is a modular hardware electronic unit that simplifies the development of Industrial IoT applications allowing rapid integration with sensors, actuators, and Cloud services. 4ZeroBox mounts a powerful ESP32 Microcontroller by Espressif Systems (240MHz, 4Mb Flash, 512KB SRAM) and provides many onboard features like: a DIN-rail mountable case with industrial grade sensor channels, support for Wi-fi, Bluetooth, Ethernet, LoRa, CAN, RS485, RS232, SD Card, JTAG, I2C, SPI; last but not least, there are 2 on-board MikroBUS sockets to extend the 4ZeroBox with hundreds of MikroElektronika click boards (see \u201cMikroBus Slots\u201d section). You can find more info about 4ZeroBox here . 4ZeroManager \u00b6 The 4ZeroManager is a device management service for organizing, monitoring, and remotely updating connected devices at scale. The 4ZeroManager includes a web interface for the control of connected devices and for the customization of data forwarding toward other services (e.i. MES, ERP, BI tools, etc.) via REST API or MQTT connection. The 4ZeroManager can be also extended on request with dedicated data processing services and visualization dashboards. You can find more info about how to use 4ZeroManager here . Programming Suite \u00b6 The 4ZeroBox official programming framework is Zerynth . Zerynth allows programming the 4ZeroBox applications in Python (or hybrid C/Python). Zerynth includes a compiler, debugger, and an editor, alongside tutorials and example projects for an easy learning experience. The 4ZeroBox includes a Zerynth\u00ae Virtual Machine Premium License, thus it is programmable in Zerynth free and without limitations. Zerynth\u00ae and all the required libraries will be installed by the 4ZeroPlatform Configurator during the setup phase. API \u00b6 Our services expose some RESTful API for developing external tools and platforms and integrate them with the 4ZeroPlatform. The full documentation can be found here .","title":"4ZeroPlatform"},{"location":"4zp/4ZeroPlatform/#welcome-to-4zeroplatform","text":"4ZeroPlatform is a plug-and-play data gathering, processing, and reporting solution for small and large enterprises who need to achieve full visibility and optimization of Industrial Processes. 4zeroPlatform is composed of: 4ZeroBox, a versatile data acquisition unit, based on 32-bit microcontroller programmable in Python thanks to Zerynth; while allowing to acquire data from the PLC via digital ports, filtering the data onboard to avoid bandwidth overload and waste of cloud resources \u2013 it also enables the installation and management of external sensors, for a full Industrial IoT experience; The 4ZeroManager is a Cloud or \u201con-premise\u201d system for device and data management and integration with ERP, MES and BI tools; it allows to provision each device for a correct configuration, to send commands or firmware updates over the air (FOTA), to receive data for aggregation and subsequent analysis, and to foward data and events to third party services based on Azure, IBM cloud, Google IoT and others. 4ZeroPlatform is a tool designed for Industry 4.0 solution providers and thanks to its versatility it can be adapted to any industrial context. 4ZeroPlatform lets the user choose the best installation strategy, adapting it to the specific industrial environment.","title":"Welcome to 4ZeroPlatform"},{"location":"4zp/4ZeroPlatform/#4zeroplatform-configurator","text":"The 4ZeroPlatform Configurator is the tool that guides you during the installation of all the required software, drivers, libraries and tools needed for programming the 4ZeroBox and using the 4ZeroManager. Download the 4ZeroPlatform Configurator and start the setup procedure by visiting: getting-started .","title":"4ZeroPlatform Configurator"},{"location":"4zp/4ZeroPlatform/#4zerobox","text":"The 4ZeroBox is a modular hardware electronic unit that simplifies the development of Industrial IoT applications allowing rapid integration with sensors, actuators, and Cloud services. 4ZeroBox mounts a powerful ESP32 Microcontroller by Espressif Systems (240MHz, 4Mb Flash, 512KB SRAM) and provides many onboard features like: a DIN-rail mountable case with industrial grade sensor channels, support for Wi-fi, Bluetooth, Ethernet, LoRa, CAN, RS485, RS232, SD Card, JTAG, I2C, SPI; last but not least, there are 2 on-board MikroBUS sockets to extend the 4ZeroBox with hundreds of MikroElektronika click boards (see \u201cMikroBus Slots\u201d section). You can find more info about 4ZeroBox here .","title":"4ZeroBox"},{"location":"4zp/4ZeroPlatform/#4zeromanager","text":"The 4ZeroManager is a device management service for organizing, monitoring, and remotely updating connected devices at scale. The 4ZeroManager includes a web interface for the control of connected devices and for the customization of data forwarding toward other services (e.i. MES, ERP, BI tools, etc.) via REST API or MQTT connection. The 4ZeroManager can be also extended on request with dedicated data processing services and visualization dashboards. You can find more info about how to use 4ZeroManager here .","title":"4ZeroManager"},{"location":"4zp/4ZeroPlatform/#programming-suite","text":"The 4ZeroBox official programming framework is Zerynth . Zerynth allows programming the 4ZeroBox applications in Python (or hybrid C/Python). Zerynth includes a compiler, debugger, and an editor, alongside tutorials and example projects for an easy learning experience. The 4ZeroBox includes a Zerynth\u00ae Virtual Machine Premium License, thus it is programmable in Zerynth free and without limitations. Zerynth\u00ae and all the required libraries will be installed by the 4ZeroPlatform Configurator during the setup phase.","title":"Programming Suite"},{"location":"4zp/4ZeroPlatform/#api","text":"Our services expose some RESTful API for developing external tools and platforms and integrate them with the 4ZeroPlatform. The full documentation can be found here .","title":"API"},{"location":"4zp/Getting%20started/","text":"Getting started \u00b6 This is a step-by-step tutorial that guides the user in the usage of the 4ZeroPlatform Web-App interface from the the registration of a new account to the configuration of your device. From the sidebar men\u00f9 you can always easly navigate to each main section of the platform: 4ZeroPlatform Configurator : the tool that guides the user during the installation of all the required softwares, drivers, libraries and tools needed for programming the 4ZeroBox (only Desktop version for all platforms \u2013 Windows, Mac, Linux). 4ZeroManager : the device management service for organizing, monitoring, and remotely updating connected devices at scale. The 4ZeroManager includes a web interface for the control of connected devices and for the customization of data forwarding. 4ZeroPlatform Apps : the list of custom apps to allow dedicated data processing services, data visualization in dashboards, automatic alarming and reporting. 4ZeroPlatform Configurator \u00b6 There are some RPC available by default that can be called without any further configuration after this library is imported. Gathering required software \u00b6 Download it here: 4ZeroPlatform Configurator for Windows 4ZeroPlatform Configurator for Linux 4ZeroPlatform Configurator for Mac Extract the downloaded archive and run the executable file named \u201c4ZeroPlatformConfigurator\u201d. Creating an account \u00b6 Open the 4ZeroPlatform Configurator, if that\u2019s your first time, you will need an user account for the 4ZeroPlatform. Click on Register and compile the form: After that, you will be redirected to the login page, where you can enter the email address and the password of the account you just created: Setup your local machine \u00b6 Before starting to interact with your 4ZeroBox and discover all 4ZeroPlatform functionalities, you need to install the official developing tool for programming the 4ZeroBox. Zerynth is an ecosystem of software tools to program microcontrollers in Python and connect them to the Cloud. With Zerynth you can program your 4ZeroBox in Python or hybrid C/Python language and t is available for all 64-bit platforms (Windows, Mac, Linux). Zerynth main features are: Python and C blended together for efficient development; Tiny Footprint: Zerynth requires just 60k-80kB of Flash and 3-5kB of RAM dedicated to the Zerynth Virtual Machine; Real-Time: Zerynth integrates the RTOS of your choice with multithreading support; Connectivity: Zerynth allows an easy integration with top Cloud services and Firmware Over-The-Air updates. Warning The 4ZeroPlatform Configurator depends on the latest version of Zerynth Studio, the IDE provided by Zerynth. You can download from here and install Zerynth following the Installation guide . Once Installed Zerynth Studio, following page will apprear: In sequence, both operation must be excecuted before proceeding to program the 4ZeroBox: Driver Installation : 4ZeroBox comes with a serial-to-usb chip on board that allows programming and opening the UART of the ESP32 module. The CH340 USB to UART chip is also connected to the boot pins of the module, allowing for a seamless virtualization of the device. Drivers for the CH340 Module are needed for Windows and Mac OS platforms; Zerynth Studio Configuration : This operation installs all packages needed to auto-recognize the 4ZeroBox inside the Zerynth Studio (device, libraries, etc.) with examples ready to publish data in the 4Zeroplatform. Important To install the driver, press the button related to your OS, start the download, extract the archive and run the executable file inside it: - CH341SER/SETUP.EXE for Windows - CH341SER_MAC/CH34x_Install_V1.4.pkg for Mac OS !!! note: Linux users : while devices drivers are already included in the kernel, the read/write access to the serial port must be granted to your user. You must add your user to the group dialout , or uucp depending on your distribution. This command should do the trick: bash -c 'sudo usermod -a -G $(grep -o \"^\\(uucp\\|dialout\\)\" /etc/group) ${USER}' Remember to logout and log back in to apply the group changes. After Driver installation, click on Configure Zerynth Studio to apply new libraries and examples to it. Important Configuration of Zerynth Studio must be done every time there is a new release or new patch of it. Configure your device Before connecting your 4ZeroBox you have to check jumper and switch position on-board to enable the programming status. As shown in the figure, to enable the programming via USB you have to set: Jumper JP1 in U5V position: JP1 is the power supply selector; with E5V External Power Supply is selected otherwise with U5V USB Power Supply is selected; Switch SW2 position 11 high: position 11 of the switch SW2 connects the mail serial port of the microcontroller to the USB-to-Serial chip to enable serial comunication. It\u2019s time to register your device! Plug your 4ZeroBox to your computer using an USB cable and click on Add new device section. If drivers are correctly installed and Zerynth Studio correctly configured, clicking the Configure new device button the device configuration procedure will start as shown in figure below. At the end, the device will be ready to be programmed: You can now add a new device if you have or click on Launch Zerynth Studio to open the IDE and program your 4ZeroBox, it will be listed in the available devices, select it! If you click on the console icon, a serial terminal monitor will show up, printing a line with \u201cHello 4ZeroBox\u201d message every second: On the left column, you can click on the light bulb icon to open available examples. Searching for toi in the bar shows a couple of code samples: Double-click on the example provided within the fourzeromanager library clone it (more informations about cloning an example and uplinking it can be found here ) and edit the line 129 with a valid Wi-Fi configuration to be like that: try : fzbox . net_connect ( \"Your WiFi name\" , \"your-wifi-password\" ) except Exception as e : mcu . reset () you\u2019ll be able to send your first data online. Note These data are random for now \u2013 to connect a real sensor and send data refer to the 4ZeroBox documentation: 4ZeroBox . Also, the full 4ZeroManager library for connecting, registering new RPCs, and sending data is available here: 4ZeroManager . Important To devolop new applications for the 4ZeroBox, a project.yml file must be present inside the project folder (can be copied from the examples available in TOI libraries). In project.yml file, peripherals and functionalities can be enabled or disabled according to what your application need making your script optimized and saving resources. More info here Warning Remember that to make more safe each application, a recovery mechanism from unexpected behavior based on microcontroller watchdog is enabled for all available Zerynth Virtual Machines of the 4ZeroBox. More info on Zerynth Secure Firmware can be found here 4ZeroManager \u00b6 4ZeroManager is a cloud-base device management service for organizing, monitoring, and remotely updating connected devices at scale. As last step, re-opening the 4ZeroPlatform Configurator, you can find a 4ZeroManager section: Here, you will be able to have an overview of all your registered devices. Clicking on the name of one of them, you can see details and settings of this specific device. Consoles \u00b6 There are two MQTT consoles showing data received respectively from the data topic, and from the RPC (Remote Procedure Call) topic. RPC \u2013 Remote Procedure Call \u00b6 A RPC is a method activated by remote. There are some already defined in the fourzeromanager library and that are always available: Reset device to force a full reset Manifest RPCs to see available RPCs FOTA to start a remote update. From the custom RPC section you can call your RPC registered in the Zerynth firmware. FOTA \u2013 Firmware over the Air \u00b6 One of the default RPC is the FOTA update. This means that you can flash a new firmware on your device, without having it connected to your computer \u2013 it just needs to be online! Clicking the FOTA button will ask you for a folder containing a valid Zerynth project, select it and wait some seconds \u2013 the device will reboot using the new firmware. Important FOTA functionalities are available only on desktop version of the 4ZeroPlatform Configurator. Webhooks and MQTT Endpoints \u00b6 Setting an URL in the Webhook section will make it possible to send data received from the device to any valid HTTP endpoint. The token is something similar to a password, you can choose one or click on Generate to set a random one. Check this token on your server to be sure the data you are receiving are from us!","title":"Getting started"},{"location":"4zp/Getting%20started/#getting-started","text":"This is a step-by-step tutorial that guides the user in the usage of the 4ZeroPlatform Web-App interface from the the registration of a new account to the configuration of your device. From the sidebar men\u00f9 you can always easly navigate to each main section of the platform: 4ZeroPlatform Configurator : the tool that guides the user during the installation of all the required softwares, drivers, libraries and tools needed for programming the 4ZeroBox (only Desktop version for all platforms \u2013 Windows, Mac, Linux). 4ZeroManager : the device management service for organizing, monitoring, and remotely updating connected devices at scale. The 4ZeroManager includes a web interface for the control of connected devices and for the customization of data forwarding. 4ZeroPlatform Apps : the list of custom apps to allow dedicated data processing services, data visualization in dashboards, automatic alarming and reporting.","title":"Getting started"},{"location":"4zp/Getting%20started/#4zeroplatform-configurator","text":"There are some RPC available by default that can be called without any further configuration after this library is imported.","title":"4ZeroPlatform Configurator"},{"location":"4zp/Getting%20started/#gathering-required-software","text":"Download it here: 4ZeroPlatform Configurator for Windows 4ZeroPlatform Configurator for Linux 4ZeroPlatform Configurator for Mac Extract the downloaded archive and run the executable file named \u201c4ZeroPlatformConfigurator\u201d.","title":"Gathering required software"},{"location":"4zp/Getting%20started/#creating-an-account","text":"Open the 4ZeroPlatform Configurator, if that\u2019s your first time, you will need an user account for the 4ZeroPlatform. Click on Register and compile the form: After that, you will be redirected to the login page, where you can enter the email address and the password of the account you just created:","title":"Creating an account"},{"location":"4zp/Getting%20started/#setup-your-local-machine","text":"Before starting to interact with your 4ZeroBox and discover all 4ZeroPlatform functionalities, you need to install the official developing tool for programming the 4ZeroBox. Zerynth is an ecosystem of software tools to program microcontrollers in Python and connect them to the Cloud. With Zerynth you can program your 4ZeroBox in Python or hybrid C/Python language and t is available for all 64-bit platforms (Windows, Mac, Linux). Zerynth main features are: Python and C blended together for efficient development; Tiny Footprint: Zerynth requires just 60k-80kB of Flash and 3-5kB of RAM dedicated to the Zerynth Virtual Machine; Real-Time: Zerynth integrates the RTOS of your choice with multithreading support; Connectivity: Zerynth allows an easy integration with top Cloud services and Firmware Over-The-Air updates. Warning The 4ZeroPlatform Configurator depends on the latest version of Zerynth Studio, the IDE provided by Zerynth. You can download from here and install Zerynth following the Installation guide . Once Installed Zerynth Studio, following page will apprear: In sequence, both operation must be excecuted before proceeding to program the 4ZeroBox: Driver Installation : 4ZeroBox comes with a serial-to-usb chip on board that allows programming and opening the UART of the ESP32 module. The CH340 USB to UART chip is also connected to the boot pins of the module, allowing for a seamless virtualization of the device. Drivers for the CH340 Module are needed for Windows and Mac OS platforms; Zerynth Studio Configuration : This operation installs all packages needed to auto-recognize the 4ZeroBox inside the Zerynth Studio (device, libraries, etc.) with examples ready to publish data in the 4Zeroplatform. Important To install the driver, press the button related to your OS, start the download, extract the archive and run the executable file inside it: - CH341SER/SETUP.EXE for Windows - CH341SER_MAC/CH34x_Install_V1.4.pkg for Mac OS !!! note: Linux users : while devices drivers are already included in the kernel, the read/write access to the serial port must be granted to your user. You must add your user to the group dialout , or uucp depending on your distribution. This command should do the trick: bash -c 'sudo usermod -a -G $(grep -o \"^\\(uucp\\|dialout\\)\" /etc/group) ${USER}' Remember to logout and log back in to apply the group changes. After Driver installation, click on Configure Zerynth Studio to apply new libraries and examples to it. Important Configuration of Zerynth Studio must be done every time there is a new release or new patch of it. Configure your device Before connecting your 4ZeroBox you have to check jumper and switch position on-board to enable the programming status. As shown in the figure, to enable the programming via USB you have to set: Jumper JP1 in U5V position: JP1 is the power supply selector; with E5V External Power Supply is selected otherwise with U5V USB Power Supply is selected; Switch SW2 position 11 high: position 11 of the switch SW2 connects the mail serial port of the microcontroller to the USB-to-Serial chip to enable serial comunication. It\u2019s time to register your device! Plug your 4ZeroBox to your computer using an USB cable and click on Add new device section. If drivers are correctly installed and Zerynth Studio correctly configured, clicking the Configure new device button the device configuration procedure will start as shown in figure below. At the end, the device will be ready to be programmed: You can now add a new device if you have or click on Launch Zerynth Studio to open the IDE and program your 4ZeroBox, it will be listed in the available devices, select it! If you click on the console icon, a serial terminal monitor will show up, printing a line with \u201cHello 4ZeroBox\u201d message every second: On the left column, you can click on the light bulb icon to open available examples. Searching for toi in the bar shows a couple of code samples: Double-click on the example provided within the fourzeromanager library clone it (more informations about cloning an example and uplinking it can be found here ) and edit the line 129 with a valid Wi-Fi configuration to be like that: try : fzbox . net_connect ( \"Your WiFi name\" , \"your-wifi-password\" ) except Exception as e : mcu . reset () you\u2019ll be able to send your first data online. Note These data are random for now \u2013 to connect a real sensor and send data refer to the 4ZeroBox documentation: 4ZeroBox . Also, the full 4ZeroManager library for connecting, registering new RPCs, and sending data is available here: 4ZeroManager . Important To devolop new applications for the 4ZeroBox, a project.yml file must be present inside the project folder (can be copied from the examples available in TOI libraries). In project.yml file, peripherals and functionalities can be enabled or disabled according to what your application need making your script optimized and saving resources. More info here Warning Remember that to make more safe each application, a recovery mechanism from unexpected behavior based on microcontroller watchdog is enabled for all available Zerynth Virtual Machines of the 4ZeroBox. More info on Zerynth Secure Firmware can be found here","title":"Setup your local machine"},{"location":"4zp/Getting%20started/#4zeromanager","text":"4ZeroManager is a cloud-base device management service for organizing, monitoring, and remotely updating connected devices at scale. As last step, re-opening the 4ZeroPlatform Configurator, you can find a 4ZeroManager section: Here, you will be able to have an overview of all your registered devices. Clicking on the name of one of them, you can see details and settings of this specific device.","title":"4ZeroManager"},{"location":"4zp/Getting%20started/#consoles","text":"There are two MQTT consoles showing data received respectively from the data topic, and from the RPC (Remote Procedure Call) topic.","title":"Consoles"},{"location":"4zp/Getting%20started/#rpc-remote-procedure-call","text":"A RPC is a method activated by remote. There are some already defined in the fourzeromanager library and that are always available: Reset device to force a full reset Manifest RPCs to see available RPCs FOTA to start a remote update. From the custom RPC section you can call your RPC registered in the Zerynth firmware.","title":"RPC \u2013 Remote Procedure Call"},{"location":"4zp/Getting%20started/#fota-firmware-over-the-air","text":"One of the default RPC is the FOTA update. This means that you can flash a new firmware on your device, without having it connected to your computer \u2013 it just needs to be online! Clicking the FOTA button will ask you for a folder containing a valid Zerynth project, select it and wait some seconds \u2013 the device will reboot using the new firmware. Important FOTA functionalities are available only on desktop version of the 4ZeroPlatform Configurator.","title":"FOTA \u2013 Firmware over the Air"},{"location":"4zp/Getting%20started/#webhooks-and-mqtt-endpoints","text":"Setting an URL in the Webhook section will make it possible to send data received from the device to any valid HTTP endpoint. The token is something similar to a password, you can choose one or click on Generate to set a random one. Check this token on your server to be sure the data you are receiving are from us!","title":"Webhooks and MQTT Endpoints"},{"location":"4zp/docs/img/test.md/","text":"Written with StackEdit .","title":"Test.md"},{"location":"conceptualmodel/Conceptual%20Model/","text":"Zerynth is a platform that simplifies and accelerates the development of IoT applications. Zerynth offers developers, system integrators, and businesses a way to enable IoT for their products, rapidly. Zerynth includes various tools, software and hardware units. The entry point to the Zerynth journey is not fixed, it depends on the user's needs and goals. The development of IOT projects is a very long journey. Typically an IOT project requires a hardware platform, used as reference for the development of the IOT device. Zerynth can help you in this phase, thanks to the Zerynth Hardware and the Zerynth Powered Devices . Zerynth hardware are Zerynth officially commercialized devices that are fully integrated with the Zerynth suite, providing users a seamless IOT development experience. Zerynth Powered Devices are third party hardware units that natively include the Zerynth OS, thus making it ready for being programmed and managed with the Zerynth suite. Zerynth also supports many other boards. A comprehensive list of all the supported boards, sensors, peripherals and libraries can be found here . Once you have identified your IOT hardware it is time to develop the firmware for your embedded devices. The Zerynth OS (ZOS) is a tiny real-time operating system that runs on a variety of 32bit microcontrollers allowing code portability within IOT platforms. It means that if you develop your firmware for Zerynth OS you can easily load it on all the Zerynth supported devices in a few clicks. The ZOS includes a Python Virtual Machine that allow developing IOT firmware in Python, or C and Python. For example, you can develop a motor control library in C in order to be very fast in the control cycle while developing the cloud connection code in Python in order to easily write and maintain the code. To develop for ZOS and to be able to manage your board\u2019s firmware upload you need to install the Zerynth SDK . Z-SDK is a cross platform (Windows, Linux and MAC) toolkit that includes Zerynth Studio , The Zerynth Tool Chain and various board programming tools, libraries and drivers. Zerynth Studio is our IDE. It is a lightweight code editor fully integrated with the Zerynth suite that provides basic coding functionalities, board management tools and firmware loading routines. If you are an expert programmer you can easily develop your Zerynth Code using your preferred IDE and then use the Zerynth Tool Chain command line interface for the compilation, upload, and management of your developed firmware. We also have released various third party IDE plugins that allow programming Zerynth firmwares from Visual Studio Code , Sublime Text and PyCharm. The development of an IOT project is not finished with device firmware creation. An IOT device needs to be connected on a cloud service in order to be able to stream data, receive commands and be easily updated, disabled or killed if necessary. IOT Device Management and Data collection is provided in Zerynth thanks to the Zerynth Device Manager . ZDM is a data and device management system that allows to easily connect IOT devices to a cloud allowing an easy and intuitive management and aggregation of the data and a seamless management of IOT devices updates and security. ZDM is one of the few device managers available on the market that can be installed on premises on request. ZDM collects and stores your IOT data while also allowing a seamless forward to any other cloud (Azure, AWS, IBM, Google IOT) or backend service via Webhook or REST API. You are at the end of the IOT development journey, if you need more help on finalizing your project or in converting your IOT prototype in an industrial project just check our R&D services. If you are interested in ready to use vertical IOT solutions, you can check the Zerynth 4ZeroBox . The Zerynth 4ZeroBox is a ready to use industrial unit that allows to easily interface modern and legacy industrial machines to the cloud, thus building the \u201cdigital twin\u201d of the Industry 4.0 paradigms. The 4ZeroBox can be connected to the Zerynth Device Manager and collected data visualized thanks to our Grafana and Microsoft PowerBi integrations. The 4ZeroBox has been already used in various industrial use-cases you can find documented here .","title":"Conceptual Model"},{"location":"conceptualmodel/Zerynth%20Components/","text":"Zerynth OS \u00b6 A multithreaded real-time OS that supports hybrid Python/C coding, advanced security and connectivity features, advanced power-management, FOTA, and provides real hardware independence. Learn more Zerynth Device Manager \u00b6 Zerynth Device Manager (ZDM) is a device and data management service that makes it easy to securely register, organize, monitor, and remotely manage IoT devices at scale. Learn more Zerynth Hardware \u00b6 4ZeroBox \u00b6 4ZeroBox, a versatile data acquisition unit, programmable in hybrid Python/C thanks to the Zerynth OS. 4ZeroBox is ideal as a machine-to-cloud interface to plug into old and modern industrial machines. Learn more Zerynth Powered Devices \u00b6 These Zerynth powered solutions will inspire you to look beyond your expectations of what you can do with Python. You\u2019ll see how Python programming is solving real problems in the industrial IoT, how it\u2019s helping embedded developers with prototyping, and much more. Learn more Zerynth Supported Devices \u00b6 Learn more Zerynth 4.0 Platform \u00b6 4ZeroPlatform is a platform designed for Industry 4.0 solution providers, and thanks to its versatility, it can be adapted to any industrial context. 4ZeroPlatform is composed of 4ZeroBox and 4ZeroManager. Learn more","title":"Zerynth Components"},{"location":"conceptualmodel/Zerynth%20Components/#zerynth-os","text":"A multithreaded real-time OS that supports hybrid Python/C coding, advanced security and connectivity features, advanced power-management, FOTA, and provides real hardware independence. Learn more","title":"Zerynth OS"},{"location":"conceptualmodel/Zerynth%20Components/#zerynth-device-manager","text":"Zerynth Device Manager (ZDM) is a device and data management service that makes it easy to securely register, organize, monitor, and remotely manage IoT devices at scale. Learn more","title":"Zerynth Device Manager"},{"location":"conceptualmodel/Zerynth%20Components/#zerynth-hardware","text":"","title":"Zerynth Hardware"},{"location":"conceptualmodel/Zerynth%20Components/#4zerobox","text":"4ZeroBox, a versatile data acquisition unit, programmable in hybrid Python/C thanks to the Zerynth OS. 4ZeroBox is ideal as a machine-to-cloud interface to plug into old and modern industrial machines. Learn more","title":"4ZeroBox"},{"location":"conceptualmodel/Zerynth%20Components/#zerynth-powered-devices","text":"These Zerynth powered solutions will inspire you to look beyond your expectations of what you can do with Python. You\u2019ll see how Python programming is solving real problems in the industrial IoT, how it\u2019s helping embedded developers with prototyping, and much more. Learn more","title":"Zerynth Powered Devices"},{"location":"conceptualmodel/Zerynth%20Components/#zerynth-supported-devices","text":"Learn more","title":"Zerynth Supported Devices"},{"location":"conceptualmodel/Zerynth%20Components/#zerynth-40-platform","text":"4ZeroPlatform is a platform designed for Industry 4.0 solution providers, and thanks to its versatility, it can be adapted to any industrial context. 4ZeroPlatform is composed of 4ZeroBox and 4ZeroManager. Learn more","title":"Zerynth 4.0 Platform"},{"location":"deploy/Deploy%20and%20Manage/","text":"Deploy and Manage \u00b6 Zerynth Device Manager (ZDM) is a device and data management service that speeds up the development of scalable, secure and reliable IoT solutions. Main features: Devices onboarding and provisioning: enabled with gold-standard security practices; Devices lifecycle control: allowing complex tasks like remote procedure call and over the air updates (FOTA) through REST APIs; Data Management: storage, aggregation, plotting and feeding of data to the final IoT Application; Easy integration with third parties services and frontends. Each Zerynth user has access to the ZDM SaaS instance hosted on Zerynth servers. The ZDM can also be hosted on-premises, using container technology, on top cloud providers (such as Azure, AWS, IBM, Google), or on your server. The Zerynth Device Manager is a device and data manager for IoT applications. Zerynth Device Manager helps you register, organize, monitor, and remotely manage IoT devices at scale. ZDM allows managing devices and also collects and aggregates the data they produce. ZDM is device and OS independent, allowing the connection of microcontroller-based devices programmed in Zerynth but also microprocessor-based devices, like the Raspberry Pi and any other PC application. This device produced data is collected, aggregated, and stored by the ZDM, allowing IoT application frontend to retrieve the data by means of RESTfull API or using the ZDM Gates. The Zerynth Device Managers is based on the following key concepts; A Device is the smallest entity you can find in the ZDM. It is represented by the physical IoT device connected with the ZDM via MQTT. A workspace is the entity that groups and isolates devices and their produced data. You can imagine the workspace as the main folder of your project. A fleet is a group of devices belonging to a workspace. You can use fleets to group devices with similar features and applications. Fleets allow sending bulk device commands, FOTA updates and Jobs; A Tag is a data label used for querying and aggregating data. Each device can publish data on multiple tags and the ZDM will take care of aggregate and align them; A Gate is an interface between the ZDM and an external service like your project frontend application. Gates are typically used to stream data out from the ZDM. In the beta version a Gate can stream data from one tag only, multiple tags gates will be added soon. A Job is a command sent by the ZDM to a device. Jobs are used to activate device firmware functions like: reset, send status, and FOTA updates. How to access the ZDM \u00b6 ZDM can be accessed via the web user interface available at https://zdm.zerynth.com or using the ZDM CLI (command line interface) that is integrated into the Zerynth SDK (download from https://www.zerynth.com/zsdk/ ). To use the ZDM service you need a Zerynth account, if you do not have it yet you can register to zerynth from https://backend.zerynth.com/v1/sso The ZDM web user interface \u00b6 Go to https://zdm.zerynth.com and login with your zerynth account, you will reach the ZDM home page. Home Page From here you can get an overview of your workspaces, search for them and add new ones. Each registered user has the \u201cDefault Workspace\u201d endowed with the \u201cDefault Fleet\u201d that can be used for starting with the ZDM. You can easily add more workspaces and fleets if needed. The Default workspace can\u2019t be deleted. Keep your project well organized! We suggest using a new workspace for each new project. Add new Workspace To add a new workspace, just click the \u201cNew Workspace\u201d button on the ZDM home page, indicate the name and optionally add a description and some fleets. After clicking \u201cAdd\u201d the new workspace will be added to the home ready to be managed. If you don\u2019t indicate any fleet in the form, the default fleet will be created automatically. Workspace To open a workspace just click on its title in the homepage grid. The workspace page allows you to configure the workspace, manage associated devices, create gates and lunch jobs on your devices. Configuration The configuration button: is used to: delete the fleets (you can delete only empty fleets) delete the workspace itself (only if it doesn\u2019t contain devices) Fleets Management On the configuration page, you can view and delete fleets by clicking on the recycle bin icon. Delete a Workspace Further down the configuration window, you can find the button to permanently delete the workspace. Remember: only workspaces that do not have devices inside can be deleted. Gates Gates are the interfaces of the ZDM with external services. The ZDM aggregates data published by your devices into gates that can be exposed to external services via: webhooks and MQTT (coming soon). Gates for specific third party services are also available: we currently support Ubidots , many others will come soon. Add new Gate To add a new GATE click on the Add new Gate button, and select the type of Gate you want to create. The new gate form will open. Webhook For the Webhook gate, you have to fill the form with: The Gate\u2019s name; The URL of the endpoint that will receive your data; the sending period expressed in seconds; Select the tag you want agg to aggregate in the gate stream. in Future gates will also support multiple tags. A token (if needed). Ubidots GATE In the Ubidots gate creation form you will find the Ubidots address URL pre-filled. To add a Ubidots webhook you need to add the \u201cdevice label\u201d of the Ubidots device where you want to receive the data. If you have already created a device on Ubidots, copy it here otherwise insert a device name you prefer (without spaces) and Ubidots will create it automatically when the ZDM gate is created. The Ubidots token can be copied from the Ubidots API credential section of the Ubidots user menu. In the Example 2 of this guide you will find more details on how to create a device in Ubidots. View, activate/deactivate, modify and delete a Gate Once created, the Gates are added to the Gates tab, and from here it is possible to activate/deactivate them, edit and delete them. My Devices At the bottom of the workspace page, you will find the list of the devices associated. Devices can be filtered by fleets and ordered by creation date. Through the table you can see the \u201cFOTA Status\u201c, so if the device has never received a FOTA you will see: \u201cNever Done\u201d, or \u201cFirmware Version + Data\u201d of the last successful FOTA update. In the device tab you can also get information about the last message sent by the device to the ZDM. Selecting one or more devices from the list you can perform mass operations such as FOTA, Custom RPC, Device Reset and other bulk actions that can be selected from the drop-down menu on the left. Add new Fleet You can add a new fleet on the Workspace using the \u201cAdd new Fleet\u201d button. The form allows creating multiple fleets, just click the \u201c+ add fleet\u201d button, fill the form and click \u201cAdd\u201d at the bottom of the dialog. Add new Device Just click on the \u201cAdd New Device\u201d button on the workspace page. You will be prompted with the device creation form. Here, just fill in \u201cDevice Name\u201d and select the fleet to which the device will be associated from the drop-down menu. Once successfully created, the screen will show the device id and the Password required for device authentication on the ZDM. Please copy the password and the device id, you will need to paste it in the Zerynth Device firmware or in your ZDM client lib based application. The device created form also reports a ready to copy code that you can easily paste in the ZDM lib and in the ZDM client lib examples. Very important: for security reasons, the device\u2019s password can\u2019t be re-visualized. So, once this window will be closed you will no longer be able to retrieve the generated password!. If you lose a device password you can always regenerate it from the specific device page. Device pages can be opened by clicking on each device name in the device list. Regenerate device password Bulk Actions With the bulk actions you can do: Delete a device (many others will be added soon) just select one or more devices from the table, choose one of the actions in bulk from the drop-down menu and click on \u201cApply\u201d FOTA The FOTA (Firmware Over The Air) update procedure is used to update the firmware of one or more devices remotely. Important In order to perform the FOTA of a device you need to virtualize it with a \u201cFota Enabled\u201d virtual machine. The first step to start a FOTA update on your devices is to prepare and upload a firmware to the ZDM cloud. To upload your firmware, open the Zerynth Studio ( Note: Zerynth studio v. 2.5.0 or higher is required). Open the project you want to compile and use for the FOTA and click on the Zerynth Device Manager Icon on the left vertical menu. Now click on the ZDM FOTA Prepare orange button. Select the ZDM device you want to update and indicate a unique firmware version identifier (you can\u2019t reuse a version identifier previously used), click prepare. When the firmware preparation and upload process will be completed Zerynth Studio will prompt you to another window. If you want to go ahead with the FOTA procedure click Open ZDM GUI. You will be redirected to the ZDM selected device page. Just click FOTA, select the firmware you just uploaded and click Start. The FOTA procedure will be scheduled on your device. Refresh the device Status form and you will see the status of the FOTA procedure. Jobs Jobs are device actions that the ZDM will be scheduled. Jobs need to be enabled on device firmware associating the functions that will be called when a job request is received. Once your device or devices are online and programmed with custom Jobs, you can select one or more devices and click the \u201cJobs\u201d button. A dialog will come up, which will summarize the list of devices you have selected. You will see a cascader with the Jobs that are common to all the devices you have selected. Select one, optionally fill in the text box below with the arguments if required, and click the \u201cLaunch\u201d button. Note If the selected devices do not have common Jobs, or if you select devices without custom Jobs defined in the firmware you will get the: \u201cNo Jobs found\u201d message. Device Page On the page of a specific device, you will see the info about that device, then the name, the creation date, workspace and fleet of belonging, etc. In addition you will see the Tag Console, which will show you in real time the data that that device is publishing in a specific tag. At the top you can see some summary information on your device such as name, id, fleet to which it belongs, associated tags, the firmware version, the status of the jobs called and the last time your device was seen online. Data Console At the end of device pages, you can find the Data Console, it allows you to see what data your device publishes in real time. By clicking in the left checkboxes you can better navigate the published data, they will be presented on the right in the \u201cShow selected Data\u201d box. The ZDM Command Line Interface \u00b6 This section is a guide for the most used ZDM CLI commands. Note that the zdm command line interface is available from Zerynth >= r2.4.3, download it here or update to the last version! Adding ZDM to the OS path In order to use the zdm command line interface, you need to add it to your OS path: On Linux: open the terminal and launch the following command: ~/. zerynth2 / sys / cli / zpm setpaths Close and reopen the terminal or reload the \u201csource\u201d builtin command. On Windows: open the command prompt as administrator and launch the following command: % userprofile % \\ zerynth2 \\ sys \\ cli \\ zpm setpaths Close and reopen the command prompt. On Mac: open the terminal and launch the following command: ~/. zerynth2 / sys / cli / zpm setpaths Close and reopen the terminal or reload the \u201csource\u201d builtin command. Now you can use the zdm command line interface by typing on your command prompt zdm To see the list of all the possible commands with details use the help command with option \u2013help . For example zdm \u2013help or zdm device \u2013help . Login The first step to use the ZDM (Zerynth device manager) using the Zerynth Toolchain is to log in using your Zerynth account. Open a terminal and type this command to login with your Zerynth account: zdm login You will be redirected to the Zerynth SSO and, once logged, you will see your authorization token. Copy the generated token and paste it into the terminal. If you\u2019re logging in for the first time, a default workspace and a default fleet will be created for your account. The first step to work with your devices and ZDM is to associate your devices to a fleet inside a workspace, so you can choose to use the default ones or to create your first custom workspace and fleet. Account commands Account\u2019s information Once you\u2019re logged in, if you want to see your account information use the command: zdm profile Logout To logout of the ZDM give the command: zdm logout and your current session will be closed. Workspaces Workspace creation To create a new workspace use the following command: zdm workspace create [ WorkspaceName ] WorkspaceName is the name you want to give to your workspace (don\u2019t use \u201cdefault\u201d). You can also give your workspace a description using the option \u2013description If you create a workspace, you will see your workspace\u2019s information: ID Name Description wks-id my-first description Once you\u2019ve created a workspace, you should create a fleet inside to be able to manage your devices\u2019 data. Copy your new workspace\u2019s id or use the list workspaces command to see all your workspaces. List workspaces and workspace information If you want to see the list of workspaces you\u2019ve created, their name, description and id type the command: zdm workspace all You can also get information about one single workspace from your list giving the command: zdm workspace get [ WorkspaceId ] Fleets Fleet creation To create a new fleet type the following command: zdm fleet create [ FleetName ] [ WorkspaceId ] Also in this case, don\u2019t use \u201cdefault\u201d as the fleet name, and use one of your workspaces\u2019 id to create your new fleet. A result message with the fleet name will be shown. List fleets and fleet information If you want to see the list of fleets you\u2019ve created type: zdm fleet all You will have the fleet id, the name, and the workspace id of all of your fleets. Devices Device creation Once you have created a new workspace and fleet, or you\u2019ve decided to skip and to use the default ones, you can create a new device. To create a device type the command: zdm device create [ DeviceName ] [ FleetId ] DeviceName represents the device\u2019s name, FleetId is the fleet id you want the device to belong to. If you don\u2019t specify a fleet id, the device will be associated to the default fleet in the default workspace. To authenticate your new device, you have to generate a key for the device with the corresponding command. Let\u2019s see a description of the other commands you can use to manage devices. Device list and device information If you want to list your devices or to get a device information you can use the list and get commands, to see the device name, id, and fleet id. Give the command: zdm device all to list all your devices or zdm device get [ DeviceId ] to have information about a single device. Get the device\u2019s workspace To get the workspace\u2019s name and id that contains your device, you can use the following command: zdm device workspace [ DeviceId ] Device\u2019s key generation To be able to manage your device\u2019s data you have to create a key at first and then generate a password (as jwt token) from the created key. The generated key can be used as the password to connect your device to the ZDM in your firmware. You can generate different keys with different names for your devices with the command: Create a new key. zdm device key create [ DeviceId ] [ Name ] Generate a new Jwt password for a device starting from a generated key. zdm device key generate [ DeviceId ] [ KeyId ] Jobs and actions You can use ZDM to remotely send a job command to your devices. To send a new job to a device, you just have to start it using the command: zdm job schedule [ name ] [ devices ] The \u2018name\u2019\u2019 argument is a string representing the method name. The \u2018devices\u2019\u2019 argument is a list of the device ids you want to schedule the job (i.e. [\u201cdevice1\u201d, \u201cdevice2\u201d]). If the device needs some arguments to execute the job, you can use the \u2013arg option. Events You can use ZDM CLI to see the last 25 events sent by your devices. Use the command zdm event list [ workspaceId ] If you want to see the last 25 events filtering on device use the option -- device - id [ deviceId ] It\u2019s also possible to filter results on date. You can indicate a start and end date (RFC3339 format) using the options: -- start [ startDate ] -- end [ endDate ] Fota (Firmware over the air) Important: In order to perform the FOTA of a device you need to have a Virtual machine with the \u201cFota Enable\u201d feature. Upload a firmware The first step to start a FOTA update on your devices is to upload a firmware to the ZDM cloud. To upload your firmware, use the command: zdm fota prepare [ firmwareProjectPath ] [ DeviceId ] [ Version ] Where firmwareProjectPath is the firmware\u2019s project location in your local file system, deviceId is the id of the device you want to update, version is a string used to label your firmware (e.g., \u201c1.0\u201d) Note that the firmware will be associated with the workspace that contains your device. If you will associate new devices to the same workspace you can send them the same firmware. Start FOTA Once you\u2019ve uploaded your firmware, you can send the FOTA command to the device typing: zdm fota schedule [ FirmwareVersion ] [ DeviceId ] For example: schedule the new firmware to the device with id dev-yyyyy zdm fota schedule 1.0 dev - yyyy Check FOTA status To check the status of a FOTA you started, to know if the device finished the task or if an error occurred, give the following commands to have a list of your fota and their status: zdm fota check [ DeviceId ] Gates Using the ZDM you\u2019re able to also receive your device\u2019s data on your webhooks. For example you can send data to a WebHook server or to Ubidots (see the example section). Now let\u2019s see a complete example, on how to connect a device to the ZDM and see data using an Ubidots dashboard and widgets. Zerynth Device Manager CLI Programming Guide \u00b6 ZDM API documentation \u00b6 TK ZDM GATES \u00b6 TK ZDM Client Python Library for PC and Raspberry \u00b6 Zerynth Device Manager can be used for orchestrating both MCU (microcontroller) and CPU (microprocessor) based devices. If you want to connect an MCU device like a Raspberry PI, an SBC (Single Board Computer) a PC, or any Python application in general, the ZDM Client Python Library is what you need. Installation The latest stable version of the ZDM-Client Python Library is available on PyPI ( https://pypi.org/project/zdm-client-py/ ) The installation assumes that you have installed the latest Python version with pip. In order to install the ZDM-Client Python Library, type the following command or add the zdm-client-py into the requirements.txt file. pip install zdm - client - py If you want, you can also download the repository publicly available on GitHub. git clone https : // github . com / zerynth / zdm - client - py . git navigate to the download repo directory and create a virtual env using the command virtualenv venv And install the python package locally. pip install Usage Once you have installed the ZDM-client Python lib you can use it for connecting your CPU based device to the ZDM and stream your data. Login to the ZDM in order to obtain the device id and the password of a device (see the ZDM getting started guide for more info) Create a new file zdm_basic.py and copy the following script and replace the obtained device id and password in the placeholders. CODE TO BE TAKEN FROM WP ARTICLE Jobs In addition, the ZDM-client Python lib permits also to define a set of jobs on the client that can be invoked by the ZDM. The jobs are passed to the ZDMClient as a dictionary, where the key is the name of the job and the value is the corresponding function to execute. The example below illustrates a simple example of a client exposing one job named set_temp. Upon the device receiving the Job, it executes the corresponding function and returns a result of a JSON object. Copy the following script into a new file hello_jobs.py. CODE TO BE TAKEN FROM WORDPRESS Now, you can schedule the job in two different ways: by using the ZDM UI or the ZDM CLI. ZDM UI Steps needed to execute the job \u201cset_led\u201d on the device by using the ZDM UI: Login to the ZDM ( https://zdm.zerynth.com/login ) Click on the workspace where the device is associated. On the section \u201cMy Devices\u201d, click the checkbox of the device Click on the button \u201cJobs\u201d, and on the popup select the job Name \u201cset_temp\u201d in the Job Name dropdown menu. Add to the \u201cArguments\u201d section any arguments of the function in json format (if any). For this example, you can leave the field empty. Click on \u201cLaunch Job\u201d button. ZDM CLI Steps needed to execute the job \u201cset_led\u201d on the device by using the ZDM CLI. Make sure you have configured the ZDM CLI ( https://www.zerynth.com/blog/docs/the-tools/zdm/getting-started/ ). In order to schedule the job, type the following command (where the DEVICE_ID must be substituted with the actual id of the device): zdm job schedule set_temp < DEVICE_ID > Expected result: If the job has been correctly scheduled to the zdm client py, the following message will appear in the console: Executing job set_temp . Received args : {} [ INFO | zdmclient . py : 185 ] > [ DEVICE - ID ] job set_temp executed with result res :{ \"msg\" : \"Temperature set correctly.\" } That \u2019 s all ! Edit the script file and build your own ZDM powered IOT project !","title":"Deploy and Manage"},{"location":"deploy/Deploy%20and%20Manage/#deploy-and-manage","text":"Zerynth Device Manager (ZDM) is a device and data management service that speeds up the development of scalable, secure and reliable IoT solutions. Main features: Devices onboarding and provisioning: enabled with gold-standard security practices; Devices lifecycle control: allowing complex tasks like remote procedure call and over the air updates (FOTA) through REST APIs; Data Management: storage, aggregation, plotting and feeding of data to the final IoT Application; Easy integration with third parties services and frontends. Each Zerynth user has access to the ZDM SaaS instance hosted on Zerynth servers. The ZDM can also be hosted on-premises, using container technology, on top cloud providers (such as Azure, AWS, IBM, Google), or on your server. The Zerynth Device Manager is a device and data manager for IoT applications. Zerynth Device Manager helps you register, organize, monitor, and remotely manage IoT devices at scale. ZDM allows managing devices and also collects and aggregates the data they produce. ZDM is device and OS independent, allowing the connection of microcontroller-based devices programmed in Zerynth but also microprocessor-based devices, like the Raspberry Pi and any other PC application. This device produced data is collected, aggregated, and stored by the ZDM, allowing IoT application frontend to retrieve the data by means of RESTfull API or using the ZDM Gates. The Zerynth Device Managers is based on the following key concepts; A Device is the smallest entity you can find in the ZDM. It is represented by the physical IoT device connected with the ZDM via MQTT. A workspace is the entity that groups and isolates devices and their produced data. You can imagine the workspace as the main folder of your project. A fleet is a group of devices belonging to a workspace. You can use fleets to group devices with similar features and applications. Fleets allow sending bulk device commands, FOTA updates and Jobs; A Tag is a data label used for querying and aggregating data. Each device can publish data on multiple tags and the ZDM will take care of aggregate and align them; A Gate is an interface between the ZDM and an external service like your project frontend application. Gates are typically used to stream data out from the ZDM. In the beta version a Gate can stream data from one tag only, multiple tags gates will be added soon. A Job is a command sent by the ZDM to a device. Jobs are used to activate device firmware functions like: reset, send status, and FOTA updates.","title":"Deploy and Manage"},{"location":"deploy/Deploy%20and%20Manage/#how-to-access-the-zdm","text":"ZDM can be accessed via the web user interface available at https://zdm.zerynth.com or using the ZDM CLI (command line interface) that is integrated into the Zerynth SDK (download from https://www.zerynth.com/zsdk/ ). To use the ZDM service you need a Zerynth account, if you do not have it yet you can register to zerynth from https://backend.zerynth.com/v1/sso","title":"How to access the ZDM"},{"location":"deploy/Deploy%20and%20Manage/#the-zdm-web-user-interface","text":"Go to https://zdm.zerynth.com and login with your zerynth account, you will reach the ZDM home page. Home Page From here you can get an overview of your workspaces, search for them and add new ones. Each registered user has the \u201cDefault Workspace\u201d endowed with the \u201cDefault Fleet\u201d that can be used for starting with the ZDM. You can easily add more workspaces and fleets if needed. The Default workspace can\u2019t be deleted. Keep your project well organized! We suggest using a new workspace for each new project. Add new Workspace To add a new workspace, just click the \u201cNew Workspace\u201d button on the ZDM home page, indicate the name and optionally add a description and some fleets. After clicking \u201cAdd\u201d the new workspace will be added to the home ready to be managed. If you don\u2019t indicate any fleet in the form, the default fleet will be created automatically. Workspace To open a workspace just click on its title in the homepage grid. The workspace page allows you to configure the workspace, manage associated devices, create gates and lunch jobs on your devices. Configuration The configuration button: is used to: delete the fleets (you can delete only empty fleets) delete the workspace itself (only if it doesn\u2019t contain devices) Fleets Management On the configuration page, you can view and delete fleets by clicking on the recycle bin icon. Delete a Workspace Further down the configuration window, you can find the button to permanently delete the workspace. Remember: only workspaces that do not have devices inside can be deleted. Gates Gates are the interfaces of the ZDM with external services. The ZDM aggregates data published by your devices into gates that can be exposed to external services via: webhooks and MQTT (coming soon). Gates for specific third party services are also available: we currently support Ubidots , many others will come soon. Add new Gate To add a new GATE click on the Add new Gate button, and select the type of Gate you want to create. The new gate form will open. Webhook For the Webhook gate, you have to fill the form with: The Gate\u2019s name; The URL of the endpoint that will receive your data; the sending period expressed in seconds; Select the tag you want agg to aggregate in the gate stream. in Future gates will also support multiple tags. A token (if needed). Ubidots GATE In the Ubidots gate creation form you will find the Ubidots address URL pre-filled. To add a Ubidots webhook you need to add the \u201cdevice label\u201d of the Ubidots device where you want to receive the data. If you have already created a device on Ubidots, copy it here otherwise insert a device name you prefer (without spaces) and Ubidots will create it automatically when the ZDM gate is created. The Ubidots token can be copied from the Ubidots API credential section of the Ubidots user menu. In the Example 2 of this guide you will find more details on how to create a device in Ubidots. View, activate/deactivate, modify and delete a Gate Once created, the Gates are added to the Gates tab, and from here it is possible to activate/deactivate them, edit and delete them. My Devices At the bottom of the workspace page, you will find the list of the devices associated. Devices can be filtered by fleets and ordered by creation date. Through the table you can see the \u201cFOTA Status\u201c, so if the device has never received a FOTA you will see: \u201cNever Done\u201d, or \u201cFirmware Version + Data\u201d of the last successful FOTA update. In the device tab you can also get information about the last message sent by the device to the ZDM. Selecting one or more devices from the list you can perform mass operations such as FOTA, Custom RPC, Device Reset and other bulk actions that can be selected from the drop-down menu on the left. Add new Fleet You can add a new fleet on the Workspace using the \u201cAdd new Fleet\u201d button. The form allows creating multiple fleets, just click the \u201c+ add fleet\u201d button, fill the form and click \u201cAdd\u201d at the bottom of the dialog. Add new Device Just click on the \u201cAdd New Device\u201d button on the workspace page. You will be prompted with the device creation form. Here, just fill in \u201cDevice Name\u201d and select the fleet to which the device will be associated from the drop-down menu. Once successfully created, the screen will show the device id and the Password required for device authentication on the ZDM. Please copy the password and the device id, you will need to paste it in the Zerynth Device firmware or in your ZDM client lib based application. The device created form also reports a ready to copy code that you can easily paste in the ZDM lib and in the ZDM client lib examples. Very important: for security reasons, the device\u2019s password can\u2019t be re-visualized. So, once this window will be closed you will no longer be able to retrieve the generated password!. If you lose a device password you can always regenerate it from the specific device page. Device pages can be opened by clicking on each device name in the device list. Regenerate device password Bulk Actions With the bulk actions you can do: Delete a device (many others will be added soon) just select one or more devices from the table, choose one of the actions in bulk from the drop-down menu and click on \u201cApply\u201d FOTA The FOTA (Firmware Over The Air) update procedure is used to update the firmware of one or more devices remotely. Important In order to perform the FOTA of a device you need to virtualize it with a \u201cFota Enabled\u201d virtual machine. The first step to start a FOTA update on your devices is to prepare and upload a firmware to the ZDM cloud. To upload your firmware, open the Zerynth Studio ( Note: Zerynth studio v. 2.5.0 or higher is required). Open the project you want to compile and use for the FOTA and click on the Zerynth Device Manager Icon on the left vertical menu. Now click on the ZDM FOTA Prepare orange button. Select the ZDM device you want to update and indicate a unique firmware version identifier (you can\u2019t reuse a version identifier previously used), click prepare. When the firmware preparation and upload process will be completed Zerynth Studio will prompt you to another window. If you want to go ahead with the FOTA procedure click Open ZDM GUI. You will be redirected to the ZDM selected device page. Just click FOTA, select the firmware you just uploaded and click Start. The FOTA procedure will be scheduled on your device. Refresh the device Status form and you will see the status of the FOTA procedure. Jobs Jobs are device actions that the ZDM will be scheduled. Jobs need to be enabled on device firmware associating the functions that will be called when a job request is received. Once your device or devices are online and programmed with custom Jobs, you can select one or more devices and click the \u201cJobs\u201d button. A dialog will come up, which will summarize the list of devices you have selected. You will see a cascader with the Jobs that are common to all the devices you have selected. Select one, optionally fill in the text box below with the arguments if required, and click the \u201cLaunch\u201d button. Note If the selected devices do not have common Jobs, or if you select devices without custom Jobs defined in the firmware you will get the: \u201cNo Jobs found\u201d message. Device Page On the page of a specific device, you will see the info about that device, then the name, the creation date, workspace and fleet of belonging, etc. In addition you will see the Tag Console, which will show you in real time the data that that device is publishing in a specific tag. At the top you can see some summary information on your device such as name, id, fleet to which it belongs, associated tags, the firmware version, the status of the jobs called and the last time your device was seen online. Data Console At the end of device pages, you can find the Data Console, it allows you to see what data your device publishes in real time. By clicking in the left checkboxes you can better navigate the published data, they will be presented on the right in the \u201cShow selected Data\u201d box.","title":"The ZDM web user interface"},{"location":"deploy/Deploy%20and%20Manage/#the-zdm-command-line-interface","text":"This section is a guide for the most used ZDM CLI commands. Note that the zdm command line interface is available from Zerynth >= r2.4.3, download it here or update to the last version! Adding ZDM to the OS path In order to use the zdm command line interface, you need to add it to your OS path: On Linux: open the terminal and launch the following command: ~/. zerynth2 / sys / cli / zpm setpaths Close and reopen the terminal or reload the \u201csource\u201d builtin command. On Windows: open the command prompt as administrator and launch the following command: % userprofile % \\ zerynth2 \\ sys \\ cli \\ zpm setpaths Close and reopen the command prompt. On Mac: open the terminal and launch the following command: ~/. zerynth2 / sys / cli / zpm setpaths Close and reopen the terminal or reload the \u201csource\u201d builtin command. Now you can use the zdm command line interface by typing on your command prompt zdm To see the list of all the possible commands with details use the help command with option \u2013help . For example zdm \u2013help or zdm device \u2013help . Login The first step to use the ZDM (Zerynth device manager) using the Zerynth Toolchain is to log in using your Zerynth account. Open a terminal and type this command to login with your Zerynth account: zdm login You will be redirected to the Zerynth SSO and, once logged, you will see your authorization token. Copy the generated token and paste it into the terminal. If you\u2019re logging in for the first time, a default workspace and a default fleet will be created for your account. The first step to work with your devices and ZDM is to associate your devices to a fleet inside a workspace, so you can choose to use the default ones or to create your first custom workspace and fleet. Account commands Account\u2019s information Once you\u2019re logged in, if you want to see your account information use the command: zdm profile Logout To logout of the ZDM give the command: zdm logout and your current session will be closed. Workspaces Workspace creation To create a new workspace use the following command: zdm workspace create [ WorkspaceName ] WorkspaceName is the name you want to give to your workspace (don\u2019t use \u201cdefault\u201d). You can also give your workspace a description using the option \u2013description If you create a workspace, you will see your workspace\u2019s information: ID Name Description wks-id my-first description Once you\u2019ve created a workspace, you should create a fleet inside to be able to manage your devices\u2019 data. Copy your new workspace\u2019s id or use the list workspaces command to see all your workspaces. List workspaces and workspace information If you want to see the list of workspaces you\u2019ve created, their name, description and id type the command: zdm workspace all You can also get information about one single workspace from your list giving the command: zdm workspace get [ WorkspaceId ] Fleets Fleet creation To create a new fleet type the following command: zdm fleet create [ FleetName ] [ WorkspaceId ] Also in this case, don\u2019t use \u201cdefault\u201d as the fleet name, and use one of your workspaces\u2019 id to create your new fleet. A result message with the fleet name will be shown. List fleets and fleet information If you want to see the list of fleets you\u2019ve created type: zdm fleet all You will have the fleet id, the name, and the workspace id of all of your fleets. Devices Device creation Once you have created a new workspace and fleet, or you\u2019ve decided to skip and to use the default ones, you can create a new device. To create a device type the command: zdm device create [ DeviceName ] [ FleetId ] DeviceName represents the device\u2019s name, FleetId is the fleet id you want the device to belong to. If you don\u2019t specify a fleet id, the device will be associated to the default fleet in the default workspace. To authenticate your new device, you have to generate a key for the device with the corresponding command. Let\u2019s see a description of the other commands you can use to manage devices. Device list and device information If you want to list your devices or to get a device information you can use the list and get commands, to see the device name, id, and fleet id. Give the command: zdm device all to list all your devices or zdm device get [ DeviceId ] to have information about a single device. Get the device\u2019s workspace To get the workspace\u2019s name and id that contains your device, you can use the following command: zdm device workspace [ DeviceId ] Device\u2019s key generation To be able to manage your device\u2019s data you have to create a key at first and then generate a password (as jwt token) from the created key. The generated key can be used as the password to connect your device to the ZDM in your firmware. You can generate different keys with different names for your devices with the command: Create a new key. zdm device key create [ DeviceId ] [ Name ] Generate a new Jwt password for a device starting from a generated key. zdm device key generate [ DeviceId ] [ KeyId ] Jobs and actions You can use ZDM to remotely send a job command to your devices. To send a new job to a device, you just have to start it using the command: zdm job schedule [ name ] [ devices ] The \u2018name\u2019\u2019 argument is a string representing the method name. The \u2018devices\u2019\u2019 argument is a list of the device ids you want to schedule the job (i.e. [\u201cdevice1\u201d, \u201cdevice2\u201d]). If the device needs some arguments to execute the job, you can use the \u2013arg option. Events You can use ZDM CLI to see the last 25 events sent by your devices. Use the command zdm event list [ workspaceId ] If you want to see the last 25 events filtering on device use the option -- device - id [ deviceId ] It\u2019s also possible to filter results on date. You can indicate a start and end date (RFC3339 format) using the options: -- start [ startDate ] -- end [ endDate ] Fota (Firmware over the air) Important: In order to perform the FOTA of a device you need to have a Virtual machine with the \u201cFota Enable\u201d feature. Upload a firmware The first step to start a FOTA update on your devices is to upload a firmware to the ZDM cloud. To upload your firmware, use the command: zdm fota prepare [ firmwareProjectPath ] [ DeviceId ] [ Version ] Where firmwareProjectPath is the firmware\u2019s project location in your local file system, deviceId is the id of the device you want to update, version is a string used to label your firmware (e.g., \u201c1.0\u201d) Note that the firmware will be associated with the workspace that contains your device. If you will associate new devices to the same workspace you can send them the same firmware. Start FOTA Once you\u2019ve uploaded your firmware, you can send the FOTA command to the device typing: zdm fota schedule [ FirmwareVersion ] [ DeviceId ] For example: schedule the new firmware to the device with id dev-yyyyy zdm fota schedule 1.0 dev - yyyy Check FOTA status To check the status of a FOTA you started, to know if the device finished the task or if an error occurred, give the following commands to have a list of your fota and their status: zdm fota check [ DeviceId ] Gates Using the ZDM you\u2019re able to also receive your device\u2019s data on your webhooks. For example you can send data to a WebHook server or to Ubidots (see the example section). Now let\u2019s see a complete example, on how to connect a device to the ZDM and see data using an Ubidots dashboard and widgets.","title":"The ZDM Command Line Interface"},{"location":"deploy/Deploy%20and%20Manage/#zerynth-device-manager-cli-programming-guide","text":"","title":"Zerynth Device Manager CLI Programming Guide"},{"location":"deploy/Deploy%20and%20Manage/#zdm-api-documentation","text":"TK","title":"ZDM API documentation"},{"location":"deploy/Deploy%20and%20Manage/#zdm-gates","text":"TK","title":"ZDM GATES"},{"location":"deploy/Deploy%20and%20Manage/#zdm-client-python-library-for-pc-and-raspberry","text":"Zerynth Device Manager can be used for orchestrating both MCU (microcontroller) and CPU (microprocessor) based devices. If you want to connect an MCU device like a Raspberry PI, an SBC (Single Board Computer) a PC, or any Python application in general, the ZDM Client Python Library is what you need. Installation The latest stable version of the ZDM-Client Python Library is available on PyPI ( https://pypi.org/project/zdm-client-py/ ) The installation assumes that you have installed the latest Python version with pip. In order to install the ZDM-Client Python Library, type the following command or add the zdm-client-py into the requirements.txt file. pip install zdm - client - py If you want, you can also download the repository publicly available on GitHub. git clone https : // github . com / zerynth / zdm - client - py . git navigate to the download repo directory and create a virtual env using the command virtualenv venv And install the python package locally. pip install Usage Once you have installed the ZDM-client Python lib you can use it for connecting your CPU based device to the ZDM and stream your data. Login to the ZDM in order to obtain the device id and the password of a device (see the ZDM getting started guide for more info) Create a new file zdm_basic.py and copy the following script and replace the obtained device id and password in the placeholders. CODE TO BE TAKEN FROM WP ARTICLE Jobs In addition, the ZDM-client Python lib permits also to define a set of jobs on the client that can be invoked by the ZDM. The jobs are passed to the ZDMClient as a dictionary, where the key is the name of the job and the value is the corresponding function to execute. The example below illustrates a simple example of a client exposing one job named set_temp. Upon the device receiving the Job, it executes the corresponding function and returns a result of a JSON object. Copy the following script into a new file hello_jobs.py. CODE TO BE TAKEN FROM WORDPRESS Now, you can schedule the job in two different ways: by using the ZDM UI or the ZDM CLI. ZDM UI Steps needed to execute the job \u201cset_led\u201d on the device by using the ZDM UI: Login to the ZDM ( https://zdm.zerynth.com/login ) Click on the workspace where the device is associated. On the section \u201cMy Devices\u201d, click the checkbox of the device Click on the button \u201cJobs\u201d, and on the popup select the job Name \u201cset_temp\u201d in the Job Name dropdown menu. Add to the \u201cArguments\u201d section any arguments of the function in json format (if any). For this example, you can leave the field empty. Click on \u201cLaunch Job\u201d button. ZDM CLI Steps needed to execute the job \u201cset_led\u201d on the device by using the ZDM CLI. Make sure you have configured the ZDM CLI ( https://www.zerynth.com/blog/docs/the-tools/zdm/getting-started/ ). In order to schedule the job, type the following command (where the DEVICE_ID must be substituted with the actual id of the device): zdm job schedule set_temp < DEVICE_ID > Expected result: If the job has been correctly scheduled to the zdm client py, the following message will appear in the console: Executing job set_temp . Received args : {} [ INFO | zdmclient . py : 185 ] > [ DEVICE - ID ] job set_temp executed with result res :{ \"msg\" : \"Temperature set correctly.\" } That \u2019 s all ! Edit the script file and build your own ZDM powered IOT project !","title":"ZDM Client Python Library for PC and Raspberry"},{"location":"deploy/img/test.md/","text":"Written with StackEdit .","title":"Test.md"},{"location":"develop/Develop/","text":"Develop \u00b6 This section introduces you to the main features of Zerynth and provides you a step-by-step guide to get started with the system. Take a look at the video below to see Zerynth in action! Create a Zerynth User Account \u00b6 It is necessary to create a User Account to access Zerynth. To register a new Zerynth Account or to Log in an existing one, you can proceed manually ( email , username and password ) or you can automatically register/login with social credentials ( Facebook and Google+ ). Note For Manual Registration: check your email and verify your new account by clicking on the link provided in the confirmation email Warning The first time you create a user account or if you have sign-in issues, a restart of Zerynth Studio might be necessary Connect, Register and Virtualize your Device \u00b6 To make a device usable with Zerynth, you need to Connect , Register , and \u201cVirtualize\u201d it. According to the platform used and to the connected device, the user has to install the related driver to make the machine able to recognize and exchange data with the board. Warning Procedure to install drivers, if needed, is reported device by device in Supported Devices . The Registration phase is the process of retrieving the device info to allow the Zerynth backend to build its specific virtual machine. If the device has never been connected before, by clicking the \u201cZ\u201d button, the registration dialog, shown above, is displayed. To register a new device, you can follow these steps: connect your device to the machine. The \u201cDevices Management Widget\u201d notifies the devices list update with a yellow blink; select the device from the dropdown menu; click on the \u201cZerynth\u201d button. Zerynth Studio will guide you in the entire process through info messages displayed in the log console section at the bottom of the screen. Note \u201cPowered by Zerynth\u201d devices are accompained by a redeemable code that can be inserted in the above window and exchanged for a free virtual machine license. Warning Some devices require to be set in Device Firmware Update (DFU) mode in order to allow their registration and the flashing of the Zerynth Virtual Machine. Detailed guides on how to put them in DFU mode is available in the Supported Devices section of the documentation. Once registration has been performed, the user is given the option to create a Virtual Machine for the registered device by clicking again the \u201cZ\u201d button. Note A device can always be registered again with the dedicated dialog button. In the figure below, after clicking the \u201cCreate\u201d button, the user can select one available of different virtual machines compatible with the target device choosing the licenses (Starter/Premium), the real time operating system from those supported for the target device, and (for Premium licenses only) the features to be included in the virtual machine (FOTA, Power Saving, Secure Firmware, etc.). Note Some devices cannot be recognized automatically; for these devices, the dialog provides some more options to be specified before the actual registration/virtualization can take place. Warning The \u201cAvailable\u201d column in the table shows the possibility to create the related virtual machine according to the user asset. The created Virtual Machine can now be virtualized (i.e. burned on the device). The \u201cVirtualization\u201d is the process of installing the Zerynth Virtual Machine by flashing it on a device. By clicking the \u201cVirtualize\u201d button, the user can select the Zerynth Virtual Machine to be installed in his device choosing from those created. Note Zerynth Studio toolbar allows to \u201cVirtualize\u201d the selected device. Zerynth Devices \u00b6 The supported devices are grouped into Physical Devices (the ones physically connected to the local machine) and Virtual Devices (the devices usable with Zerynth). The Zerynth \u201cVirtual Devices\u201d feature allows to implement and develop the user application verifying the code for all the supported devices, without having them physically connected to the local machine. Once the desired supported device (virtual or physically connected) is selected, Zerynth Studio displays all collected info related to the chosen device in 2 different dialogs: Device Info Window ; Device Pinmap Window . The Device Info Window shows detailed information about the device, including the Flash/Ram size and the port for serial communication. Warning Some boards cannot be automatically recognized by Zerynth Studio and need a disambiguation. In this case the system asks you to indicate the device type. You can always revert this choice by clicking on the \u201cForget\u201d button. Finally, the Device Pinmap window provides the pinout of the selected device, along with the hardware features and peripherals available on each pin. Thanks to the Device Pinmap window it is also possible to understand how the device embedded peripherals are grouped and/or multiplexed. This allows to better understand how to use each specific hardware feature in the Zerynth Python scripts without having hardware conflicts. Clone an example and start with Zerynth Python Scripts \u00b6 Zerynth Studio includes many examples to get started: from the most basic ones to the examples related to the installed libraries. Zerynth examples cannot be edited, they are \u201cread only\u201d folders and they can be used as reference for the design of new projects. Zerynth examples can be cloned in just few clicks: open the Examples browser by clicking on the \u201clight bulb\u201d icon on the left panel of Zerynth Studio; select the example you prefer and clone it by clicking on the dedicated button; At this stage Zerynth converts the example into a new project giving you the possibility to edit the Title , the Description and the Folder of your new project project; click on \u201cCreate\u201d and you are done! Warning Remember that Zerynth does not allow two projects to have the same Folder Verify and Uplink a Zerynth Project \u00b6 The buttons on the upper left toolbar allow you to verify and uplink a script into a device. To verify a project click on the Verify icon to check your script for errors. The errors will be reported in the console and in the code editor with helpful tooltips. To Uplink your verified project into a Virtualized device just click the Uplink icon and follow the Zerynth Studio messages. Warning Some devices require to be reset during the uplink operation in order to write in flash the bytecode Develop your First Zerynth Project \u00b6 To create your First Zerynth Project from scratch you have to do just a few steps: click on the button \u201cBrowse Project\u201d; click on \u201cNew Project\u201d; Decide a project title and the project folder, and write an optional description; click on the \u201cCreate\u201d button. Once you click on the \u201cCreate\u201d button, the new Zerynth Project opens and you will be prompted with the editor of the \u201cmain.py\u201d file. The main is where the principal Zerynth code is written in Python: here is where you develop the logic of your script. If you wish to add more files to the Zerynth project you can easily do it. In Zerynth you can create html, json, txt, bin files and save them together with the bytecode on the device flash memory. You can also create more .py files where you can develop other parts of your code like modules and functions to be used in the main.py file. To add new files to a Zerynth project, follow these steps: click on \u201cBrowse Project\u201d; click on \u201cAdd file\u201d ; after naming the file click on \u201cCreate\u201d; write the code within the empty field in the editor; You can also add a new folder, delete a selected file, refresh the project folder, etc. by clicking the icon on the right of the \u201cProject view\u201d bar. Note When you add a .py file containing some code to be used in the main.py file (e.g. a file named helpers.py ), you have to import it by adding the line import helpers in the main.py file. Thus, you can call functions located in the helpers.py file by using the following syntax: helpers.fun_name(fun_attribute1, fun_attribute2, ...) !! note If you want to save the template.html in the device flash as resource to be used by a specific module like the Zerynth App library, you have to use the new_resource() function defining the following code in the main.py file: new_resource(\"template.html\") Import a Zerynth Package into a Project \u00b6 Packages import syntax is very simple: Official Packages are imported with: from c import m where c is the name of the package and m is the name of a module inside the package. (e.g. from cc3000 import cc3000 or from cc3000 import cc3000_tiny ). Community Packages are imported with: from community.b.c import m where b is the namespace of the package, c is the package name and m is the name of a module (e.g. from community.floyd.rtttl import rtttl ) The import autocomplete feature of Zerynth Studio makes the task of importing modules even easier: as soon as \u201cfrom\u201d or \u201cimport\u201d is typed in the code editor, the autocomplete box lists all the matching modules. The Zerynth Programming Guide and various programming examples are also provided. For both the Official Library and the Community Library, a complete documentation is available and if the package contains usage examples, they can be found under the examples tab. Finally, if you need help with Python, here you can find a good overview on Python 3 with simple and exhaustive examples. You can always post your questions and doubts on the Zerynth Community Forum logging-in with your Zerynth Account. Zerynth Studio updates \u00b6 Zerynth Studio has two different update mechanisms: major system release rolling updates When a new major version of Zerynth is released a notification \u201cSystem Update!\u201d will appear in the footer area of Zerynth Studio. By clicking the notification, the new version will be downloaded and installed. After a restart, the new version will be selected and launched. However, the previous version is still there and can be selected during the launch phase. If a previous version is not needed anymore, it can be deleted from the \u201cPreferences\u201d menu. On the contrary, rolling updates do not change the system version but just a group of packages. Rolling updates are notified by the \u201cRolling update\u201d label in the footer area of Zerynth Studio. By clicking the notification, the list of updated packages and a detailed changelog are displayed. If accepted, a rolling update will download the selected packages only and will unpack them. After a restart, the launcher will take care of finishing the update and start Zerynth Studio. Zerynth and Git \u00b6 Zerynth Studio offers the possibility to store your projects on our backend, in a private git repository. Such feature is accessible from the Project View in the left panel by clicking the git \u201ccode-branch\u201d icon. The first time a project is pushed to our backend, the \u201cCreate repository\u201d option must be selected. From there on, the project view changes, showing a footer with information about the current remote/branch, the current tag if present, the number of modified files (identified by a bullet) and the status of the local repository with respect to the remote repository. The project git repository is automatically configured with a remote called \u201czerynth\u201d pointing to our backend. All git operations accessible from Zerynth Studio will operate on that remote. It is however possible to manually configure the project local repository to use different remotes (for example GitHub or GitLab). However, such configuration is up to the user. Git operations not featured in Zerynth Studio (for example \u201cmerge\u201d), can be performed manually using git from the command line. Search and Install Community Libraries \u00b6 Zerynth allows searching and installing libraries created by Zerynth users and hosted on GitHub. Libraries can be searched and installed from the Zerynth Library Manager Section (\u201cpuzzle\u201d icon) in the left toolbar. The latest version is displayed and options to update or downgrade the library are present. The results of the search are shown in the left column that displays a brief description of the libraries together with the available version. By clicking \u201cInstall\u201d or \u201cUpdate\u201d the library can be easily added to the system. Publishing community libraries \u00b6 Zerynth Studio allows publishing your projects as community libraries that can be installed by everyone else in the Zerynth community. To publish a project, select the \u201cPublish\u201d option for the currently opened project to fire up the publish wizard. The first step is needed to get the user permission to manage the Github repository where the library will be hosted. In order to do so, a popup window will be displayed and the Github authorization flow for Zerynth will be started. It is usually needed to login to Github with the user credentials and authorize Zerynth. Upon correct authorization the Zerynth backend will associate the Github account with the user Zerynth account. In the second step the Github repository to host the library on must be chosen from the available ones. Some information on the library must be given in this step, namely: the library title: will be displayed in the Library Manager the library description: a short text that will be displayed in the Library Manager and that will be indexed to ease searching for libraries a list of keywords to tag the library the version of the library that will be made available after publishing a descriptive text for the version (usually a list of changes, bugfixes and improvements) If the library has already been published, some of the required field will be automatically filled. The third step is a recap of what is going to happen during the publishing; read it carefully and confirm the repository, the project and the version of the library! In the last step the selected Github repository is cloned, the project to be published is copied in and the changes are committed and pushed back to the master branch. Also, a new Github release is created with version and description given in step 2. As soon as the Zerynth backend discovers the new release, the library will be made available to all the Zerynth users. Important In order for the users of your library to have a better programming experience, we strongly suggest to add examples and documentation. Please refer here for more details. Creating Custom Virtual Machines \u00b6 Zeryth Studio allows creating custom Virtual Machines for PCBs and devices based on supported microcontrollers (At the moment only ESP32 has the support for custom VMs, more architectures will be added soon). The customization process involves editing a template file where many settings like pin mapping and onboard peripherals can be specified. More info can be found here and here .","title":"Develop"},{"location":"develop/Develop/#develop","text":"This section introduces you to the main features of Zerynth and provides you a step-by-step guide to get started with the system. Take a look at the video below to see Zerynth in action!","title":"Develop"},{"location":"develop/Develop/#create-a-zerynth-user-account","text":"It is necessary to create a User Account to access Zerynth. To register a new Zerynth Account or to Log in an existing one, you can proceed manually ( email , username and password ) or you can automatically register/login with social credentials ( Facebook and Google+ ). Note For Manual Registration: check your email and verify your new account by clicking on the link provided in the confirmation email Warning The first time you create a user account or if you have sign-in issues, a restart of Zerynth Studio might be necessary","title":"Create a Zerynth User Account"},{"location":"develop/Develop/#connect-register-and-virtualize-your-device","text":"To make a device usable with Zerynth, you need to Connect , Register , and \u201cVirtualize\u201d it. According to the platform used and to the connected device, the user has to install the related driver to make the machine able to recognize and exchange data with the board. Warning Procedure to install drivers, if needed, is reported device by device in Supported Devices . The Registration phase is the process of retrieving the device info to allow the Zerynth backend to build its specific virtual machine. If the device has never been connected before, by clicking the \u201cZ\u201d button, the registration dialog, shown above, is displayed. To register a new device, you can follow these steps: connect your device to the machine. The \u201cDevices Management Widget\u201d notifies the devices list update with a yellow blink; select the device from the dropdown menu; click on the \u201cZerynth\u201d button. Zerynth Studio will guide you in the entire process through info messages displayed in the log console section at the bottom of the screen. Note \u201cPowered by Zerynth\u201d devices are accompained by a redeemable code that can be inserted in the above window and exchanged for a free virtual machine license. Warning Some devices require to be set in Device Firmware Update (DFU) mode in order to allow their registration and the flashing of the Zerynth Virtual Machine. Detailed guides on how to put them in DFU mode is available in the Supported Devices section of the documentation. Once registration has been performed, the user is given the option to create a Virtual Machine for the registered device by clicking again the \u201cZ\u201d button. Note A device can always be registered again with the dedicated dialog button. In the figure below, after clicking the \u201cCreate\u201d button, the user can select one available of different virtual machines compatible with the target device choosing the licenses (Starter/Premium), the real time operating system from those supported for the target device, and (for Premium licenses only) the features to be included in the virtual machine (FOTA, Power Saving, Secure Firmware, etc.). Note Some devices cannot be recognized automatically; for these devices, the dialog provides some more options to be specified before the actual registration/virtualization can take place. Warning The \u201cAvailable\u201d column in the table shows the possibility to create the related virtual machine according to the user asset. The created Virtual Machine can now be virtualized (i.e. burned on the device). The \u201cVirtualization\u201d is the process of installing the Zerynth Virtual Machine by flashing it on a device. By clicking the \u201cVirtualize\u201d button, the user can select the Zerynth Virtual Machine to be installed in his device choosing from those created. Note Zerynth Studio toolbar allows to \u201cVirtualize\u201d the selected device.","title":"Connect, Register and Virtualize your Device"},{"location":"develop/Develop/#zerynth-devices","text":"The supported devices are grouped into Physical Devices (the ones physically connected to the local machine) and Virtual Devices (the devices usable with Zerynth). The Zerynth \u201cVirtual Devices\u201d feature allows to implement and develop the user application verifying the code for all the supported devices, without having them physically connected to the local machine. Once the desired supported device (virtual or physically connected) is selected, Zerynth Studio displays all collected info related to the chosen device in 2 different dialogs: Device Info Window ; Device Pinmap Window . The Device Info Window shows detailed information about the device, including the Flash/Ram size and the port for serial communication. Warning Some boards cannot be automatically recognized by Zerynth Studio and need a disambiguation. In this case the system asks you to indicate the device type. You can always revert this choice by clicking on the \u201cForget\u201d button. Finally, the Device Pinmap window provides the pinout of the selected device, along with the hardware features and peripherals available on each pin. Thanks to the Device Pinmap window it is also possible to understand how the device embedded peripherals are grouped and/or multiplexed. This allows to better understand how to use each specific hardware feature in the Zerynth Python scripts without having hardware conflicts.","title":"Zerynth Devices"},{"location":"develop/Develop/#clone-an-example-and-start-with-zerynth-python-scripts","text":"Zerynth Studio includes many examples to get started: from the most basic ones to the examples related to the installed libraries. Zerynth examples cannot be edited, they are \u201cread only\u201d folders and they can be used as reference for the design of new projects. Zerynth examples can be cloned in just few clicks: open the Examples browser by clicking on the \u201clight bulb\u201d icon on the left panel of Zerynth Studio; select the example you prefer and clone it by clicking on the dedicated button; At this stage Zerynth converts the example into a new project giving you the possibility to edit the Title , the Description and the Folder of your new project project; click on \u201cCreate\u201d and you are done! Warning Remember that Zerynth does not allow two projects to have the same Folder","title":"Clone an example and start with Zerynth Python Scripts"},{"location":"develop/Develop/#verify-and-uplink-a-zerynth-project","text":"The buttons on the upper left toolbar allow you to verify and uplink a script into a device. To verify a project click on the Verify icon to check your script for errors. The errors will be reported in the console and in the code editor with helpful tooltips. To Uplink your verified project into a Virtualized device just click the Uplink icon and follow the Zerynth Studio messages. Warning Some devices require to be reset during the uplink operation in order to write in flash the bytecode","title":"Verify and Uplink a Zerynth Project"},{"location":"develop/Develop/#develop-your-first-zerynth-project","text":"To create your First Zerynth Project from scratch you have to do just a few steps: click on the button \u201cBrowse Project\u201d; click on \u201cNew Project\u201d; Decide a project title and the project folder, and write an optional description; click on the \u201cCreate\u201d button. Once you click on the \u201cCreate\u201d button, the new Zerynth Project opens and you will be prompted with the editor of the \u201cmain.py\u201d file. The main is where the principal Zerynth code is written in Python: here is where you develop the logic of your script. If you wish to add more files to the Zerynth project you can easily do it. In Zerynth you can create html, json, txt, bin files and save them together with the bytecode on the device flash memory. You can also create more .py files where you can develop other parts of your code like modules and functions to be used in the main.py file. To add new files to a Zerynth project, follow these steps: click on \u201cBrowse Project\u201d; click on \u201cAdd file\u201d ; after naming the file click on \u201cCreate\u201d; write the code within the empty field in the editor; You can also add a new folder, delete a selected file, refresh the project folder, etc. by clicking the icon on the right of the \u201cProject view\u201d bar. Note When you add a .py file containing some code to be used in the main.py file (e.g. a file named helpers.py ), you have to import it by adding the line import helpers in the main.py file. Thus, you can call functions located in the helpers.py file by using the following syntax: helpers.fun_name(fun_attribute1, fun_attribute2, ...) !! note If you want to save the template.html in the device flash as resource to be used by a specific module like the Zerynth App library, you have to use the new_resource() function defining the following code in the main.py file: new_resource(\"template.html\")","title":"Develop your First Zerynth Project"},{"location":"develop/Develop/#import-a-zerynth-package-into-a-project","text":"Packages import syntax is very simple: Official Packages are imported with: from c import m where c is the name of the package and m is the name of a module inside the package. (e.g. from cc3000 import cc3000 or from cc3000 import cc3000_tiny ). Community Packages are imported with: from community.b.c import m where b is the namespace of the package, c is the package name and m is the name of a module (e.g. from community.floyd.rtttl import rtttl ) The import autocomplete feature of Zerynth Studio makes the task of importing modules even easier: as soon as \u201cfrom\u201d or \u201cimport\u201d is typed in the code editor, the autocomplete box lists all the matching modules. The Zerynth Programming Guide and various programming examples are also provided. For both the Official Library and the Community Library, a complete documentation is available and if the package contains usage examples, they can be found under the examples tab. Finally, if you need help with Python, here you can find a good overview on Python 3 with simple and exhaustive examples. You can always post your questions and doubts on the Zerynth Community Forum logging-in with your Zerynth Account.","title":"Import a Zerynth Package into a Project"},{"location":"develop/Develop/#zerynth-studio-updates","text":"Zerynth Studio has two different update mechanisms: major system release rolling updates When a new major version of Zerynth is released a notification \u201cSystem Update!\u201d will appear in the footer area of Zerynth Studio. By clicking the notification, the new version will be downloaded and installed. After a restart, the new version will be selected and launched. However, the previous version is still there and can be selected during the launch phase. If a previous version is not needed anymore, it can be deleted from the \u201cPreferences\u201d menu. On the contrary, rolling updates do not change the system version but just a group of packages. Rolling updates are notified by the \u201cRolling update\u201d label in the footer area of Zerynth Studio. By clicking the notification, the list of updated packages and a detailed changelog are displayed. If accepted, a rolling update will download the selected packages only and will unpack them. After a restart, the launcher will take care of finishing the update and start Zerynth Studio.","title":"Zerynth Studio updates"},{"location":"develop/Develop/#zerynth-and-git","text":"Zerynth Studio offers the possibility to store your projects on our backend, in a private git repository. Such feature is accessible from the Project View in the left panel by clicking the git \u201ccode-branch\u201d icon. The first time a project is pushed to our backend, the \u201cCreate repository\u201d option must be selected. From there on, the project view changes, showing a footer with information about the current remote/branch, the current tag if present, the number of modified files (identified by a bullet) and the status of the local repository with respect to the remote repository. The project git repository is automatically configured with a remote called \u201czerynth\u201d pointing to our backend. All git operations accessible from Zerynth Studio will operate on that remote. It is however possible to manually configure the project local repository to use different remotes (for example GitHub or GitLab). However, such configuration is up to the user. Git operations not featured in Zerynth Studio (for example \u201cmerge\u201d), can be performed manually using git from the command line.","title":"Zerynth and Git"},{"location":"develop/Develop/#search-and-install-community-libraries","text":"Zerynth allows searching and installing libraries created by Zerynth users and hosted on GitHub. Libraries can be searched and installed from the Zerynth Library Manager Section (\u201cpuzzle\u201d icon) in the left toolbar. The latest version is displayed and options to update or downgrade the library are present. The results of the search are shown in the left column that displays a brief description of the libraries together with the available version. By clicking \u201cInstall\u201d or \u201cUpdate\u201d the library can be easily added to the system.","title":"Search and Install Community Libraries"},{"location":"develop/Develop/#publishing-community-libraries","text":"Zerynth Studio allows publishing your projects as community libraries that can be installed by everyone else in the Zerynth community. To publish a project, select the \u201cPublish\u201d option for the currently opened project to fire up the publish wizard. The first step is needed to get the user permission to manage the Github repository where the library will be hosted. In order to do so, a popup window will be displayed and the Github authorization flow for Zerynth will be started. It is usually needed to login to Github with the user credentials and authorize Zerynth. Upon correct authorization the Zerynth backend will associate the Github account with the user Zerynth account. In the second step the Github repository to host the library on must be chosen from the available ones. Some information on the library must be given in this step, namely: the library title: will be displayed in the Library Manager the library description: a short text that will be displayed in the Library Manager and that will be indexed to ease searching for libraries a list of keywords to tag the library the version of the library that will be made available after publishing a descriptive text for the version (usually a list of changes, bugfixes and improvements) If the library has already been published, some of the required field will be automatically filled. The third step is a recap of what is going to happen during the publishing; read it carefully and confirm the repository, the project and the version of the library! In the last step the selected Github repository is cloned, the project to be published is copied in and the changes are committed and pushed back to the master branch. Also, a new Github release is created with version and description given in step 2. As soon as the Zerynth backend discovers the new release, the library will be made available to all the Zerynth users. Important In order for the users of your library to have a better programming experience, we strongly suggest to add examples and documentation. Please refer here for more details.","title":"Publishing community libraries"},{"location":"develop/Develop/#creating-custom-virtual-machines","text":"Zeryth Studio allows creating custom Virtual Machines for PCBs and devices based on supported microcontrollers (At the moment only ESP32 has the support for custom VMs, more architectures will be added soon). The customization process involves editing a template file where many settings like pin mapping and onboard peripherals can be specified. More info can be found here and here .","title":"Creating Custom Virtual Machines"},{"location":"gettingstarted/Getting%20Started/","text":"The Zerynth SDK is the gateway to our platform and includes: The Zerynth Toolchain \u2013 a command-line interface that integrates all the essential functions for the development of Zerynth OS firmware and the management of the Zerynth Device Manager cloud service. The Zerynth Studio \u2013 an advanced IDE for the Zerynth Toolchain. It includes development and debugging tools and numerous code examples. To install the ZSDK download the latest Zerynth Release according to your platform from the Zerynth Download page . Note Zerynth works only on 64-bit platform Start Zerynth Installation and agree to the Term of Service To start the installation, according to your platform, you can: Double click on the executable file for installing Zerynth on Microsoft Windows Open and run the Disk image (.dmg) file for installing Zerynth on Mac OS Extract the \u201ctar.xz\u201d archive and run the \u201c./zerynth\u201d command from the terminal to install Zerynth on Linux Warning Only for Microsoft Windows platform: if the alert message for \u201callowing unknown publisher to make changes to this computer\u201d appears click on the \u201cYes\u201d option Once the installation has started, the window below will appear and you are asked to agree to the \u201cLicense and Service Terms\u201d to continue the operation Note To read all the agreement conditions, you can click on provided links Then, after accepting the agreement conditions, you can choose between two options to complete the installation: online and offline. The online installation is recommended. The Offline Installation meets the needs of educational and training courses, workshops, or places with network and internet issues. It enables you to download an offline package repository and share it with other people, to facilitate and speed up the installation operations. If you choose the online installation, you can select which version of Zerynth Studio you want to install. By clicking the install button, the required files are downloaded from Zerynth online repository and automatically installed. If you choose the Offline Installation you need to have downloaded also the offline package repository in advance related to your platform (Windows, Mac, Linux), from the Zerynth Download page . Normal Installation and Expert mode \u00b6 To reduce the number of files downloaded during the installation process, the installer will let you choose which of the supported architectures to install. By clicking \u201cInstall\u201d none of the available architectures will be downloaded and you will be prompted to download the needed dependencies whenever Zerynth Studio recognizes a new board. By choosing the \u201cExpert Mode\u201d you will be able to select the architectures you wish to download right now, but you will still be prompted to install the needed dependencies if you connect a board with an architecture not included in the already downloaded ones. Unpack and Install all The Zerynth Packages \u00b6 Now the system unpacks and installs all the required packages creating a working instance on your local machine; you have to wait a few minutes to complete the Zerynth installation. Launch Zerynth Studio and you\u2019ll be ready to work. Third-Party IDE plugins \u00b6 Once you have the ZSDK installed you can also code using your favorite IDE by installing the dedicated plugin or using the ready to use project template. For more details on how to develop for Zerynth OS follow the Develop guide we made for Zerynth studio, the main steps are the same also for third party IDEs. VSCode \u00b6 This is a step by step guide for enabling Zerynth programming in Microsoft Visual Studio Code for developing Internet of Things applications. VSCode is a free multi-language editor that can be downloaded and installed from here . We prepared a VSCode template project that enables the execution of compilation, uplink, and other functions of the Zerynth toolchain (ZTC) directly from VSCode while also adding support for Zerynth libraries auto-completion. Note This guide requires Zerynth Version 2.5.1 or later Download the VSCode project template for your platform from here: Windows Linux Mac Note the templates follow the Zerynth distribution versioning. Go to the Github release section and download the template for your Zerynth installation version. We strongly suggest having Zerynth always updated to the last version thus install the last release fo the VSCode templates. The template is a ready-to-use VSCode project for Zerynth. Open the template folder and you are ready to code. The most important files in the template are: main.py: Write your Zerynth code here Project.yml: The project configuration file where the target board, board port, and other info need to be added in order to allow compilation, uplink, and other functionalities of the Zerynth tool-chain. The Zerynth commands integrated into the VSCode will support you in preparing the project.yml, see below. Commands Usage Press CTRL+SHIFT+B and select the ZTC command to launch. The following ZTC commands are available: Login: Open a browser for authentication; paste the authentication token into the vscode terminal Show Supported Device: the list of supported devices is shown on the terminal, find the \u201ctarget\u201d name of your device. Jtag probe support is also displayed. Set Target Device Type: change the target device of the current project. Type your device target name found in the previous step Register Device: starts the device registration procedure (mandatory for new devices). It updates the project configuration with the device identifier Show Available Virtual Machines: displays the various virtual machine available for the device. Choose one and note down version, features, and RTOS. Open project.yml and type the version, RTOS and feature fields in the VM section Virtualize Device: starts the device virtualization procedure (mandatory for new boards). Create, download, and transfer the selected VM on the device. Automatically updates project configuration Compile: Compiles the current project. If you get an error about missing dependencies, run the Install Deps command below Show Available Ports: list the serial ports on your system; Note down the one corresponding to your device Set Target Device Port: set the serial port of the device from the previous list Set Target Device Probe: if the device is programmable with a jtag probe, set the correct value Uplink: uplink the current project on the selected target device (must be virtualized at least once) Clean: clean the project cache and allows full recompilation of sources Install Deps: Installs missing dependencies and libs required by the project Open Device Console: Opens the serial console on the target device port; Press Ctrl+C twice to close it Prepare FOTA: create and uploads new firmware to the ZDM. The device_id to prepare the firmware for needs to be specified in the project.yml file under the zdm section (zdm: {device_id: XXXX} ); the firmware version must also be specified in the zdm fota section ( zdm: { fota: {version: X }}); By running the command on a new project, the required fields with empty values are automatically added to the configuration. Edit them with your device data. To add other commands or customize them you can follow this guide: https://code.visualstudio.com/docs/editor/tasks#vscode","title":"Getting Started"},{"location":"gettingstarted/Getting%20Started/#normal-installation-and-expert-mode","text":"To reduce the number of files downloaded during the installation process, the installer will let you choose which of the supported architectures to install. By clicking \u201cInstall\u201d none of the available architectures will be downloaded and you will be prompted to download the needed dependencies whenever Zerynth Studio recognizes a new board. By choosing the \u201cExpert Mode\u201d you will be able to select the architectures you wish to download right now, but you will still be prompted to install the needed dependencies if you connect a board with an architecture not included in the already downloaded ones.","title":"Normal Installation and Expert mode"},{"location":"gettingstarted/Getting%20Started/#unpack-and-install-all-the-zerynth-packages","text":"Now the system unpacks and installs all the required packages creating a working instance on your local machine; you have to wait a few minutes to complete the Zerynth installation. Launch Zerynth Studio and you\u2019ll be ready to work.","title":"Unpack and Install all The Zerynth Packages"},{"location":"gettingstarted/Getting%20Started/#third-party-ide-plugins","text":"Once you have the ZSDK installed you can also code using your favorite IDE by installing the dedicated plugin or using the ready to use project template. For more details on how to develop for Zerynth OS follow the Develop guide we made for Zerynth studio, the main steps are the same also for third party IDEs.","title":"Third-Party IDE plugins"},{"location":"gettingstarted/Getting%20Started/#vscode","text":"This is a step by step guide for enabling Zerynth programming in Microsoft Visual Studio Code for developing Internet of Things applications. VSCode is a free multi-language editor that can be downloaded and installed from here . We prepared a VSCode template project that enables the execution of compilation, uplink, and other functions of the Zerynth toolchain (ZTC) directly from VSCode while also adding support for Zerynth libraries auto-completion. Note This guide requires Zerynth Version 2.5.1 or later Download the VSCode project template for your platform from here: Windows Linux Mac Note the templates follow the Zerynth distribution versioning. Go to the Github release section and download the template for your Zerynth installation version. We strongly suggest having Zerynth always updated to the last version thus install the last release fo the VSCode templates. The template is a ready-to-use VSCode project for Zerynth. Open the template folder and you are ready to code. The most important files in the template are: main.py: Write your Zerynth code here Project.yml: The project configuration file where the target board, board port, and other info need to be added in order to allow compilation, uplink, and other functionalities of the Zerynth tool-chain. The Zerynth commands integrated into the VSCode will support you in preparing the project.yml, see below. Commands Usage Press CTRL+SHIFT+B and select the ZTC command to launch. The following ZTC commands are available: Login: Open a browser for authentication; paste the authentication token into the vscode terminal Show Supported Device: the list of supported devices is shown on the terminal, find the \u201ctarget\u201d name of your device. Jtag probe support is also displayed. Set Target Device Type: change the target device of the current project. Type your device target name found in the previous step Register Device: starts the device registration procedure (mandatory for new devices). It updates the project configuration with the device identifier Show Available Virtual Machines: displays the various virtual machine available for the device. Choose one and note down version, features, and RTOS. Open project.yml and type the version, RTOS and feature fields in the VM section Virtualize Device: starts the device virtualization procedure (mandatory for new boards). Create, download, and transfer the selected VM on the device. Automatically updates project configuration Compile: Compiles the current project. If you get an error about missing dependencies, run the Install Deps command below Show Available Ports: list the serial ports on your system; Note down the one corresponding to your device Set Target Device Port: set the serial port of the device from the previous list Set Target Device Probe: if the device is programmable with a jtag probe, set the correct value Uplink: uplink the current project on the selected target device (must be virtualized at least once) Clean: clean the project cache and allows full recompilation of sources Install Deps: Installs missing dependencies and libs required by the project Open Device Console: Opens the serial console on the target device port; Press Ctrl+C twice to close it Prepare FOTA: create and uploads new firmware to the ZDM. The device_id to prepare the firmware for needs to be specified in the project.yml file under the zdm section (zdm: {device_id: XXXX} ); the firmware version must also be specified in the zdm fota section ( zdm: { fota: {version: X }}); By running the command on a new project, the required fields with empty values are automatically added to the configuration. Edit them with your device data. To add other commands or customize them you can follow this guide: https://code.visualstudio.com/docs/editor/tasks#vscode","title":"VSCode"},{"location":"gettingstarted/img/test.md/","text":"Written with StackEdit .","title":"Test.md"},{"location":"integrate/Integrate/","text":"Zerynth Device can connect directly to various external services: Amazon Web Services Integration \u00b6 Learn more Microsoft Azure Integration \u00b6 Learn more IBM Cloud Integration \u00b6 Learn more Google Cloud Integration \u00b6 Learn more Ethereum Blockchain \u00b6 Learn more","title":"Integrate"},{"location":"integrate/Integrate/#amazon-web-services-integration","text":"Learn more","title":"Amazon Web Services Integration"},{"location":"integrate/Integrate/#microsoft-azure-integration","text":"Learn more","title":"Microsoft Azure Integration"},{"location":"integrate/Integrate/#ibm-cloud-integration","text":"Learn more","title":"IBM Cloud Integration"},{"location":"integrate/Integrate/#google-cloud-integration","text":"Learn more","title":"Google Cloud Integration"},{"location":"integrate/Integrate/#ethereum-blockchain","text":"Learn more","title":"Ethereum Blockchain"},{"location":"learn/","text":"Learn \u00b6","title":"Index"},{"location":"learn/#learn","text":"","title":"Learn"},{"location":"reference/boards/Supported_Devices/","text":"The complete list of devices supported by Zerynth: Adafruit Feather Huzzah Adafruit Feather M0 Wi-Fi Adafruit Huzzah32 Arduino DUE Arduino/Genuino MKR1000 MXChip IoT DevKit AZ3166 ESP-WROOM32 DOIT Esp32 DevKit v1 ESP32 DevKitC ESP32 EthernetKit ESP32 Pico v4 DFRobot FireBeetle Esp32 DFRobot FireBeetle ESP8266 Flip & Click Sam3X Arduino/Genuino Zero Heltec Wi-Fi Kit 32 AWS Hexagon v1 Hexiwear MikroElektronika Quail NodeMCU v2 NodeMCU v3 NodeMCU ESP-32S Nordic nRF52 DK Nordic nRF52840 DK oddWires IO oddWires Proteus Olimex Esp32 EVB Olimex Esp32 Gateway Particle Core (Formerly Spark Core) Particle Electron Particle Photon Polaris 2G Polaris 3G Polaris NB-IoT PSoC6 WiFi-Bt Pioneer Kit Pycom FiPy 1.0 Pycom WiPy 3.0 RedBear Blend 2 RedBear Nano 2 Renesas PK-S5D9 Renesas TB-S5D5 Riverdi IoT Display SODAQ ExpLoRer Sony Spresense Sparkfun ESP32 Thing Sparkfun Esp8266 Thing Dev SparkFun Photon RedBoard ST Microelectronics Discovery F407VG ST Microelectronics Nucleo F401RE ST Microelectronics Nucleo F429ZI ST Microelectronics Nucleo F746ZG Wemos D1 Mini Wemos ESP32 OLED Wio Link Wireless Tag WT8266-DK V2 XinaBox CW02 (ESP32) Infineon XMC4200 Digital Power Control Card Infineon XMC4400 Enterprise Kit Infineon XMC4700 Relax Kit Infineon XMC4800 Connectivity Kit Xplained Pro Sam C21 Xplained Pro Sam C21N Xplained Pro Sam D21 Xplained Pro Sam L21 Xplained Pro Sam G55","title":"Supported Devices"},{"location":"reference/boards/adafruit_feather_huzzah/docs/","text":"Adafruit Feather Huzzah \u00b6 The Adafruit Feather Huzzah ESP8266 is an \u2018all-in-one\u2019 ESP8266 WiFi development board with built in USB and battery charging. The Feather Huzzah features 4MB of flash memory, Tensilica microcontroller (80MHz of system clock), around 50k of usable RAM and an Espressif ESP8266 chip Wi-fi Transceiver. This device wired up a high-quality SiLabs CP2104 USB-Serial chip that can upload code at a blistering 921600 baud for fast development time. It also has auto-reset so no noodling with pins and reset button pressings. To make it easy to use for portable projects, the Adafruit Feather Huzzah provides a connector for a 3.7/4.2 V Lithium polymer battery and built in battery charging circuit thought USB port. The Feather will automatically switch over to USB power when its available. Pin Mapping \u00b6 Official reference for Adafruit Feather Huzzah can be found here . Flash Layout \u00b6 The Adafruit Feather Huzzah device features a 4 MB (32 Mb) flash memory organized in sectors of 4k each. The flash memory address starts at 0x40200000 and can be read and written from a Zerynth program using the internal flash module. Warning If flash memory must be used in a Zerynth program, it is recommended to begin using it from secure addresses towards the end the bytecode (start address of the bytecode can be found in the log console of Zerynth Studio during the uplink operation), leaving a minimum safe place to minimize the chance of clashes. Note The internal flash of Adafruit Feather Huzzah can be organized in different ways. The standard VM is a non-FOTA VM with the VM code beginning at 0x0000, followed by the esp8266 ir0m image at 0x20000 and the esp_init_data at 0x3fc000. The VM is based on the Espressif RTOS SDK 1.4.1. Device Summary \u00b6 Microcontroller: Tensilica 32-bit RISC CPU Xtensa LX106 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 12 Analog Input Pins (ADC): 1 UARTs: 2 SPIs: 1 I2Cs: 1 Flash Memory: 4 MB SRAM: 64 KB Clock Speed: 80 Mhz Wi-Fi: IEEE 802.11 b/g/n: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks Power \u00b6 Power to the Adafruit Feather Huzzah is supplied via the on-board USB Micro B connector or directly throught the connector for a 3.7/4.2 V battery. The power source is selected automatically. The device can operate on an external supply of 2.5 to 6 volts. If using more than 6V, the voltage regulator may overheat and damage the device. Connect, Register, Virtualize and Program \u00b6 The Adafruit Feather Huzzah exposes the serial port of the ESP8266 module via a CP2104 usb bridge which is also connected to the boot pins of the module, allowing for a seamless virtualization of the device. Note Drivers for the bridge can be downloaded here and are needed for Windows and Mac platforms . Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected to a USB port the Feather Huzzah device can be seen as a Virtual Serial port and it is automatically recognized by Zerynth Studio. The next steps are: Select the Feather Huzzah on the Device Management Toolbar (Disambiguate operation may be required); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the Feather Huzzah device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the upload process. Important To exploit the Wi-Fi chip functionalities of the Feather Huzzah, the lib.espressif.esp8266wifi library must be installed (some example code is provided). Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Adafruit Feather Huzzah device is available for bytecode only. Flash Layout is shown in table below: Start address Size Content 0x40200000 448Kb VM Slot 0x40270000 256Kb Bytecode Slot 0 0x402B0000 320Kb Bytecode Slot 1 Important FOTA Record (small segment of memory where the current and desired state of the firmware is store) for the Feather Huzzah device is allocated in the RTC memory. Power Management \u00b6 Power Management feature allows to optimize power consumption by putting the device in low consumption state. More information in Power Management - ESP8266 section and Secure Firmware - Microchip SAMD21 section .","title":"Adafruit Feather Huzzah"},{"location":"reference/boards/adafruit_feather_huzzah/docs/#adafruit-feather-huzzah","text":"The Adafruit Feather Huzzah ESP8266 is an \u2018all-in-one\u2019 ESP8266 WiFi development board with built in USB and battery charging. The Feather Huzzah features 4MB of flash memory, Tensilica microcontroller (80MHz of system clock), around 50k of usable RAM and an Espressif ESP8266 chip Wi-fi Transceiver. This device wired up a high-quality SiLabs CP2104 USB-Serial chip that can upload code at a blistering 921600 baud for fast development time. It also has auto-reset so no noodling with pins and reset button pressings. To make it easy to use for portable projects, the Adafruit Feather Huzzah provides a connector for a 3.7/4.2 V Lithium polymer battery and built in battery charging circuit thought USB port. The Feather will automatically switch over to USB power when its available.","title":"Adafruit Feather Huzzah"},{"location":"reference/boards/adafruit_feather_huzzah/docs/#pin-mapping","text":"Official reference for Adafruit Feather Huzzah can be found here .","title":"Pin Mapping"},{"location":"reference/boards/adafruit_feather_huzzah/docs/#flash-layout","text":"The Adafruit Feather Huzzah device features a 4 MB (32 Mb) flash memory organized in sectors of 4k each. The flash memory address starts at 0x40200000 and can be read and written from a Zerynth program using the internal flash module. Warning If flash memory must be used in a Zerynth program, it is recommended to begin using it from secure addresses towards the end the bytecode (start address of the bytecode can be found in the log console of Zerynth Studio during the uplink operation), leaving a minimum safe place to minimize the chance of clashes. Note The internal flash of Adafruit Feather Huzzah can be organized in different ways. The standard VM is a non-FOTA VM with the VM code beginning at 0x0000, followed by the esp8266 ir0m image at 0x20000 and the esp_init_data at 0x3fc000. The VM is based on the Espressif RTOS SDK 1.4.1.","title":"Flash Layout"},{"location":"reference/boards/adafruit_feather_huzzah/docs/#device-summary","text":"Microcontroller: Tensilica 32-bit RISC CPU Xtensa LX106 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 12 Analog Input Pins (ADC): 1 UARTs: 2 SPIs: 1 I2Cs: 1 Flash Memory: 4 MB SRAM: 64 KB Clock Speed: 80 Mhz Wi-Fi: IEEE 802.11 b/g/n: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks","title":"Device Summary"},{"location":"reference/boards/adafruit_feather_huzzah/docs/#power","text":"Power to the Adafruit Feather Huzzah is supplied via the on-board USB Micro B connector or directly throught the connector for a 3.7/4.2 V battery. The power source is selected automatically. The device can operate on an external supply of 2.5 to 6 volts. If using more than 6V, the voltage regulator may overheat and damage the device.","title":"Power"},{"location":"reference/boards/adafruit_feather_huzzah/docs/#connect-register-virtualize-and-program","text":"The Adafruit Feather Huzzah exposes the serial port of the ESP8266 module via a CP2104 usb bridge which is also connected to the boot pins of the module, allowing for a seamless virtualization of the device. Note Drivers for the bridge can be downloaded here and are needed for Windows and Mac platforms . Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected to a USB port the Feather Huzzah device can be seen as a Virtual Serial port and it is automatically recognized by Zerynth Studio. The next steps are: Select the Feather Huzzah on the Device Management Toolbar (Disambiguate operation may be required); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the Feather Huzzah device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the upload process. Important To exploit the Wi-Fi chip functionalities of the Feather Huzzah, the lib.espressif.esp8266wifi library must be installed (some example code is provided).","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/adafruit_feather_huzzah/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Adafruit Feather Huzzah device is available for bytecode only. Flash Layout is shown in table below: Start address Size Content 0x40200000 448Kb VM Slot 0x40270000 256Kb Bytecode Slot 0 0x402B0000 320Kb Bytecode Slot 1 Important FOTA Record (small segment of memory where the current and desired state of the firmware is store) for the Feather Huzzah device is allocated in the RTC memory.","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/adafruit_feather_huzzah/docs/#power-management","text":"Power Management feature allows to optimize power consumption by putting the device in low consumption state. More information in Power Management - ESP8266 section and Secure Firmware - Microchip SAMD21 section .","title":"Power Management"},{"location":"reference/boards/adafruit_feather_m0wifi/docs/","text":"Adafruit Feather M0 Wi-Fi \u00b6 The Adafruit Feather M0 Wi-Fi is based on the Atmel (Microchip Technology) ATSAMD21 microcontroller (Cortex-M0+ 32bit low power ARM MCU) and features on-board the ATWINC1500 Wi-Fi module , a low power network controller (2.4GHz IEEE\u00ae 802.11 b/g/n Wi-Fi), specifically designed for IoT projects and devices. The design includes a Li-Po charging circuit that allows the Adafruit Feather M0 Wi-Fi to run on battery power or external 5V, charging the Li-Po battery while running on external power. Switching from one source to the other is done automatically. All these features make this device the preferred choice for the emerging IoT battery-powered projects in a compact form factor. Warning The Adafruit Feather M0 Wi-Fi runs at 3.3V. The maximum voltage that the I/O pins can tolerate is 3.3V. Applying voltages higher than 3.3V to any I/O pin could damage the device. Note All the reported information are extracted from the official Adafruit Feather M0 Wi-Fi page , visit this page for more details and updates. Pin Mapping \u00b6 Adafruit Feather M0 Wi-Fi Official Schematic, Reference Design and Pin Mapping are available on the official Adafruit Feather M0 Wi-Fi reference page . Flash Layout \u00b6 The internal flash of the Adafruit Feather M0 Wi-Fi is organized as a single bank of 256k. Note Zerynth VM preserves SAM-BA Bootloader located at Flash start. Device Summary \u00b6 Microcontroller: SAMD21 Cortex-M0+ 32bit low power ARM MCU Power Supply (USB/VIN): 5V Supported Battery: Li-Po single cell, 3.7V, 700mAh minimum Operating Voltage: 3.3V Digital I/O Pins (DIO): 14 Analog Input Pins (ADC): 6 UARTs: 2 SPIs: 1 I2Cs: 1 Flash Memory: 256 KB SRAM: 32 KB Clock Speed: 48 MHz Size (LxW mm): 61.5 x 25.0 Power \u00b6 Power to the Adafruit Feather M0 Wi-Fi is supplied via the on-board USB Micro B connector or directly throught the connector for a 3.7/4.2 V battery. The power source is selected automatically. The device can operate on an external supply of 2.5 to 6 volts. If using more than 6V, the voltage regulator may overheat and damage the device. Connect, Register, Virtualize and Program \u00b6 Adafruit Feather M0 Wi-Fi should be recognized out of the box for Windows 8/10/+, Mac and Linux platforms; for Windows 7 platform, drivers must be installed and can be found here , otherwise this can be done by using the Zadig utility version 2.2 or greate. Note Drivers must be installed for both Standard and Virtualization Mode of the Feather M0 Wi-Fi device. Warning Remember, when using the Zadig utility, to select \u201cOptions > List all devices\u201d to search for the Feather M0 Wi-Fi device. Select the Usb CDC driver for the standard mode and any other for the virtualization mode Once connected on a USB port, if drivers have been correctly installed, the Adafruit Feather M0 Wi-Fi device is recognized by the Zerynth Studio and listed in the Device Management Toolbar . Follow these steps to register and virtualize a Adafruit Feather M0 Wi-Fi: Put the Feather M0 Wi-Fi in Virtualization Mode : Double click on the RST button; Select the Adafruit Feather M0 Wi-Fi Virtualizable on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note During these operations the Feather M0 Wi-Fi device must be in Virtualization Mode . if the device returns in standard mode, it is necessary to put it in Virtualization Mode again. After virtualization, the Adafruit Feather M0 Wi-Fi is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d, click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the RST on-board button when asked. Important To exploit the Wi-Fi chip functionalities of the Adafruit Feather M0 Wi-Fi, the lib.microchip.winc1500 library must be installed and imported in the Zerynth script. Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Adafruit Feather M0 Wi-Fi device is available for bytecode only. Flash Layout is shown in table below: Start address Size Content 0x00002000 94Kb VM Slot 0x00019600 77Kb Bytecode Slot 0 0x0002CB00 77Kb Bytecode Slot 1 Power Management and Secure Firmware \u00b6 Power Management feature allows to optimize power consumption by putting the device in low consumption state. Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). Both these features are strongly platform dependent; more information at Power Management - Microchip SAMD21 section and Secure Firmware - Microchip SAMD21 section .","title":"Adafruit Feather M0 Wi-Fi"},{"location":"reference/boards/adafruit_feather_m0wifi/docs/#adafruit-feather-m0-wi-fi","text":"The Adafruit Feather M0 Wi-Fi is based on the Atmel (Microchip Technology) ATSAMD21 microcontroller (Cortex-M0+ 32bit low power ARM MCU) and features on-board the ATWINC1500 Wi-Fi module , a low power network controller (2.4GHz IEEE\u00ae 802.11 b/g/n Wi-Fi), specifically designed for IoT projects and devices. The design includes a Li-Po charging circuit that allows the Adafruit Feather M0 Wi-Fi to run on battery power or external 5V, charging the Li-Po battery while running on external power. Switching from one source to the other is done automatically. All these features make this device the preferred choice for the emerging IoT battery-powered projects in a compact form factor. Warning The Adafruit Feather M0 Wi-Fi runs at 3.3V. The maximum voltage that the I/O pins can tolerate is 3.3V. Applying voltages higher than 3.3V to any I/O pin could damage the device. Note All the reported information are extracted from the official Adafruit Feather M0 Wi-Fi page , visit this page for more details and updates.","title":"Adafruit Feather M0 Wi-Fi"},{"location":"reference/boards/adafruit_feather_m0wifi/docs/#pin-mapping","text":"Adafruit Feather M0 Wi-Fi Official Schematic, Reference Design and Pin Mapping are available on the official Adafruit Feather M0 Wi-Fi reference page .","title":"Pin Mapping"},{"location":"reference/boards/adafruit_feather_m0wifi/docs/#flash-layout","text":"The internal flash of the Adafruit Feather M0 Wi-Fi is organized as a single bank of 256k. Note Zerynth VM preserves SAM-BA Bootloader located at Flash start.","title":"Flash Layout"},{"location":"reference/boards/adafruit_feather_m0wifi/docs/#device-summary","text":"Microcontroller: SAMD21 Cortex-M0+ 32bit low power ARM MCU Power Supply (USB/VIN): 5V Supported Battery: Li-Po single cell, 3.7V, 700mAh minimum Operating Voltage: 3.3V Digital I/O Pins (DIO): 14 Analog Input Pins (ADC): 6 UARTs: 2 SPIs: 1 I2Cs: 1 Flash Memory: 256 KB SRAM: 32 KB Clock Speed: 48 MHz Size (LxW mm): 61.5 x 25.0","title":"Device Summary"},{"location":"reference/boards/adafruit_feather_m0wifi/docs/#power","text":"Power to the Adafruit Feather M0 Wi-Fi is supplied via the on-board USB Micro B connector or directly throught the connector for a 3.7/4.2 V battery. The power source is selected automatically. The device can operate on an external supply of 2.5 to 6 volts. If using more than 6V, the voltage regulator may overheat and damage the device.","title":"Power"},{"location":"reference/boards/adafruit_feather_m0wifi/docs/#connect-register-virtualize-and-program","text":"Adafruit Feather M0 Wi-Fi should be recognized out of the box for Windows 8/10/+, Mac and Linux platforms; for Windows 7 platform, drivers must be installed and can be found here , otherwise this can be done by using the Zadig utility version 2.2 or greate. Note Drivers must be installed for both Standard and Virtualization Mode of the Feather M0 Wi-Fi device. Warning Remember, when using the Zadig utility, to select \u201cOptions > List all devices\u201d to search for the Feather M0 Wi-Fi device. Select the Usb CDC driver for the standard mode and any other for the virtualization mode Once connected on a USB port, if drivers have been correctly installed, the Adafruit Feather M0 Wi-Fi device is recognized by the Zerynth Studio and listed in the Device Management Toolbar . Follow these steps to register and virtualize a Adafruit Feather M0 Wi-Fi: Put the Feather M0 Wi-Fi in Virtualization Mode : Double click on the RST button; Select the Adafruit Feather M0 Wi-Fi Virtualizable on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note During these operations the Feather M0 Wi-Fi device must be in Virtualization Mode . if the device returns in standard mode, it is necessary to put it in Virtualization Mode again. After virtualization, the Adafruit Feather M0 Wi-Fi is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d, click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the RST on-board button when asked. Important To exploit the Wi-Fi chip functionalities of the Adafruit Feather M0 Wi-Fi, the lib.microchip.winc1500 library must be installed and imported in the Zerynth script.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/adafruit_feather_m0wifi/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Adafruit Feather M0 Wi-Fi device is available for bytecode only. Flash Layout is shown in table below: Start address Size Content 0x00002000 94Kb VM Slot 0x00019600 77Kb Bytecode Slot 0 0x0002CB00 77Kb Bytecode Slot 1","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/adafruit_feather_m0wifi/docs/#power-management-and-secure-firmware","text":"Power Management feature allows to optimize power consumption by putting the device in low consumption state. Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). Both these features are strongly platform dependent; more information at Power Management - Microchip SAMD21 section and Secure Firmware - Microchip SAMD21 section .","title":"Power Management and Secure Firmware"},{"location":"reference/boards/adafruit_huzzah32/docs/","text":"Adafruit Huzzah32 \u00b6 The Huzzah32 is one of the development board created by Adafruit that mounts on-board the official WROOM32 module. The Huzzah32 device features built-in USB-to-Serial converter, automatic bootloader reset, Lithium Ion/Polymer charger, and all the GPIO brought. Adafruit Huzza32 contains a dual-core ESP32 chip, 4 MB of SPI Flash, tuned antenna, and The ESP32 microcontroller has both WiFi and Bluetooth Classic/LE support. Pin Mapping \u00b6 Official reference for Adafruit Huzzah32 can be found here . Flash Layout \u00b6 The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved Device Summary \u00b6 Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 28 Analog Input Pins (ADC): 8 Analog Outputs Pins (DAC): 2 UARTs: 3 SPIs: 2 I2Cs: 3 Flash Memory: 4 MB SRAM: 520 KB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks Power \u00b6 Power to the Adafruit Huzzah32 is supplied via the on-board USB Micro B connector or directly throught the connector for a 3.7/4.2 V battery. The power source is selected automatically. The device can operate on an external supply of 2.5 to 6 volts. If using more than 6V, the voltage regulator may overheat and damage the device. Connect, Register, Virtualize and Program \u00b6 The Adafruit Huzzah32 exposes the serial port of the ESP32 module via a CP2104 usb bridge which is also connected to the boot pins of the module, allowing for a seamless virtualization of the device. Note Drivers for the bridge can be downloaded here and are needed for Windows and Mac platforms . Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu ` distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the Huzzah32 device is recognized by Zerynth Studio. The next steps are: Select the Adafruit Huzzah32 on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the Huzzah32 is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process. Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Huzzah32 device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1 For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs. Secure Firmware \u00b6 Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section . Zerynth Secure Socket \u00b6 To be able to use Zerynth Secure Socket on esp32 boards NATIVE_MBEDTLS: true must be used instead of ZERYNTH_SSL: true in the project.yml file. Missing features \u00b6 Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"Adafruit Huzzah32"},{"location":"reference/boards/adafruit_huzzah32/docs/#adafruit-huzzah32","text":"The Huzzah32 is one of the development board created by Adafruit that mounts on-board the official WROOM32 module. The Huzzah32 device features built-in USB-to-Serial converter, automatic bootloader reset, Lithium Ion/Polymer charger, and all the GPIO brought. Adafruit Huzza32 contains a dual-core ESP32 chip, 4 MB of SPI Flash, tuned antenna, and The ESP32 microcontroller has both WiFi and Bluetooth Classic/LE support.","title":"Adafruit Huzzah32"},{"location":"reference/boards/adafruit_huzzah32/docs/#pin-mapping","text":"Official reference for Adafruit Huzzah32 can be found here .","title":"Pin Mapping"},{"location":"reference/boards/adafruit_huzzah32/docs/#flash-layout","text":"The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved","title":"Flash Layout"},{"location":"reference/boards/adafruit_huzzah32/docs/#device-summary","text":"Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 28 Analog Input Pins (ADC): 8 Analog Outputs Pins (DAC): 2 UARTs: 3 SPIs: 2 I2Cs: 3 Flash Memory: 4 MB SRAM: 520 KB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks","title":"Device Summary"},{"location":"reference/boards/adafruit_huzzah32/docs/#power","text":"Power to the Adafruit Huzzah32 is supplied via the on-board USB Micro B connector or directly throught the connector for a 3.7/4.2 V battery. The power source is selected automatically. The device can operate on an external supply of 2.5 to 6 volts. If using more than 6V, the voltage regulator may overheat and damage the device.","title":"Power"},{"location":"reference/boards/adafruit_huzzah32/docs/#connect-register-virtualize-and-program","text":"The Adafruit Huzzah32 exposes the serial port of the ESP32 module via a CP2104 usb bridge which is also connected to the boot pins of the module, allowing for a seamless virtualization of the device. Note Drivers for the bridge can be downloaded here and are needed for Windows and Mac platforms . Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu ` distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the Huzzah32 device is recognized by Zerynth Studio. The next steps are: Select the Adafruit Huzzah32 on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the Huzzah32 is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/adafruit_huzzah32/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Huzzah32 device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1 For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs.","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/adafruit_huzzah32/docs/#secure-firmware","text":"Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section .","title":"Secure Firmware"},{"location":"reference/boards/adafruit_huzzah32/docs/#zerynth-secure-socket","text":"To be able to use Zerynth Secure Socket on esp32 boards NATIVE_MBEDTLS: true must be used instead of ZERYNTH_SSL: true in the project.yml file.","title":"Zerynth Secure Socket"},{"location":"reference/boards/adafruit_huzzah32/docs/#missing-features","text":"Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"Missing features"},{"location":"reference/boards/arduino_due/docs/","text":"Arduino DUE \u00b6 The Arduino Due is a microcontroller device based on the Atmel SAM3X8E ARM Cortex-M3 CPU . It is the first Arduino device based on a 32-bit ARM core microcontroller. It has 54 digital input/output pins (of which 12 can be used as PWM outputs), 12 analog inputs, 4 UARTs (hardware serial ports), a 84 MHz clock, an USB OTG capable connection, 2 DAC (digital to analog), 2 TWI, a power jack, an SPI header, a JTAG header, a reset button and an erase button. Warning Unlike other Arduino devices, Arduino Due runs at 3.3V. The maximum voltage that the I/O pins can tolerate is 3.3V. Providing higher voltages, like 5V to an I/O pin could damage the device. Note All the reported information are extracted from the official Arduino DUE page , visit this page for more details and updates. Pin Mapping \u00b6 Arduino Official Schematic, Reference Design and Pin Mapping are available on the official Arduino DUE reference page . Flash Layout \u00b6 The internal flash of Arduino Due is organized into two banks of 256k each. Each bank is divided into 1024 pages of 256 bytes each. The first bank, starting at 0x80000, is used by the virtual machine runtime. The second bank is used to store bytecode and can be read and written from a Zerynth program using the internal flash module. The bytecode always starts at the address 0xC0000 (the starting address of the second bank) and ends depending on its size. The second bank extends up to address 0x100000. If internal flash has to be used in a Zerynth program, it is recommended to start using pages from the end of the bank towards the bytecode, to minimize the chance of clashes. Device Summary \u00b6 Microcontroller: AT91SAM3X8E Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 54 Analog Input Pins (ADC): 12 Analog Outputs Pins (DAC): 2 UARTs: 4 SPIs: 1 I2Cs: 1 CAN: 2 Flash Memory: 512 KB SRAM: 96 KB Clock Speed: 84 MHz Size (LxW mm): 101.52 x 53.3 Power \u00b6 The Arduino Due can be powered via the USB connector or with an external power supply. The power source is selected automatically. External (non-USB) power can come either from an AC-to-DC adapter (wall-wart) or battery. The adapter can be connected by plugging a 2.1 mm center-positive plug into the device\u2019s power jack. Leads from a battery can be inserted in the Gnd and Vin pin headers of the POWER connector. The device can operate on an external supply of 6 to 20 volts. If supplied with less than 7V, however, the 5V pin may supply less than five volts and the device may be unstable. If more than 12V are used, the voltage regulator may overheat and damage the device. The recommended range is 7 to 12 volts. Connect, Register, Virtualize and Program \u00b6 The Arduino DUE Programming port is connected to an ATmega16U2, which provides a virtual COM port to software on a connected computer, allowing for a seamless virtualization of the device. Note Drivers for the FTDI can be downloaded here and are needed for Windows and Mac platforms . Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. The 16U2 is also connected to the SAM3X hardware UART. Serial on pins RX0 and TX0 provides Serial-to-USB communication for programming the device through the ATmega16U2 microcontroller. Once connected on a USB port, if drivers have been correctly installed, the Arduino DUE device is recognized by Zerynth Studio. The next steps are: Select the Arduino DUE on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process After virtualization, the Arduino DUE is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process. Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Arduino Due device is available for bytecode only. Flash Layout is shown in table below: Start address Size Content 0x00080000 256Kb VM Slot 0x000C0000 125Kb Bytecode Slot 0 0x000E0000 128Kb-256b Bytecode Slot 1 0x000FFF00 256b FOTA Record","title":"Arduino DUE"},{"location":"reference/boards/arduino_due/docs/#arduino-due","text":"The Arduino Due is a microcontroller device based on the Atmel SAM3X8E ARM Cortex-M3 CPU . It is the first Arduino device based on a 32-bit ARM core microcontroller. It has 54 digital input/output pins (of which 12 can be used as PWM outputs), 12 analog inputs, 4 UARTs (hardware serial ports), a 84 MHz clock, an USB OTG capable connection, 2 DAC (digital to analog), 2 TWI, a power jack, an SPI header, a JTAG header, a reset button and an erase button. Warning Unlike other Arduino devices, Arduino Due runs at 3.3V. The maximum voltage that the I/O pins can tolerate is 3.3V. Providing higher voltages, like 5V to an I/O pin could damage the device. Note All the reported information are extracted from the official Arduino DUE page , visit this page for more details and updates.","title":"Arduino DUE"},{"location":"reference/boards/arduino_due/docs/#pin-mapping","text":"Arduino Official Schematic, Reference Design and Pin Mapping are available on the official Arduino DUE reference page .","title":"Pin Mapping"},{"location":"reference/boards/arduino_due/docs/#flash-layout","text":"The internal flash of Arduino Due is organized into two banks of 256k each. Each bank is divided into 1024 pages of 256 bytes each. The first bank, starting at 0x80000, is used by the virtual machine runtime. The second bank is used to store bytecode and can be read and written from a Zerynth program using the internal flash module. The bytecode always starts at the address 0xC0000 (the starting address of the second bank) and ends depending on its size. The second bank extends up to address 0x100000. If internal flash has to be used in a Zerynth program, it is recommended to start using pages from the end of the bank towards the bytecode, to minimize the chance of clashes.","title":"Flash Layout"},{"location":"reference/boards/arduino_due/docs/#device-summary","text":"Microcontroller: AT91SAM3X8E Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 54 Analog Input Pins (ADC): 12 Analog Outputs Pins (DAC): 2 UARTs: 4 SPIs: 1 I2Cs: 1 CAN: 2 Flash Memory: 512 KB SRAM: 96 KB Clock Speed: 84 MHz Size (LxW mm): 101.52 x 53.3","title":"Device Summary"},{"location":"reference/boards/arduino_due/docs/#power","text":"The Arduino Due can be powered via the USB connector or with an external power supply. The power source is selected automatically. External (non-USB) power can come either from an AC-to-DC adapter (wall-wart) or battery. The adapter can be connected by plugging a 2.1 mm center-positive plug into the device\u2019s power jack. Leads from a battery can be inserted in the Gnd and Vin pin headers of the POWER connector. The device can operate on an external supply of 6 to 20 volts. If supplied with less than 7V, however, the 5V pin may supply less than five volts and the device may be unstable. If more than 12V are used, the voltage regulator may overheat and damage the device. The recommended range is 7 to 12 volts.","title":"Power"},{"location":"reference/boards/arduino_due/docs/#connect-register-virtualize-and-program","text":"The Arduino DUE Programming port is connected to an ATmega16U2, which provides a virtual COM port to software on a connected computer, allowing for a seamless virtualization of the device. Note Drivers for the FTDI can be downloaded here and are needed for Windows and Mac platforms . Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. The 16U2 is also connected to the SAM3X hardware UART. Serial on pins RX0 and TX0 provides Serial-to-USB communication for programming the device through the ATmega16U2 microcontroller. Once connected on a USB port, if drivers have been correctly installed, the Arduino DUE device is recognized by Zerynth Studio. The next steps are: Select the Arduino DUE on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process After virtualization, the Arduino DUE is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/arduino_due/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Arduino Due device is available for bytecode only. Flash Layout is shown in table below: Start address Size Content 0x00080000 256Kb VM Slot 0x000C0000 125Kb Bytecode Slot 0 0x000E0000 128Kb-256b Bytecode Slot 1 0x000FFF00 256b FOTA Record","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/arduino_mkr1000/docs/","text":"Arduino/Genuino MKR1000 \u00b6 The Arduino/Genuino MKR1000 is based on the Atmel (Microchip Technology) ATSAMW25 SoC (System on Chip), that is part of the SmartConnect family of Microchip Wireless devices, specifically designed for IoT projects and devices. The ATSAMW25 is composed of three main blocks: SAMD21 Cortex-M0+ 32bit low power ARM MCU WINC1500 low power 2.4GHz IEEE\u00ae 802.11 b/g/n Wi-Fi ECC508 CryptoAuthentication The ATSAMW25 includes also a single 1x1 stream PCB Antenna. The design includes a Li-Po charging circuit that allows the Arduino/Genuino MKR1000 to run on battery power or external 5V, charging the Li-Po battery while running on external power. Switching from one source to the other is done automatically. All these features make this device the preferred choice for the emerging IoT battery-powered projects in a compact form factor. The USB port can be used to supply power (5V) to the device. The Arduino/Genuino MKR1000 is able to run with or without the Li-Po battery connected and has limited power consumption. Warning Unlike most Arduino & Genuino devices, the MKR1000 runs at 3.3V. The maximum voltage that the I/O pins can tolerate is 3.3V. Applying voltages higher than 3.3V to any I/O pin could damage the device. Note All the reported information are extracted from the official Arduino/Genuino MKR1000 page , visit this page for more details and updates. Pin Mapping \u00b6 Arduino/Genuino MKR1000 Official Schematic, Reference Design and Pin Mapping are available on the official Arduino/Genuino MKR1000 reference page . Flash Layout \u00b6 The internal flash of the Arduino/Genuino MKR1000 is organized as a single bank of 256k. Note Zerynth VM preserves SAM-BA Bootloader located at Flash start. Device Summary \u00b6 Microcontroller: SAMD21 Cortex-M0+ 32bit low power ARM MCU Power Supply (USB/VIN): 5V Supported Battery: Li-Po single cell, 3.7V, 700mAh minimum Operating Voltage: 3.3V Digital I/O Pins (DIO): 14 Analog Input Pins (ADC): 7 UARTs: 1 SPIs: 1 I2Cs: 1 Flash Memory: 256 KB SRAM: 32 KB Clock Speed: 48 MHz Size (LxW mm): 61.5 x 25.0 Power \u00b6 Battery capacity : Li-Po batteries are charged up to 4.2V with a current that is usually half of the nominal capacity. For Arduino/Genuino MKR1000 a specialized chip that has a preset charging current of 350mAh is used. This means that the MINIMUM capacity of the Li-Po battery should be 700 mAh. Smaller cells will be damaged by this current and may overheat, develop internal gasses and explode, setting on fire the surroundings. It is strongly recommended to select a Li-Po battery of at least 700mAh capacity. A bigger cell will take more time to charge, but won\u2019t be harmed or overheated. The chip is programmed with 4 hours of charging time, then it goes into automatic sleep mode. This will limit the amount of charge to max 1400 mAh per charging round. Battery connector : If you want to connect a battery to your MKR1000 be sure to search one with female 2 pin JST PHR2 Type connector. Polarity: looking at the device connector pins, polarity is Left = Positive, Right = GND. Download here the Connector datasheet . On the MKR1000, connector is a Male 2pin JST PH Type. Vin : This pin can be used to power the device with a regulated 5V source. If the power is fed through this pin, the USB power source is disconnected. This is the only way you can supply 5v (range is 5V to maximum 6V) to the device not using USB. This pin is an INPUT. 5V : This pin outputs 5V from the the device when powered from the USB connector or from the VIN pin of the device. It is unregulated and the voltage is taken directly from the inputs. As an OUTPUT, it should not be used as an input pin to power the device. VCC : This pin outputs 3.3V through the on-board voltage regulator. This voltage is the same regardless the power source used (USB, Vin and Battery). LED ON : This LED is connected to the 5V input from either USB or VIN. It is not connected to the battery power. This means that it lits up when power is from USB or VIN, but stays off when the device is running on battery power. This maximizes the usage of the energy stored in the battery. It is therefore normal to have the device properly running on battery power without the LED ON being lit. CHARGE LED : The CHARGE LED on the device is driven by the charger chip that monitors the current drawn by the Li-Po battery while charging. Usually it will lit up when the device gets 5V from VIN or USB and the chip starts charging the Li-Po battery connected to the JST connector. There are several occasions where this LED will start to blink at a frequency of about 2Hz. This flashing is caused by the following conditions maintained for a long time (from 20 to 70 minutes): No battery is connected to JST connector. Overdischarged/damaged battery is connected. It can\u2019t be recharged. A fully charged battery is put through another unnecessary charging cycle. This is done disconnecting and reconnecting either VIN or the battery itself while VIN is connected. Note All the reported information are extracted from the official Arduino/Genuino MKR1000 page , visit this page for more details and updates. Connect, Register, Virtualize and Program \u00b6 To recognize the device, Windows machines require drivers that can be downloaded from the Arduino/Genuino MKR1000 guide , otherwise this can be done by using the Zadig utility version 2.2 or greater; OSX and Linux machines will recognize the device automatically. Note Drivers must be installed for both Standard and Virtualization Mode of the MKR1000 device. Warning Remember, when using the Zadig utility, to select \u201cOptions > List all devices\u201d to search for the MKR1000 device. Select the Usb CDC driver for the standard mode and any other for the virtualization mode. Once connected on a USB port, if drivers have been correctly installed, the Arduino/Genuino MKR1000 device is recognized by the Zerynth Studio and listed in the Device Management Toolbar . Follow these steps to register and virtualize a Arduino/Genuino MKR1000: Put the MKR1000 in Virtualization Mode : Double click on the RST button; Select the MKR1000 Virtualizable on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note During these operations the MKR1000 device must be in Virtualization Mode . if the device returns in standard mode, it is necessary to put it in DFU Mode again. Zerynth scripts can be uploaded on virtualized Arduino/Genuino MKR1000 by clicking the dedicated upload button available on the Current Project panel of the IDE. Follow these steps to upload a Zerynth script on a virtualized Arduino/Genuino MKR1000: After virtualization, the Arduino/Genuino MKR1000 is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d, click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the RST on-board button when asked. Important To exploit the Wi-Fi chip functionalities of the Arduino/Genuino MKR1000, the lib.microchip.winc1500 library must be installed and imported in the Zerynth script. Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Arduino/Genuino MKR1000 device is available for bytecode only. Flash Layout is shown in table below: Start address Size Content 0x00002000 94Kb VM Slot 0x00019600 77Kb Bytecode Slot 0 0x0002CB00 77Kb Bytecode Slot 1 Power Management and Secure Firmware \u00b6 Power Management feature allows to optimize power consumption by putting the device in low consumption state. Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). Both these features are strongly platform dependent; more information at Power Management - Microchip SAMD21 section and Secure Firmware - Microchip SAMD21 section .","title":"Arduino/Genuino MKR1000"},{"location":"reference/boards/arduino_mkr1000/docs/#arduinogenuino-mkr1000","text":"The Arduino/Genuino MKR1000 is based on the Atmel (Microchip Technology) ATSAMW25 SoC (System on Chip), that is part of the SmartConnect family of Microchip Wireless devices, specifically designed for IoT projects and devices. The ATSAMW25 is composed of three main blocks: SAMD21 Cortex-M0+ 32bit low power ARM MCU WINC1500 low power 2.4GHz IEEE\u00ae 802.11 b/g/n Wi-Fi ECC508 CryptoAuthentication The ATSAMW25 includes also a single 1x1 stream PCB Antenna. The design includes a Li-Po charging circuit that allows the Arduino/Genuino MKR1000 to run on battery power or external 5V, charging the Li-Po battery while running on external power. Switching from one source to the other is done automatically. All these features make this device the preferred choice for the emerging IoT battery-powered projects in a compact form factor. The USB port can be used to supply power (5V) to the device. The Arduino/Genuino MKR1000 is able to run with or without the Li-Po battery connected and has limited power consumption. Warning Unlike most Arduino & Genuino devices, the MKR1000 runs at 3.3V. The maximum voltage that the I/O pins can tolerate is 3.3V. Applying voltages higher than 3.3V to any I/O pin could damage the device. Note All the reported information are extracted from the official Arduino/Genuino MKR1000 page , visit this page for more details and updates.","title":"Arduino/Genuino MKR1000"},{"location":"reference/boards/arduino_mkr1000/docs/#pin-mapping","text":"Arduino/Genuino MKR1000 Official Schematic, Reference Design and Pin Mapping are available on the official Arduino/Genuino MKR1000 reference page .","title":"Pin Mapping"},{"location":"reference/boards/arduino_mkr1000/docs/#flash-layout","text":"The internal flash of the Arduino/Genuino MKR1000 is organized as a single bank of 256k. Note Zerynth VM preserves SAM-BA Bootloader located at Flash start.","title":"Flash Layout"},{"location":"reference/boards/arduino_mkr1000/docs/#device-summary","text":"Microcontroller: SAMD21 Cortex-M0+ 32bit low power ARM MCU Power Supply (USB/VIN): 5V Supported Battery: Li-Po single cell, 3.7V, 700mAh minimum Operating Voltage: 3.3V Digital I/O Pins (DIO): 14 Analog Input Pins (ADC): 7 UARTs: 1 SPIs: 1 I2Cs: 1 Flash Memory: 256 KB SRAM: 32 KB Clock Speed: 48 MHz Size (LxW mm): 61.5 x 25.0","title":"Device Summary"},{"location":"reference/boards/arduino_mkr1000/docs/#power","text":"Battery capacity : Li-Po batteries are charged up to 4.2V with a current that is usually half of the nominal capacity. For Arduino/Genuino MKR1000 a specialized chip that has a preset charging current of 350mAh is used. This means that the MINIMUM capacity of the Li-Po battery should be 700 mAh. Smaller cells will be damaged by this current and may overheat, develop internal gasses and explode, setting on fire the surroundings. It is strongly recommended to select a Li-Po battery of at least 700mAh capacity. A bigger cell will take more time to charge, but won\u2019t be harmed or overheated. The chip is programmed with 4 hours of charging time, then it goes into automatic sleep mode. This will limit the amount of charge to max 1400 mAh per charging round. Battery connector : If you want to connect a battery to your MKR1000 be sure to search one with female 2 pin JST PHR2 Type connector. Polarity: looking at the device connector pins, polarity is Left = Positive, Right = GND. Download here the Connector datasheet . On the MKR1000, connector is a Male 2pin JST PH Type. Vin : This pin can be used to power the device with a regulated 5V source. If the power is fed through this pin, the USB power source is disconnected. This is the only way you can supply 5v (range is 5V to maximum 6V) to the device not using USB. This pin is an INPUT. 5V : This pin outputs 5V from the the device when powered from the USB connector or from the VIN pin of the device. It is unregulated and the voltage is taken directly from the inputs. As an OUTPUT, it should not be used as an input pin to power the device. VCC : This pin outputs 3.3V through the on-board voltage regulator. This voltage is the same regardless the power source used (USB, Vin and Battery). LED ON : This LED is connected to the 5V input from either USB or VIN. It is not connected to the battery power. This means that it lits up when power is from USB or VIN, but stays off when the device is running on battery power. This maximizes the usage of the energy stored in the battery. It is therefore normal to have the device properly running on battery power without the LED ON being lit. CHARGE LED : The CHARGE LED on the device is driven by the charger chip that monitors the current drawn by the Li-Po battery while charging. Usually it will lit up when the device gets 5V from VIN or USB and the chip starts charging the Li-Po battery connected to the JST connector. There are several occasions where this LED will start to blink at a frequency of about 2Hz. This flashing is caused by the following conditions maintained for a long time (from 20 to 70 minutes): No battery is connected to JST connector. Overdischarged/damaged battery is connected. It can\u2019t be recharged. A fully charged battery is put through another unnecessary charging cycle. This is done disconnecting and reconnecting either VIN or the battery itself while VIN is connected. Note All the reported information are extracted from the official Arduino/Genuino MKR1000 page , visit this page for more details and updates.","title":"Power"},{"location":"reference/boards/arduino_mkr1000/docs/#connect-register-virtualize-and-program","text":"To recognize the device, Windows machines require drivers that can be downloaded from the Arduino/Genuino MKR1000 guide , otherwise this can be done by using the Zadig utility version 2.2 or greater; OSX and Linux machines will recognize the device automatically. Note Drivers must be installed for both Standard and Virtualization Mode of the MKR1000 device. Warning Remember, when using the Zadig utility, to select \u201cOptions > List all devices\u201d to search for the MKR1000 device. Select the Usb CDC driver for the standard mode and any other for the virtualization mode. Once connected on a USB port, if drivers have been correctly installed, the Arduino/Genuino MKR1000 device is recognized by the Zerynth Studio and listed in the Device Management Toolbar . Follow these steps to register and virtualize a Arduino/Genuino MKR1000: Put the MKR1000 in Virtualization Mode : Double click on the RST button; Select the MKR1000 Virtualizable on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note During these operations the MKR1000 device must be in Virtualization Mode . if the device returns in standard mode, it is necessary to put it in DFU Mode again. Zerynth scripts can be uploaded on virtualized Arduino/Genuino MKR1000 by clicking the dedicated upload button available on the Current Project panel of the IDE. Follow these steps to upload a Zerynth script on a virtualized Arduino/Genuino MKR1000: After virtualization, the Arduino/Genuino MKR1000 is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d, click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the RST on-board button when asked. Important To exploit the Wi-Fi chip functionalities of the Arduino/Genuino MKR1000, the lib.microchip.winc1500 library must be installed and imported in the Zerynth script.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/arduino_mkr1000/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Arduino/Genuino MKR1000 device is available for bytecode only. Flash Layout is shown in table below: Start address Size Content 0x00002000 94Kb VM Slot 0x00019600 77Kb Bytecode Slot 0 0x0002CB00 77Kb Bytecode Slot 1","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/arduino_mkr1000/docs/#power-management-and-secure-firmware","text":"Power Management feature allows to optimize power consumption by putting the device in low consumption state. Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). Both these features are strongly platform dependent; more information at Power Management - Microchip SAMD21 section and Secure Firmware - Microchip SAMD21 section .","title":"Power Management and Secure Firmware"},{"location":"reference/boards/az3166/docs/","text":"MXChip IoT DevKit AZ3166 \u00b6 The MXChip IoT DevKit AZ3166 provides a smart hardware solution. It is compatible with several peripherals and sensors. AZ3166 could be used for the development of IoT and smart hardware prototype, making it continent to verify the software and function of users. AZ3166 is EMW3166 , a low power consumption Wi-Fi module developed by MXCHIP, With DAP Link emulator and 128\u00d764 OLED and other resources such as LED light. The development kit has onboard a Temperature and Humidity sensor (HTS221), an Acceleromenter and Gyroscope sensor (LSM6DSL), an absolupe Pressure sensor (LPS22HB), a Magnetometer sensor (LIS2MDL) and more. EMW3166 integrates STM32F412RG (Cortex-M4) microcontroller of 256Kbytes SRAM and 1Mbytes on-chip flash with another 2Mbytes on-board SPI flash added. Various peripheral interfaces of analog and digital are available. The power supply voltage is 3.3V. The TCP/IP protocols and security encryption algorithm could be applied in various Wi-Fi applications. In addition, several particular firmware prepares for some typical applications easylink configuration and services for cloud interfacing. Note All the reported information are extracted from the official MXChip IoT DevKit AZ3166 reference page , visit this page for more details and updates. Pin Mapping \u00b6 MXChip IoT DevKit AZ3166 Schematic are available on the official MXChip official page . Flash Layout \u00b6 The internal flash of the IoT DevKit AZ3166 is organized into sectors of different size according to the following table: Start address Size Content 0x8000000 16Kb Virtual Machine 0x8004000 16Kb Virtual Machine 0x8008000 16Kb Virtual Machine 0x800C000 16Kb Virtual Machine 0x8010000 64Kb Virtual Machine 0x8020000 128kb Bytecode Bank 0 0x8040000 128kb Bytecode Bank 1 0x8060000 128kb Bytecode Bank 2 0x8080000 128kb Bytecode Bank 3 0x80A0000 128kb Bytecode Bank 4 0x80C0000 128kb Bytecode Bank 5 0x80E0000 128kb Bytecode Bank 6 Warning If internal flash is used in a Zerynth program, it is suggested to begin using pages from the end of flash (bytecode bank 6) towards the virtual machine, to minimize the chance of clashes. Since writing to a sector entails erasing it first, the write operation can be slow even for small chunks of data, depending on the size of the choosen sector. Device Summary \u00b6 Microcontroller: STM32F412RG ARM\u00ae32-bit Cortex\u00ae-M4 CPU Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 31 Analog Input Pins (ADC): 2 UARTs: 2 SPIs: 1 I2Cs: 1 Flash Memory: 1 MB SRAM: 256 KB Clock Speed: 100 MHz Power \u00b6 Power to the MXChip IoT DevKit AZ3166 is supplied via the on-board USB Micro B connector. The device can operate on an external supply voltage of 3.3 to 5.5 volts. If using more than 5.5V, the voltage regulator may overheat and damage the device. Connect, Register, Virtualize and Program \u00b6 The IoT DevKit AZ3166 Programming port is connected to the ST-Link uploader creating a virtual COM port on a connected computer. To recognize the device, Windows machines requires drivers that can be downloaded from the ST-Link download page , while MAC OSX and Linux machines will recognize the device automatically. The St-Link is also connected to the STM32 hardware UART0. Once connected on a USB port, if drivers have been correctly installed the IoT DevKit AZ3166 device is recognized by Zerynth Studio and listed in the Device Management Toolbar . The next steps are: Select the IoT DevKit AZ3166 on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the IoT DevKit AZ3166 device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked. Note If the reset is not performed within 5 seconds the upload procedure fails. Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the IoT DevKit AZ3166 device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x08000000 128Kb VM Slot 0 0x08020000 384kb Bytecode Slot 0 0x08080000 128kb VM Slot 1 0x080A0000 384kb Bytecode Slot 1 Important FOTA Record (small segment of memory where the current and desired state of the firmware is store) for the IoT DevKit AZ3166 device is allocated in 16kb sector inside the VM Slot 0 at 0x08004000 address. Power Management and Secure Firmware \u00b6 Power Management feature allows to optimize power consumption by putting the device in low consumption state. Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). Both these features are strongly platform dependent; more information at Power Management - STM32F section and Secure Firmware - STM32F section .","title":"MXChip IoT DevKit AZ3166"},{"location":"reference/boards/az3166/docs/#mxchip-iot-devkit-az3166","text":"The MXChip IoT DevKit AZ3166 provides a smart hardware solution. It is compatible with several peripherals and sensors. AZ3166 could be used for the development of IoT and smart hardware prototype, making it continent to verify the software and function of users. AZ3166 is EMW3166 , a low power consumption Wi-Fi module developed by MXCHIP, With DAP Link emulator and 128\u00d764 OLED and other resources such as LED light. The development kit has onboard a Temperature and Humidity sensor (HTS221), an Acceleromenter and Gyroscope sensor (LSM6DSL), an absolupe Pressure sensor (LPS22HB), a Magnetometer sensor (LIS2MDL) and more. EMW3166 integrates STM32F412RG (Cortex-M4) microcontroller of 256Kbytes SRAM and 1Mbytes on-chip flash with another 2Mbytes on-board SPI flash added. Various peripheral interfaces of analog and digital are available. The power supply voltage is 3.3V. The TCP/IP protocols and security encryption algorithm could be applied in various Wi-Fi applications. In addition, several particular firmware prepares for some typical applications easylink configuration and services for cloud interfacing. Note All the reported information are extracted from the official MXChip IoT DevKit AZ3166 reference page , visit this page for more details and updates.","title":"MXChip IoT DevKit AZ3166"},{"location":"reference/boards/az3166/docs/#pin-mapping","text":"MXChip IoT DevKit AZ3166 Schematic are available on the official MXChip official page .","title":"Pin Mapping"},{"location":"reference/boards/az3166/docs/#flash-layout","text":"The internal flash of the IoT DevKit AZ3166 is organized into sectors of different size according to the following table: Start address Size Content 0x8000000 16Kb Virtual Machine 0x8004000 16Kb Virtual Machine 0x8008000 16Kb Virtual Machine 0x800C000 16Kb Virtual Machine 0x8010000 64Kb Virtual Machine 0x8020000 128kb Bytecode Bank 0 0x8040000 128kb Bytecode Bank 1 0x8060000 128kb Bytecode Bank 2 0x8080000 128kb Bytecode Bank 3 0x80A0000 128kb Bytecode Bank 4 0x80C0000 128kb Bytecode Bank 5 0x80E0000 128kb Bytecode Bank 6 Warning If internal flash is used in a Zerynth program, it is suggested to begin using pages from the end of flash (bytecode bank 6) towards the virtual machine, to minimize the chance of clashes. Since writing to a sector entails erasing it first, the write operation can be slow even for small chunks of data, depending on the size of the choosen sector.","title":"Flash Layout"},{"location":"reference/boards/az3166/docs/#device-summary","text":"Microcontroller: STM32F412RG ARM\u00ae32-bit Cortex\u00ae-M4 CPU Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 31 Analog Input Pins (ADC): 2 UARTs: 2 SPIs: 1 I2Cs: 1 Flash Memory: 1 MB SRAM: 256 KB Clock Speed: 100 MHz","title":"Device Summary"},{"location":"reference/boards/az3166/docs/#power","text":"Power to the MXChip IoT DevKit AZ3166 is supplied via the on-board USB Micro B connector. The device can operate on an external supply voltage of 3.3 to 5.5 volts. If using more than 5.5V, the voltage regulator may overheat and damage the device.","title":"Power"},{"location":"reference/boards/az3166/docs/#connect-register-virtualize-and-program","text":"The IoT DevKit AZ3166 Programming port is connected to the ST-Link uploader creating a virtual COM port on a connected computer. To recognize the device, Windows machines requires drivers that can be downloaded from the ST-Link download page , while MAC OSX and Linux machines will recognize the device automatically. The St-Link is also connected to the STM32 hardware UART0. Once connected on a USB port, if drivers have been correctly installed the IoT DevKit AZ3166 device is recognized by Zerynth Studio and listed in the Device Management Toolbar . The next steps are: Select the IoT DevKit AZ3166 on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the IoT DevKit AZ3166 device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked. Note If the reset is not performed within 5 seconds the upload procedure fails.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/az3166/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the IoT DevKit AZ3166 device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x08000000 128Kb VM Slot 0 0x08020000 384kb Bytecode Slot 0 0x08080000 128kb VM Slot 1 0x080A0000 384kb Bytecode Slot 1 Important FOTA Record (small segment of memory where the current and desired state of the firmware is store) for the IoT DevKit AZ3166 device is allocated in 16kb sector inside the VM Slot 0 at 0x08004000 address.","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/az3166/docs/#power-management-and-secure-firmware","text":"Power Management feature allows to optimize power consumption by putting the device in low consumption state. Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). Both these features are strongly platform dependent; more information at Power Management - STM32F section and Secure Firmware - STM32F section .","title":"Power Management and Secure Firmware"},{"location":"reference/boards/cvm_espwroom32/docs/","text":"ESP-WROOM32 \u00b6 The ESP-WROOM32 developed by Espressif is based on the ESP32 microcontroller that boasts Wifi, Bluetooth, Ethernet and Low Power support all in a single chip. Pin Mapping \u00b6 The ESP-WROOM32 module is supported as a Zerynth customizable Virtual Machine, therefore the pinmap must be defined by the user. Please refer to here for more info on creating custom Virtual Machines. Flash Layout \u00b6 The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved Device Summary \u00b6 Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 28 Analog Input Pins (ADC): 8 Analog Outputs Pins (DAC): 2 UARTs: 3 SPIs: 2 I2Cs: 3 Flash Memory: 4 MB SRAM: 520 KB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks Connect, Register, Virtualize and Program \u00b6 The workflow for custom Virtual Machines varies depending on the feature of the PCB hosting the module. Registration, virtualization and programming can be done both through an usb-to-serial converter linked to one of the serial port of the ESP-WROOM32 or through jtag. Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the ESP-WROOM32 device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs. Secure Firmware \u00b6 Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section . Missing features \u00b6 Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"ESP-WROOM32"},{"location":"reference/boards/cvm_espwroom32/docs/#esp-wroom32","text":"The ESP-WROOM32 developed by Espressif is based on the ESP32 microcontroller that boasts Wifi, Bluetooth, Ethernet and Low Power support all in a single chip.","title":"ESP-WROOM32"},{"location":"reference/boards/cvm_espwroom32/docs/#pin-mapping","text":"The ESP-WROOM32 module is supported as a Zerynth customizable Virtual Machine, therefore the pinmap must be defined by the user. Please refer to here for more info on creating custom Virtual Machines.","title":"Pin Mapping"},{"location":"reference/boards/cvm_espwroom32/docs/#flash-layout","text":"The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved","title":"Flash Layout"},{"location":"reference/boards/cvm_espwroom32/docs/#device-summary","text":"Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 28 Analog Input Pins (ADC): 8 Analog Outputs Pins (DAC): 2 UARTs: 3 SPIs: 2 I2Cs: 3 Flash Memory: 4 MB SRAM: 520 KB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks","title":"Device Summary"},{"location":"reference/boards/cvm_espwroom32/docs/#connect-register-virtualize-and-program","text":"The workflow for custom Virtual Machines varies depending on the feature of the PCB hosting the module. Registration, virtualization and programming can be done both through an usb-to-serial converter linked to one of the serial port of the ESP-WROOM32 or through jtag.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/cvm_espwroom32/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the ESP-WROOM32 device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs.","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/cvm_espwroom32/docs/#secure-firmware","text":"Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section .","title":"Secure Firmware"},{"location":"reference/boards/cvm_espwroom32/docs/#missing-features","text":"Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"Missing features"},{"location":"reference/boards/doit_esp32/docs/","text":"DOIT Esp32 DevKit v1 \u00b6 The DOIT Esp32 DevKit v1 is one of the development board created by DOIT to evaluate the ESP-WROOM-32 module. It is based on the ESP32 microcontroller that boasts Wifi, Bluetooth, Ethernet and Low Power support all in a single chip. Pin Mapping \u00b6 More info about DOIT Esp32 DevKit v1 can be found here . Flash Layout \u00b6 The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved Device Summary \u00b6 Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 25 Analog Input Pins (ADC): 6 Analog Outputs Pins (DAC): 2 UARTs: 3 SPIs: 2 I2Cs: 3 Flash Memory: 4 MB SRAM: 520 KB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks Power \u00b6 Power to the DOIT Esp32 DevKit v1 is supplied via the on-board USB Micro B connector or directly via the \u201cVIN\u201d pin. The power source is selected automatically. The device can operate on an external supply of 6 to 20 volts. If using more than 12V, the voltage regulator may overheat and damage the device. The recommended range is 7 to 12 volts. Connect, Register, Virtualize and Program \u00b6 The DOIT Esp32 DevKit v1 comes with a serial-to-usb chip on board that allows programming and opening the UART of the ESP32 module. Drivers may be needed depending on your system (Mac or Windows) and can be download from the official Espressif documentation page. In Linux systems, the DevKit v1 should work out of the box. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the DevKit v1 device is recognized by Zerynth Studio. The next steps are: Select the DevKit v1 on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the DevKit v1 is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process. Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the DevKitC device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs. Secure Firmware \u00b6 Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section . Zerynth Secure Socket \u00b6 To be able to use Zerynth Secure Socket on esp32 boards NATIVE_MBEDTLS: true must be used instead of ZERYNTH_SSL: true in the project.yml file. Missing features \u00b6 Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"DOIT Esp32 DevKit v1"},{"location":"reference/boards/doit_esp32/docs/#doit-esp32-devkit-v1","text":"The DOIT Esp32 DevKit v1 is one of the development board created by DOIT to evaluate the ESP-WROOM-32 module. It is based on the ESP32 microcontroller that boasts Wifi, Bluetooth, Ethernet and Low Power support all in a single chip.","title":"DOIT Esp32 DevKit v1"},{"location":"reference/boards/doit_esp32/docs/#pin-mapping","text":"More info about DOIT Esp32 DevKit v1 can be found here .","title":"Pin Mapping"},{"location":"reference/boards/doit_esp32/docs/#flash-layout","text":"The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved","title":"Flash Layout"},{"location":"reference/boards/doit_esp32/docs/#device-summary","text":"Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 25 Analog Input Pins (ADC): 6 Analog Outputs Pins (DAC): 2 UARTs: 3 SPIs: 2 I2Cs: 3 Flash Memory: 4 MB SRAM: 520 KB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks","title":"Device Summary"},{"location":"reference/boards/doit_esp32/docs/#power","text":"Power to the DOIT Esp32 DevKit v1 is supplied via the on-board USB Micro B connector or directly via the \u201cVIN\u201d pin. The power source is selected automatically. The device can operate on an external supply of 6 to 20 volts. If using more than 12V, the voltage regulator may overheat and damage the device. The recommended range is 7 to 12 volts.","title":"Power"},{"location":"reference/boards/doit_esp32/docs/#connect-register-virtualize-and-program","text":"The DOIT Esp32 DevKit v1 comes with a serial-to-usb chip on board that allows programming and opening the UART of the ESP32 module. Drivers may be needed depending on your system (Mac or Windows) and can be download from the official Espressif documentation page. In Linux systems, the DevKit v1 should work out of the box. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the DevKit v1 device is recognized by Zerynth Studio. The next steps are: Select the DevKit v1 on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the DevKit v1 is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/doit_esp32/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the DevKitC device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs.","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/doit_esp32/docs/#secure-firmware","text":"Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section .","title":"Secure Firmware"},{"location":"reference/boards/doit_esp32/docs/#zerynth-secure-socket","text":"To be able to use Zerynth Secure Socket on esp32 boards NATIVE_MBEDTLS: true must be used instead of ZERYNTH_SSL: true in the project.yml file.","title":"Zerynth Secure Socket"},{"location":"reference/boards/doit_esp32/docs/#missing-features","text":"Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"Missing features"},{"location":"reference/boards/esp32_devkitc/docs/","text":"ESP32 DevKitC \u00b6 The ESP32 DevKitC is one of the development board created by Espressif to evaluate the ESP-WROOM-32 module. It is based on the ESP32 microcontroller that boasts Wifi, Bluetooth, Ethernet and Low Power support all in a single chip. Pin Mapping \u00b6 Official reference for ESP32 DevKitC can be found here . Flash Layout \u00b6 The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved Device Summary \u00b6 Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 28 Analog Input Pins (ADC): 8 Analog Outputs Pins (DAC): 2 UARTs: 3 SPIs: 2 I2Cs: 3 Flash Memory: 4 MB SRAM: 520 KB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks Power \u00b6 Power to the Esp32 DevKitC is supplied via the on-board USB Micro B connector or directly via the \u201cVIN\u201d pin. The power source is selected automatically. The device can operate on an external supply of 6 to 20 volts. If using more than 12V, the voltage regulator may overheat and damage the device. The recommended range is 7 to 12 volts. Connect, Register, Virtualize and Program \u00b6 The Esp32 DevKitC comes with a serial-to-usb chip on board that allows programming and opening the UART of the ESP32 module. Drivers may be needed depending on your system (Mac or Windows) and can be download from the official Espressif documentation page. In Linux systems, the DevKitC should work out of the box. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the DevKitC device is recognized by Zerynth Studio. The next steps are: Select the DevKitC on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the DevKitC is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Check this video for a live demo: Note No user intervention on the device is required for the uplink process. Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the DevKitC device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs. Secure Firmware \u00b6 Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section . Zerynth Secure Socket \u00b6 To be able to use Zerynth Secure Socket on esp32 boards NATIVE_MBEDTLS: true must be used instead of ZERYNTH_SSL: true in the project.yml file. Missing features \u00b6 Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"ESP32 DevKitC"},{"location":"reference/boards/esp32_devkitc/docs/#esp32-devkitc","text":"The ESP32 DevKitC is one of the development board created by Espressif to evaluate the ESP-WROOM-32 module. It is based on the ESP32 microcontroller that boasts Wifi, Bluetooth, Ethernet and Low Power support all in a single chip.","title":"ESP32 DevKitC"},{"location":"reference/boards/esp32_devkitc/docs/#pin-mapping","text":"Official reference for ESP32 DevKitC can be found here .","title":"Pin Mapping"},{"location":"reference/boards/esp32_devkitc/docs/#flash-layout","text":"The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved","title":"Flash Layout"},{"location":"reference/boards/esp32_devkitc/docs/#device-summary","text":"Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 28 Analog Input Pins (ADC): 8 Analog Outputs Pins (DAC): 2 UARTs: 3 SPIs: 2 I2Cs: 3 Flash Memory: 4 MB SRAM: 520 KB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks","title":"Device Summary"},{"location":"reference/boards/esp32_devkitc/docs/#power","text":"Power to the Esp32 DevKitC is supplied via the on-board USB Micro B connector or directly via the \u201cVIN\u201d pin. The power source is selected automatically. The device can operate on an external supply of 6 to 20 volts. If using more than 12V, the voltage regulator may overheat and damage the device. The recommended range is 7 to 12 volts.","title":"Power"},{"location":"reference/boards/esp32_devkitc/docs/#connect-register-virtualize-and-program","text":"The Esp32 DevKitC comes with a serial-to-usb chip on board that allows programming and opening the UART of the ESP32 module. Drivers may be needed depending on your system (Mac or Windows) and can be download from the official Espressif documentation page. In Linux systems, the DevKitC should work out of the box. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the DevKitC device is recognized by Zerynth Studio. The next steps are: Select the DevKitC on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the DevKitC is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Check this video for a live demo: Note No user intervention on the device is required for the uplink process.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/esp32_devkitc/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the DevKitC device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs.","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/esp32_devkitc/docs/#secure-firmware","text":"Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section .","title":"Secure Firmware"},{"location":"reference/boards/esp32_devkitc/docs/#zerynth-secure-socket","text":"To be able to use Zerynth Secure Socket on esp32 boards NATIVE_MBEDTLS: true must be used instead of ZERYNTH_SSL: true in the project.yml file.","title":"Zerynth Secure Socket"},{"location":"reference/boards/esp32_devkitc/docs/#missing-features","text":"Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"Missing features"},{"location":"reference/boards/esp32_ethernetkit/docs/","text":"ESP32 EthernetKit \u00b6 The ESP32 DevKitC is one of the development board created by Espressif to evaluate the ESP-WROOM-32 module. It is based on the ESP32 microcontroller that boasts Wifi, Bluetooth, Ethernet and Low Power support all in a single chip. ESP32-Ethernet-Kit is an ESP32 microcontroller based development board produced by Espressif. It consists of two development boards, the Ethernet board and the PoE board. The Ethernet board contains Bluetooth / Wi-Fi dual-mode ESP32-WROVER-B module and IP101GRI, a Single Port 10/100 Fast Ethernet Transceiver (PHY). The PoE board provides power over Ethernet functionality. The Ethernet board can work independently, without the PoE board installed. Pin Mapping \u00b6 Official reference for ESP32 EthernetKit can be found here . Flash Layout \u00b6 The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved Device Summary \u00b6 Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 28 Analog Input Pins (ADC): 8 Analog Outputs Pins (DAC): 2 UARTs: 3 SPIs: 2 I2Cs: 3 Flash Memory: 4 MB SRAM: 520 KB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks PoE Board \u00b6 This board coverts power delivered over the Ethernet cable (PoE) to provide a power supply for the Ethernet board. The main components of the PoE board are shown on the block diagram under Functionality Overview. The PoE board has the following features: Support for IEEE 802.3at Power output: 5 V, 1.4 A To take advantage of the PoE functionality the RJ45 Port of the Ethernet board should be connected with an Ethernet cable to a switch that supports PoE. When the Ethernet board detects 5 V power output from the PoE board, the USB power will be automatically cut off. Power \u00b6 Power to the Esp32 EthernetKit is supplied via the on-board USB Micro B connector.j The device can operate on an external supply of 6 to 20 volts. If using more than 12V, the voltage regulator may overheat and damage the device. The recommended range is 7 to 12 volts. Connect, Register, Virtualize and Program \u00b6 The Esp32 EthernetKit comes with a serial-to-usb chip on board that allows programming and opening the UART of the ESP32 module. Drivers may be needed depending on your system (Mac or Windows) and can be download from the official Espressif documentation page. In Linux systems, the DevKitC should work out of the box. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the DevKitC device is recognized by Zerynth Studio. The next steps are: Select the DevKitC on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the DevKitC is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process. Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the DevKitC device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs. Secure Firmware \u00b6 Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section . Zerynth Secure Socket \u00b6 To be able to use Zerynth Secure Socket on esp32 boards NATIVE_MBEDTLS: true must be used instead of ZERYNTH_SSL: true in the project.yml file. Missing features \u00b6 Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support; WROVER\u2019s SPI flash module;","title":"ESP32 EthernetKit"},{"location":"reference/boards/esp32_ethernetkit/docs/#esp32-ethernetkit","text":"The ESP32 DevKitC is one of the development board created by Espressif to evaluate the ESP-WROOM-32 module. It is based on the ESP32 microcontroller that boasts Wifi, Bluetooth, Ethernet and Low Power support all in a single chip. ESP32-Ethernet-Kit is an ESP32 microcontroller based development board produced by Espressif. It consists of two development boards, the Ethernet board and the PoE board. The Ethernet board contains Bluetooth / Wi-Fi dual-mode ESP32-WROVER-B module and IP101GRI, a Single Port 10/100 Fast Ethernet Transceiver (PHY). The PoE board provides power over Ethernet functionality. The Ethernet board can work independently, without the PoE board installed.","title":"ESP32 EthernetKit"},{"location":"reference/boards/esp32_ethernetkit/docs/#pin-mapping","text":"Official reference for ESP32 EthernetKit can be found here .","title":"Pin Mapping"},{"location":"reference/boards/esp32_ethernetkit/docs/#flash-layout","text":"The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved","title":"Flash Layout"},{"location":"reference/boards/esp32_ethernetkit/docs/#device-summary","text":"Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 28 Analog Input Pins (ADC): 8 Analog Outputs Pins (DAC): 2 UARTs: 3 SPIs: 2 I2Cs: 3 Flash Memory: 4 MB SRAM: 520 KB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks","title":"Device Summary"},{"location":"reference/boards/esp32_ethernetkit/docs/#poe-board","text":"This board coverts power delivered over the Ethernet cable (PoE) to provide a power supply for the Ethernet board. The main components of the PoE board are shown on the block diagram under Functionality Overview. The PoE board has the following features: Support for IEEE 802.3at Power output: 5 V, 1.4 A To take advantage of the PoE functionality the RJ45 Port of the Ethernet board should be connected with an Ethernet cable to a switch that supports PoE. When the Ethernet board detects 5 V power output from the PoE board, the USB power will be automatically cut off.","title":"PoE Board"},{"location":"reference/boards/esp32_ethernetkit/docs/#power","text":"Power to the Esp32 EthernetKit is supplied via the on-board USB Micro B connector.j The device can operate on an external supply of 6 to 20 volts. If using more than 12V, the voltage regulator may overheat and damage the device. The recommended range is 7 to 12 volts.","title":"Power"},{"location":"reference/boards/esp32_ethernetkit/docs/#connect-register-virtualize-and-program","text":"The Esp32 EthernetKit comes with a serial-to-usb chip on board that allows programming and opening the UART of the ESP32 module. Drivers may be needed depending on your system (Mac or Windows) and can be download from the official Espressif documentation page. In Linux systems, the DevKitC should work out of the box. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the DevKitC device is recognized by Zerynth Studio. The next steps are: Select the DevKitC on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the DevKitC is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/esp32_ethernetkit/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the DevKitC device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs.","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/esp32_ethernetkit/docs/#secure-firmware","text":"Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section .","title":"Secure Firmware"},{"location":"reference/boards/esp32_ethernetkit/docs/#zerynth-secure-socket","text":"To be able to use Zerynth Secure Socket on esp32 boards NATIVE_MBEDTLS: true must be used instead of ZERYNTH_SSL: true in the project.yml file.","title":"Zerynth Secure Socket"},{"location":"reference/boards/esp32_ethernetkit/docs/#missing-features","text":"Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support; WROVER\u2019s SPI flash module;","title":"Missing features"},{"location":"reference/boards/esp32_pico_v4/docs/","text":"ESP32 Pico v4 \u00b6 The ESP32 Pico v4 is a mini development board produced by Espressif. The core of this board is the ESP32-PICO-D4, based on ESP32 microcontroller , a System-in-Package (SIP) module with complete Wi-Fi and Bluetooth functionalities. Comparing to other ESP32 chips, the ESP32-PICO-D4 integrates several peripheral components in one single package, that otherwise would need to be installed separately. This includes a 40 MHz crystal oscillator, 4 MB flash, filter capacitors and RF matching links in. Pin Mapping \u00b6 Official reference for ESP32 Pico v4 can be found here . Flash Layout \u00b6 The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved Device Summary \u00b6 Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 28 Analog Input Pins (ADC): 8 Analog Outputs Pins (DAC): 2 UARTs: 3 SPIs: 2 I2Cs: 3 Flash Memory: 4 MB SRAM: 520 KB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks Power \u00b6 Power to the Esp32 Pico v4 is supplied via the on-board USB Micro B connector or directly via the \u201cVIN\u201d pin. The power source is selected automatically. The device can operate on an external supply of 6 to 20 volts. If using more than 12V, the voltage regulator may overheat and damage the device. The recommended range is 7 to 12 volts. Connect, Register, Virtualize and Program \u00b6 The Esp32 Pico v4 comes with a serial-to-usb chip on board that allows programming and opening the UART of the ESP32 module. Drivers may be needed depending on your system (Mac or Windows) and can be download from the official Espressif documentation page. In Linux systems, the Pico v4 should work out of the box. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the Pico v4 device is recognized by Zerynth Studio. The next steps are: Select the Pico v4 on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the Pico v4 is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process. Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the DevKitC device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs. Secure Firmware \u00b6 Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section. Zerynth Secure Socket \u00b6 To be able to use Zerynth Secure Socket on esp32 boards NATIVE_MBEDTLS: true must be used instead of ZERYNTH_SSL: true in the project.yml file. Missing features \u00b6 Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"ESP32 Pico v4"},{"location":"reference/boards/esp32_pico_v4/docs/#esp32-pico-v4","text":"The ESP32 Pico v4 is a mini development board produced by Espressif. The core of this board is the ESP32-PICO-D4, based on ESP32 microcontroller , a System-in-Package (SIP) module with complete Wi-Fi and Bluetooth functionalities. Comparing to other ESP32 chips, the ESP32-PICO-D4 integrates several peripheral components in one single package, that otherwise would need to be installed separately. This includes a 40 MHz crystal oscillator, 4 MB flash, filter capacitors and RF matching links in.","title":"ESP32 Pico v4"},{"location":"reference/boards/esp32_pico_v4/docs/#pin-mapping","text":"Official reference for ESP32 Pico v4 can be found here .","title":"Pin Mapping"},{"location":"reference/boards/esp32_pico_v4/docs/#flash-layout","text":"The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved","title":"Flash Layout"},{"location":"reference/boards/esp32_pico_v4/docs/#device-summary","text":"Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 28 Analog Input Pins (ADC): 8 Analog Outputs Pins (DAC): 2 UARTs: 3 SPIs: 2 I2Cs: 3 Flash Memory: 4 MB SRAM: 520 KB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks","title":"Device Summary"},{"location":"reference/boards/esp32_pico_v4/docs/#power","text":"Power to the Esp32 Pico v4 is supplied via the on-board USB Micro B connector or directly via the \u201cVIN\u201d pin. The power source is selected automatically. The device can operate on an external supply of 6 to 20 volts. If using more than 12V, the voltage regulator may overheat and damage the device. The recommended range is 7 to 12 volts.","title":"Power"},{"location":"reference/boards/esp32_pico_v4/docs/#connect-register-virtualize-and-program","text":"The Esp32 Pico v4 comes with a serial-to-usb chip on board that allows programming and opening the UART of the ESP32 module. Drivers may be needed depending on your system (Mac or Windows) and can be download from the official Espressif documentation page. In Linux systems, the Pico v4 should work out of the box. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the Pico v4 device is recognized by Zerynth Studio. The next steps are: Select the Pico v4 on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the Pico v4 is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/esp32_pico_v4/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the DevKitC device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs.","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/esp32_pico_v4/docs/#secure-firmware","text":"Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section.","title":"Secure Firmware"},{"location":"reference/boards/esp32_pico_v4/docs/#zerynth-secure-socket","text":"To be able to use Zerynth Secure Socket on esp32 boards NATIVE_MBEDTLS: true must be used instead of ZERYNTH_SSL: true in the project.yml file.","title":"Zerynth Secure Socket"},{"location":"reference/boards/esp32_pico_v4/docs/#missing-features","text":"Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"Missing features"},{"location":"reference/boards/firebeetle_esp32/docs/","text":"DFRobot FireBeetle Esp32 \u00b6 FireBeetle Esp32 is a low-power consumption development hardware designed for Internet of Things (IoT) by DFRobot. FireBeetle ESP32 integrates a Dual-Core ESP-WROOM-32 module , which supports MCU and Wi-Fi &Bluetooth dual-mode communication. The main controller supports two power supply methods: USB and 3.7V external lithium battery. And both USB and external DC can charge the Lipo battery directly Pin Mapping \u00b6 Official reference for DFRobot FireBeetle Esp32 can be found here . Flash Layout \u00b6 The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved 0x00392000 4Mb Free for user storage For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved 0x00392000 4Mb Free for user storage Device Summary \u00b6 Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 31 Analog Input Pins (ADC): 4 Analog Outputs Pins (DAC): 2 UARTs: 3 SPIs: 2 I2Cs: 3 Flash Memory: 8 MB SRAM: 520 KB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks Power \u00b6 Power to the DFRobot FireBeetle ESP32 is supplied via the on-board USB Micro B connector or directly throught the connector for a 3.7/4.2 V battery. The power source is selected automatically. The device can operate on an external supply of 3 to 5 volts. If using more than 5V, the voltage regulator may overheat and damage the device. Connect, Register, Virtualize and Program \u00b6 The DFRobot FireBeetle ESP32 comes with a serial-to-usb chip on board that allows programming and opening the UART of the ESP32 module. Drivers may be needed depending on your system (Mac or Windows) and can be download from here . In Linux systems, the FireBeetle ESP32 should work out of the box. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the FireBeetle ESP32 device is recognized by Zerynth Studio. The next steps are: Select the FireBeetle ESP32 on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the FireBeetle ESP32 is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Check this video for a live demo: Note No user intervention on the device is required for the uplink process. Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the DFRobot FireBeetle ESP32 device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs. Secure Firmware \u00b6 Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section . Zerynth Secure Socket \u00b6 To be able to use Zerynth Secure Socket on esp32 boards NATIVE_MBEDTLS: true must be used instead of ZERYNTH_SSL: true in the project.yml file. Missing features \u00b6 Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"DFRobot FireBeetle Esp32"},{"location":"reference/boards/firebeetle_esp32/docs/#dfrobot-firebeetle-esp32","text":"FireBeetle Esp32 is a low-power consumption development hardware designed for Internet of Things (IoT) by DFRobot. FireBeetle ESP32 integrates a Dual-Core ESP-WROOM-32 module , which supports MCU and Wi-Fi &Bluetooth dual-mode communication. The main controller supports two power supply methods: USB and 3.7V external lithium battery. And both USB and external DC can charge the Lipo battery directly","title":"DFRobot FireBeetle Esp32"},{"location":"reference/boards/firebeetle_esp32/docs/#pin-mapping","text":"Official reference for DFRobot FireBeetle Esp32 can be found here .","title":"Pin Mapping"},{"location":"reference/boards/firebeetle_esp32/docs/#flash-layout","text":"The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved 0x00392000 4Mb Free for user storage For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved 0x00392000 4Mb Free for user storage","title":"Flash Layout"},{"location":"reference/boards/firebeetle_esp32/docs/#device-summary","text":"Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 31 Analog Input Pins (ADC): 4 Analog Outputs Pins (DAC): 2 UARTs: 3 SPIs: 2 I2Cs: 3 Flash Memory: 8 MB SRAM: 520 KB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks","title":"Device Summary"},{"location":"reference/boards/firebeetle_esp32/docs/#power","text":"Power to the DFRobot FireBeetle ESP32 is supplied via the on-board USB Micro B connector or directly throught the connector for a 3.7/4.2 V battery. The power source is selected automatically. The device can operate on an external supply of 3 to 5 volts. If using more than 5V, the voltage regulator may overheat and damage the device.","title":"Power"},{"location":"reference/boards/firebeetle_esp32/docs/#connect-register-virtualize-and-program","text":"The DFRobot FireBeetle ESP32 comes with a serial-to-usb chip on board that allows programming and opening the UART of the ESP32 module. Drivers may be needed depending on your system (Mac or Windows) and can be download from here . In Linux systems, the FireBeetle ESP32 should work out of the box. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the FireBeetle ESP32 device is recognized by Zerynth Studio. The next steps are: Select the FireBeetle ESP32 on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the FireBeetle ESP32 is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Check this video for a live demo: Note No user intervention on the device is required for the uplink process.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/firebeetle_esp32/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the DFRobot FireBeetle ESP32 device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs.","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/firebeetle_esp32/docs/#secure-firmware","text":"Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section .","title":"Secure Firmware"},{"location":"reference/boards/firebeetle_esp32/docs/#zerynth-secure-socket","text":"To be able to use Zerynth Secure Socket on esp32 boards NATIVE_MBEDTLS: true must be used instead of ZERYNTH_SSL: true in the project.yml file.","title":"Zerynth Secure Socket"},{"location":"reference/boards/firebeetle_esp32/docs/#missing-features","text":"Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"Missing features"},{"location":"reference/boards/firebeetle_esp8266/docs/","text":"DFRobot FireBeetle ESP8266 \u00b6 The FireBeetle ESP8266 is a low-power-consumption development hardware designed for Internet of Things (IoT) by DFRobot. Firebeetle ESP8266 is a development device with built in USB and battery charging, integrated with IoT WiFi, TCP/IP, 32-bit MCU, 10-bit ADC and multiple interfaces such as HSPI, UART, PWM, I2C. The DFRobot FireBeetle ESP8266 device features Tensilica microcontroller (80MHz of system clock), around 50k of usable RAM and an Espressif ESP8266 chip Wi-fi Transceiver. This device wired up a CH40* USB-to-Serial to upload the code. It also has auto-reset so no noodling with pins and reset button pressings. To make it easy to use for portable projects, the FireBeetle ESP8266 provides a connector for a 3.7/4.2 V Lithium polymer battery and built in battery charging circuit thought USB port. The FireBeetle ESP8266 will automatically switch over to USB power when its available. Pin Mapping \u00b6 Official reference for DFRobot FireBeetle ESP8266 can be found here . Flash Layout \u00b6 The DFRobot FireBeetle ESP8266 device features a 4 MB (32 Mb) flash memory organized in sectors of 4k each. The flash memory address starts at 0x40200000 and can be read and written from a Zerynth program using the internal flash module. Warning If flash memory must be used in a Zerynth program, it is recommended to begin using it from secure addresses towards the end the bytecode (start address of the bytecode can be found in the log console of Zerynth Studio during the uplink operation), leaving a minimum safe place to minimize the chance of clashes. Note The internal flash of DFRobot FireBeetle ESP8266 can be organized in different ways. The standard VM is a non-FOTA VM with the VM code beginning at 0x0000, followed by the esp8266 ir0m image at 0x20000 and the esp_init_data at 0x3fc000. The VM is based on the Espressif RTOS SDK 1.4.1. Device Summary \u00b6 Microcontroller: Tensilica 32-bit RISC CPU Xtensa LX106 Operating Voltage: 3.3V Input Voltage: 3.3-5V Digital I/O Pins (DIO): 12 Analog Input Pins (ADC): 1 UARTs: 2 SPIs: 1 I2Cs: 1 Flash Memory: 4 MB SRAM: 64 KB Clock Speed: 80 Mhz Wi-Fi: IEEE 802.11 b/g/n: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks Power \u00b6 Power to the DFRobot FireBeetle ESP8266 is supplied via the on-board USB Micro B connector or directly throught the connector for a 3.7/4.2 V battery. The power source is selected automatically. The device can operate on an external supply of 3 to 5 volts. If using more than 5V, the voltage regulator may overheat and damage the device. Connect, Register, Virtualize and Program \u00b6 The DFRobot FireBeetle ESP8266 exposes the serial port of the ESP8266 module via CH340 USB to UART chip which is also connected to the boot pins of the module, allowing for a seamless virtualization of the device. Note Drivers for the CH340 Module can be downloaded here and are needed for Windows and Mac platforms . Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected to a USB port the FireBeetle ESP8266 device can be seen as a Virtual Serial port and it is automatically recognized by Zerynth Studio. The next steps are: Select the FireBeetle ESP8266 on the Device Management Toolbar (Disambiguate operation may be required); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the FireBeetle ESP8266 device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the upload process. Important To exploit the Wi-Fi chip functionalities of the FireBeetle ESP8266, the lib.espressif.esp8266wifi library must be installed (some example code is provided). Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the DFRobot FireBeetle ESP8266 device is available for bytecode only. Flash Layout is shown in table below: Start address Size Content 0x40200000 448Kb VM Slot 0x40270000 256Kb Bytecode Slot 0 0x402B0000 320Kb Bytecode Slot 1 Important FOTA Record (small segment of memory where the current and desired state of the firmware is store) for the FireBeetle ESP8266 device is allocated in the RTC memory. Power Management \u00b6 Power Management feature allows to optimize power consumption by putting the device in low consumption state. More information in Power Management - ESP8266 section .","title":"DFRobot FireBeetle ESP8266"},{"location":"reference/boards/firebeetle_esp8266/docs/#dfrobot-firebeetle-esp8266","text":"The FireBeetle ESP8266 is a low-power-consumption development hardware designed for Internet of Things (IoT) by DFRobot. Firebeetle ESP8266 is a development device with built in USB and battery charging, integrated with IoT WiFi, TCP/IP, 32-bit MCU, 10-bit ADC and multiple interfaces such as HSPI, UART, PWM, I2C. The DFRobot FireBeetle ESP8266 device features Tensilica microcontroller (80MHz of system clock), around 50k of usable RAM and an Espressif ESP8266 chip Wi-fi Transceiver. This device wired up a CH40* USB-to-Serial to upload the code. It also has auto-reset so no noodling with pins and reset button pressings. To make it easy to use for portable projects, the FireBeetle ESP8266 provides a connector for a 3.7/4.2 V Lithium polymer battery and built in battery charging circuit thought USB port. The FireBeetle ESP8266 will automatically switch over to USB power when its available.","title":"DFRobot FireBeetle ESP8266"},{"location":"reference/boards/firebeetle_esp8266/docs/#pin-mapping","text":"Official reference for DFRobot FireBeetle ESP8266 can be found here .","title":"Pin Mapping"},{"location":"reference/boards/firebeetle_esp8266/docs/#flash-layout","text":"The DFRobot FireBeetle ESP8266 device features a 4 MB (32 Mb) flash memory organized in sectors of 4k each. The flash memory address starts at 0x40200000 and can be read and written from a Zerynth program using the internal flash module. Warning If flash memory must be used in a Zerynth program, it is recommended to begin using it from secure addresses towards the end the bytecode (start address of the bytecode can be found in the log console of Zerynth Studio during the uplink operation), leaving a minimum safe place to minimize the chance of clashes. Note The internal flash of DFRobot FireBeetle ESP8266 can be organized in different ways. The standard VM is a non-FOTA VM with the VM code beginning at 0x0000, followed by the esp8266 ir0m image at 0x20000 and the esp_init_data at 0x3fc000. The VM is based on the Espressif RTOS SDK 1.4.1.","title":"Flash Layout"},{"location":"reference/boards/firebeetle_esp8266/docs/#device-summary","text":"Microcontroller: Tensilica 32-bit RISC CPU Xtensa LX106 Operating Voltage: 3.3V Input Voltage: 3.3-5V Digital I/O Pins (DIO): 12 Analog Input Pins (ADC): 1 UARTs: 2 SPIs: 1 I2Cs: 1 Flash Memory: 4 MB SRAM: 64 KB Clock Speed: 80 Mhz Wi-Fi: IEEE 802.11 b/g/n: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks","title":"Device Summary"},{"location":"reference/boards/firebeetle_esp8266/docs/#power","text":"Power to the DFRobot FireBeetle ESP8266 is supplied via the on-board USB Micro B connector or directly throught the connector for a 3.7/4.2 V battery. The power source is selected automatically. The device can operate on an external supply of 3 to 5 volts. If using more than 5V, the voltage regulator may overheat and damage the device.","title":"Power"},{"location":"reference/boards/firebeetle_esp8266/docs/#connect-register-virtualize-and-program","text":"The DFRobot FireBeetle ESP8266 exposes the serial port of the ESP8266 module via CH340 USB to UART chip which is also connected to the boot pins of the module, allowing for a seamless virtualization of the device. Note Drivers for the CH340 Module can be downloaded here and are needed for Windows and Mac platforms . Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected to a USB port the FireBeetle ESP8266 device can be seen as a Virtual Serial port and it is automatically recognized by Zerynth Studio. The next steps are: Select the FireBeetle ESP8266 on the Device Management Toolbar (Disambiguate operation may be required); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the FireBeetle ESP8266 device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the upload process. Important To exploit the Wi-Fi chip functionalities of the FireBeetle ESP8266, the lib.espressif.esp8266wifi library must be installed (some example code is provided).","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/firebeetle_esp8266/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the DFRobot FireBeetle ESP8266 device is available for bytecode only. Flash Layout is shown in table below: Start address Size Content 0x40200000 448Kb VM Slot 0x40270000 256Kb Bytecode Slot 0 0x402B0000 320Kb Bytecode Slot 1 Important FOTA Record (small segment of memory where the current and desired state of the firmware is store) for the FireBeetle ESP8266 device is allocated in the RTC memory.","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/firebeetle_esp8266/docs/#power-management","text":"Power Management feature allows to optimize power consumption by putting the device in low consumption state. More information in Power Management - ESP8266 section .","title":"Power Management"},{"location":"reference/boards/flipnclick_sam3x/docs/","text":"Flip & Click Sam3X \u00b6 The Flip & Click is a microcontroller device based on the Atmel SAM3X8E ARM Cortex-M3 CPU , produced by MikroElektronika This device has the predisposition in both sides for shields and expansion boards in general: In the front side (Blue side in MikroElektronica parlance), it features the Arduino Uno standard pinout with additional SPI pins; In the back side (White side in MikroE parlance) the device has four mikroBUS sockets to connect MikroE Click Boards showing one of the best features for a hardware development platform: modularity . Note Clicks are bite-sized add-on boards with a standardized mikroBUS connector that make prototyping as elegant and enjoyable as it gets. Each one carries a single sensor, transceiver, display, encoder, connection port or any other sort of chip or module. With more than 160 to choose from, and more coming out every week, it\u2019s very simple to create a custom product by simply adding new functionality to the main device. Pin Mapping \u00b6 MikroElektronika Flip & Click official manual is available here . Flash Layout \u00b6 The internal flash of the Flip & Click Sam3X is organized into two banks of 256k each. Each bank is divided into 1024 pages of 256 bytes each. The first bank, starting at 0x80000, is used by the virtual machine runtime. The second bank is used to store bytecode and can be read and written from a Zerynth program using the internal flash module. The bytecode always starts at the address 0xC0000 (the starting address of the second bank) and ends depending on its size. The second bank extends up to address 0x100000. If internal flash has to be used in a Zerynth program, it is recommended to start using pages from the end of the bank towards the bytecode, to minimize the chance of clashes. Device Summary \u00b6 Microcontroller: AT91SAM3X8E Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 49 Analog Input Pins (ADC): 5 UARTs: 4 SPIs: 1 I2Cs: 2 Flash Memory: 512 KB SRAM: 96 KB Clock Speed: 84 MHz Slots for Clicks: 4 Power \u00b6 The Flip & Click can be powered via the USB connector or with an external power supply. The power source is selected automatically. External (non-USB) power can come either from an AC-to-DC adapter (wall-wart) or battery. The adapter can be connected by plugging a 2.1 mm center-positive plug into the device\u2019s power jack. Leads from a battery can be inserted in the Gnd and Vin pin headers of the POWER connector. The device can operate on an external supply of 6 to 20 volts. If supplied with less than 7V, however, the 5V pin may supply less than five volts and the device may be unstable. If more than 12V are used, the voltage regulator may overheat and damage the device. The recommended range is 7 to 12 volts. Connect, Register, Virtualize and Program \u00b6 The Flip & Click Programming port is connected to an ATmega16U2, which provides a virtual COM port to software on a connected computer, allowing for a seamless virtualization of the device. Note Drivers for the FTDI can be downloaded here and are needed for Windows and Mac platforms . Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. The 16U2 is also connected to the SAM3X hardware UART. Serial on pins RX0 and TX0 provides Serial-to-USB communication for programming the device through the ATmega16U2 microcontroller. Once connected on a USB port, if drivers have been correctly installed, the Flip & Click device is recognized by Zerynth Studio. The next steps are: Select the Flip & Click on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Check this video for a live demo: !!! note No user intervention on the device is required for the uplink process. Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Flip & Click device is available for bytecode only. Flash Layout is shown in table below: Start address Size Content 0x00080000 256Kb VM Slot 0x000C0000 125Kb Bytecode Slot 0 0x000E0000 128Kb-256b Bytecode Slot 1 0x000FFF00 256b FOTA Record","title":"Flip & Click Sam3X"},{"location":"reference/boards/flipnclick_sam3x/docs/#flip-click-sam3x","text":"The Flip & Click is a microcontroller device based on the Atmel SAM3X8E ARM Cortex-M3 CPU , produced by MikroElektronika This device has the predisposition in both sides for shields and expansion boards in general: In the front side (Blue side in MikroElektronica parlance), it features the Arduino Uno standard pinout with additional SPI pins; In the back side (White side in MikroE parlance) the device has four mikroBUS sockets to connect MikroE Click Boards showing one of the best features for a hardware development platform: modularity . Note Clicks are bite-sized add-on boards with a standardized mikroBUS connector that make prototyping as elegant and enjoyable as it gets. Each one carries a single sensor, transceiver, display, encoder, connection port or any other sort of chip or module. With more than 160 to choose from, and more coming out every week, it\u2019s very simple to create a custom product by simply adding new functionality to the main device.","title":"Flip &amp; Click Sam3X"},{"location":"reference/boards/flipnclick_sam3x/docs/#pin-mapping","text":"MikroElektronika Flip & Click official manual is available here .","title":"Pin Mapping"},{"location":"reference/boards/flipnclick_sam3x/docs/#flash-layout","text":"The internal flash of the Flip & Click Sam3X is organized into two banks of 256k each. Each bank is divided into 1024 pages of 256 bytes each. The first bank, starting at 0x80000, is used by the virtual machine runtime. The second bank is used to store bytecode and can be read and written from a Zerynth program using the internal flash module. The bytecode always starts at the address 0xC0000 (the starting address of the second bank) and ends depending on its size. The second bank extends up to address 0x100000. If internal flash has to be used in a Zerynth program, it is recommended to start using pages from the end of the bank towards the bytecode, to minimize the chance of clashes.","title":"Flash Layout"},{"location":"reference/boards/flipnclick_sam3x/docs/#device-summary","text":"Microcontroller: AT91SAM3X8E Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 49 Analog Input Pins (ADC): 5 UARTs: 4 SPIs: 1 I2Cs: 2 Flash Memory: 512 KB SRAM: 96 KB Clock Speed: 84 MHz Slots for Clicks: 4","title":"Device Summary"},{"location":"reference/boards/flipnclick_sam3x/docs/#power","text":"The Flip & Click can be powered via the USB connector or with an external power supply. The power source is selected automatically. External (non-USB) power can come either from an AC-to-DC adapter (wall-wart) or battery. The adapter can be connected by plugging a 2.1 mm center-positive plug into the device\u2019s power jack. Leads from a battery can be inserted in the Gnd and Vin pin headers of the POWER connector. The device can operate on an external supply of 6 to 20 volts. If supplied with less than 7V, however, the 5V pin may supply less than five volts and the device may be unstable. If more than 12V are used, the voltage regulator may overheat and damage the device. The recommended range is 7 to 12 volts.","title":"Power"},{"location":"reference/boards/flipnclick_sam3x/docs/#connect-register-virtualize-and-program","text":"The Flip & Click Programming port is connected to an ATmega16U2, which provides a virtual COM port to software on a connected computer, allowing for a seamless virtualization of the device. Note Drivers for the FTDI can be downloaded here and are needed for Windows and Mac platforms . Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. The 16U2 is also connected to the SAM3X hardware UART. Serial on pins RX0 and TX0 provides Serial-to-USB communication for programming the device through the ATmega16U2 microcontroller. Once connected on a USB port, if drivers have been correctly installed, the Flip & Click device is recognized by Zerynth Studio. The next steps are: Select the Flip & Click on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Check this video for a live demo: !!! note No user intervention on the device is required for the uplink process.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/flipnclick_sam3x/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Flip & Click device is available for bytecode only. Flash Layout is shown in table below: Start address Size Content 0x00080000 256Kb VM Slot 0x000C0000 125Kb Bytecode Slot 0 0x000E0000 128Kb-256b Bytecode Slot 1 0x000FFF00 256b FOTA Record","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/genuino_zero/docs/","text":"Arduino/Genuino Zero \u00b6 The Arduino/Genuino Zero is a microcontroller device based on the Atmel SAMD21G18AU ARM Cortex-M0+ CPU . It is a simple and powerful 32-bit extension of the platform established by the UNO. It has 20 digital input/output pins (of which 10 can be used as PWM outputs), 6 analog inputs, 2 UARTs (hardware serial ports), a 48 MHz clock, 1 DAC (digital to analog), 1 TWI, an SPI header, a JTAG header, a reset button. One of its most important features is the Atmel Embedded Debugger (EDBG), which provides a full debug interface without the need for additional hardware, significantly increasing the ease-of-use for software debugging. EDBG also supports a virtual COM port that can be used for device and bootloader programming. Warning Unlike most Arduino & Genuino devices, the Zero runs at 3.3V. The maximum voltage that the I/O pins can tolerate is 3.3V. Applying voltages higher than 3.3V to any I/O pin could damage the device. Note All the reported information are extracted from the official Arduino/Genuino Zero page , visit this page for more details and updates. Pin Mapping \u00b6 Arduino/Genuino Zero Official Schematic, Reference Design and Pin Mapping are available on the official Arduino/Genuino Zero reference page . Flash Layout \u00b6 The internal flash of the Arduino/Genuino Zero is organized as a single bank of 256k. Zerynth VM overwrites SAM-BA Bootloader located at Flash start, SAM-BA bootloader can be restored using Arduino IDE. Device Summary \u00b6 Microcontroller: ATSAMD21G18 Operating Voltage: 3.3V Digital I/O Pins (DIO): 20 Analog Input Pins (ADC): 6 Analog Outputs Pins (DAC): 1 UARTs: 2 SPIs: 1 I2Cs: 1 Flash Memory: 256 KB SRAM: 32 KB Clock Speed: 48 MHz Size (LxW mm): 68.0 x 30.0 Power \u00b6 The Arduino/Genuino Zero can be powered via the USB connector or with an external power supply. The power source is selected automatically. External (non-USB) power can come either from an AC-to-DC adapter (such as a wall-wart) or battery, and can be connected using a 2.1mm center-positive plug connected to the device\u2019s power jack, or directly to the GND and VIN pin headers of the POWER connector. The device can operate on an external supply of 6 to 20 volts. If supplied with less than 7V, however, the 5V pin may supply less than five volts and the device may be unstable. If more than 12V are used, the voltage regulator may overheat and damage the device. The recommended range is 7 to 12 volts. Connect, Register, Virtualize and Program \u00b6 The Arduino/Genuino Zero Programming port is connected to EDBG, which provides a virtual COM port to software on a connected computer. To recognize the device, Windows machines requires drivers that can be downloaded from the Arduino/Genuino Zero guide , while OSX and Linux machines will recognize the device as a COM port automatically. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. If the device is still not recognized or not working, the following udev rules may need to be added: #Genuino Zero Device SUBSYSTEMS == \"usb\" , ATTRS { idVendor } == \"03eb\" , ATTRS { idProduct } == \"2157\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE } = \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor } == \"03eb\" , ATTRS { idProduct } == \"2157\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE } = \"1\" EDBG is also connected to the SAMD21 hardware UART. Serial on pins RX0 and TX0 provides Serial-to-USB communication for programming the device through Atmel EDBG. Once connected on a USB port, if drivers have been correctly installed, the Arduino/Genuino Zero device is recognized by Zerynth Studio. The next steps are: Select the Arduino/Genuino Zero on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the Arduino/Genuino Zero is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked. Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Arduino/Genuino Zero device is available for bytecode only. Flash Layout is shown in table below: Start address Size Content 0x00002000 88Kb VM Slot 0x00018000 80Kb Bytecode Slot 0 0x0002C000 80Kb Bytecode Slot 1 Power Management and Secure Firmware \u00b6 Power Management feature allows to optimize power consumption by putting the device in low consumption state. Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). Both these features are strongly platform dependent; more information at Power Management - Microchip SAMD21 section and Secure Firmware - Microchip SAMD21 section .","title":"Arduino/Genuino Zero"},{"location":"reference/boards/genuino_zero/docs/#arduinogenuino-zero","text":"The Arduino/Genuino Zero is a microcontroller device based on the Atmel SAMD21G18AU ARM Cortex-M0+ CPU . It is a simple and powerful 32-bit extension of the platform established by the UNO. It has 20 digital input/output pins (of which 10 can be used as PWM outputs), 6 analog inputs, 2 UARTs (hardware serial ports), a 48 MHz clock, 1 DAC (digital to analog), 1 TWI, an SPI header, a JTAG header, a reset button. One of its most important features is the Atmel Embedded Debugger (EDBG), which provides a full debug interface without the need for additional hardware, significantly increasing the ease-of-use for software debugging. EDBG also supports a virtual COM port that can be used for device and bootloader programming. Warning Unlike most Arduino & Genuino devices, the Zero runs at 3.3V. The maximum voltage that the I/O pins can tolerate is 3.3V. Applying voltages higher than 3.3V to any I/O pin could damage the device. Note All the reported information are extracted from the official Arduino/Genuino Zero page , visit this page for more details and updates.","title":"Arduino/Genuino Zero"},{"location":"reference/boards/genuino_zero/docs/#pin-mapping","text":"Arduino/Genuino Zero Official Schematic, Reference Design and Pin Mapping are available on the official Arduino/Genuino Zero reference page .","title":"Pin Mapping"},{"location":"reference/boards/genuino_zero/docs/#flash-layout","text":"The internal flash of the Arduino/Genuino Zero is organized as a single bank of 256k. Zerynth VM overwrites SAM-BA Bootloader located at Flash start, SAM-BA bootloader can be restored using Arduino IDE.","title":"Flash Layout"},{"location":"reference/boards/genuino_zero/docs/#device-summary","text":"Microcontroller: ATSAMD21G18 Operating Voltage: 3.3V Digital I/O Pins (DIO): 20 Analog Input Pins (ADC): 6 Analog Outputs Pins (DAC): 1 UARTs: 2 SPIs: 1 I2Cs: 1 Flash Memory: 256 KB SRAM: 32 KB Clock Speed: 48 MHz Size (LxW mm): 68.0 x 30.0","title":"Device Summary"},{"location":"reference/boards/genuino_zero/docs/#power","text":"The Arduino/Genuino Zero can be powered via the USB connector or with an external power supply. The power source is selected automatically. External (non-USB) power can come either from an AC-to-DC adapter (such as a wall-wart) or battery, and can be connected using a 2.1mm center-positive plug connected to the device\u2019s power jack, or directly to the GND and VIN pin headers of the POWER connector. The device can operate on an external supply of 6 to 20 volts. If supplied with less than 7V, however, the 5V pin may supply less than five volts and the device may be unstable. If more than 12V are used, the voltage regulator may overheat and damage the device. The recommended range is 7 to 12 volts.","title":"Power"},{"location":"reference/boards/genuino_zero/docs/#connect-register-virtualize-and-program","text":"The Arduino/Genuino Zero Programming port is connected to EDBG, which provides a virtual COM port to software on a connected computer. To recognize the device, Windows machines requires drivers that can be downloaded from the Arduino/Genuino Zero guide , while OSX and Linux machines will recognize the device as a COM port automatically. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. If the device is still not recognized or not working, the following udev rules may need to be added: #Genuino Zero Device SUBSYSTEMS == \"usb\" , ATTRS { idVendor } == \"03eb\" , ATTRS { idProduct } == \"2157\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE } = \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor } == \"03eb\" , ATTRS { idProduct } == \"2157\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE } = \"1\" EDBG is also connected to the SAMD21 hardware UART. Serial on pins RX0 and TX0 provides Serial-to-USB communication for programming the device through Atmel EDBG. Once connected on a USB port, if drivers have been correctly installed, the Arduino/Genuino Zero device is recognized by Zerynth Studio. The next steps are: Select the Arduino/Genuino Zero on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the Arduino/Genuino Zero is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/genuino_zero/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Arduino/Genuino Zero device is available for bytecode only. Flash Layout is shown in table below: Start address Size Content 0x00002000 88Kb VM Slot 0x00018000 80Kb Bytecode Slot 0 0x0002C000 80Kb Bytecode Slot 1","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/genuino_zero/docs/#power-management-and-secure-firmware","text":"Power Management feature allows to optimize power consumption by putting the device in low consumption state. Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). Both these features are strongly platform dependent; more information at Power Management - Microchip SAMD21 section and Secure Firmware - Microchip SAMD21 section .","title":"Power Management and Secure Firmware"},{"location":"reference/boards/heltec_wifikit32/docs/","text":"Heltec Wi-Fi Kit 32 \u00b6 Wi-Fi Kit 32 is a classic IoT dev-board designed and produced by Heltec Automation (TM). It is based on the ESP32 microcontroller that boasts Wi-Fi, Bluetooth, Ethernet and Low Power support all in a single chip; Li-Po battery management system, 0.96\u2033 OLED are also included. It is one of the best choice for smart solutions, smart farms, smart home, and IoT makers. Pin Mapping \u00b6 Official reference for Heltec Wi-Fi Kit 32 can be found here . Flash Layout \u00b6 The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved 0x00392000 4Mb Free for user storage For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved 0x00392000 4Mb Free for user storage Device Summary \u00b6 Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 28 Analog Input Pins (ADC): 8 Analog Outputs Pins (DAC): 2 UARTs: 3 SPIs: 2 I2Cs: 3 OLED: 0.96\u201d Display driven by Solomon SSD1306 (I2C) Flash Memory: 8 MB SRAM: 520 KB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks Power \u00b6 Power to the Wi-Fi Kit 32 is supplied via the on-board USB Micro B connector or directly throught the connector for a 3.7/4.2 V battery. The power source is selected automatically. The device can operate on an external supply of 2.5 to 6 volts. If using more than 6V, the voltage regulator may overheat and damage the device. Connect, Register, Virtualize and Program \u00b6 The Wi-Fi Kit 32 comes with a serial-to-usb chip on board that allows programming and opening the UART of the ESP32 module. Drivers may be needed depending on your system (Mac or Windows) and can be download from the official Espressif documentation page. In Linux systems, the Wi-Fi Kit 32 should work out of the box. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the Wi-Fi Kit 32 device is recognized by Zerynth Studio. The next steps are: Select the Heltec Wi-Fi Kit 32 on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the Wi-Fi Kit 32 is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the sdevice is required for the uplink process. Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Wi-Fi Kit 32 device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs. Secure Firmware \u00b6 Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section . Zerynth Secure Socket \u00b6 To be able to use Zerynth Secure Socket on esp32 boards NATIVE_MBEDTLS: true must be used instead of ZERYNTH_SSL: true in the project.yml file. Missing features \u00b6 Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"Heltec Wi-Fi Kit 32"},{"location":"reference/boards/heltec_wifikit32/docs/#heltec-wi-fi-kit-32","text":"Wi-Fi Kit 32 is a classic IoT dev-board designed and produced by Heltec Automation (TM). It is based on the ESP32 microcontroller that boasts Wi-Fi, Bluetooth, Ethernet and Low Power support all in a single chip; Li-Po battery management system, 0.96\u2033 OLED are also included. It is one of the best choice for smart solutions, smart farms, smart home, and IoT makers.","title":"Heltec Wi-Fi Kit 32"},{"location":"reference/boards/heltec_wifikit32/docs/#pin-mapping","text":"Official reference for Heltec Wi-Fi Kit 32 can be found here .","title":"Pin Mapping"},{"location":"reference/boards/heltec_wifikit32/docs/#flash-layout","text":"The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved 0x00392000 4Mb Free for user storage For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved 0x00392000 4Mb Free for user storage","title":"Flash Layout"},{"location":"reference/boards/heltec_wifikit32/docs/#device-summary","text":"Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 28 Analog Input Pins (ADC): 8 Analog Outputs Pins (DAC): 2 UARTs: 3 SPIs: 2 I2Cs: 3 OLED: 0.96\u201d Display driven by Solomon SSD1306 (I2C) Flash Memory: 8 MB SRAM: 520 KB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks","title":"Device Summary"},{"location":"reference/boards/heltec_wifikit32/docs/#power","text":"Power to the Wi-Fi Kit 32 is supplied via the on-board USB Micro B connector or directly throught the connector for a 3.7/4.2 V battery. The power source is selected automatically. The device can operate on an external supply of 2.5 to 6 volts. If using more than 6V, the voltage regulator may overheat and damage the device.","title":"Power"},{"location":"reference/boards/heltec_wifikit32/docs/#connect-register-virtualize-and-program","text":"The Wi-Fi Kit 32 comes with a serial-to-usb chip on board that allows programming and opening the UART of the ESP32 module. Drivers may be needed depending on your system (Mac or Windows) and can be download from the official Espressif documentation page. In Linux systems, the Wi-Fi Kit 32 should work out of the box. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the Wi-Fi Kit 32 device is recognized by Zerynth Studio. The next steps are: Select the Heltec Wi-Fi Kit 32 on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the Wi-Fi Kit 32 is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the sdevice is required for the uplink process.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/heltec_wifikit32/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Wi-Fi Kit 32 device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs.","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/heltec_wifikit32/docs/#secure-firmware","text":"Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section .","title":"Secure Firmware"},{"location":"reference/boards/heltec_wifikit32/docs/#zerynth-secure-socket","text":"To be able to use Zerynth Secure Socket on esp32 boards NATIVE_MBEDTLS: true must be used instead of ZERYNTH_SSL: true in the project.yml file.","title":"Zerynth Secure Socket"},{"location":"reference/boards/heltec_wifikit32/docs/#missing-features","text":"Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"Missing features"},{"location":"reference/boards/hexagon_v1/docs/","text":"AWS Hexagon v1 \u00b6 The AWS Hexagon v1 is one of the development board created by Tekt Industries that mounts on-board the official WROOM32 module. The Hexagon device features built-in USB-to-Serial converter, automatic bootloader reset, Lithium Ion/Polymer charger, 2 Groove connectors, 2 user buttons, 6 APA102-2020 Super LED, and all the GPIO brought. AWS Hexagon v1 contains a dual-core ESP32 chip, 4 MB of SPI Flash, tuned antenna, and The ESP32 microcontroller has both WiFi and Bluetooth Classic/LE support. Pin Mapping \u00b6 Flash Layout \u00b6 The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved Device Summary \u00b6 Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 28 Analog Input Pins (ADC): 8 Analog Outputs Pins (DAC): 2 UARTs: 3 SPIs: 2 I2Cs: 3 Flash Memory: 4 MB SRAM: 520 KB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks Power \u00b6 Power to the AWS Hexagon v1 is supplied via the on-board USB Micro B connector or directly throught the connector for a 3.7/4.2 V battery. The power source is selected automatically. The device can operate on an external supply of 2.5 to 6 volts. If using more than 6V, the voltage regulator may overheat and damage the device. Connect, Register, Virtualize and Program \u00b6 The AWS Hexagon v1 exposes the serial port of the ESP32 module via a CP2104 usb bridge which is also connected to the boot pins of the module, allowing for a seamless virtualization of the device. Note Drivers for the bridge can be downloaded here and are needed for Windows and Mac platforms . Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the Hexagon device is recognized by Zerynth Studio. The next steps are: Select the Hexagon on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process After virtualization, the Hexagon is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process. Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Hexagon device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs. Secure Firmware \u00b6 Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section . Zerynth Secure Socket \u00b6 To be able to use Zerynth Secure Socket on esp32 boards NATIVE_MBEDTLS: true must be used instead of ZERYNTH_SSL: true in the project.yml file. Missing features \u00b6 Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"AWS Hexagon v1"},{"location":"reference/boards/hexagon_v1/docs/#aws-hexagon-v1","text":"The AWS Hexagon v1 is one of the development board created by Tekt Industries that mounts on-board the official WROOM32 module. The Hexagon device features built-in USB-to-Serial converter, automatic bootloader reset, Lithium Ion/Polymer charger, 2 Groove connectors, 2 user buttons, 6 APA102-2020 Super LED, and all the GPIO brought. AWS Hexagon v1 contains a dual-core ESP32 chip, 4 MB of SPI Flash, tuned antenna, and The ESP32 microcontroller has both WiFi and Bluetooth Classic/LE support.","title":"AWS Hexagon v1"},{"location":"reference/boards/hexagon_v1/docs/#pin-mapping","text":"","title":"Pin Mapping"},{"location":"reference/boards/hexagon_v1/docs/#flash-layout","text":"The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved","title":"Flash Layout"},{"location":"reference/boards/hexagon_v1/docs/#device-summary","text":"Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 28 Analog Input Pins (ADC): 8 Analog Outputs Pins (DAC): 2 UARTs: 3 SPIs: 2 I2Cs: 3 Flash Memory: 4 MB SRAM: 520 KB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks","title":"Device Summary"},{"location":"reference/boards/hexagon_v1/docs/#power","text":"Power to the AWS Hexagon v1 is supplied via the on-board USB Micro B connector or directly throught the connector for a 3.7/4.2 V battery. The power source is selected automatically. The device can operate on an external supply of 2.5 to 6 volts. If using more than 6V, the voltage regulator may overheat and damage the device.","title":"Power"},{"location":"reference/boards/hexagon_v1/docs/#connect-register-virtualize-and-program","text":"The AWS Hexagon v1 exposes the serial port of the ESP32 module via a CP2104 usb bridge which is also connected to the boot pins of the module, allowing for a seamless virtualization of the device. Note Drivers for the bridge can be downloaded here and are needed for Windows and Mac platforms . Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the Hexagon device is recognized by Zerynth Studio. The next steps are: Select the Hexagon on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process After virtualization, the Hexagon is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/hexagon_v1/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Hexagon device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs.","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/hexagon_v1/docs/#secure-firmware","text":"Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section .","title":"Secure Firmware"},{"location":"reference/boards/hexagon_v1/docs/#zerynth-secure-socket","text":"To be able to use Zerynth Secure Socket on esp32 boards NATIVE_MBEDTLS: true must be used instead of ZERYNTH_SSL: true in the project.yml file.","title":"Zerynth Secure Socket"},{"location":"reference/boards/hexagon_v1/docs/#missing-features","text":"Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"Missing features"},{"location":"reference/boards/hexiwear/docs/","text":"Hexiwear \u00b6 Hexiwear platform combines the style and usability found in high-end consumer devices, with the functionality and expandability of sophisticated engineering development platforms, making Hexiwear the ideal form factor for the IoT edge node and wearable markets. Completely open-source and developed by MikroElektronika in partnership with NXP; the Hexiwear hardware includes the low power, high performance Kinetis K6x Microcontroller based on ARM Cortex-M4 core, the Kinetis KW40Z multimode radio SoC, supporting BLE in Hexiwear. The Hardware features included 6 on-board sensors such as Optical Heart Rate Monitor, Accelerometer and Magnetometer, Gyroscope, Temperature, Humidity, light and Pressure sensors. Hexiwear also includes Color OLED Display, Rechargeable battery and External flash memory. For this device, a docking station is also available; The Hexiwear Docking Station is an expansion board for Hexiwear that provides an interface for programming, debugging, and enhancing Hexiwear with additional functionalities by adding click boards. Note All the reported information are extracted from the official Hexiwear page , visit this page for more details and updates. Pin Mapping \u00b6 Flash Layout \u00b6 The Hexiwear device features a 1 MB flash memory organized in 2 blocks (512 KB each) consisting of 4 KB sectors. The flash memory address starts at 0x00000000 and can be read and written from a Zerynth program using the internal flash module. Warning If flash memory must be used in a Zerynth program, it is recommended to begin using it from secure addresses towards the end the bytecode (start address of the bytecode can be found in the log console of Zerynth Studio during the uplink operation), leaving a minimum safe place to minimize the chance of clashes. Device Summary \u00b6 Microcontroller: NXP Kinetis K64F MCU Operating Voltage: 3.3V Digital I/O Pins (DIO): 76 Analog Input Pins (ADC): 8 UARTs: 6 SPIs: 3 I2Cs: 3 Flash Memory: 1 MB SRAM: 256 KB Clock Speed: 120 MHz Power \u00b6 The Hexiwear provides an on-board 5 to 3.3 V regulator and can be powered in three different ways: Throught an Embedded 19 mAh 2C Li-Po battery; Throught the USB Micro B connector on Hexiwear Docking Station (charging on-board battery features enabled); Throught the USB Micro B connector on Hexiwear (charging on-board battery features enabled); Connect, Virtualize and Program \u00b6 The Hexiwear Docking Station has an on-board DAP Link circuitry that exposes three USB interfaces: A serial port over USB A mass storage device for drag-n-drop programming flash memory A DAP compliant debug channel DAP Link should be supported natively by all platforms. Once connected to a USB port, the Hexiwear Device is recognized by Zerynth Studio. The device can be virtualized by clicking the related Studio button without requiring any other user intervention. Note Register, Virtualize and Program operations for Hexiwear are available only connecting the device on its Docking Station. Once connected to a USB port the Hexiwear device can be seen as a Virtual Serial port and it is automatically recognized by Zerynth Studio. The next steps are: Select the Hexiwear on the Device Management Toolbar (Disambiguate operation may be required); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d, click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset button on Hexiwear Docking Station when asked. Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Hexiwear device is available for bytecode only. Flash Layout is shown in table below: Start address Size Content 0x00000000 96Kb VM Slot 0x00018000 452Kb Bytecode Slot 0 0x00089000 472Kb Bytecode Slot 1 0x000FF000 4Kb FOTA Record Power Management and Secure Firmware \u00b6 Power Management feature allows to optimize power consumption by putting the device in low consumption state. Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). Both these features are strongly platform dependent; more information at Power Management - NXP K64 section and Secure Firmware - NXP K64 section .","title":"Hexiwear"},{"location":"reference/boards/hexiwear/docs/#hexiwear","text":"Hexiwear platform combines the style and usability found in high-end consumer devices, with the functionality and expandability of sophisticated engineering development platforms, making Hexiwear the ideal form factor for the IoT edge node and wearable markets. Completely open-source and developed by MikroElektronika in partnership with NXP; the Hexiwear hardware includes the low power, high performance Kinetis K6x Microcontroller based on ARM Cortex-M4 core, the Kinetis KW40Z multimode radio SoC, supporting BLE in Hexiwear. The Hardware features included 6 on-board sensors such as Optical Heart Rate Monitor, Accelerometer and Magnetometer, Gyroscope, Temperature, Humidity, light and Pressure sensors. Hexiwear also includes Color OLED Display, Rechargeable battery and External flash memory. For this device, a docking station is also available; The Hexiwear Docking Station is an expansion board for Hexiwear that provides an interface for programming, debugging, and enhancing Hexiwear with additional functionalities by adding click boards. Note All the reported information are extracted from the official Hexiwear page , visit this page for more details and updates.","title":"Hexiwear"},{"location":"reference/boards/hexiwear/docs/#pin-mapping","text":"","title":"Pin Mapping"},{"location":"reference/boards/hexiwear/docs/#flash-layout","text":"The Hexiwear device features a 1 MB flash memory organized in 2 blocks (512 KB each) consisting of 4 KB sectors. The flash memory address starts at 0x00000000 and can be read and written from a Zerynth program using the internal flash module. Warning If flash memory must be used in a Zerynth program, it is recommended to begin using it from secure addresses towards the end the bytecode (start address of the bytecode can be found in the log console of Zerynth Studio during the uplink operation), leaving a minimum safe place to minimize the chance of clashes.","title":"Flash Layout"},{"location":"reference/boards/hexiwear/docs/#device-summary","text":"Microcontroller: NXP Kinetis K64F MCU Operating Voltage: 3.3V Digital I/O Pins (DIO): 76 Analog Input Pins (ADC): 8 UARTs: 6 SPIs: 3 I2Cs: 3 Flash Memory: 1 MB SRAM: 256 KB Clock Speed: 120 MHz","title":"Device Summary"},{"location":"reference/boards/hexiwear/docs/#power","text":"The Hexiwear provides an on-board 5 to 3.3 V regulator and can be powered in three different ways: Throught an Embedded 19 mAh 2C Li-Po battery; Throught the USB Micro B connector on Hexiwear Docking Station (charging on-board battery features enabled); Throught the USB Micro B connector on Hexiwear (charging on-board battery features enabled);","title":"Power"},{"location":"reference/boards/hexiwear/docs/#connect-virtualize-and-program","text":"The Hexiwear Docking Station has an on-board DAP Link circuitry that exposes three USB interfaces: A serial port over USB A mass storage device for drag-n-drop programming flash memory A DAP compliant debug channel DAP Link should be supported natively by all platforms. Once connected to a USB port, the Hexiwear Device is recognized by Zerynth Studio. The device can be virtualized by clicking the related Studio button without requiring any other user intervention. Note Register, Virtualize and Program operations for Hexiwear are available only connecting the device on its Docking Station. Once connected to a USB port the Hexiwear device can be seen as a Virtual Serial port and it is automatically recognized by Zerynth Studio. The next steps are: Select the Hexiwear on the Device Management Toolbar (Disambiguate operation may be required); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d, click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset button on Hexiwear Docking Station when asked.","title":"Connect, Virtualize and Program"},{"location":"reference/boards/hexiwear/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Hexiwear device is available for bytecode only. Flash Layout is shown in table below: Start address Size Content 0x00000000 96Kb VM Slot 0x00018000 452Kb Bytecode Slot 0 0x00089000 472Kb Bytecode Slot 1 0x000FF000 4Kb FOTA Record","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/hexiwear/docs/#power-management-and-secure-firmware","text":"Power Management feature allows to optimize power consumption by putting the device in low consumption state. Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). Both these features are strongly platform dependent; more information at Power Management - NXP K64 section and Secure Firmware - NXP K64 section .","title":"Power Management and Secure Firmware"},{"location":"reference/boards/mikroe_quail/docs/","text":"MikroElektronika Quail \u00b6 The Quail device is an STM32-powered development solution for building hardware prototypes with MikroElektronika Click Boards . Hardware-wise, Quail has 4 mikroBUS sockets for click board connectivity, along with 24 screw terminals for connecting additional electronics and two USB ports (one for programming, the other for external mass storage). The device needs a 5V power supply and features a STM32F427 MCU running at 168MHz with 192Kb of RAM, 2Mb of flash and additional 8Mb of spi flash. Note Quail is produced by MikroElektronika , but the idea and design of the device was done by MikroBUS.NET , a team of software and hardware professionals from France Pin Mapping \u00b6 MikroElektronika Quail official manual is available here Flash Layout \u00b6 The internal flash of the MikroElektronika Quail is organized into two banks of 1Mb each. Each bank has sectors of different size according to the following table: .tg {border-collapse:collapse;border-spacing:0;} .tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px; overflow:hidden;padding:10px 5px;word-break:normal;} .tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px; font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;} .tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top} Bank 1 Bank 2 Start address Size Content Start address Size Content 0x8000000 16Kb Virtual Machine 0x8100000 16Kb Bytecode Bank 7 0x8004000 16Kb Virtual Machine 0x8104000 16Kb Bytecode Bank 8 0x8008000 16Kb Virtual Machine 0x8108000 16Kb Bytecode Bank 9 0x800C000 16Kb Virtual Machine 0x810C000 16Kb Bytecode Bank 10 0x8010000 64Kb Virtual Machine 0x8110000 64Kb Bytecode Bank 11 0x8020000 128kb Bytecode Bank 0 0x8120000 128kb Bytecode Bank 12 0x8040000 128kb Bytecode Bank 1 0x8140000 128kb Bytecode Bank 13 0x8060000 128kb Bytecode Bank 2 0x8160000 128kb Bytecode Bank 14 0x8080000 128kb Bytecode Bank 3 0x8180000 128kb Bytecode Bank 15 0x80A0000 128kb Bytecode Bank 4 0x81A0000 128kb Bytecode Bank 16 0x80C0000 128kb Bytecode Bank 5 0x81C0000 128kb Bytecode Bank 17 0x80E0000 128kb Bytecode Bank 6 0x81E0000 128kb Bytecode Bank 18 Device Summary \u00b6 Microcontroller: ARM 32-bit Cortex\u2122-M4 CPU Core Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 66 Analog Input Pins (ADC): 10 UARTs: 5 SPIs: 2 I2Cs: 2 Flash Memory: 2Mb SRAM: 192 KB + 64Kb CCM Clock Speed: 168Mhz Size (LxW mm): 97 x 72 Power \u00b6 The MikroElektronika Quail can be powered via the on-board USB Mini-B connector or with an external power supply. The power source is selected automatically. External (non-USB) power can be inserted in the \u201cGnd\u201d and \u201c+20v\u201d pin terminals of the device. The device can operate on an external supply of 6 to 20 volts. If supplied with less than 7V, however, the 5V pin may supply less than five volts and the device may be unstable. If more than 12V are used, the voltage regulator may overheat and damage the device. The recommended range is 7 to 12 volts. Connect, Register, Virtualize and Program \u00b6 On Windows machines two set of drivers must be installed: the DFU drivers and the USB serial drivers. This can be done by using the Zadig utility version 2.2 or greater. Use the Zadig utility once with the Quail in DFU mode (see below) and once after the device has been virtualized. Note Remember to select \u201cOptions > List all devices\u201d to search for the Quail device. * In DFU mode, the VID:PID you should see is 0483:DF11 and the Quail si recognized as \u201cSTM32 BOOTLOADER\u201d. * For the virtualized Quail the VID:PID is 0483:DF12. Warning In DFU mode any driver is ok, except Usb CDC; for the virtualized Quail the only valid driver is Usb CDC. Note It could be necessary to temporarily disable the digitally signed driver enforcement policy of Windows to allow the driver installation. There are good instructions on how to do that in this guide . On MAC OSX and Linux USB drivers are not required. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group If the device is still not recognized or not working, the following udev rules may need to be added: #MikroElektronica Quail Device SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"0483\" , ATTRS { idProduct }== \"df11\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"0483\" , ATTRS { idProduct }== \"df12\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" Once connected to a USB port the Quail device can be seen as a Virtual Serial port or as a DFU device depending on its virtualized/virtualizable status and it is automatically recognized by Zerynth Studio. The next steps are: Put the Quail in DFU Mode (Device Firmware Upgrade): Hold down BOTH on-board buttons (reset and boot); Release only the reset button, while holding down the boot button; After a second, release the boot button; the Quail is now in DFU mode; Select the Quail on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Creaet a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note During these operations the Quail device must be in DFU mode. if the device returns in standard mode, it is necessary to put it in DFU Mode again. After virtualization, the MikroElektronika Quail is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked. Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the MikroElektronika Quail device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x08000000 128Kb VM Slot 0 0x08020000 384kb Bytecode Slot 0 0x08080000 128kb VM Slot 1 0x080A0000 384kb Bytecode Slot 1 Important FOTA Record (small segment of memory where the current and desired state of the firmware is store) for the MikroElektronika Quail device is allocated in 16kb sector inside the VM Slot 0 at 0x08004000 address. Power Management and Secure Firmware \u00b6 Power Management feature allows to optimize power consumption by putting the device in low consumption state. Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). Both these features are strongly platform dependent; more information at Power Management - STM32F section and Secure Firmware - STM32F section .","title":"MikroElektronika Quail"},{"location":"reference/boards/mikroe_quail/docs/#mikroelektronika-quail","text":"The Quail device is an STM32-powered development solution for building hardware prototypes with MikroElektronika Click Boards . Hardware-wise, Quail has 4 mikroBUS sockets for click board connectivity, along with 24 screw terminals for connecting additional electronics and two USB ports (one for programming, the other for external mass storage). The device needs a 5V power supply and features a STM32F427 MCU running at 168MHz with 192Kb of RAM, 2Mb of flash and additional 8Mb of spi flash. Note Quail is produced by MikroElektronika , but the idea and design of the device was done by MikroBUS.NET , a team of software and hardware professionals from France","title":"MikroElektronika Quail"},{"location":"reference/boards/mikroe_quail/docs/#pin-mapping","text":"MikroElektronika Quail official manual is available here","title":"Pin Mapping"},{"location":"reference/boards/mikroe_quail/docs/#flash-layout","text":"The internal flash of the MikroElektronika Quail is organized into two banks of 1Mb each. Each bank has sectors of different size according to the following table: .tg {border-collapse:collapse;border-spacing:0;} .tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px; overflow:hidden;padding:10px 5px;word-break:normal;} .tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px; font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;} .tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top} Bank 1 Bank 2 Start address Size Content Start address Size Content 0x8000000 16Kb Virtual Machine 0x8100000 16Kb Bytecode Bank 7 0x8004000 16Kb Virtual Machine 0x8104000 16Kb Bytecode Bank 8 0x8008000 16Kb Virtual Machine 0x8108000 16Kb Bytecode Bank 9 0x800C000 16Kb Virtual Machine 0x810C000 16Kb Bytecode Bank 10 0x8010000 64Kb Virtual Machine 0x8110000 64Kb Bytecode Bank 11 0x8020000 128kb Bytecode Bank 0 0x8120000 128kb Bytecode Bank 12 0x8040000 128kb Bytecode Bank 1 0x8140000 128kb Bytecode Bank 13 0x8060000 128kb Bytecode Bank 2 0x8160000 128kb Bytecode Bank 14 0x8080000 128kb Bytecode Bank 3 0x8180000 128kb Bytecode Bank 15 0x80A0000 128kb Bytecode Bank 4 0x81A0000 128kb Bytecode Bank 16 0x80C0000 128kb Bytecode Bank 5 0x81C0000 128kb Bytecode Bank 17 0x80E0000 128kb Bytecode Bank 6 0x81E0000 128kb Bytecode Bank 18","title":"Flash Layout"},{"location":"reference/boards/mikroe_quail/docs/#device-summary","text":"Microcontroller: ARM 32-bit Cortex\u2122-M4 CPU Core Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 66 Analog Input Pins (ADC): 10 UARTs: 5 SPIs: 2 I2Cs: 2 Flash Memory: 2Mb SRAM: 192 KB + 64Kb CCM Clock Speed: 168Mhz Size (LxW mm): 97 x 72","title":"Device Summary"},{"location":"reference/boards/mikroe_quail/docs/#power","text":"The MikroElektronika Quail can be powered via the on-board USB Mini-B connector or with an external power supply. The power source is selected automatically. External (non-USB) power can be inserted in the \u201cGnd\u201d and \u201c+20v\u201d pin terminals of the device. The device can operate on an external supply of 6 to 20 volts. If supplied with less than 7V, however, the 5V pin may supply less than five volts and the device may be unstable. If more than 12V are used, the voltage regulator may overheat and damage the device. The recommended range is 7 to 12 volts.","title":"Power"},{"location":"reference/boards/mikroe_quail/docs/#connect-register-virtualize-and-program","text":"On Windows machines two set of drivers must be installed: the DFU drivers and the USB serial drivers. This can be done by using the Zadig utility version 2.2 or greater. Use the Zadig utility once with the Quail in DFU mode (see below) and once after the device has been virtualized. Note Remember to select \u201cOptions > List all devices\u201d to search for the Quail device. * In DFU mode, the VID:PID you should see is 0483:DF11 and the Quail si recognized as \u201cSTM32 BOOTLOADER\u201d. * For the virtualized Quail the VID:PID is 0483:DF12. Warning In DFU mode any driver is ok, except Usb CDC; for the virtualized Quail the only valid driver is Usb CDC. Note It could be necessary to temporarily disable the digitally signed driver enforcement policy of Windows to allow the driver installation. There are good instructions on how to do that in this guide . On MAC OSX and Linux USB drivers are not required. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group If the device is still not recognized or not working, the following udev rules may need to be added: #MikroElektronica Quail Device SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"0483\" , ATTRS { idProduct }== \"df11\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"0483\" , ATTRS { idProduct }== \"df12\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" Once connected to a USB port the Quail device can be seen as a Virtual Serial port or as a DFU device depending on its virtualized/virtualizable status and it is automatically recognized by Zerynth Studio. The next steps are: Put the Quail in DFU Mode (Device Firmware Upgrade): Hold down BOTH on-board buttons (reset and boot); Release only the reset button, while holding down the boot button; After a second, release the boot button; the Quail is now in DFU mode; Select the Quail on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Creaet a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note During these operations the Quail device must be in DFU mode. if the device returns in standard mode, it is necessary to put it in DFU Mode again. After virtualization, the MikroElektronika Quail is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/mikroe_quail/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the MikroElektronika Quail device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x08000000 128Kb VM Slot 0 0x08020000 384kb Bytecode Slot 0 0x08080000 128kb VM Slot 1 0x080A0000 384kb Bytecode Slot 1 Important FOTA Record (small segment of memory where the current and desired state of the firmware is store) for the MikroElektronika Quail device is allocated in 16kb sector inside the VM Slot 0 at 0x08004000 address.","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/mikroe_quail/docs/#power-management-and-secure-firmware","text":"Power Management feature allows to optimize power consumption by putting the device in low consumption state. Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). Both these features are strongly platform dependent; more information at Power Management - STM32F section and Secure Firmware - STM32F section .","title":"Power Management and Secure Firmware"},{"location":"reference/boards/nodemcu2/docs/","text":"NodeMCU v2 \u00b6 NodeMCU is an open source IoT platform including a firmware which runs on the ESP8266 with the Espressif Non-OS SDK, and hardware based on the ESP-12 module. The device features 4MB of flash memory, 80MHz of system clock, around 50k of usable RAM and an on chip Wifi Transceiver. Pin Mapping \u00b6 Official reference for NodeMCU can be found here . Flash Layout \u00b6 The NodeMCU v2 device features a 4 MB (32 Mb) flash memory organized in sectors of 4k each. The flash memory address starts at 0x40200000 and can be read and written from a Zerynth program using the internal flash module. Warning If flash memory must be used in a Zerynth program, it is recommended to begin using it from secure addresses towards the end the bytecode (start address of the bytecode can be found in the log console of Zerynth Studio during the uplink operation), leaving a minimum safe place to minimize the chance of clashes. Note The internal flash of NodeMCU can be organized in different ways. The standard VM is a non-FOTA VM with the VM code beginning at 0x0000, followed by the esp8266 ir0m image at 0x20000 and the esp_init_data at 0x3fc000. The VM is based on the Espressif RTOS SDK 1.4.1. Device Summary \u00b6 Microcontroller: Tensilica 32-bit RISC CPU Xtensa LX106 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 16 Analog Input Pins (ADC): 1 UARTs: 1 SPIs: 1 I2Cs: 1 Flash Memory: 4 MB SRAM: 64 KB Clock Speed: 80 Mhz Wi-Fi: IEEE 802.11 b/g/n: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks Power \u00b6 Power to the NodeMCU v2 is supplied via the on-board USB Micro B connector or directly via the \u201cVIN\u201d pin. The power source is selected automatically. The device can operate on an external supply of 6 to 20 volts. If using more than 12V, the voltage regulator may overheat and damage the device. The recommended range is 7 to 12 volts. Connect, Register, Virtualize and Program \u00b6 The NodeMCU v2 exposes the serial port of the ESP8266 module via a CP2102 usb bridge which is also connected to the boot pins of the module, allowing for a seamless virtualization of the device. Note Drivers for the bridge can be downloaded here and are needed for Windows and Mac platforms . Bote For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected to a USB port the NodeMCU v2 device can be seen as a Virtual Serial port and it is automatically recognized by Zerynth Studio. The next steps are: Select the NodeMCU on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process After virtualization, the NodeMCU v2 device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the upload process. Important To exploit the Wi-Fi chip functionalities of the NodeMCU, the lib.espressif.esp8266wifi library must be installed (some example code is provided). Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the NodeMCU v2 device is available for bytecode only. Flash Layout is shown in table below: Start address Size Content 0x40200000 448Kb VM Slot 0x40270000 256Kb Bytecode Slot 0 0x402B0000 320Kb Bytecode Slot 1 Important FOTA Record (small segment of memory where the current and desired state of the firmware is store) for the NodeMCU v2 device is allocated in the RTC memory. Power Management \u00b6 Power Management feature allows to optimize power consumption by putting the device in low consumption state. More information in Power Management - ESP8266 section .","title":"NodeMCU v2"},{"location":"reference/boards/nodemcu2/docs/#nodemcu-v2","text":"NodeMCU is an open source IoT platform including a firmware which runs on the ESP8266 with the Espressif Non-OS SDK, and hardware based on the ESP-12 module. The device features 4MB of flash memory, 80MHz of system clock, around 50k of usable RAM and an on chip Wifi Transceiver.","title":"NodeMCU v2"},{"location":"reference/boards/nodemcu2/docs/#pin-mapping","text":"Official reference for NodeMCU can be found here .","title":"Pin Mapping"},{"location":"reference/boards/nodemcu2/docs/#flash-layout","text":"The NodeMCU v2 device features a 4 MB (32 Mb) flash memory organized in sectors of 4k each. The flash memory address starts at 0x40200000 and can be read and written from a Zerynth program using the internal flash module. Warning If flash memory must be used in a Zerynth program, it is recommended to begin using it from secure addresses towards the end the bytecode (start address of the bytecode can be found in the log console of Zerynth Studio during the uplink operation), leaving a minimum safe place to minimize the chance of clashes. Note The internal flash of NodeMCU can be organized in different ways. The standard VM is a non-FOTA VM with the VM code beginning at 0x0000, followed by the esp8266 ir0m image at 0x20000 and the esp_init_data at 0x3fc000. The VM is based on the Espressif RTOS SDK 1.4.1.","title":"Flash Layout"},{"location":"reference/boards/nodemcu2/docs/#device-summary","text":"Microcontroller: Tensilica 32-bit RISC CPU Xtensa LX106 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 16 Analog Input Pins (ADC): 1 UARTs: 1 SPIs: 1 I2Cs: 1 Flash Memory: 4 MB SRAM: 64 KB Clock Speed: 80 Mhz Wi-Fi: IEEE 802.11 b/g/n: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks","title":"Device Summary"},{"location":"reference/boards/nodemcu2/docs/#power","text":"Power to the NodeMCU v2 is supplied via the on-board USB Micro B connector or directly via the \u201cVIN\u201d pin. The power source is selected automatically. The device can operate on an external supply of 6 to 20 volts. If using more than 12V, the voltage regulator may overheat and damage the device. The recommended range is 7 to 12 volts.","title":"Power"},{"location":"reference/boards/nodemcu2/docs/#connect-register-virtualize-and-program","text":"The NodeMCU v2 exposes the serial port of the ESP8266 module via a CP2102 usb bridge which is also connected to the boot pins of the module, allowing for a seamless virtualization of the device. Note Drivers for the bridge can be downloaded here and are needed for Windows and Mac platforms . Bote For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected to a USB port the NodeMCU v2 device can be seen as a Virtual Serial port and it is automatically recognized by Zerynth Studio. The next steps are: Select the NodeMCU on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process After virtualization, the NodeMCU v2 device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the upload process. Important To exploit the Wi-Fi chip functionalities of the NodeMCU, the lib.espressif.esp8266wifi library must be installed (some example code is provided).","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/nodemcu2/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the NodeMCU v2 device is available for bytecode only. Flash Layout is shown in table below: Start address Size Content 0x40200000 448Kb VM Slot 0x40270000 256Kb Bytecode Slot 0 0x402B0000 320Kb Bytecode Slot 1 Important FOTA Record (small segment of memory where the current and desired state of the firmware is store) for the NodeMCU v2 device is allocated in the RTC memory.","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/nodemcu2/docs/#power-management","text":"Power Management feature allows to optimize power consumption by putting the device in low consumption state. More information in Power Management - ESP8266 section .","title":"Power Management"},{"location":"reference/boards/nodemcu3/docs/","text":"NodeMCU v3 \u00b6 NodeMCU v3 is a development board which runs on the ESP8266 with the Espressif Non-OS SDK, and hardware based on the ESP-12 module. The device features 4MB of flash memory, 80MHz of system clock, around 50k of usable RAM and an on chip Wifi Transceiver. Pin Mapping \u00b6 Flash Layout \u00b6 The NodeMCU v3 device features a 4 MB (32 Mb) flash memory organized in sectors of 4k each. The flash memory address starts at 0x40200000 and can be read and written from a Zerynth program using the internal flash module. Warning If flash memory must be used in a Zerynth program, it is recommended to begin using it from secure addresses towards the end the bytecode (start address of the bytecode can be found in the log console of Zerynth Studio during the uplink operation), leaving a minimum safe place to minimize the chance of clashes. Note The internal flash of NodeMCU v3 can be organized in different ways. The standard VM is a non-FOTA VM with the VM code beginning at 0x0000, followed by the esp8266 ir0m image at 0x20000 and the esp_init_data at 0x3fc000. The VM is based on the Espressif RTOS SDK 1.4.1. Device Summary \u00b6 Microcontroller: Tensilica 32-bit RISC CPU Xtensa LX106 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 16 Analog Input Pins (ADC): 1 UARTs: 1 SPIs: 1 I2Cs: 1 Flash Memory: 4 MB SRAM: 64 KB Clock Speed: 80 Mhz Wi-Fi: IEEE 802.11 b/g/n: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks Power \u00b6 Power to the NodeMCU v3 is supplied via the on-board USB Micro B connector or directly via the \u201cVIN\u201d pin. The power source is selected automatically. The device can operate on an external supply of 6 to 20 volts. If using more than 12V, the voltage regulator may overheat and damage the device. The recommended range is 7 to 12 volts. Connect, Register, Virtualize and Program \u00b6 The NodeMCU v3 exposes the serial port of the ESP8266 module via CH340 USB to UART chip which is also connected to the boot pins of the module, allowing for a seamless virtualization of the device. Note Drivers for the CH340 Module can be downloaded here and are needed for Windows and Mac platforms . Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected to a USB port the NodeMCU v3 device can be seen as a Virtual Serial port and it is automatically recognized by Zerynth Studio. The next steps are: Select the NodeMCU v3 on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the NodeMCU v3 device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the upload process. Important To exploit the Wi-Fi chip functionalities of the NodeMCU v3, the lib.espressif.esp8266wifi library must be installed (some example code is provided). Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the NodeMCU v3 device is available for bytecode only. Flash Layout is shown in table below: Start address Size Content 0x40200000 448Kb VM Slot 0x40270000 256Kb Bytecode Slot 0 0x402B0000 320Kb Bytecode Slot 1 Important FOTA Record (small segment of memory where the current and desired state of the firmware is store) for the NodeMCU v3 is allocated in the RTC memory. Power Management \u00b6 Power Management feature allows to optimize power consumption by putting the device in low consumption state. More information in Power Management - ESP8266 section .","title":"NodeMCU v3"},{"location":"reference/boards/nodemcu3/docs/#nodemcu-v3","text":"NodeMCU v3 is a development board which runs on the ESP8266 with the Espressif Non-OS SDK, and hardware based on the ESP-12 module. The device features 4MB of flash memory, 80MHz of system clock, around 50k of usable RAM and an on chip Wifi Transceiver.","title":"NodeMCU v3"},{"location":"reference/boards/nodemcu3/docs/#pin-mapping","text":"","title":"Pin Mapping"},{"location":"reference/boards/nodemcu3/docs/#flash-layout","text":"The NodeMCU v3 device features a 4 MB (32 Mb) flash memory organized in sectors of 4k each. The flash memory address starts at 0x40200000 and can be read and written from a Zerynth program using the internal flash module. Warning If flash memory must be used in a Zerynth program, it is recommended to begin using it from secure addresses towards the end the bytecode (start address of the bytecode can be found in the log console of Zerynth Studio during the uplink operation), leaving a minimum safe place to minimize the chance of clashes. Note The internal flash of NodeMCU v3 can be organized in different ways. The standard VM is a non-FOTA VM with the VM code beginning at 0x0000, followed by the esp8266 ir0m image at 0x20000 and the esp_init_data at 0x3fc000. The VM is based on the Espressif RTOS SDK 1.4.1.","title":"Flash Layout"},{"location":"reference/boards/nodemcu3/docs/#device-summary","text":"Microcontroller: Tensilica 32-bit RISC CPU Xtensa LX106 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 16 Analog Input Pins (ADC): 1 UARTs: 1 SPIs: 1 I2Cs: 1 Flash Memory: 4 MB SRAM: 64 KB Clock Speed: 80 Mhz Wi-Fi: IEEE 802.11 b/g/n: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks","title":"Device Summary"},{"location":"reference/boards/nodemcu3/docs/#power","text":"Power to the NodeMCU v3 is supplied via the on-board USB Micro B connector or directly via the \u201cVIN\u201d pin. The power source is selected automatically. The device can operate on an external supply of 6 to 20 volts. If using more than 12V, the voltage regulator may overheat and damage the device. The recommended range is 7 to 12 volts.","title":"Power"},{"location":"reference/boards/nodemcu3/docs/#connect-register-virtualize-and-program","text":"The NodeMCU v3 exposes the serial port of the ESP8266 module via CH340 USB to UART chip which is also connected to the boot pins of the module, allowing for a seamless virtualization of the device. Note Drivers for the CH340 Module can be downloaded here and are needed for Windows and Mac platforms . Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected to a USB port the NodeMCU v3 device can be seen as a Virtual Serial port and it is automatically recognized by Zerynth Studio. The next steps are: Select the NodeMCU v3 on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the NodeMCU v3 device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the upload process. Important To exploit the Wi-Fi chip functionalities of the NodeMCU v3, the lib.espressif.esp8266wifi library must be installed (some example code is provided).","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/nodemcu3/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the NodeMCU v3 device is available for bytecode only. Flash Layout is shown in table below: Start address Size Content 0x40200000 448Kb VM Slot 0x40270000 256Kb Bytecode Slot 0 0x402B0000 320Kb Bytecode Slot 1 Important FOTA Record (small segment of memory where the current and desired state of the firmware is store) for the NodeMCU v3 is allocated in the RTC memory.","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/nodemcu3/docs/#power-management","text":"Power Management feature allows to optimize power consumption by putting the device in low consumption state. More information in Power Management - ESP8266 section .","title":"Power Management"},{"location":"reference/boards/nodemcu_esp32/docs/","text":"NodeMCU ESP-32S \u00b6 The NodeMCU ESP-32S is one of the development board created by NodeMcu to evaluate the ESP-WROOM-32 module. It is based on the ESP32 microcontroller that boasts Wifi, Bluetooth, Ethernet and Low Power support all in a single chip. Pin Mapping \u00b6 Reference for NodeMCU ESP-32S can be found here . Flash Layout \u00b6 The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved Device Summary \u00b6 Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 28 Analog Input Pins (ADC): 8 Analog Outputs Pins (DAC): 2 UARTs: 3 SPIs: 2 I2Cs: 3 Flash Memory: 4 MB SRAM: 520 KB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks Power \u00b6 Power to the NodeMCU ESP-32S is supplied via the on-board USB Micro B connector or directly via the \u201cVIN\u201d pin. The power source is selected automatically. The device can operate on an external supply of 6 to 20 volts. If using more than 12V, the voltage regulator may overheat and damage the device. The recommended range is 7 to 12 volts. Connect, Register, Virtualize and Program \u00b6 The NodeMCU ESP-32S comes with a serial-to-usb chip on board that allows programming and opening the UART of the ESP32 module. Drivers may be needed depending on your system (Mac or Windows) and can be download from the official Espressif documentation page. In Linux systems, the NodeMCU ESP-32S should work out of the box. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the NodeMCU ESP-32S device is recognized by Zerynth Studio. The next steps are: Select the NodeMCU ESP-32S on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the NodeMCU ESP-32S is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process. Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the NodeMCU ESP-32S device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs. Secure Firmware \u00b6 Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section . Zerynth secure socket \u00b6 To be able to use zerynth secure socket on esp32 boards native_mbedtls: true must be used instead of zerynth_ssl: true in the project.yml file. Missing features \u00b6 Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"NodeMCU ESP-32S"},{"location":"reference/boards/nodemcu_esp32/docs/#nodemcu-esp-32s","text":"The NodeMCU ESP-32S is one of the development board created by NodeMcu to evaluate the ESP-WROOM-32 module. It is based on the ESP32 microcontroller that boasts Wifi, Bluetooth, Ethernet and Low Power support all in a single chip.","title":"NodeMCU ESP-32S"},{"location":"reference/boards/nodemcu_esp32/docs/#pin-mapping","text":"Reference for NodeMCU ESP-32S can be found here .","title":"Pin Mapping"},{"location":"reference/boards/nodemcu_esp32/docs/#flash-layout","text":"The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved","title":"Flash Layout"},{"location":"reference/boards/nodemcu_esp32/docs/#device-summary","text":"Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 28 Analog Input Pins (ADC): 8 Analog Outputs Pins (DAC): 2 UARTs: 3 SPIs: 2 I2Cs: 3 Flash Memory: 4 MB SRAM: 520 KB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks","title":"Device Summary"},{"location":"reference/boards/nodemcu_esp32/docs/#power","text":"Power to the NodeMCU ESP-32S is supplied via the on-board USB Micro B connector or directly via the \u201cVIN\u201d pin. The power source is selected automatically. The device can operate on an external supply of 6 to 20 volts. If using more than 12V, the voltage regulator may overheat and damage the device. The recommended range is 7 to 12 volts.","title":"Power"},{"location":"reference/boards/nodemcu_esp32/docs/#connect-register-virtualize-and-program","text":"The NodeMCU ESP-32S comes with a serial-to-usb chip on board that allows programming and opening the UART of the ESP32 module. Drivers may be needed depending on your system (Mac or Windows) and can be download from the official Espressif documentation page. In Linux systems, the NodeMCU ESP-32S should work out of the box. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the NodeMCU ESP-32S device is recognized by Zerynth Studio. The next steps are: Select the NodeMCU ESP-32S on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the NodeMCU ESP-32S is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/nodemcu_esp32/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the NodeMCU ESP-32S device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs.","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/nodemcu_esp32/docs/#secure-firmware","text":"Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section .","title":"Secure Firmware"},{"location":"reference/boards/nodemcu_esp32/docs/#zerynth-secure-socket","text":"To be able to use zerynth secure socket on esp32 boards native_mbedtls: true must be used instead of zerynth_ssl: true in the project.yml file.","title":"Zerynth secure socket"},{"location":"reference/boards/nodemcu_esp32/docs/#missing-features","text":"Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"Missing features"},{"location":"reference/boards/nordic_pca10040/docs/","text":"Nordic nRF52 DK \u00b6 The nRF52 DK is a versatile single board development kit for Bluetooth 5, NFC, ANT and 2.4 GHz proprietary applications on nRF52832 SoC. It facilitates development exploiting all features of the nRF52832 SoC. It includes an NFC antenna that quickly enables utilization of the NFC-A tag peripheral on the nRF52832. All GPIOs are available via edge connectors and headers, and 4 buttons and 4 LEDs simplifies output and input from and to the SoC. It comes with an on-board SEGGER J-Link debugger allowing programming and debugging both the on-board SoC and external SoCs through the debug out header. Pin Mapping \u00b6 Official reference for Nordic nRF52 DK can be found here . Flash Layout \u00b6 The internal flash of the NRF52832 is organized as a single bank of 512Kb, with pages of 4Kb each. The flash begins at address 0x00000 where is stored the Zerynth Virtual Machine (bytecode starts at address 0x55000). Board Summary \u00b6 Microcontroller: NRF52832 Operating Voltage: 3.3V Digital I/O Pins (DIO): 32 Analog Input Pins (ADC): 6 Analog Outputs Pins (DAC): 0 UARTs: 1 SPIs: 1 I2Cs: 1 Flash Memory: 512 Kb SRAM: 64 Kb Clock Speed: 64 MHz Size (LxW mm): 18.0 x 21.0 Power \u00b6 The Nordic nRF52 DK is equipped with on-board Li-Po button cell to power-up the device. nRF52 DK can, also, be powered via external power supply through related connector, external Li-Po battery, or via USB Micro B connector. When powered from a battery alone, the power management IC switches off the internal regulator and supplies power to the system directly from the battery. Power source (Debugger VDD, Li-Po, USB) is selected by on-board switch SW9. Connect, Register, Virtualize and Program \u00b6 The Nordic nRF52 DK can be programmed through the on-board SEGGER J-Link debugger that exposes three USB interfaces: A serial port over USB A mass storage device for drag-n-drop programming flash memory A SEGGER J-Link debug channel Drivers are needed (Linux, Mac or Windows) and can be downloaded from the official JLink software page. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, .gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group Once connected to a USB port, the Nordic nRF52 DK device is recognized by Zerynth Studio. The board can be virtualized by clicking the related Studio button without requiring any other user intervention. Follow these steps to uplink a Zerynth script on a virtualized nRF52 DK: Select nRF52 DK on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Important To exploit the BLE chip functionalities of nRF52 DK, the lib.nordic.nrf52_ble library must be installed and imported on the Zerynth script. Moreover, in the creation phase, a VM with BLE support must be selected.","title":"Nordic nRF52 DK"},{"location":"reference/boards/nordic_pca10040/docs/#nordic-nrf52-dk","text":"The nRF52 DK is a versatile single board development kit for Bluetooth 5, NFC, ANT and 2.4 GHz proprietary applications on nRF52832 SoC. It facilitates development exploiting all features of the nRF52832 SoC. It includes an NFC antenna that quickly enables utilization of the NFC-A tag peripheral on the nRF52832. All GPIOs are available via edge connectors and headers, and 4 buttons and 4 LEDs simplifies output and input from and to the SoC. It comes with an on-board SEGGER J-Link debugger allowing programming and debugging both the on-board SoC and external SoCs through the debug out header.","title":"Nordic nRF52 DK"},{"location":"reference/boards/nordic_pca10040/docs/#pin-mapping","text":"Official reference for Nordic nRF52 DK can be found here .","title":"Pin Mapping"},{"location":"reference/boards/nordic_pca10040/docs/#flash-layout","text":"The internal flash of the NRF52832 is organized as a single bank of 512Kb, with pages of 4Kb each. The flash begins at address 0x00000 where is stored the Zerynth Virtual Machine (bytecode starts at address 0x55000).","title":"Flash Layout"},{"location":"reference/boards/nordic_pca10040/docs/#board-summary","text":"Microcontroller: NRF52832 Operating Voltage: 3.3V Digital I/O Pins (DIO): 32 Analog Input Pins (ADC): 6 Analog Outputs Pins (DAC): 0 UARTs: 1 SPIs: 1 I2Cs: 1 Flash Memory: 512 Kb SRAM: 64 Kb Clock Speed: 64 MHz Size (LxW mm): 18.0 x 21.0","title":"Board Summary"},{"location":"reference/boards/nordic_pca10040/docs/#power","text":"The Nordic nRF52 DK is equipped with on-board Li-Po button cell to power-up the device. nRF52 DK can, also, be powered via external power supply through related connector, external Li-Po battery, or via USB Micro B connector. When powered from a battery alone, the power management IC switches off the internal regulator and supplies power to the system directly from the battery. Power source (Debugger VDD, Li-Po, USB) is selected by on-board switch SW9.","title":"Power"},{"location":"reference/boards/nordic_pca10040/docs/#connect-register-virtualize-and-program","text":"The Nordic nRF52 DK can be programmed through the on-board SEGGER J-Link debugger that exposes three USB interfaces: A serial port over USB A mass storage device for drag-n-drop programming flash memory A SEGGER J-Link debug channel Drivers are needed (Linux, Mac or Windows) and can be downloaded from the official JLink software page. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, .gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group Once connected to a USB port, the Nordic nRF52 DK device is recognized by Zerynth Studio. The board can be virtualized by clicking the related Studio button without requiring any other user intervention. Follow these steps to uplink a Zerynth script on a virtualized nRF52 DK: Select nRF52 DK on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Important To exploit the BLE chip functionalities of nRF52 DK, the lib.nordic.nrf52_ble library must be installed and imported on the Zerynth script. Moreover, in the creation phase, a VM with BLE support must be selected.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/nordic_pca10056/docs/","text":"Nordic nRF52840 DK \u00b6 The nRF52840 DK is a versatile single board development kit for Bluetooth 5, NFC, ANT and 2.4 GHz proprietary applications on nRF52840 SoC. It facilitates development exploiting all features of the nRF52840 SoC. It includes an NFC antenna that quickly enables utilization of the NFC-A tag peripheral on the nRF52840. All GPIOs are available via edge connectors and headers, and 4 buttons and 4 LEDs simplifies output and input from and to the SoC. It comes with an on-board SEGGER J-Link debugger allowing programming and debugging both the on-board SoC and external SoCs through the debug out header. Pin Mapping \u00b6 Official reference for Nordic nRF52840 DK can be found here . Flash Layout \u00b6 The internal flash of the nRF52840 is organized as a single bank of 1 MB, with pages of 4Kb each. The flash begins at address 0x00000 where is stored the Zerynth Virtual Machine (bytecode starts at address 0x55000). Board Summary \u00b6 Microcontroller: nRF52840 Operating Voltage: 3.3V Digital I/O Pins (DIO): 48 Analog Input Pins (ADC): 6 Analog Outputs Pins (DAC): 0 UARTs: 1 SPIs: 2 I2Cs: 1 Flash Memory: 1 MB SRAM: 256 kB Clock Speed: 64 MHz Size (LxW mm): 18.0 x 21.0 Power \u00b6 The Nordic nRF52840 DK is equipped with on-board Li-Po button cell to power-up the device. nRF52840 DK can, also, be powered via external power supply through related connector, external Li-Po battery, or via USB Micro B connector. When powered from a battery alone, the power management IC switches off the internal regulator and supplies power to the system directly from the battery. Power source (Debugger VDD, Li-Po, USB) is selected by on-board switch SW9. Connect, Register, Virtualize and Program \u00b6 The Nordic nRF52840 DK can be programmed through the on-board SEGGER J-Link debugger that exposes three USB interfaces: A serial port over USB A mass storage device for drag-n-drop programming flash memory A SEGGER J-Link debug channel Drivers are needed (Linux, Mac or Windows) and can be downloaded from the official JLink software page. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected to a USB port, the Nordic nRF52840 DK device is recognized by Zerynth Studio. The board can be virtualized by clicking the related Studio button without requiring any other user intervention. Follow these steps to uplink a Zerynth script on a virtualized nRF52840 DK: Select nRF52840 DK on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Important To exploit the BLE chip functionalities of nRF52 DK, the lib.nordic.nrf52_ble library must be installed and imported on the Zerynth script. Moreover, in the creation phase, a VM with BLE support must be selected.","title":"Nordic nRF52840 DK"},{"location":"reference/boards/nordic_pca10056/docs/#nordic-nrf52840-dk","text":"The nRF52840 DK is a versatile single board development kit for Bluetooth 5, NFC, ANT and 2.4 GHz proprietary applications on nRF52840 SoC. It facilitates development exploiting all features of the nRF52840 SoC. It includes an NFC antenna that quickly enables utilization of the NFC-A tag peripheral on the nRF52840. All GPIOs are available via edge connectors and headers, and 4 buttons and 4 LEDs simplifies output and input from and to the SoC. It comes with an on-board SEGGER J-Link debugger allowing programming and debugging both the on-board SoC and external SoCs through the debug out header.","title":"Nordic nRF52840 DK"},{"location":"reference/boards/nordic_pca10056/docs/#pin-mapping","text":"Official reference for Nordic nRF52840 DK can be found here .","title":"Pin Mapping"},{"location":"reference/boards/nordic_pca10056/docs/#flash-layout","text":"The internal flash of the nRF52840 is organized as a single bank of 1 MB, with pages of 4Kb each. The flash begins at address 0x00000 where is stored the Zerynth Virtual Machine (bytecode starts at address 0x55000).","title":"Flash Layout"},{"location":"reference/boards/nordic_pca10056/docs/#board-summary","text":"Microcontroller: nRF52840 Operating Voltage: 3.3V Digital I/O Pins (DIO): 48 Analog Input Pins (ADC): 6 Analog Outputs Pins (DAC): 0 UARTs: 1 SPIs: 2 I2Cs: 1 Flash Memory: 1 MB SRAM: 256 kB Clock Speed: 64 MHz Size (LxW mm): 18.0 x 21.0","title":"Board Summary"},{"location":"reference/boards/nordic_pca10056/docs/#power","text":"The Nordic nRF52840 DK is equipped with on-board Li-Po button cell to power-up the device. nRF52840 DK can, also, be powered via external power supply through related connector, external Li-Po battery, or via USB Micro B connector. When powered from a battery alone, the power management IC switches off the internal regulator and supplies power to the system directly from the battery. Power source (Debugger VDD, Li-Po, USB) is selected by on-board switch SW9.","title":"Power"},{"location":"reference/boards/nordic_pca10056/docs/#connect-register-virtualize-and-program","text":"The Nordic nRF52840 DK can be programmed through the on-board SEGGER J-Link debugger that exposes three USB interfaces: A serial port over USB A mass storage device for drag-n-drop programming flash memory A SEGGER J-Link debug channel Drivers are needed (Linux, Mac or Windows) and can be downloaded from the official JLink software page. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected to a USB port, the Nordic nRF52840 DK device is recognized by Zerynth Studio. The board can be virtualized by clicking the related Studio button without requiring any other user intervention. Follow these steps to uplink a Zerynth script on a virtualized nRF52840 DK: Select nRF52840 DK on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Important To exploit the BLE chip functionalities of nRF52 DK, the lib.nordic.nrf52_ble library must be installed and imported on the Zerynth script. Moreover, in the creation phase, a VM with BLE support must be selected.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/oddwires_io/docs/","text":"oddWires IO \u00b6 The oddWires IO is one of the development board created by oddWires to evaluate the ESP-WROOM-32 module. It is based on the ESP32 microcontroller that boasts Wifi, Bluetooth, Ethernet and Low Power support all in a single chip. The IO offers a 240 MHz, 32-bit processor with 4Mb of flash memory. The IO accepts all of the IoT-Bus modules and can be bought in with male, female or stacking headers. The oddWires IoT-Bus System is based on a low-cost, open design that includes multiple main boards including a minimalist, breadboard-friendly form factor (IO). Pin Mapping \u00b6 Official reference for oddWires IO can be found here . Flash Layout \u00b6 The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved Device Summary \u00b6 Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 26 Analog Input Pins (ADC): 16 Analog Outputs Pins (DAC): 2 UARTs: 3 SPIs: 2 I2Cs: 3 Flash Memory: 4 MB SRAM: 520 KB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks Power \u00b6 Power to the oddWires IO is supplied via the on-board USB Micro B connector or directly throught the connector for a 3.7/4.2 V battery. The power source is selected automatically. The device can operate on an external supply of 2.5 to 6 volts. If using more than 6V, the voltage regulator may overheat and damage the device. Connect, Register, Virtualize and Program \u00b6 The oddWires IO comes with a serial-to-usb chip on board that allows programming and opening the UART of the ESP32 module. Drivers may be needed depending on your system (Mac or Windows) and can be download from the official Espressif documentation page. In Linux systems, the oddWires IO should work out of the box. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the oddWires IO device is recognized by Zerynth Studio. The next steps are: Select the oddWires IO on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the oddWires IO is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process. Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the oddWires IO device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs. Secure Firmware \u00b6 Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section . zerynth secure socket \u00b6 To be able to use zerynth secure socket on esp32 boards native_mbedtls: true must be used instead of zerynth_ssl: true in the project.yml file. Missing features \u00b6 Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"oddWires IO"},{"location":"reference/boards/oddwires_io/docs/#oddwires-io","text":"The oddWires IO is one of the development board created by oddWires to evaluate the ESP-WROOM-32 module. It is based on the ESP32 microcontroller that boasts Wifi, Bluetooth, Ethernet and Low Power support all in a single chip. The IO offers a 240 MHz, 32-bit processor with 4Mb of flash memory. The IO accepts all of the IoT-Bus modules and can be bought in with male, female or stacking headers. The oddWires IoT-Bus System is based on a low-cost, open design that includes multiple main boards including a minimalist, breadboard-friendly form factor (IO).","title":"oddWires IO"},{"location":"reference/boards/oddwires_io/docs/#pin-mapping","text":"Official reference for oddWires IO can be found here .","title":"Pin Mapping"},{"location":"reference/boards/oddwires_io/docs/#flash-layout","text":"The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved","title":"Flash Layout"},{"location":"reference/boards/oddwires_io/docs/#device-summary","text":"Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 26 Analog Input Pins (ADC): 16 Analog Outputs Pins (DAC): 2 UARTs: 3 SPIs: 2 I2Cs: 3 Flash Memory: 4 MB SRAM: 520 KB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks","title":"Device Summary"},{"location":"reference/boards/oddwires_io/docs/#power","text":"Power to the oddWires IO is supplied via the on-board USB Micro B connector or directly throught the connector for a 3.7/4.2 V battery. The power source is selected automatically. The device can operate on an external supply of 2.5 to 6 volts. If using more than 6V, the voltage regulator may overheat and damage the device.","title":"Power"},{"location":"reference/boards/oddwires_io/docs/#connect-register-virtualize-and-program","text":"The oddWires IO comes with a serial-to-usb chip on board that allows programming and opening the UART of the ESP32 module. Drivers may be needed depending on your system (Mac or Windows) and can be download from the official Espressif documentation page. In Linux systems, the oddWires IO should work out of the box. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the oddWires IO device is recognized by Zerynth Studio. The next steps are: Select the oddWires IO on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the oddWires IO is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/oddwires_io/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the oddWires IO device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs.","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/oddwires_io/docs/#secure-firmware","text":"Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section .","title":"Secure Firmware"},{"location":"reference/boards/oddwires_io/docs/#zerynth-secure-socket","text":"To be able to use zerynth secure socket on esp32 boards native_mbedtls: true must be used instead of zerynth_ssl: true in the project.yml file.","title":"zerynth secure socket"},{"location":"reference/boards/oddwires_io/docs/#missing-features","text":"Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"Missing features"},{"location":"reference/boards/oddwires_proteus/docs/","text":"oddWires Proteus \u00b6 The oddWires Proteus is one of the development board created by oddWires to evaluate the ESP-WROOM-32 module. It is based on the ESP32 microcontroller that boasts Wifi, Bluetooth, Ethernet and Low Power support all in a single chip. The Proteus offers a 240 MHz, 32-bit processor with 4Mb of flash memory. The Proteus accepts all of the IoT-Bus modules and is also a version with a large prototyping area which enables a single-board IoT solution. This version includes both 3.3V and 5V power rails The oddWires IoT-Bus System is based on a low-cost, open design that includes multiple main boards including a minimalist, breadboard-friendly form factor. Pin Mapping \u00b6 Official reference for oddWires Proteus can be found here . Flash Layout \u00b6 The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved Device Summary \u00b6 Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 26 Analog Input Pins (ADC): 16 Analog Outputs Pins (DAC): 2 UARTs: 3 SPIs: 2 I2Cs: 3 Flash Memory: 4 MB SRAM: 520 KB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks Power \u00b6 Power to the oddWires Proteus is supplied via the on-board USB Micro B connector or directly throught the connector for a 3.7/4.2 V battery. The power source is selected automatically. The device can operate on an external supply of 2.5 to 6 volts. If using more than 6V, the voltage regulator may overheat and damage the device. Connect, Register, Virtualize and Program \u00b6 The oddWires Proteus comes with a serial-to-usb chip on board that allows programming and opening the UART of the ESP32 module. Drivers may be needed depending on your system (Mac or Windows) and can be download from the official Espressif documentation page. In Linux systems, the oddWires Proteus should work out of the box. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu ` distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the oddWires Proteus device is recognized by Zerynth Studio. The next steps are: Select the oddWires Proteus on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the oddWires Proteus is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process. Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the oddWires Proteus device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs. Secure Firmware \u00b6 Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section . zerynth secure socket \u00b6 To be able to use zerynth secure socket on esp32 boards native_mbedtls: true must be used instead of zerynth_ssl: true in the project.yml file. Missing features \u00b6 Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"oddWires Proteus"},{"location":"reference/boards/oddwires_proteus/docs/#oddwires-proteus","text":"The oddWires Proteus is one of the development board created by oddWires to evaluate the ESP-WROOM-32 module. It is based on the ESP32 microcontroller that boasts Wifi, Bluetooth, Ethernet and Low Power support all in a single chip. The Proteus offers a 240 MHz, 32-bit processor with 4Mb of flash memory. The Proteus accepts all of the IoT-Bus modules and is also a version with a large prototyping area which enables a single-board IoT solution. This version includes both 3.3V and 5V power rails The oddWires IoT-Bus System is based on a low-cost, open design that includes multiple main boards including a minimalist, breadboard-friendly form factor.","title":"oddWires Proteus"},{"location":"reference/boards/oddwires_proteus/docs/#pin-mapping","text":"Official reference for oddWires Proteus can be found here .","title":"Pin Mapping"},{"location":"reference/boards/oddwires_proteus/docs/#flash-layout","text":"The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved","title":"Flash Layout"},{"location":"reference/boards/oddwires_proteus/docs/#device-summary","text":"Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 26 Analog Input Pins (ADC): 16 Analog Outputs Pins (DAC): 2 UARTs: 3 SPIs: 2 I2Cs: 3 Flash Memory: 4 MB SRAM: 520 KB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks","title":"Device Summary"},{"location":"reference/boards/oddwires_proteus/docs/#power","text":"Power to the oddWires Proteus is supplied via the on-board USB Micro B connector or directly throught the connector for a 3.7/4.2 V battery. The power source is selected automatically. The device can operate on an external supply of 2.5 to 6 volts. If using more than 6V, the voltage regulator may overheat and damage the device.","title":"Power"},{"location":"reference/boards/oddwires_proteus/docs/#connect-register-virtualize-and-program","text":"The oddWires Proteus comes with a serial-to-usb chip on board that allows programming and opening the UART of the ESP32 module. Drivers may be needed depending on your system (Mac or Windows) and can be download from the official Espressif documentation page. In Linux systems, the oddWires Proteus should work out of the box. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu ` distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the oddWires Proteus device is recognized by Zerynth Studio. The next steps are: Select the oddWires Proteus on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the oddWires Proteus is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/oddwires_proteus/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the oddWires Proteus device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs.","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/oddwires_proteus/docs/#secure-firmware","text":"Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section .","title":"Secure Firmware"},{"location":"reference/boards/oddwires_proteus/docs/#zerynth-secure-socket","text":"To be able to use zerynth secure socket on esp32 boards native_mbedtls: true must be used instead of zerynth_ssl: true in the project.yml file.","title":"zerynth secure socket"},{"location":"reference/boards/oddwires_proteus/docs/#missing-features","text":"Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"Missing features"},{"location":"reference/boards/olimex_esp32evb/docs/","text":"Olimex Esp32 EVB \u00b6 The Esp32 EVB device is one of the development board created by Olimex to evaluate the ESP-WROOM-32 module. Based on the ESP32 microcontroller , Olimex ESP32 EVB features 100Mb Ethernet Interface, Bluetooth LE, WiFi, Remote control IR, and CAN connectivity. The device can operate with single LiPo backup battery like UPS as it has an internal LiPo battery charger and a step-up converter. Two relays are also available to switch power appliances on and off. Pin Mapping \u00b6 Official reference for Olimex Esp32 EVB can be found here . Flash Layout \u00b6 The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved Device Summary \u00b6 Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 5V Digital I/O Pins (DIO): 36 Analog Input Pins (ADC): 4 UARTs: 3 SPIs: 1 I2Cs: 1 Flash Memory: 4 MB SRAM: 520 KB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks Power \u00b6 Power to the Olimex Esp32 EVB is supplied via the on-board USB Micro B connector or with an external power supply. The power source is selected automatically. External (non-USB) power can come either from an AC-to-DC adapter (wall-wart) or throught the connector for a 3.7/4.2 V Li-Po battery. The adapter can be connected by plugging a 2.1 mm center-positive plug into the device\u2019s power jack. The recommended range for external power supply is 5 volts; if more than 5V are provided, the voltage regulator will overheat and damage the device. Connect, Register, Virtualize and Program \u00b6 The Olimex Esp32 EVB comes with a serial-to-usb chip on board that allows programming and opening the UART of the ESP32 module. The CH340 USB to UART chip is also connected to the boot pins of the module, allowing for a seamless virtualization of the device. Note Drivers for the CH340 Module can be downloaded here in \u201cSoftware\u201d section and are needed for Windows and Mac platforms . In Linux systems, the Olimex Esp32 EVB should work out of the box. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the Olimex Esp32 EVB device is recognized by Zerynth Studio. The next steps are: Select the Olimex Esp32 EVB on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the Olimex Esp32 EVB is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process. Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Olimex Esp32 EVB device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs. Secure Firmware \u00b6 Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section . Zerynth secure socket \u00b6 To be able to use zerynth secure socket on esp32 boards native_mbedtls: true must be used instead of zerynth_ssl: true in the project.yml file. Missing features \u00b6 Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"Olimex Esp32 EVB"},{"location":"reference/boards/olimex_esp32evb/docs/#olimex-esp32-evb","text":"The Esp32 EVB device is one of the development board created by Olimex to evaluate the ESP-WROOM-32 module. Based on the ESP32 microcontroller , Olimex ESP32 EVB features 100Mb Ethernet Interface, Bluetooth LE, WiFi, Remote control IR, and CAN connectivity. The device can operate with single LiPo backup battery like UPS as it has an internal LiPo battery charger and a step-up converter. Two relays are also available to switch power appliances on and off.","title":"Olimex Esp32 EVB"},{"location":"reference/boards/olimex_esp32evb/docs/#pin-mapping","text":"Official reference for Olimex Esp32 EVB can be found here .","title":"Pin Mapping"},{"location":"reference/boards/olimex_esp32evb/docs/#flash-layout","text":"The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved","title":"Flash Layout"},{"location":"reference/boards/olimex_esp32evb/docs/#device-summary","text":"Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 5V Digital I/O Pins (DIO): 36 Analog Input Pins (ADC): 4 UARTs: 3 SPIs: 1 I2Cs: 1 Flash Memory: 4 MB SRAM: 520 KB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks","title":"Device Summary"},{"location":"reference/boards/olimex_esp32evb/docs/#power","text":"Power to the Olimex Esp32 EVB is supplied via the on-board USB Micro B connector or with an external power supply. The power source is selected automatically. External (non-USB) power can come either from an AC-to-DC adapter (wall-wart) or throught the connector for a 3.7/4.2 V Li-Po battery. The adapter can be connected by plugging a 2.1 mm center-positive plug into the device\u2019s power jack. The recommended range for external power supply is 5 volts; if more than 5V are provided, the voltage regulator will overheat and damage the device.","title":"Power"},{"location":"reference/boards/olimex_esp32evb/docs/#connect-register-virtualize-and-program","text":"The Olimex Esp32 EVB comes with a serial-to-usb chip on board that allows programming and opening the UART of the ESP32 module. The CH340 USB to UART chip is also connected to the boot pins of the module, allowing for a seamless virtualization of the device. Note Drivers for the CH340 Module can be downloaded here in \u201cSoftware\u201d section and are needed for Windows and Mac platforms . In Linux systems, the Olimex Esp32 EVB should work out of the box. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the Olimex Esp32 EVB device is recognized by Zerynth Studio. The next steps are: Select the Olimex Esp32 EVB on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the Olimex Esp32 EVB is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/olimex_esp32evb/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Olimex Esp32 EVB device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs.","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/olimex_esp32evb/docs/#secure-firmware","text":"Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section .","title":"Secure Firmware"},{"location":"reference/boards/olimex_esp32evb/docs/#zerynth-secure-socket","text":"To be able to use zerynth secure socket on esp32 boards native_mbedtls: true must be used instead of zerynth_ssl: true in the project.yml file.","title":"Zerynth secure socket"},{"location":"reference/boards/olimex_esp32evb/docs/#missing-features","text":"Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"Missing features"},{"location":"reference/boards/olimex_esp32gateway/docs/","text":"Olimex Esp32 Gateway \u00b6 The Esp32 Gateway device is one of the development board created by Olimex to evaluate the ESP-WROOM-32 module. Based on the ESP32 microcontroller , Olimex ESP32 Gateway features 100Mb Ethernet Interface, Bluetooth LE, WiFi. Pin Mapping \u00b6 Official reference for Olimex Esp32 Gateway can be found here . Flash Layout \u00b6 The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved Device Summary \u00b6 Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 5V Digital I/O Pins (DIO): 34 Analog Input Pins (ADC): 6 UARTs: 2 SPIs: 1 I2Cs: 1 Flash Memory: 4 MB SRAM: 520 KB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks Power \u00b6 Power to the Olimex Esp32 Gateway is supplied via the on-board USB Micro B connector or directly via the \u201cVIN\u201d pin. The power source is selected automatically. The device can operate on an external supply of 5V. If using more than 5V, the voltage regulator may overheat and damage the device. Connect, Register, Virtualize and Program \u00b6 The Olimex Esp32 Gateway comes with a serial-to-usb chip on board that allows programming and opening the UART of the ESP32 module. The CH340 USB to UART chip is also connected to the boot pins of the module, allowing for a seamless virtualization of the device. Note Drivers for the CH340 Module can be downloaded here in \u201cSoftware\u201d section and are needed for Windows and Mac platforms . In Linux systems, the Olimex Esp32 Gateway should work out of the box. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the Olimex Esp32 Gateway device is recognized by Zerynth Studio. The next steps are: Select the Olimex Esp32 Gateway on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the Olimex Esp32 Gateway is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process. Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Olimex Esp32 Gateway device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs. Secure Firmware \u00b6 Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section . Zerynth secure socket \u00b6 To be able to use zerynth secure socket on esp32 boards native_mbedtls: true must be used instead of zerynth_ssl: true in the project.yml file. Missing features \u00b6 Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"Olimex Esp32 Gateway"},{"location":"reference/boards/olimex_esp32gateway/docs/#olimex-esp32-gateway","text":"The Esp32 Gateway device is one of the development board created by Olimex to evaluate the ESP-WROOM-32 module. Based on the ESP32 microcontroller , Olimex ESP32 Gateway features 100Mb Ethernet Interface, Bluetooth LE, WiFi.","title":"Olimex Esp32 Gateway"},{"location":"reference/boards/olimex_esp32gateway/docs/#pin-mapping","text":"Official reference for Olimex Esp32 Gateway can be found here .","title":"Pin Mapping"},{"location":"reference/boards/olimex_esp32gateway/docs/#flash-layout","text":"The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved","title":"Flash Layout"},{"location":"reference/boards/olimex_esp32gateway/docs/#device-summary","text":"Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 5V Digital I/O Pins (DIO): 34 Analog Input Pins (ADC): 6 UARTs: 2 SPIs: 1 I2Cs: 1 Flash Memory: 4 MB SRAM: 520 KB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks","title":"Device Summary"},{"location":"reference/boards/olimex_esp32gateway/docs/#power","text":"Power to the Olimex Esp32 Gateway is supplied via the on-board USB Micro B connector or directly via the \u201cVIN\u201d pin. The power source is selected automatically. The device can operate on an external supply of 5V. If using more than 5V, the voltage regulator may overheat and damage the device.","title":"Power"},{"location":"reference/boards/olimex_esp32gateway/docs/#connect-register-virtualize-and-program","text":"The Olimex Esp32 Gateway comes with a serial-to-usb chip on board that allows programming and opening the UART of the ESP32 module. The CH340 USB to UART chip is also connected to the boot pins of the module, allowing for a seamless virtualization of the device. Note Drivers for the CH340 Module can be downloaded here in \u201cSoftware\u201d section and are needed for Windows and Mac platforms . In Linux systems, the Olimex Esp32 Gateway should work out of the box. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the Olimex Esp32 Gateway device is recognized by Zerynth Studio. The next steps are: Select the Olimex Esp32 Gateway on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the Olimex Esp32 Gateway is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/olimex_esp32gateway/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Olimex Esp32 Gateway device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs.","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/olimex_esp32gateway/docs/#secure-firmware","text":"Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section .","title":"Secure Firmware"},{"location":"reference/boards/olimex_esp32gateway/docs/#zerynth-secure-socket","text":"To be able to use zerynth secure socket on esp32 boards native_mbedtls: true must be used instead of zerynth_ssl: true in the project.yml file.","title":"Zerynth secure socket"},{"location":"reference/boards/olimex_esp32gateway/docs/#missing-features","text":"Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"Missing features"},{"location":"reference/boards/particle_core/docs/","text":"Particle Core (Formerly Spark Core) \u00b6 The Particle Core is a complete Wi-Fi enabled development platform for creating connected devices with ease. The Particle Core is small, low power, and does all the heavy WiFi lifting. Particle Core v1.0 uses the STM32F103CB Cortex M3 microcontroller . In addition to having 128KB of internal flash memory for storing the firmware, the Core also features an external SPI based flash memory chip - SST25VF016B. This memory space (a total of 2MB) is used to store the factory reset firmware and a back up firmware. Part of the space is also available to the user who can use it to store log data, user parameters, etc. Note All the reported information are extracted from the official Particle Core reference page , visit this page for more details and updates. Pin Mapping \u00b6 Particle Core Official Schematic, Reference Design & Pin Mapping are available on the official Particle Core datasheet page . Flash Layout \u00b6 The internal flash of the Particle Core is organized into 128 pages of 1k each starting from address 0x08000000 up to 0x8020000. The memory below 0x08005000 is reserved for Particle bootloader. The Virtual Machine starts at 0x08005000. The bytecode is stored in a variable position depending on the VM size. Note The start address is shown during the uplinking operation in the log console of Zerynth Studio (romstart symbol). Device Summary \u00b6 Microcontroller: ARM 32-bit Cortex\u2122-M3 CPU Core Operating Voltage: 3.3V Input Voltage: 3.6-6V Digital I/O Pins (DIO): 18 Analog Input Pins (ADC): 8 Analog Outputs Pins (DAC): 0 UARTs: 1 SPIs: 1 I2Cs: 1 CANs: 0 Flash Memory: 128KB SRAM: 20 KB Clock Speed: 72Mhz Size (LxW mm): 37.33 X 20.32 Power \u00b6 The entire Particle Core, including all of the on device peripherals, runs at 3.3V DC. The Particle Core has internal voltage regulator that allows powering the device from the USB port or through an external power supply that can range from 3.6V to 6.0V DC. Ideal sources of power can be: 3.6V LiPo battery, 4AA battery pack, backup USB battery or an USB wall charger. Connect, Register, Virtualize and Program \u00b6 On Windows machines the Particle Core USB Drivers are required by the Zerynth Studio for accessing the Core serial port establishing a connection with the STM32 UART. To install the drivers on Windows plug the Core on an USB port, unzip the downloaded package, go to the Windows Device Manager and double-click on the Particle device under \u201cOther Devices\u201d. Click Update Driver, and select Browse for driver software on your computer. Navigate to the folder where the package has been unzipped and select it (Note that right now, the drivers are in a Spark folder and are named spark_core). Note It could be necessary to temporarily disable the digitally signed driver enforcement policy of Windows to allow Core driver installation. There are good instructions on how to do that in this guide . On MAC OSX and Linux USB drivers are not required. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. If the device is still not recognized or not working, the following udev rules may need to be added: #Particle Core SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"1d50\" , ATTRS { idProduct }== \"607f\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"1d50\" , ATTRS { idProduct }== \"607f\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"1d50\" , ATTRS { idProduct }== \"607d\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"1d50\" , ATTRS { idProduct }== \"607d\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" Once connected on a USB port, if drivers have been correctly installed, the Core can be seen as Virtual Serial port and it is automatically recognized by the Zerynth Studio and listed in the Device Management Toolbar as \u201cParticle Core DFU Mode\u201d if the device is in DFU Mode, otherwise as \u201cParticle Core\u201d. To register and virtualize the Core, it is necessary to put the Core in DFU Mode (Device Firmware Upgrade) as reported in the official Particle Core Guide . Note On Windows machines it is necessary to install also the Particle Core DFU drivers for virtualizing the device. The official Particle Core DFU driver and the related installation procedure are reported here . Follow these steps to register and virtualize a Particle Core: Put the Core in DFU Mode (Device Firmware Upgrade): Hold down BOTH buttons (reset and mode); Release only the reset button, while holding down the mode button; Wait for the LED to start flashing yellow; Release the mode button; the device is now in DFU Mode (yellow blinking led); Select the Core on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note During these operations the Core device must be in DFU Mode . If the device returns in standard mode, it is necessary to put it in DFU Mode again. Warning Depending on the Particle Core bootloader version, it may be necessary to virtualize it twice. If after the first virtualization, the Particle Core starts blinking red (factory reset mode), wait for the factory reset to finish and repeat the operation sequence. After virtualization, the Particle Core is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked. Important To exploit the Wi-Fi chip functionalities of the Particle Core, the lib.texas.cc3000 library must be installed and imported on the Zerynth script.","title":"Particle Core (Formerly Spark Core)"},{"location":"reference/boards/particle_core/docs/#particle-core-formerly-spark-core","text":"The Particle Core is a complete Wi-Fi enabled development platform for creating connected devices with ease. The Particle Core is small, low power, and does all the heavy WiFi lifting. Particle Core v1.0 uses the STM32F103CB Cortex M3 microcontroller . In addition to having 128KB of internal flash memory for storing the firmware, the Core also features an external SPI based flash memory chip - SST25VF016B. This memory space (a total of 2MB) is used to store the factory reset firmware and a back up firmware. Part of the space is also available to the user who can use it to store log data, user parameters, etc. Note All the reported information are extracted from the official Particle Core reference page , visit this page for more details and updates.","title":"Particle Core (Formerly Spark Core)"},{"location":"reference/boards/particle_core/docs/#pin-mapping","text":"Particle Core Official Schematic, Reference Design & Pin Mapping are available on the official Particle Core datasheet page .","title":"Pin Mapping"},{"location":"reference/boards/particle_core/docs/#flash-layout","text":"The internal flash of the Particle Core is organized into 128 pages of 1k each starting from address 0x08000000 up to 0x8020000. The memory below 0x08005000 is reserved for Particle bootloader. The Virtual Machine starts at 0x08005000. The bytecode is stored in a variable position depending on the VM size. Note The start address is shown during the uplinking operation in the log console of Zerynth Studio (romstart symbol).","title":"Flash Layout"},{"location":"reference/boards/particle_core/docs/#device-summary","text":"Microcontroller: ARM 32-bit Cortex\u2122-M3 CPU Core Operating Voltage: 3.3V Input Voltage: 3.6-6V Digital I/O Pins (DIO): 18 Analog Input Pins (ADC): 8 Analog Outputs Pins (DAC): 0 UARTs: 1 SPIs: 1 I2Cs: 1 CANs: 0 Flash Memory: 128KB SRAM: 20 KB Clock Speed: 72Mhz Size (LxW mm): 37.33 X 20.32","title":"Device Summary"},{"location":"reference/boards/particle_core/docs/#power","text":"The entire Particle Core, including all of the on device peripherals, runs at 3.3V DC. The Particle Core has internal voltage regulator that allows powering the device from the USB port or through an external power supply that can range from 3.6V to 6.0V DC. Ideal sources of power can be: 3.6V LiPo battery, 4AA battery pack, backup USB battery or an USB wall charger.","title":"Power"},{"location":"reference/boards/particle_core/docs/#connect-register-virtualize-and-program","text":"On Windows machines the Particle Core USB Drivers are required by the Zerynth Studio for accessing the Core serial port establishing a connection with the STM32 UART. To install the drivers on Windows plug the Core on an USB port, unzip the downloaded package, go to the Windows Device Manager and double-click on the Particle device under \u201cOther Devices\u201d. Click Update Driver, and select Browse for driver software on your computer. Navigate to the folder where the package has been unzipped and select it (Note that right now, the drivers are in a Spark folder and are named spark_core). Note It could be necessary to temporarily disable the digitally signed driver enforcement policy of Windows to allow Core driver installation. There are good instructions on how to do that in this guide . On MAC OSX and Linux USB drivers are not required. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. If the device is still not recognized or not working, the following udev rules may need to be added: #Particle Core SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"1d50\" , ATTRS { idProduct }== \"607f\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"1d50\" , ATTRS { idProduct }== \"607f\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"1d50\" , ATTRS { idProduct }== \"607d\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"1d50\" , ATTRS { idProduct }== \"607d\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" Once connected on a USB port, if drivers have been correctly installed, the Core can be seen as Virtual Serial port and it is automatically recognized by the Zerynth Studio and listed in the Device Management Toolbar as \u201cParticle Core DFU Mode\u201d if the device is in DFU Mode, otherwise as \u201cParticle Core\u201d. To register and virtualize the Core, it is necessary to put the Core in DFU Mode (Device Firmware Upgrade) as reported in the official Particle Core Guide . Note On Windows machines it is necessary to install also the Particle Core DFU drivers for virtualizing the device. The official Particle Core DFU driver and the related installation procedure are reported here . Follow these steps to register and virtualize a Particle Core: Put the Core in DFU Mode (Device Firmware Upgrade): Hold down BOTH buttons (reset and mode); Release only the reset button, while holding down the mode button; Wait for the LED to start flashing yellow; Release the mode button; the device is now in DFU Mode (yellow blinking led); Select the Core on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note During these operations the Core device must be in DFU Mode . If the device returns in standard mode, it is necessary to put it in DFU Mode again. Warning Depending on the Particle Core bootloader version, it may be necessary to virtualize it twice. If after the first virtualization, the Particle Core starts blinking red (factory reset mode), wait for the factory reset to finish and repeat the operation sequence. After virtualization, the Particle Core is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked. Important To exploit the Wi-Fi chip functionalities of the Particle Core, the lib.texas.cc3000 library must be installed and imported on the Zerynth script.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/particle_electron/docs/","text":"Particle Electron \u00b6 The Particle Electron is a GSM enabled development platform for creating connected devices with M2M in mind. Particle Electron combines a powerful ARM Cortex M3 micro-controller with a 3G/2G gsm module from UBlox (U260 or G350). Particle Electron uses the STM32F205RG Cortex M3 microcontroller . In addition to having 1Mb of internal flash memory for storing the firmware, the Electron also features 128k of Ram and 120 MHz of clock. Note All the reported information are extracted from the official Particle Electron reference page , visit this page for more details and updates. Pin Mapping \u00b6 Particle Electron Official Schematic, Reference Design & Pin Mapping are available on the official Particle Electron datasheet page . Flash Layout \u00b6 The internal flash of the Particle Electron is organized into sectors of different size according to the following table: Start address Size Content 0x8000000 16Kb BootLoader 0x8004000 16Kb DCT1 0x8008000 16Kb DCT2 0x800C000 16Kb EEPROM1 0x8010000 64Kb EEPROM2 0x8020000 128kb Virtual Machine 0x8040000 128kb Bytecode Bank 0 0x8060000 128kb Bytecode Bank 1 0x8080000 128kb Bytecode Bank 2 0x80A0000 128kb Bytecode Bank 3 0x80C0000 128kb Bytecode Bank 4 0x80E0000 128kb Bytecode Bank 5 Important To avoid deleting the Electron configuration it is suggested to not write to sectors between 0x8004000 and 0x8020000. Warning If internal flash is used in a Zerynth program, it is recommended to start from pages at the end of flash (bytecode bank 5) towards the virtual machine, to minimize the chance of clashes. Since writing to a sector entails erasing it first, the write operation can be slow even for small chunks of data, depending on the size of the choosen sector. Device Summary \u00b6 Microcontroller: ARM 32-bit Cortex\u2122-M3 CPU Core Operating Voltage: 3.3V Input Voltage: 3.6-6V Digital I/O Pins (DIO): 28 Analog Input Pins (ADC): 14 Analog Outputs Pins (DAC): 1 UARTs: 5 SPIs: 2 I2Cs: 1 CANs: 1 Flash Memory: 1Mb SRAM: 128 KB Clock Speed: 120Mhz Power \u00b6 The Electron is equipped with on device power management circuit powered by BQ24195 pm unit and MAX17043 fuel gauge. The Electron can be powered via the VIN (3.9V-12VDC) pin, the USB Micro B connector or a LiPo battery. When powered from a LiPo battery alone, the power management IC switches off the internal regulator and supplies power to the system directly from the battery. Connect, Register, Virtualize and Program \u00b6 On Windows machines the Particle Electron USB Drivers are required by the Zerynth Studio for accessing the serial port establishing a connection with the STM32 UART. To install the drivers on Windows plug the Electron on an USB port, unzip the downloaded package, go to the Windows Device Manager and double-click on the Particle device under \u201cOther Devices\u201d. Click Update Driver, and select Browse for driver software on your computer. Navigate to the folder where the package has been unzipped and select it (Note that right now, the drivers are in a Spark folder and are named photon.cat). Note It could be necessary to temporarily disable the digitally signed driver enforcement policy of Windows to allow Electron driver installation. There are good instructions on how to do that in this guide . On MAC OSX and Linux USB drivers are not required. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. If the device is still not recognized or not working, the following udev rules may need to be added: #Particle Electron SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"2b04\" , ATTRS { idProduct }== \"d00a\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"2b04\" , ATTRS { idProduct }== \"d00a\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"2b04\" , ATTRS { idProduct }== \"c00a\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"2b04\" , ATTRS { idProduct }== \"c00a\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" Once connected on a USB port, if drivers have been correctly installed, the Electron can be seen as Virtual Serial port and it is automatically recognized by the Zerynth Studio and listed in the Device Management Toolbar as \u201cParticle Electron DFU Mode\u201d if the device is in DFU Mode, otherwise as \u201cParticle Electron\u201d. To register and virtualize an Electron, it is necessary to put the Electron in DFU Mode (Device Firmware Upgrade) as reported in the official Particle Electron Guide . Note On Windows machines it is necessary to install also the Particle Electron DFU drivers for virtualizing the device. The official Particle Core DFU driver and the related installation procedure are reported here but they also work for the Particle Electron . Follow these steps to register and virtualize a Particle Electron: Put the Electron in DFU Mode (Device Firmware Upgrade): Hold down BOTH buttons (reset and setup); Release only the reset button, while holding down the setup button; Wait for the LED to start flashing flashing magenta, then yellow; Release the setup button; the device is now in DFU Mode (yellow blinking led); Select the Electron on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note During these operations the Electron device must be in DFU Mode . if the device returns in standard mode, it is necessary to put it in DFU Mode again. After virtualization, the Particle Electron is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked. Important To exploit the GSM/GPRS chip functionalities of the Particle Electron, the lib.ublox.g350 library must be installed (some example code is provided). Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Particle Electron device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x08020000 128Kb VM Slot 0 0x08040000 384kb Bytecode Slot 0 0x080A0000 128kb VM Slot 1 0x080C0000 256kb Bytecode Slot 1 Important FOTA Record (small segment of memory where the current and desired state of the firmware is store) for the Particle Electron device is allocated in 16kb DCT1 (see Flash Layout) sector at 0x08006000 address. Power Management and Secure Firmware \u00b6 Power Management feature allows to optimize power consumption by putting the device in low consumption state. Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). Both these features are strongly platform dependent; more information at Power Management - STM32F section and Secure Firmware - STM32F section .","title":"Particle Electron"},{"location":"reference/boards/particle_electron/docs/#particle-electron","text":"The Particle Electron is a GSM enabled development platform for creating connected devices with M2M in mind. Particle Electron combines a powerful ARM Cortex M3 micro-controller with a 3G/2G gsm module from UBlox (U260 or G350). Particle Electron uses the STM32F205RG Cortex M3 microcontroller . In addition to having 1Mb of internal flash memory for storing the firmware, the Electron also features 128k of Ram and 120 MHz of clock. Note All the reported information are extracted from the official Particle Electron reference page , visit this page for more details and updates.","title":"Particle Electron"},{"location":"reference/boards/particle_electron/docs/#pin-mapping","text":"Particle Electron Official Schematic, Reference Design & Pin Mapping are available on the official Particle Electron datasheet page .","title":"Pin Mapping"},{"location":"reference/boards/particle_electron/docs/#flash-layout","text":"The internal flash of the Particle Electron is organized into sectors of different size according to the following table: Start address Size Content 0x8000000 16Kb BootLoader 0x8004000 16Kb DCT1 0x8008000 16Kb DCT2 0x800C000 16Kb EEPROM1 0x8010000 64Kb EEPROM2 0x8020000 128kb Virtual Machine 0x8040000 128kb Bytecode Bank 0 0x8060000 128kb Bytecode Bank 1 0x8080000 128kb Bytecode Bank 2 0x80A0000 128kb Bytecode Bank 3 0x80C0000 128kb Bytecode Bank 4 0x80E0000 128kb Bytecode Bank 5 Important To avoid deleting the Electron configuration it is suggested to not write to sectors between 0x8004000 and 0x8020000. Warning If internal flash is used in a Zerynth program, it is recommended to start from pages at the end of flash (bytecode bank 5) towards the virtual machine, to minimize the chance of clashes. Since writing to a sector entails erasing it first, the write operation can be slow even for small chunks of data, depending on the size of the choosen sector.","title":"Flash Layout"},{"location":"reference/boards/particle_electron/docs/#device-summary","text":"Microcontroller: ARM 32-bit Cortex\u2122-M3 CPU Core Operating Voltage: 3.3V Input Voltage: 3.6-6V Digital I/O Pins (DIO): 28 Analog Input Pins (ADC): 14 Analog Outputs Pins (DAC): 1 UARTs: 5 SPIs: 2 I2Cs: 1 CANs: 1 Flash Memory: 1Mb SRAM: 128 KB Clock Speed: 120Mhz","title":"Device Summary"},{"location":"reference/boards/particle_electron/docs/#power","text":"The Electron is equipped with on device power management circuit powered by BQ24195 pm unit and MAX17043 fuel gauge. The Electron can be powered via the VIN (3.9V-12VDC) pin, the USB Micro B connector or a LiPo battery. When powered from a LiPo battery alone, the power management IC switches off the internal regulator and supplies power to the system directly from the battery.","title":"Power"},{"location":"reference/boards/particle_electron/docs/#connect-register-virtualize-and-program","text":"On Windows machines the Particle Electron USB Drivers are required by the Zerynth Studio for accessing the serial port establishing a connection with the STM32 UART. To install the drivers on Windows plug the Electron on an USB port, unzip the downloaded package, go to the Windows Device Manager and double-click on the Particle device under \u201cOther Devices\u201d. Click Update Driver, and select Browse for driver software on your computer. Navigate to the folder where the package has been unzipped and select it (Note that right now, the drivers are in a Spark folder and are named photon.cat). Note It could be necessary to temporarily disable the digitally signed driver enforcement policy of Windows to allow Electron driver installation. There are good instructions on how to do that in this guide . On MAC OSX and Linux USB drivers are not required. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. If the device is still not recognized or not working, the following udev rules may need to be added: #Particle Electron SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"2b04\" , ATTRS { idProduct }== \"d00a\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"2b04\" , ATTRS { idProduct }== \"d00a\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"2b04\" , ATTRS { idProduct }== \"c00a\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"2b04\" , ATTRS { idProduct }== \"c00a\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" Once connected on a USB port, if drivers have been correctly installed, the Electron can be seen as Virtual Serial port and it is automatically recognized by the Zerynth Studio and listed in the Device Management Toolbar as \u201cParticle Electron DFU Mode\u201d if the device is in DFU Mode, otherwise as \u201cParticle Electron\u201d. To register and virtualize an Electron, it is necessary to put the Electron in DFU Mode (Device Firmware Upgrade) as reported in the official Particle Electron Guide . Note On Windows machines it is necessary to install also the Particle Electron DFU drivers for virtualizing the device. The official Particle Core DFU driver and the related installation procedure are reported here but they also work for the Particle Electron . Follow these steps to register and virtualize a Particle Electron: Put the Electron in DFU Mode (Device Firmware Upgrade): Hold down BOTH buttons (reset and setup); Release only the reset button, while holding down the setup button; Wait for the LED to start flashing flashing magenta, then yellow; Release the setup button; the device is now in DFU Mode (yellow blinking led); Select the Electron on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note During these operations the Electron device must be in DFU Mode . if the device returns in standard mode, it is necessary to put it in DFU Mode again. After virtualization, the Particle Electron is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked. Important To exploit the GSM/GPRS chip functionalities of the Particle Electron, the lib.ublox.g350 library must be installed (some example code is provided).","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/particle_electron/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Particle Electron device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x08020000 128Kb VM Slot 0 0x08040000 384kb Bytecode Slot 0 0x080A0000 128kb VM Slot 1 0x080C0000 256kb Bytecode Slot 1 Important FOTA Record (small segment of memory where the current and desired state of the firmware is store) for the Particle Electron device is allocated in 16kb DCT1 (see Flash Layout) sector at 0x08006000 address.","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/particle_electron/docs/#power-management-and-secure-firmware","text":"Power Management feature allows to optimize power consumption by putting the device in low consumption state. Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). Both these features are strongly platform dependent; more information at Power Management - STM32F section and Secure Firmware - STM32F section .","title":"Power Management and Secure Firmware"},{"location":"reference/boards/particle_photon/docs/","text":"Particle Photon \u00b6 The Particle Photon is a complete Wi-Fi enabled development platform for creating connected devices with ease, the successor of the Particle Core. Particle Photon combines a powerful ARM Cortex M3 micro-controller with a Broadcom Wi-Fi chip in a tiny thumbnail-sized module called the P\u00d8 (P-zero). Particle Photon uses the STM32F205RG Cortex M3 microcontroller . In addition to having 1Mb of internal flash memory for storing the firmware, the Photon also features 128k of Ram and 120 MHz of clock. Note All the reported information are extracted from the official Particle Photon reference page , visit this page for more details and updates. Pin Mapping \u00b6 Particle Photon Official Schematic, Reference Design & Pin Mapping are available on the official Particle Photon datasheet page . Flash Layout \u00b6 The internal flash of the Particle Photon is organized into sectors of different size according to the following table: Start address Size Content 0x8000000 16Kb BootLoader 0x8004000 16Kb DCT1 0x8008000 16Kb DCT2 0x800C000 16Kb EEPROM1 0x8010000 64Kb EEPROM2 0x8020000 128kb Virtual Machine 0x8040000 128kb Bytecode Bank 0 0x8060000 128kb Bytecode Bank 1 0x8080000 128kb Bytecode Bank 2 0x80A0000 128kb Bytecode Bank 3 0x80C0000 128kb Bytecode Bank 4 0x80E0000 128kb Bytecode Bank 5 Important To avoid deleting the Photon configuration it is recommended not to write in sectors between 0x8004000 and 0x8020000. Warning If internal flash is used in a Zerynth program, it is recommended to start from pages at the end of flash (bytecode bank 5) towards the virtual machine, to minimize the chance of clashes. Since writing to a sector entails erasing it first, the write operation can be slow even for small chunks of data, depending on the size of the chosen sector. Device Summary \u00b6 Microcontroller: ARM 32-bit Cortex\u2122-M3 CPU Core Operating Voltage: 3.3V Input Voltage: 3.6-6V Digital I/O Pins (DIO): 18 Analog Input Pins (ADC): 5 Analog Outputs Pins (DAC): 1 UARTs: 1 SPIs: 2 I2Cs: 1 CANs: 1 Flash Memory: 1Mb SRAM: 128 KB Clock Speed: 120Mhz Size (LxW mm): 36.58 X 20.32 Power \u00b6 Power to the Particle Photon device is supplied via the on-board USB micro B connector or directly via the VIN pin: If power is supplied directly to the VIN pin, the voltage should be regulated between 3.6VDC and 5.5VDC. If the device is powered via the USB port, VIN will output a voltage of approximately 4.8VDC due to a reverse polarity protection series schottky diode between V+ of USB and VIN. Note When used as an output, the max load current on VIN is 1 Ampere. Typical current consumption is 80mA with a 5V input. Deep sleep quiescent current is 160uA. When powering the Photon from the USB connector, make sure to use a quality cable to minimize voltage drops. If a high resistance cable (i.e., low current) is used, peak currents drawn from the Photon when transmitting and receiving will result in voltage sag at the input which may cause a system brown out or intermittent operation. Likewise, the power source should be sufficient enough to source 1A of current to be on the safe side. Connect, Register, Virtualize and Program \u00b6 On Windows machines the Particle Photon USB Drivers are required by Zerynth Studio for accessing the serial port establishing a connection with the STM32 UART. To install the drivers on Windows plug the Photon on an USB port, unzip the downloaded package, go to the Window Devices Manager and double-click on the Particle device under \u201cOther Devices\u201d. Click Update Driver, and select Browse for driver software on your computer. Navigate to the folder where the package has been unzipped and select it (Note that right now, the drivers are in a Spark folder and are named photon.cat). Note It could be necessary to temporarily disable the digitally signed driver enforcement policy of Windows to allow Photon driver installation. There are good instructions on how to do that in this guide . On MAC OSX and Linux platforms USB drivers are not required. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. If the device is still not recognized or not working, the following udev rules may need to be added: #Particle Photon SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"2b04\" , ATTRS { idProduct }== \"d006\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"2b04\" , ATTRS { idProduct }== \"d006\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"2b04\" , ATTRS { idProduct }== \"c006\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"2b04\" , ATTRS { idProduct }== \"c006\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" Once connected on a USB port, if drivers have been correctly installed, the Particle Photon can be seen as Virtual Serial port and it is automatically recognized by Zerynth Studio and listed in the Device Management Toolbar as \u201cParticle Photon DFU Mode\u201d if the device is in DFU Mode, otherwise as \u201cParticle Photon\u201d. To register and virtualize a Particle Photon, it is necessary to put the Photon in DFU Mode (Device Firmware Upgrade) as reported in the official Particle Photon Guide . Note On Windows machines it is necessary to install also the Photon DFU drivers for virtualizing the device. The official Particle Core DFU driver and the related installation procedure are reported here but they also work for Particle Photon . Follow these steps to register and virtualize a Particle Photon: Put the Photon in DFU Mode (Device Firmware Upgrade): Hold down BOTH buttons (reset and setup); Release only the reset button, while holding down the setup button; Wait for the LED to start flashing magenta, then yellow; Release the setup button; the device is now in DFU Mode (yellow blinking led); Select the Photon on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note During these operations the Photon device must be in DFU Mode . if the device returns in standard mode, it is necessary to put it in DFU Mode again. After virtualization, the Particle Photon is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked. Important To exploit the Wi-Fi chip functionalities of the Particle Photon, the lib.broadcom.bcm43362 library must be installed and imported on the Zerynth script. Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Particle Photon device is available for bytecode. Flash Layout is shown in table below: Start address Size Content 0x08020000 128Kb VM Slot 0 0x08040000 384kb Bytecode Slot 0 0x080A0000 384kb Bytecode Slot 1 Important OTA Record (small segment of memory where the current and desired state of the firmware is store) for the Particle Photon device is allocated in 16kb DCT1 (see Flash Layout) sector at 0x08006000 address. Power Management and Secure Firmware \u00b6 Power Management feature allows to optimize power consumption by putting the device in low consumption state. Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). Both these features are strongly platform dependent; more information at Power Management - STM32F section and Secure Firmware - STM32F section .","title":"Particle Photon"},{"location":"reference/boards/particle_photon/docs/#particle-photon","text":"The Particle Photon is a complete Wi-Fi enabled development platform for creating connected devices with ease, the successor of the Particle Core. Particle Photon combines a powerful ARM Cortex M3 micro-controller with a Broadcom Wi-Fi chip in a tiny thumbnail-sized module called the P\u00d8 (P-zero). Particle Photon uses the STM32F205RG Cortex M3 microcontroller . In addition to having 1Mb of internal flash memory for storing the firmware, the Photon also features 128k of Ram and 120 MHz of clock. Note All the reported information are extracted from the official Particle Photon reference page , visit this page for more details and updates.","title":"Particle Photon"},{"location":"reference/boards/particle_photon/docs/#pin-mapping","text":"Particle Photon Official Schematic, Reference Design & Pin Mapping are available on the official Particle Photon datasheet page .","title":"Pin Mapping"},{"location":"reference/boards/particle_photon/docs/#flash-layout","text":"The internal flash of the Particle Photon is organized into sectors of different size according to the following table: Start address Size Content 0x8000000 16Kb BootLoader 0x8004000 16Kb DCT1 0x8008000 16Kb DCT2 0x800C000 16Kb EEPROM1 0x8010000 64Kb EEPROM2 0x8020000 128kb Virtual Machine 0x8040000 128kb Bytecode Bank 0 0x8060000 128kb Bytecode Bank 1 0x8080000 128kb Bytecode Bank 2 0x80A0000 128kb Bytecode Bank 3 0x80C0000 128kb Bytecode Bank 4 0x80E0000 128kb Bytecode Bank 5 Important To avoid deleting the Photon configuration it is recommended not to write in sectors between 0x8004000 and 0x8020000. Warning If internal flash is used in a Zerynth program, it is recommended to start from pages at the end of flash (bytecode bank 5) towards the virtual machine, to minimize the chance of clashes. Since writing to a sector entails erasing it first, the write operation can be slow even for small chunks of data, depending on the size of the chosen sector.","title":"Flash Layout"},{"location":"reference/boards/particle_photon/docs/#device-summary","text":"Microcontroller: ARM 32-bit Cortex\u2122-M3 CPU Core Operating Voltage: 3.3V Input Voltage: 3.6-6V Digital I/O Pins (DIO): 18 Analog Input Pins (ADC): 5 Analog Outputs Pins (DAC): 1 UARTs: 1 SPIs: 2 I2Cs: 1 CANs: 1 Flash Memory: 1Mb SRAM: 128 KB Clock Speed: 120Mhz Size (LxW mm): 36.58 X 20.32","title":"Device Summary"},{"location":"reference/boards/particle_photon/docs/#power","text":"Power to the Particle Photon device is supplied via the on-board USB micro B connector or directly via the VIN pin: If power is supplied directly to the VIN pin, the voltage should be regulated between 3.6VDC and 5.5VDC. If the device is powered via the USB port, VIN will output a voltage of approximately 4.8VDC due to a reverse polarity protection series schottky diode between V+ of USB and VIN. Note When used as an output, the max load current on VIN is 1 Ampere. Typical current consumption is 80mA with a 5V input. Deep sleep quiescent current is 160uA. When powering the Photon from the USB connector, make sure to use a quality cable to minimize voltage drops. If a high resistance cable (i.e., low current) is used, peak currents drawn from the Photon when transmitting and receiving will result in voltage sag at the input which may cause a system brown out or intermittent operation. Likewise, the power source should be sufficient enough to source 1A of current to be on the safe side.","title":"Power"},{"location":"reference/boards/particle_photon/docs/#connect-register-virtualize-and-program","text":"On Windows machines the Particle Photon USB Drivers are required by Zerynth Studio for accessing the serial port establishing a connection with the STM32 UART. To install the drivers on Windows plug the Photon on an USB port, unzip the downloaded package, go to the Window Devices Manager and double-click on the Particle device under \u201cOther Devices\u201d. Click Update Driver, and select Browse for driver software on your computer. Navigate to the folder where the package has been unzipped and select it (Note that right now, the drivers are in a Spark folder and are named photon.cat). Note It could be necessary to temporarily disable the digitally signed driver enforcement policy of Windows to allow Photon driver installation. There are good instructions on how to do that in this guide . On MAC OSX and Linux platforms USB drivers are not required. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. If the device is still not recognized or not working, the following udev rules may need to be added: #Particle Photon SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"2b04\" , ATTRS { idProduct }== \"d006\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"2b04\" , ATTRS { idProduct }== \"d006\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"2b04\" , ATTRS { idProduct }== \"c006\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"2b04\" , ATTRS { idProduct }== \"c006\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" Once connected on a USB port, if drivers have been correctly installed, the Particle Photon can be seen as Virtual Serial port and it is automatically recognized by Zerynth Studio and listed in the Device Management Toolbar as \u201cParticle Photon DFU Mode\u201d if the device is in DFU Mode, otherwise as \u201cParticle Photon\u201d. To register and virtualize a Particle Photon, it is necessary to put the Photon in DFU Mode (Device Firmware Upgrade) as reported in the official Particle Photon Guide . Note On Windows machines it is necessary to install also the Photon DFU drivers for virtualizing the device. The official Particle Core DFU driver and the related installation procedure are reported here but they also work for Particle Photon . Follow these steps to register and virtualize a Particle Photon: Put the Photon in DFU Mode (Device Firmware Upgrade): Hold down BOTH buttons (reset and setup); Release only the reset button, while holding down the setup button; Wait for the LED to start flashing magenta, then yellow; Release the setup button; the device is now in DFU Mode (yellow blinking led); Select the Photon on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note During these operations the Photon device must be in DFU Mode . if the device returns in standard mode, it is necessary to put it in DFU Mode again. After virtualization, the Particle Photon is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked. Important To exploit the Wi-Fi chip functionalities of the Particle Photon, the lib.broadcom.bcm43362 library must be installed and imported on the Zerynth script.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/particle_photon/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Particle Photon device is available for bytecode. Flash Layout is shown in table below: Start address Size Content 0x08020000 128Kb VM Slot 0 0x08040000 384kb Bytecode Slot 0 0x080A0000 384kb Bytecode Slot 1 Important OTA Record (small segment of memory where the current and desired state of the firmware is store) for the Particle Photon device is allocated in 16kb DCT1 (see Flash Layout) sector at 0x08006000 address.","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/particle_photon/docs/#power-management-and-secure-firmware","text":"Power Management feature allows to optimize power consumption by putting the device in low consumption state. Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). Both these features are strongly platform dependent; more information at Power Management - STM32F section and Secure Firmware - STM32F section .","title":"Power Management and Secure Firmware"},{"location":"reference/boards/polaris_2g/docs/","text":"Polaris 2G \u00b6 Polaris 2G provided by Fortebit is a professional GPS/GLONASS vehicle tracker and IoT development platform. The Polaris 2G hardware includes a powerful 32-bit ARM Cortex-M4 controller with low-power features ( STM32L452 ), a GSM/GPRS modem for wireless connectivity, a GPS/GLONASS receiver with Assisted-GPS,on-board accelerometer and SD card socket, mikroBus\u2122 expansion slot, plenty of I/O, and a wide operating temperature range of -35\u00b0C to +80\u00b0C. With Polaris 2G, many IoT applications can be developed related to real-time asset tracking, geo-fencing, sensors logging, battery monitoring, remote controlling, and others. It works right out of the box as vehicle tracker; the only requirement is a SIM card. Important Polaris 2G belongs to Polaris family of board by Fortebit. The lib.fortebit.polaris library is available and can be imported to abstract your Zerynth project from a specific Polaris board. Pin Mapping \u00b6 Flash Layout \u00b6 The internal flash of the Polaris 2G is organized in one block divided in 256 pages of 2Kb each. The flash memory address starts at 0x8000000 and can be read and written from a Zerynth program using the internal flash module. Warning If internal flash is used in a Zerynth program, it is suggested to begin using pages from the end of flash towards the virtual machine, to minimize the chance of clashes. Since writing to a sector entails erasing it first, the write operation can be slow even for small chunks of data, depending on the size of the choosen sector. Device Summary \u00b6 Microcontroller: STM32L452 ARM\u00ae32-bit Cortex\u00ae-M4 CPU Operating Voltage: 3.3V Input Voltage: 8-36V Digital I/O Pins (DIO): 69 Analog Input Pins (ADC): 11 UARTs: 4 USB: 1 SPIs: 2 I2Cs: 1 SD Card Slot: 1 SIM Card Slot: 1 MikroBus Click Slot: 1 Flash Memory: 512 KB SRAM: 160 KB Clock Speed: 80 MHz Power \u00b6 On the Polaris 2G the power supply is provided by an external Source: VIN (8V-36V) or through the JST connector for a 3.7/4.2 V backup battery. The power source is selected automatically and when both power supply are provided, the main source can be used to enable charging the backup battery. Note Polaris 2G can be programmed through USB connector or through ST-Link debugger connected to the related JTAG connector. Warning When the device is connected to the PC by USB or by ST-LINK debugger, VUSB and Vcc are not connected as Power supply. External Power Supply or Battery Power Supply must be always provided. Connect, Register, Virtualize and Program \u00b6 On Windows machines two set of drivers may be installed: the DFU drivers and the USB serial drivers. This can be done by using the Zadig utility version 2.2 or greater. Use the Zadig utility once with the Polaris 2G in DFU mode (see below) and once after the device has been virtualized. Note Remember to select \u201cOptions > List all devices\u201d to search for the Polaris 2G device. In DFU mode, the VID:PID you should see is 0483:5740 and the Polaris 2G si recognized as \u201cSTM32 BOOTLOADER\u201d. For the virtualized Polaris 2G (DFU MODE) the VID:PID is 0483:DF12. Warning In DFU mode any driver is ok, except Usb CDC; for the virtualized Polaris the only valid driver is Usb CDC. Note It could be necessary to temporarily disable the digitally signed driver enforcement policy of Windows to allow the driver installation. There are good instructions on how to do that in this guide . On MAC OSX and Linux USB drivers are not required. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. If the device is still not recognized or not working, the following udev rules may need to be added: #Polaris 2G Device SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"0483\" , ATTRS { idProduct }== \"5740\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"0483\" , ATTRS { idProduct }== \"df12\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" Once connected to a USB port the Polaris device can be seen as a Virtual Serial port or as a DFU device depending on its virtualized/virtualizable status and it is automatically recognized by Zerynth Studio. The next steps are: Put the Polaris in DFU Mode (Device Firmware Upgrade): Click on \u201cDevice Info\u201d button; Wait until \u201cDevice Management Toolbar\u201d blinks yellow; Select the Polaris on the Device Management Toolbar (Disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note During these operations the Polaris 2G device must be in DFU mode. if the device returns in standard mode, it is necessary to put it in DFU Mode again. After virtualization, the Polaris 2G is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Power Management and Secure Firmware \u00b6 Power Management feature allows to optimize power consumption by putting the device in low consumption state. Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). Both these features are strongly platform dependent; more information at Power Management - STM32F section and Secure Firmware - STM32F section .","title":"Polaris 2G"},{"location":"reference/boards/polaris_2g/docs/#polaris-2g","text":"Polaris 2G provided by Fortebit is a professional GPS/GLONASS vehicle tracker and IoT development platform. The Polaris 2G hardware includes a powerful 32-bit ARM Cortex-M4 controller with low-power features ( STM32L452 ), a GSM/GPRS modem for wireless connectivity, a GPS/GLONASS receiver with Assisted-GPS,on-board accelerometer and SD card socket, mikroBus\u2122 expansion slot, plenty of I/O, and a wide operating temperature range of -35\u00b0C to +80\u00b0C. With Polaris 2G, many IoT applications can be developed related to real-time asset tracking, geo-fencing, sensors logging, battery monitoring, remote controlling, and others. It works right out of the box as vehicle tracker; the only requirement is a SIM card. Important Polaris 2G belongs to Polaris family of board by Fortebit. The lib.fortebit.polaris library is available and can be imported to abstract your Zerynth project from a specific Polaris board.","title":"Polaris 2G"},{"location":"reference/boards/polaris_2g/docs/#pin-mapping","text":"","title":"Pin Mapping"},{"location":"reference/boards/polaris_2g/docs/#flash-layout","text":"The internal flash of the Polaris 2G is organized in one block divided in 256 pages of 2Kb each. The flash memory address starts at 0x8000000 and can be read and written from a Zerynth program using the internal flash module. Warning If internal flash is used in a Zerynth program, it is suggested to begin using pages from the end of flash towards the virtual machine, to minimize the chance of clashes. Since writing to a sector entails erasing it first, the write operation can be slow even for small chunks of data, depending on the size of the choosen sector.","title":"Flash Layout"},{"location":"reference/boards/polaris_2g/docs/#device-summary","text":"Microcontroller: STM32L452 ARM\u00ae32-bit Cortex\u00ae-M4 CPU Operating Voltage: 3.3V Input Voltage: 8-36V Digital I/O Pins (DIO): 69 Analog Input Pins (ADC): 11 UARTs: 4 USB: 1 SPIs: 2 I2Cs: 1 SD Card Slot: 1 SIM Card Slot: 1 MikroBus Click Slot: 1 Flash Memory: 512 KB SRAM: 160 KB Clock Speed: 80 MHz","title":"Device Summary"},{"location":"reference/boards/polaris_2g/docs/#power","text":"On the Polaris 2G the power supply is provided by an external Source: VIN (8V-36V) or through the JST connector for a 3.7/4.2 V backup battery. The power source is selected automatically and when both power supply are provided, the main source can be used to enable charging the backup battery. Note Polaris 2G can be programmed through USB connector or through ST-Link debugger connected to the related JTAG connector. Warning When the device is connected to the PC by USB or by ST-LINK debugger, VUSB and Vcc are not connected as Power supply. External Power Supply or Battery Power Supply must be always provided.","title":"Power"},{"location":"reference/boards/polaris_2g/docs/#connect-register-virtualize-and-program","text":"On Windows machines two set of drivers may be installed: the DFU drivers and the USB serial drivers. This can be done by using the Zadig utility version 2.2 or greater. Use the Zadig utility once with the Polaris 2G in DFU mode (see below) and once after the device has been virtualized. Note Remember to select \u201cOptions > List all devices\u201d to search for the Polaris 2G device. In DFU mode, the VID:PID you should see is 0483:5740 and the Polaris 2G si recognized as \u201cSTM32 BOOTLOADER\u201d. For the virtualized Polaris 2G (DFU MODE) the VID:PID is 0483:DF12. Warning In DFU mode any driver is ok, except Usb CDC; for the virtualized Polaris the only valid driver is Usb CDC. Note It could be necessary to temporarily disable the digitally signed driver enforcement policy of Windows to allow the driver installation. There are good instructions on how to do that in this guide . On MAC OSX and Linux USB drivers are not required. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. If the device is still not recognized or not working, the following udev rules may need to be added: #Polaris 2G Device SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"0483\" , ATTRS { idProduct }== \"5740\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"0483\" , ATTRS { idProduct }== \"df12\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" Once connected to a USB port the Polaris device can be seen as a Virtual Serial port or as a DFU device depending on its virtualized/virtualizable status and it is automatically recognized by Zerynth Studio. The next steps are: Put the Polaris in DFU Mode (Device Firmware Upgrade): Click on \u201cDevice Info\u201d button; Wait until \u201cDevice Management Toolbar\u201d blinks yellow; Select the Polaris on the Device Management Toolbar (Disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note During these operations the Polaris 2G device must be in DFU mode. if the device returns in standard mode, it is necessary to put it in DFU Mode again. After virtualization, the Polaris 2G is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/polaris_2g/docs/#power-management-and-secure-firmware","text":"Power Management feature allows to optimize power consumption by putting the device in low consumption state. Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). Both these features are strongly platform dependent; more information at Power Management - STM32F section and Secure Firmware - STM32F section .","title":"Power Management and Secure Firmware"},{"location":"reference/boards/polaris_3g/docs/","text":"Polaris 3G \u00b6 Polaris 3G provided by Fortebit is a professional GPS/GLONASS vehicle tracker and IoT development platform. The Polaris 3G hardware includes a powerful 32-bit ARM Cortex-M4 controller with low-power features ( STM32L452 ), a GSM/GPRS modem for wireless connectivity, a GPS/GLONASS receiver with Assisted-GPS,on-board accelerometer and SD card socket, mikroBus\u2122 expansion slot, plenty of I/O, and a wide operating temperature range of -35\u00b0C to +80\u00b0C. With Polaris 3G, many IoT applications can be developed related to real-time asset tracking, geo-fencing, sensors logging, battery monitoring, remote controlling, and others. It works right out of the box as vehicle tracker; the only requirement is a SIM card. Important Polaris 3G belongs to Polaris family of board by Fortebit. The lib.fortebit.polaris library is available and can be imported to abstract your Zerynth project from a specific Polaris board. Pin Mapping \u00b6 Flash Layout \u00b6 The internal flash of the Polaris 3G is organized in one block divided in 256 pages of 2Kb each. The flash memory address starts at 0x8000000 and can be read and written from a Zerynth program using the internal flash module. Warning If internal flash is used in a Zerynth program, it is suggested to begin using pages from the end of flash towards the virtual machine, to minimize the chance of clashes. Since writing to a sector entails erasing it first, the write operation can be slow even for small chunks of data, depending on the size of the choosen sector. Device Summary \u00b6 Microcontroller: STM32L452 ARM\u00ae32-bit Cortex\u00ae-M4 CPU Operating Voltage: 3.3V Input Voltage: 8-36V Digital I/O Pins (DIO): 69 Analog Input Pins (ADC): 11 UARTs: 4 USB: 1 SPIs: 2 I2Cs: 1 SD Card Slot: 1 SIM Card Slot: 1 MikroBus Click Slot: 1 Flash Memory: 512 KB SRAM: 160 KB Clock Speed: 80 MHz Power \u00b6 On the Polaris 3G the power supply is provided by an external Source: VIN (8V-36V) or through the JST connector for a 3.7/4.2 V backup battery. The power source is selected automatically and when both power supply are provided, the main source can be used to enable charging the backup battery. Note Polaris 3G can be programmed through USB connector or through ST-Link debugger connected to the related JTAG connector. Warning When the device is connected to the PC by USB or by ST-LINK debugger, VUSB and Vcc are not connected as Power supply. External Power Supply or Battery Power Supply must be always provided. Connect, Register, Virtualize and Program \u00b6 On Windows machines two set of drivers may be installed: the DFU drivers and the USB serial drivers. This can be done by using the Zadig utility version 2.2 or greater. Use the Zadig utility once with the Polaris 3G in DFU mode (see below) and once after the device has been virtualized. Note Remember to select \u201cOptions > List all devices\u201d to search for the Polaris 3G device. In DFU mode, the VID:PID you should see is 0483:5740 and the Polaris 3G si recognized as \u201cSTM32 BOOTLOADER\u201d. For the virtualized Polaris 3G (DFU MODE) the VID:PID is 0483:DF12. Warning In DFU mode any driver is ok, except Usb CDC; for the virtualized Polaris the only valid driver is Usb CDC. Note It could be necessary to temporarily disable the digitally signed driver enforcement policy of Windows to allow the driver installation. There are good instructions on how to do that in this guide . On MAC OSX and Linux USB drivers are not required. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. If the device is still not recognized or not working, the following udev rules may need to be added: #Polaris 3G Device SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"0483\" , ATTRS { idProduct }== \"5740\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"0483\" , ATTRS { idProduct }== \"df12\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" Once connected to a USB port the Polaris device can be seen as a Virtual Serial port or as a DFU device depending on its virtualized/virtualizable status and it is automatically recognized by Zerynth Studio. The next steps are: Put the Polaris in DFU Mode (Device Firmware Upgrade): Click on \u201cDevice Info\u201d button; Wait until \u201cDevice Management Toolbar\u201d blinks yellow; Select the Polaris on the Device Management Toolbar (Disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note During these operations the Polaris 3G device must be in DFU mode. if the device returns in standard mode, it is necessary to put it in DFU Mode again. After virtualization, the Polaris 3G is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Power Management and Secure Firmware \u00b6 Power Management feature allows to optimize power consumption by putting the device in low consumption state. Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). Both these features are strongly platform dependent; more information at Power Management - STM32F section and Secure Firmware - STM32F section .","title":"Polaris 3G"},{"location":"reference/boards/polaris_3g/docs/#polaris-3g","text":"Polaris 3G provided by Fortebit is a professional GPS/GLONASS vehicle tracker and IoT development platform. The Polaris 3G hardware includes a powerful 32-bit ARM Cortex-M4 controller with low-power features ( STM32L452 ), a GSM/GPRS modem for wireless connectivity, a GPS/GLONASS receiver with Assisted-GPS,on-board accelerometer and SD card socket, mikroBus\u2122 expansion slot, plenty of I/O, and a wide operating temperature range of -35\u00b0C to +80\u00b0C. With Polaris 3G, many IoT applications can be developed related to real-time asset tracking, geo-fencing, sensors logging, battery monitoring, remote controlling, and others. It works right out of the box as vehicle tracker; the only requirement is a SIM card. Important Polaris 3G belongs to Polaris family of board by Fortebit. The lib.fortebit.polaris library is available and can be imported to abstract your Zerynth project from a specific Polaris board.","title":"Polaris 3G"},{"location":"reference/boards/polaris_3g/docs/#pin-mapping","text":"","title":"Pin Mapping"},{"location":"reference/boards/polaris_3g/docs/#flash-layout","text":"The internal flash of the Polaris 3G is organized in one block divided in 256 pages of 2Kb each. The flash memory address starts at 0x8000000 and can be read and written from a Zerynth program using the internal flash module. Warning If internal flash is used in a Zerynth program, it is suggested to begin using pages from the end of flash towards the virtual machine, to minimize the chance of clashes. Since writing to a sector entails erasing it first, the write operation can be slow even for small chunks of data, depending on the size of the choosen sector.","title":"Flash Layout"},{"location":"reference/boards/polaris_3g/docs/#device-summary","text":"Microcontroller: STM32L452 ARM\u00ae32-bit Cortex\u00ae-M4 CPU Operating Voltage: 3.3V Input Voltage: 8-36V Digital I/O Pins (DIO): 69 Analog Input Pins (ADC): 11 UARTs: 4 USB: 1 SPIs: 2 I2Cs: 1 SD Card Slot: 1 SIM Card Slot: 1 MikroBus Click Slot: 1 Flash Memory: 512 KB SRAM: 160 KB Clock Speed: 80 MHz","title":"Device Summary"},{"location":"reference/boards/polaris_3g/docs/#power","text":"On the Polaris 3G the power supply is provided by an external Source: VIN (8V-36V) or through the JST connector for a 3.7/4.2 V backup battery. The power source is selected automatically and when both power supply are provided, the main source can be used to enable charging the backup battery. Note Polaris 3G can be programmed through USB connector or through ST-Link debugger connected to the related JTAG connector. Warning When the device is connected to the PC by USB or by ST-LINK debugger, VUSB and Vcc are not connected as Power supply. External Power Supply or Battery Power Supply must be always provided.","title":"Power"},{"location":"reference/boards/polaris_3g/docs/#connect-register-virtualize-and-program","text":"On Windows machines two set of drivers may be installed: the DFU drivers and the USB serial drivers. This can be done by using the Zadig utility version 2.2 or greater. Use the Zadig utility once with the Polaris 3G in DFU mode (see below) and once after the device has been virtualized. Note Remember to select \u201cOptions > List all devices\u201d to search for the Polaris 3G device. In DFU mode, the VID:PID you should see is 0483:5740 and the Polaris 3G si recognized as \u201cSTM32 BOOTLOADER\u201d. For the virtualized Polaris 3G (DFU MODE) the VID:PID is 0483:DF12. Warning In DFU mode any driver is ok, except Usb CDC; for the virtualized Polaris the only valid driver is Usb CDC. Note It could be necessary to temporarily disable the digitally signed driver enforcement policy of Windows to allow the driver installation. There are good instructions on how to do that in this guide . On MAC OSX and Linux USB drivers are not required. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. If the device is still not recognized or not working, the following udev rules may need to be added: #Polaris 3G Device SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"0483\" , ATTRS { idProduct }== \"5740\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"0483\" , ATTRS { idProduct }== \"df12\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" Once connected to a USB port the Polaris device can be seen as a Virtual Serial port or as a DFU device depending on its virtualized/virtualizable status and it is automatically recognized by Zerynth Studio. The next steps are: Put the Polaris in DFU Mode (Device Firmware Upgrade): Click on \u201cDevice Info\u201d button; Wait until \u201cDevice Management Toolbar\u201d blinks yellow; Select the Polaris on the Device Management Toolbar (Disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note During these operations the Polaris 3G device must be in DFU mode. if the device returns in standard mode, it is necessary to put it in DFU Mode again. After virtualization, the Polaris 3G is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/polaris_3g/docs/#power-management-and-secure-firmware","text":"Power Management feature allows to optimize power consumption by putting the device in low consumption state. Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). Both these features are strongly platform dependent; more information at Power Management - STM32F section and Secure Firmware - STM32F section .","title":"Power Management and Secure Firmware"},{"location":"reference/boards/polaris_nbiot/docs/","text":"Polaris NB-IoT \u00b6 Polaris NB-IoT provided by Fortebit is a professional GPS/GLONASS vehicle tracker and IoT development platform. The Polaris NB-IoT hardware includes a powerful 32-bit ARM Cortex-M4 controller with low-power features ( STM32L452 ), a GSM/GPRS modem for wireless connectivity, a GPS/GLONASS receiver with Assisted-GPS,on-board accelerometer and SD card socket, mikroBus\u2122 expansion slot, plenty of I/O, and a wide operating temperature range of -35\u00b0C to +80\u00b0C. With Polaris NB-IoT, many IoT applications can be developed related to real-time asset tracking, geo-fencing, sensors logging, battery monitoring, remote controlling, and others. It works right out of the box as vehicle tracker; the only requirement is a SIM card. Important Polaris NB-IoT belongs to Polaris family of board by Fortebit. The lib.fortebit.polaris library is available and can be imported to abstract your Zerynth project from a specific Polaris board. Pin Mapping \u00b6 Flash Layout \u00b6 The internal flash of the Polaris NB-IoT is organized in one block divided in 256 pages of 2Kb each. The flash memory address starts at 0x8000000 and can be read and written from a Zerynth program using the internal flash module. Warning If internal flash is used in a Zerynth program, it is suggested to begin using pages from the end of flash towards the virtual machine, to minimize the chance of clashes. Since writing to a sector entails erasing it first, the write operation can be slow even for small chunks of data, depending on the size of the choosen sector. Device Summary \u00b6 Microcontroller: STM32L452 ARM\u00ae32-bit Cortex\u00ae-M4 CPU Operating Voltage: 3.3V Input Voltage: 8-36V Digital I/O Pins (DIO): 69 Analog Input Pins (ADC): 11 UARTs: 4 USB: 1 SPIs: 2 I2Cs: 1 SD Card Slot: 1 SIM Card Slot: 1 MikroBus Click Slot: 1 Flash Memory: 512 KB SRAM: 160 KB Clock Speed: 80 MHz Power \u00b6 On the Polaris NB-IoT the power supply is provided by an external Source: VIN (8V-36V) or through the JST connector for a 3.7/4.2 V backup battery. The power source is selected automatically and when both power supply are provided, the main source can be used to enable charging the backup battery. Note Polaris NB-IoT can be programmed through USB connector or through ST-Link debugger connected to the related JTAG connector. Warning When the device is connected to the PC by USB or by ST-LINK debugger, VUSB and Vcc are not connected as Power supply. External Power Supply or Battery Power Supply must be always provided. Connect, Register, Virtualize and Program \u00b6 On Windows machines two set of drivers may be installed: the DFU drivers and the USB serial drivers. This can be done by using the Zadig utility version 2.2 or greater. Use the Zadig utility once with the Polaris NB-IoT in DFU mode (see below) and once after the device has been virtualized. Note Remember to select \u201cOptions > List all devices\u201d to search for the Polaris NB-IoT device. In DFU mode, the VID:PID you should see is 0483:5740 and the Polaris NB-IoT si recognized as \u201cSTM32 BOOTLOADER\u201d. For the virtualized Polaris NB-IoT (DFU MODE) the VID:PID is 0483:DF12. Warning In DFU mode any driver is ok, except Usb CDC; for the virtualized Polaris the only valid driver is Usb CDC. Note It could be necessary to temporarily disable the digitally signed driver enforcement policy of Windows to allow the driver installation. There are good instructions on how to do that in this guide . On MAC OSX and Linux USB drivers are not required. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. If the device is still not recognized or not working, the following udev rules may need to be added: #Polaris NB-IoT Device SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"0483\" , ATTRS { idProduct }== \"5740\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"0483\" , ATTRS { idProduct }== \"df12\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" Once connected to a USB port the Polaris device can be seen as a Virtual Serial port or as a DFU device depending on its virtualized/virtualizable status and it is automatically recognized by Zerynth Studio. The next steps are: Put the Polaris in DFU Mode (Device Firmware Upgrade): Click on \u201cDevice Info\u201d button; Wait until \u201cDevice Management Toolbar\u201d blinks yellow; Select the Polaris on the Device Management Toolbar (Disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note During these operations the Polaris NB-IoT device must be in DFU mode. if the device returns in standard mode, it is necessary to put it in DFU Mode again. After virtualization, the Polaris NB-IoT is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Power Management and Secure Firmware \u00b6 Power Management feature allows to optimize power consumption by putting the device in low consumption state. Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). Both these features are strongly platform dependent; more information at Power Management - STM32F section and Secure Firmware - STM32F section .","title":"Polaris NB-IoT"},{"location":"reference/boards/polaris_nbiot/docs/#polaris-nb-iot","text":"Polaris NB-IoT provided by Fortebit is a professional GPS/GLONASS vehicle tracker and IoT development platform. The Polaris NB-IoT hardware includes a powerful 32-bit ARM Cortex-M4 controller with low-power features ( STM32L452 ), a GSM/GPRS modem for wireless connectivity, a GPS/GLONASS receiver with Assisted-GPS,on-board accelerometer and SD card socket, mikroBus\u2122 expansion slot, plenty of I/O, and a wide operating temperature range of -35\u00b0C to +80\u00b0C. With Polaris NB-IoT, many IoT applications can be developed related to real-time asset tracking, geo-fencing, sensors logging, battery monitoring, remote controlling, and others. It works right out of the box as vehicle tracker; the only requirement is a SIM card. Important Polaris NB-IoT belongs to Polaris family of board by Fortebit. The lib.fortebit.polaris library is available and can be imported to abstract your Zerynth project from a specific Polaris board.","title":"Polaris NB-IoT"},{"location":"reference/boards/polaris_nbiot/docs/#pin-mapping","text":"","title":"Pin Mapping"},{"location":"reference/boards/polaris_nbiot/docs/#flash-layout","text":"The internal flash of the Polaris NB-IoT is organized in one block divided in 256 pages of 2Kb each. The flash memory address starts at 0x8000000 and can be read and written from a Zerynth program using the internal flash module. Warning If internal flash is used in a Zerynth program, it is suggested to begin using pages from the end of flash towards the virtual machine, to minimize the chance of clashes. Since writing to a sector entails erasing it first, the write operation can be slow even for small chunks of data, depending on the size of the choosen sector.","title":"Flash Layout"},{"location":"reference/boards/polaris_nbiot/docs/#device-summary","text":"Microcontroller: STM32L452 ARM\u00ae32-bit Cortex\u00ae-M4 CPU Operating Voltage: 3.3V Input Voltage: 8-36V Digital I/O Pins (DIO): 69 Analog Input Pins (ADC): 11 UARTs: 4 USB: 1 SPIs: 2 I2Cs: 1 SD Card Slot: 1 SIM Card Slot: 1 MikroBus Click Slot: 1 Flash Memory: 512 KB SRAM: 160 KB Clock Speed: 80 MHz","title":"Device Summary"},{"location":"reference/boards/polaris_nbiot/docs/#power","text":"On the Polaris NB-IoT the power supply is provided by an external Source: VIN (8V-36V) or through the JST connector for a 3.7/4.2 V backup battery. The power source is selected automatically and when both power supply are provided, the main source can be used to enable charging the backup battery. Note Polaris NB-IoT can be programmed through USB connector or through ST-Link debugger connected to the related JTAG connector. Warning When the device is connected to the PC by USB or by ST-LINK debugger, VUSB and Vcc are not connected as Power supply. External Power Supply or Battery Power Supply must be always provided.","title":"Power"},{"location":"reference/boards/polaris_nbiot/docs/#connect-register-virtualize-and-program","text":"On Windows machines two set of drivers may be installed: the DFU drivers and the USB serial drivers. This can be done by using the Zadig utility version 2.2 or greater. Use the Zadig utility once with the Polaris NB-IoT in DFU mode (see below) and once after the device has been virtualized. Note Remember to select \u201cOptions > List all devices\u201d to search for the Polaris NB-IoT device. In DFU mode, the VID:PID you should see is 0483:5740 and the Polaris NB-IoT si recognized as \u201cSTM32 BOOTLOADER\u201d. For the virtualized Polaris NB-IoT (DFU MODE) the VID:PID is 0483:DF12. Warning In DFU mode any driver is ok, except Usb CDC; for the virtualized Polaris the only valid driver is Usb CDC. Note It could be necessary to temporarily disable the digitally signed driver enforcement policy of Windows to allow the driver installation. There are good instructions on how to do that in this guide . On MAC OSX and Linux USB drivers are not required. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. If the device is still not recognized or not working, the following udev rules may need to be added: #Polaris NB-IoT Device SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"0483\" , ATTRS { idProduct }== \"5740\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"0483\" , ATTRS { idProduct }== \"df12\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" Once connected to a USB port the Polaris device can be seen as a Virtual Serial port or as a DFU device depending on its virtualized/virtualizable status and it is automatically recognized by Zerynth Studio. The next steps are: Put the Polaris in DFU Mode (Device Firmware Upgrade): Click on \u201cDevice Info\u201d button; Wait until \u201cDevice Management Toolbar\u201d blinks yellow; Select the Polaris on the Device Management Toolbar (Disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note During these operations the Polaris NB-IoT device must be in DFU mode. if the device returns in standard mode, it is necessary to put it in DFU Mode again. After virtualization, the Polaris NB-IoT is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/polaris_nbiot/docs/#power-management-and-secure-firmware","text":"Power Management feature allows to optimize power consumption by putting the device in low consumption state. Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). Both these features are strongly platform dependent; more information at Power Management - STM32F section and Secure Firmware - STM32F section .","title":"Power Management and Secure Firmware"},{"location":"reference/boards/psoc6wifibt_pioneerkit/docs/","text":"PSoC6 WiFi-Bt Pioneer Kit \u00b6 The PSoC 6 MCU is Cypress\u2019 latest, ultra-low-power PSoC specifically designed for wearables and IoT products. It is a programmable embedded system-on-chip, integrating a 150-MHz Arm \u00aeCortex \u00ae -M4 as the primary application processor, a 100-MHz CM0+ that supports low-power operations, up to 1 MB Flash and 288 KB SRAM, CapSense \u00ae touch-sensing, and programmable analog and digital peripherals that allow higher flexibility, in-field tuning of the design, and faster time-to-market. The PSoC 6 WiFi-BT Pioneer board features a PSoC 6 MCU , a 512-Mb NOR flash, an onboard programmer/debugger (KitProg2), a 2.4-GHz WLAN and Bluetooth functionality module (CYW4343W), a USB Type-C power delivery system (EZ-PDTM CCG3), a five-segment CapSense slider, two CapSense buttons, one CapSense proximity sensing header, an RGB LED, two user LEDs, USB host and device features, and one push button. The board supports operating voltages from 1.8 V to 3.3 V for the PSoC 6 MCU. More info can be found here . Pin Mapping \u00b6 Official reference for PSoC6 WiFi-Bt Pioneer Kit can be found here . Flash Layout \u00b6 The internal flash of the PSoC6 WiFi-Bt Pioneer Kit is organized into a bank of 1 MB. The memory bank is divided into 2048 pages of 512 bytes each. The flash memory starts at 0x10000000 address but up to 0x10002000 is reserved for the CM0+ microcontroller; Addresses from 0x10002000 to 0x10002200 are used by the Zerynth Virtual Machine runtime. Addresses from 0x10002200 are used to store bytecode and can be read and written from a Zerynth program using the internal flash module. The bytecode always starts at the address 0x10002200 and ends depending on its size. If internal flash has to be used in a Zerynth program, it is recommended to start using pages after the end of the bytecode, to minimize the chance of clashes. Device Summary \u00b6 Main Microcontroller: ARM 32-bit Cortex\u2122-M4 CPU Core Secondary Microcontroller: ARM 32-bit Cortex\u2122-M0+ Core KitProg2 on-board debugger Operating Voltage: 3.3V Input Voltage: 5V Digital I/O Pins (DIO): 101 Analog Input Pins (ADC): 8 UARTs: 4 SPIs: 4 I2Cs: 4 Flash Memory: 1 MB SRAM: 280 KB Clock Speed: 100MHz Power \u00b6 Power supply can be provided by the host PC through the KitProg2 or USB Device USB ports. Please, refer to the official board documentation for more info. But only the KitProg2 port can be used for programming purposes. Connect, Register, Virtualize and Program \u00b6 Plug the device using the KitProg2 Port which allows to program the PSoC6 MCU using Cypress KitProg2 programmer. Note To successfully program the device, KitProg2 should be put in CMSIS-DAP mode clicking on the MODE SELECT button (only LED4 is turned on within this mode), please refer to the official KitProg2 documentation for more info. Note For Windows Platform : install Cypress Programmer tool, which is available for download here . Note For Linux Platform : the following udev rules may need to be added: # Match KP2 PID/VID SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"04b4\" , ATTRS { idProduct }== \"f148\" , ENV { CY_KP2_PID_VID }= \"f148:04b4\" # Match KP2 CMSIS-DAP SUBSYSTEMS == \"usb\" , ATTRS { interface }== \"KitProg2 CMSIS-DAP\" , ENV { CY_KP2_PID_VID }== \"f148:04b4\" , MODE = \"0666\" The KitProg2 is connected to the PSoC6 SERIAL0 . Once connected the PSoC6 WiFi-Bt Pioneer Kit device is recognized by Zerynth Studio and listed in the Device Management Toolbar . The next steps are: Select the PSoC6 WiFi-Bt Pioneer Kit on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the PSoC6 WiFi-Bt Pioneer Kit device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cuplink\u201d button of Zerynth Studio. Important To exploit the board WiFi capabilities, the lib.murata.lbee5kl1dx library must be imported inside your Zerynth script. Missing features \u00b6 Not all features have been included in the PSoC6 WiFi-Bt Pioneer Kit support. In particular the following are missing: Bluetooth support","title":"PSoC6 WiFi-Bt Pioneer Kit"},{"location":"reference/boards/psoc6wifibt_pioneerkit/docs/#psoc6-wifi-bt-pioneer-kit","text":"The PSoC 6 MCU is Cypress\u2019 latest, ultra-low-power PSoC specifically designed for wearables and IoT products. It is a programmable embedded system-on-chip, integrating a 150-MHz Arm \u00aeCortex \u00ae -M4 as the primary application processor, a 100-MHz CM0+ that supports low-power operations, up to 1 MB Flash and 288 KB SRAM, CapSense \u00ae touch-sensing, and programmable analog and digital peripherals that allow higher flexibility, in-field tuning of the design, and faster time-to-market. The PSoC 6 WiFi-BT Pioneer board features a PSoC 6 MCU , a 512-Mb NOR flash, an onboard programmer/debugger (KitProg2), a 2.4-GHz WLAN and Bluetooth functionality module (CYW4343W), a USB Type-C power delivery system (EZ-PDTM CCG3), a five-segment CapSense slider, two CapSense buttons, one CapSense proximity sensing header, an RGB LED, two user LEDs, USB host and device features, and one push button. The board supports operating voltages from 1.8 V to 3.3 V for the PSoC 6 MCU. More info can be found here .","title":"PSoC6 WiFi-Bt Pioneer Kit"},{"location":"reference/boards/psoc6wifibt_pioneerkit/docs/#pin-mapping","text":"Official reference for PSoC6 WiFi-Bt Pioneer Kit can be found here .","title":"Pin Mapping"},{"location":"reference/boards/psoc6wifibt_pioneerkit/docs/#flash-layout","text":"The internal flash of the PSoC6 WiFi-Bt Pioneer Kit is organized into a bank of 1 MB. The memory bank is divided into 2048 pages of 512 bytes each. The flash memory starts at 0x10000000 address but up to 0x10002000 is reserved for the CM0+ microcontroller; Addresses from 0x10002000 to 0x10002200 are used by the Zerynth Virtual Machine runtime. Addresses from 0x10002200 are used to store bytecode and can be read and written from a Zerynth program using the internal flash module. The bytecode always starts at the address 0x10002200 and ends depending on its size. If internal flash has to be used in a Zerynth program, it is recommended to start using pages after the end of the bytecode, to minimize the chance of clashes.","title":"Flash Layout"},{"location":"reference/boards/psoc6wifibt_pioneerkit/docs/#device-summary","text":"Main Microcontroller: ARM 32-bit Cortex\u2122-M4 CPU Core Secondary Microcontroller: ARM 32-bit Cortex\u2122-M0+ Core KitProg2 on-board debugger Operating Voltage: 3.3V Input Voltage: 5V Digital I/O Pins (DIO): 101 Analog Input Pins (ADC): 8 UARTs: 4 SPIs: 4 I2Cs: 4 Flash Memory: 1 MB SRAM: 280 KB Clock Speed: 100MHz","title":"Device Summary"},{"location":"reference/boards/psoc6wifibt_pioneerkit/docs/#power","text":"Power supply can be provided by the host PC through the KitProg2 or USB Device USB ports. Please, refer to the official board documentation for more info. But only the KitProg2 port can be used for programming purposes.","title":"Power"},{"location":"reference/boards/psoc6wifibt_pioneerkit/docs/#connect-register-virtualize-and-program","text":"Plug the device using the KitProg2 Port which allows to program the PSoC6 MCU using Cypress KitProg2 programmer. Note To successfully program the device, KitProg2 should be put in CMSIS-DAP mode clicking on the MODE SELECT button (only LED4 is turned on within this mode), please refer to the official KitProg2 documentation for more info. Note For Windows Platform : install Cypress Programmer tool, which is available for download here . Note For Linux Platform : the following udev rules may need to be added: # Match KP2 PID/VID SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"04b4\" , ATTRS { idProduct }== \"f148\" , ENV { CY_KP2_PID_VID }= \"f148:04b4\" # Match KP2 CMSIS-DAP SUBSYSTEMS == \"usb\" , ATTRS { interface }== \"KitProg2 CMSIS-DAP\" , ENV { CY_KP2_PID_VID }== \"f148:04b4\" , MODE = \"0666\" The KitProg2 is connected to the PSoC6 SERIAL0 . Once connected the PSoC6 WiFi-Bt Pioneer Kit device is recognized by Zerynth Studio and listed in the Device Management Toolbar . The next steps are: Select the PSoC6 WiFi-Bt Pioneer Kit on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the PSoC6 WiFi-Bt Pioneer Kit device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cuplink\u201d button of Zerynth Studio. Important To exploit the board WiFi capabilities, the lib.murata.lbee5kl1dx library must be imported inside your Zerynth script.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/psoc6wifibt_pioneerkit/docs/#missing-features","text":"Not all features have been included in the PSoC6 WiFi-Bt Pioneer Kit support. In particular the following are missing: Bluetooth support","title":"Missing features"},{"location":"reference/boards/pycom_fipy_v1/docs/","text":"Pycom FiPy 1.0 \u00b6 FiPy 1.0 is a low-power consumption development hardware designed for Internet of Things (IoT) by Pycom. Pycom Fipy 1.0 integrates WiFi, Bluetooth, LoRa, Sigfox and dual LTE-M (CAT M1 and NBIoT) in one tiny board (same small foot-print as WiPy). Pycom Fipy 1.0 features a Dual-Core ESP32 microcontroller , which supports Wi-Fi &Bluetooth dual-mode communication. Warning To be programmed, the Pycom Fipy 1.0 device needs the related expansion board or shields that expose its serial port (expansion board and shields available can be found here ). Pin Mapping \u00b6 Official reference for Pycom Fipy 1.0 can be found here . Flash Layout \u00b6 The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved 0x00392000 4Mb Free for user storage For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved 0x00392000 4Mb Free for user storage Device Summary \u00b6 Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 5.5 to 3.3 V Digital I/O Pins (DIO): 31 Analog Input Pins (ADC): 7 Analog Outputs Pins (DAC): 2 UARTs: 3 SPIs: 2 I2Cs: 3 Flash Memory: 8 MB SRAM: 4MB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks Power \u00b6 Power to the Pycom Fipy 1.0 is supplied directly via the \u201cVIN\u201d pin (5.5 V max voltage). Connecting it to one of available Pycom Expansion Board / Shields, it is possible to power up the device throught the USB Micro B connector or throught the battery connector (3.7/4.2 V Li-Po battery). The power source is selected automatically and, if both power sources are provided, battery charge system will be enabled. The device can operate on an external supply voltage of 3.3 to 5.5 volts. If using more than 5.5V, the voltage regulator may overheat and damage the device. Connect, Register, Virtualize and Program \u00b6 The Pycom Fipy 1.0 needs the related Pycom Expansion Board or Shields to be programmed. The Pycom Expansion Board comes with the FT234XD Serial-to-usb chip on-board that allows opening the UART of the ESP32 chip. Drivers may be needed depending on your system (Mac or Windows) and can be download from here . The Pycom Shields, instead, feature an USB to serial converter that should work out of the box for Windows 8/10/+, Mac and Linux platforms; for Windows 7 platform, drivers must be installed and can be found here . Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the Pycom Fipy 1.0 device is recognized by Zerynth Studio. The next steps are: Select the Pycom Fipy 1.0 on the Device Management Toolbar (disambiguate if necessary); Put the Pycom Fipy 1.0 in Download Mode (Boot mode): Open the Serial Monitor; Connect a jumper between GND and D0; Press Reset on-board button; ESP32 SDK messages must appear on the serial monitor, confirming that the device is in \u201cDownload mode\u201d; Remove the jumper and Close the serial monitor; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note During the Registration procedure, press the Reset on-board button when asked. Important To put the Pycom device in \u201cDownload Mode\u201d, a jumper between GND and D0 pin must be connected. GND and D0 pins are available in 2 different ways according to the expansion board or shield used to program the Pycom device: Pycom Expansion Board \u2013> GND and D0 pins are available on its parallel headers (see Pin Mapping section); PySense and PyTrack Shields \u2013> GND and D0 are available on their External IO 2x5 Header (pin 1 and pin 5). After virtualization, the Pycom Fipy 1.0 is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked. Important To exploit the Wi-Fi chip functionalities of the Pycom Fipy 1.0, the lib.espressif.esp32net library must be installed and imported on the Zerynth script. Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Pycom Fipy 1.0 device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs. Secure Firmware \u00b6 Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section . Zerynth secure socket \u00b6 To be able to use zerynth secure socket on esp32 boards native_mbedtls: true must be used instead of zerynth_ssl: true in the project.yml file. Missing features \u00b6 Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"Pycom FiPy 1.0"},{"location":"reference/boards/pycom_fipy_v1/docs/#pycom-fipy-10","text":"FiPy 1.0 is a low-power consumption development hardware designed for Internet of Things (IoT) by Pycom. Pycom Fipy 1.0 integrates WiFi, Bluetooth, LoRa, Sigfox and dual LTE-M (CAT M1 and NBIoT) in one tiny board (same small foot-print as WiPy). Pycom Fipy 1.0 features a Dual-Core ESP32 microcontroller , which supports Wi-Fi &Bluetooth dual-mode communication. Warning To be programmed, the Pycom Fipy 1.0 device needs the related expansion board or shields that expose its serial port (expansion board and shields available can be found here ).","title":"Pycom FiPy 1.0"},{"location":"reference/boards/pycom_fipy_v1/docs/#pin-mapping","text":"Official reference for Pycom Fipy 1.0 can be found here .","title":"Pin Mapping"},{"location":"reference/boards/pycom_fipy_v1/docs/#flash-layout","text":"The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved 0x00392000 4Mb Free for user storage For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved 0x00392000 4Mb Free for user storage","title":"Flash Layout"},{"location":"reference/boards/pycom_fipy_v1/docs/#device-summary","text":"Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 5.5 to 3.3 V Digital I/O Pins (DIO): 31 Analog Input Pins (ADC): 7 Analog Outputs Pins (DAC): 2 UARTs: 3 SPIs: 2 I2Cs: 3 Flash Memory: 8 MB SRAM: 4MB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks","title":"Device Summary"},{"location":"reference/boards/pycom_fipy_v1/docs/#power","text":"Power to the Pycom Fipy 1.0 is supplied directly via the \u201cVIN\u201d pin (5.5 V max voltage). Connecting it to one of available Pycom Expansion Board / Shields, it is possible to power up the device throught the USB Micro B connector or throught the battery connector (3.7/4.2 V Li-Po battery). The power source is selected automatically and, if both power sources are provided, battery charge system will be enabled. The device can operate on an external supply voltage of 3.3 to 5.5 volts. If using more than 5.5V, the voltage regulator may overheat and damage the device.","title":"Power"},{"location":"reference/boards/pycom_fipy_v1/docs/#connect-register-virtualize-and-program","text":"The Pycom Fipy 1.0 needs the related Pycom Expansion Board or Shields to be programmed. The Pycom Expansion Board comes with the FT234XD Serial-to-usb chip on-board that allows opening the UART of the ESP32 chip. Drivers may be needed depending on your system (Mac or Windows) and can be download from here . The Pycom Shields, instead, feature an USB to serial converter that should work out of the box for Windows 8/10/+, Mac and Linux platforms; for Windows 7 platform, drivers must be installed and can be found here . Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the Pycom Fipy 1.0 device is recognized by Zerynth Studio. The next steps are: Select the Pycom Fipy 1.0 on the Device Management Toolbar (disambiguate if necessary); Put the Pycom Fipy 1.0 in Download Mode (Boot mode): Open the Serial Monitor; Connect a jumper between GND and D0; Press Reset on-board button; ESP32 SDK messages must appear on the serial monitor, confirming that the device is in \u201cDownload mode\u201d; Remove the jumper and Close the serial monitor; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note During the Registration procedure, press the Reset on-board button when asked. Important To put the Pycom device in \u201cDownload Mode\u201d, a jumper between GND and D0 pin must be connected. GND and D0 pins are available in 2 different ways according to the expansion board or shield used to program the Pycom device: Pycom Expansion Board \u2013> GND and D0 pins are available on its parallel headers (see Pin Mapping section); PySense and PyTrack Shields \u2013> GND and D0 are available on their External IO 2x5 Header (pin 1 and pin 5). After virtualization, the Pycom Fipy 1.0 is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked. Important To exploit the Wi-Fi chip functionalities of the Pycom Fipy 1.0, the lib.espressif.esp32net library must be installed and imported on the Zerynth script.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/pycom_fipy_v1/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Pycom Fipy 1.0 device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs.","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/pycom_fipy_v1/docs/#secure-firmware","text":"Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section .","title":"Secure Firmware"},{"location":"reference/boards/pycom_fipy_v1/docs/#zerynth-secure-socket","text":"To be able to use zerynth secure socket on esp32 boards native_mbedtls: true must be used instead of zerynth_ssl: true in the project.yml file.","title":"Zerynth secure socket"},{"location":"reference/boards/pycom_fipy_v1/docs/#missing-features","text":"Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"Missing features"},{"location":"reference/boards/pycom_wipy_v3/docs/","text":"Pycom WiPy 3.0 \u00b6 WiPy v3.0 is a low-power consumption development hardware designed for Internet of Things (IoT) by Pycom. Pycom WiPy 3.0 integrates a W01 OEM module , which supports Dual-Core Espressif ESP32 chipset and Wi-Fi & Bluetooth dual-mode communication. Warning To be programmed, the Pycom WiPy 3.0 device needs the related expansion board or shields that expose its serial port (expansion board and shields available can be found here ) Pin Mapping \u00b6 Official reference for Pycom WiPy 3.0 can be found here . Flash Layout \u00b6 The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved 0x00392000 4Mb Free for user storage For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved 0x00392000 4Mb Free for user storage Device Summary \u00b6 Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 5.5 to 3.3 V Digital I/O Pins (DIO): 31 Analog Input Pins (ADC): 7 Analog Outputs Pins (DAC): 2 UARTs: 3 SPIs: 2 I2Cs: 3 Flash Memory: 8 MB SRAM: 4MB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks Power \u00b6 Power to the Pycom WiPy 3.0 is supplied directly via the \u201cVIN\u201d pin (5.5 V max voltage). Connecting it to one of available Pycom Expansion Board / Shields, it is possible to power up the device throught the USB Micro B connector or throught the battery connector (3.7/4.2 V Li-Po battery). The power source is selected automatically and, if both power sources are provided, battery charge system will be enabled. The device can operate on an external supply voltage of 3.3 to 5.5 volts. If using more than 5.5V, the voltage regulator may overheat and damage the device. Connect, Register, Virtualize and Program \u00b6 The Pycom WiPy 3.0 needs the related Pycom Expansion Board or Shields to be programmed. The Pycom Expansion Board comes with the FT234XD Serial-to-usb chip on-board that allows opening the UART of the ESP32 chip. Drivers may be needed depending on your system (Mac or Windows) and can be download from here . The Pycom Shields, instead, feature an USB to serial converter that should work out of the box for Windows 8/10/+, Mac and Linux platforms; for Windows 7 platform, drivers must be installed and can be found here . Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the Pycom WiPy 3.0 device is recognized by Zerynth Studio. The next steps are: Select the Pycom WiPy 3.0 on the Device Management Toolbar (disambiguate if necessary); Put the Pycom WiPy 3.0 in Download Mode (Boot mode): Open the Serial Monitor; Connect a jumper between GND and D0; Press Reset on-board button; ESP32 SDK messages must appear on the serial monitor, confirming that the device is in \u201cDownload mode\u201d; Remove the jumper and Close the serial monitor; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note During the Registration procedure, press the Reset on-board button when asked. Important To put the Pycom device in \u201cDownload Mode\u201d, a jumper between GND and D0 pin must be connected. GND and D0 pins are available in 2 different ways according to the expansion board or shield used to program the Pycom device: Pycom Expansion Board \u2013> GND and D0 pins are available on its parallel headers (see Pin Mapping section); PySense and PyTrack Shields \u2013> GND and D0 are available on their External IO 2x5 Header (pin 1 and pin 5). After virtualization, the Pycom WiPy 3.0 is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked. Important To exploit the Wi-Fi chip functionalities of the Pycom WiPy 3.0, the lib.espressif.esp32net library must be installed and imported on the Zerynth script. Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Pycom WiPy 3.0 device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs. Secure Firmware \u00b6 Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section. zerynth secure socket \u00b6 To be able to use zerynth secure socket on esp32 boards native_mbedtls: true must be used instead of zerynth_ssl: true in the project.yml file. Missing features \u00b6 Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"Pycom WiPy 3.0"},{"location":"reference/boards/pycom_wipy_v3/docs/#pycom-wipy-30","text":"WiPy v3.0 is a low-power consumption development hardware designed for Internet of Things (IoT) by Pycom. Pycom WiPy 3.0 integrates a W01 OEM module , which supports Dual-Core Espressif ESP32 chipset and Wi-Fi & Bluetooth dual-mode communication. Warning To be programmed, the Pycom WiPy 3.0 device needs the related expansion board or shields that expose its serial port (expansion board and shields available can be found here )","title":"Pycom WiPy 3.0"},{"location":"reference/boards/pycom_wipy_v3/docs/#pin-mapping","text":"Official reference for Pycom WiPy 3.0 can be found here .","title":"Pin Mapping"},{"location":"reference/boards/pycom_wipy_v3/docs/#flash-layout","text":"The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved 0x00392000 4Mb Free for user storage For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved 0x00392000 4Mb Free for user storage","title":"Flash Layout"},{"location":"reference/boards/pycom_wipy_v3/docs/#device-summary","text":"Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 5.5 to 3.3 V Digital I/O Pins (DIO): 31 Analog Input Pins (ADC): 7 Analog Outputs Pins (DAC): 2 UARTs: 3 SPIs: 2 I2Cs: 3 Flash Memory: 8 MB SRAM: 4MB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks","title":"Device Summary"},{"location":"reference/boards/pycom_wipy_v3/docs/#power","text":"Power to the Pycom WiPy 3.0 is supplied directly via the \u201cVIN\u201d pin (5.5 V max voltage). Connecting it to one of available Pycom Expansion Board / Shields, it is possible to power up the device throught the USB Micro B connector or throught the battery connector (3.7/4.2 V Li-Po battery). The power source is selected automatically and, if both power sources are provided, battery charge system will be enabled. The device can operate on an external supply voltage of 3.3 to 5.5 volts. If using more than 5.5V, the voltage regulator may overheat and damage the device.","title":"Power"},{"location":"reference/boards/pycom_wipy_v3/docs/#connect-register-virtualize-and-program","text":"The Pycom WiPy 3.0 needs the related Pycom Expansion Board or Shields to be programmed. The Pycom Expansion Board comes with the FT234XD Serial-to-usb chip on-board that allows opening the UART of the ESP32 chip. Drivers may be needed depending on your system (Mac or Windows) and can be download from here . The Pycom Shields, instead, feature an USB to serial converter that should work out of the box for Windows 8/10/+, Mac and Linux platforms; for Windows 7 platform, drivers must be installed and can be found here . Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the Pycom WiPy 3.0 device is recognized by Zerynth Studio. The next steps are: Select the Pycom WiPy 3.0 on the Device Management Toolbar (disambiguate if necessary); Put the Pycom WiPy 3.0 in Download Mode (Boot mode): Open the Serial Monitor; Connect a jumper between GND and D0; Press Reset on-board button; ESP32 SDK messages must appear on the serial monitor, confirming that the device is in \u201cDownload mode\u201d; Remove the jumper and Close the serial monitor; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note During the Registration procedure, press the Reset on-board button when asked. Important To put the Pycom device in \u201cDownload Mode\u201d, a jumper between GND and D0 pin must be connected. GND and D0 pins are available in 2 different ways according to the expansion board or shield used to program the Pycom device: Pycom Expansion Board \u2013> GND and D0 pins are available on its parallel headers (see Pin Mapping section); PySense and PyTrack Shields \u2013> GND and D0 are available on their External IO 2x5 Header (pin 1 and pin 5). After virtualization, the Pycom WiPy 3.0 is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked. Important To exploit the Wi-Fi chip functionalities of the Pycom WiPy 3.0, the lib.espressif.esp32net library must be installed and imported on the Zerynth script.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/pycom_wipy_v3/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Pycom WiPy 3.0 device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs.","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/pycom_wipy_v3/docs/#secure-firmware","text":"Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section.","title":"Secure Firmware"},{"location":"reference/boards/pycom_wipy_v3/docs/#zerynth-secure-socket","text":"To be able to use zerynth secure socket on esp32 boards native_mbedtls: true must be used instead of zerynth_ssl: true in the project.yml file.","title":"zerynth secure socket"},{"location":"reference/boards/pycom_wipy_v3/docs/#missing-features","text":"Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"Missing features"},{"location":"reference/boards/redbear_blend2/docs/","text":"RedBear Blend 2 \u00b6 The RedBear Blend 2 is a microcontroller board based on the Nordic NRF52832 Cortex-M4F MCU . It is a \u201cfull-size\u201d Arduino compatible board which supports most shields. It has on board a Cortex-M3 MCU that supports DAPLink, slot for Apple MFi coprocessor and two Grove connectors. Pin Mapping \u00b6 Flash Layout \u00b6 The internal flash of the NRF52832 is organized as a single bank of 512Kb, with pages of 4Kb each. The flash begins at address 0x00000. Board Summary \u00b6 Microcontroller: NRF52832 Operating Voltage: 3.3V Digital I/O Pins (DIO): 23 Analog Input Pins (ADC): 7 Analog Outputs Pins (DAC): 0 UARTs: 1 SPIs: 2 I2Cs: 2 Flash Memory: 512 Kb SRAM: 64 Kb Clock Speed: 64 MHz Size (LxW mm): 69.0 x 53.0 Power \u00b6 The RedBear Blend 2 can be powered via the USB connector or with an external power supply. The power source is selected automatically. External (non-USB) power can come either from an AC-to-DC adapter (such as a wall-wart) or battery, and can be connected using a 2.1mm center-positive plug connected to the board\u2019s power jack, or directly to the GND and VIN pins. Connect, Virtualize and Program \u00b6 The RedBear Blend 2 has an on-board DAP Link circuitry that exposes three USB interfaces: A serial port over USB A mass storage device for drag-n-drop programming flash memory A DAP compliant debug channel DAP Link should be supported natively by all platforms. Once connected to a USB port, the RedBear Blend 2 board is recognized by Zerynth Studio. The board can be virtualized by clicking the related Studio button without requiring any other user intervention. Follow these steps to uplink a Zerynth script on a virtualized RedBear Blend 2: Select the Blend 2 on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. After virtualization, the device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked. Important To exploit the BLE chip functionalities of the Blend 2, the lib.nordic.nrf52_ble library must be installed and imported on the Zerynth script. Moreover, in the creation phase, a VM with BLE support must be selected.","title":"RedBear Blend 2"},{"location":"reference/boards/redbear_blend2/docs/#redbear-blend-2","text":"The RedBear Blend 2 is a microcontroller board based on the Nordic NRF52832 Cortex-M4F MCU . It is a \u201cfull-size\u201d Arduino compatible board which supports most shields. It has on board a Cortex-M3 MCU that supports DAPLink, slot for Apple MFi coprocessor and two Grove connectors. Pin Mapping \u00b6","title":"RedBear Blend 2"},{"location":"reference/boards/redbear_blend2/docs/#flash-layout","text":"The internal flash of the NRF52832 is organized as a single bank of 512Kb, with pages of 4Kb each. The flash begins at address 0x00000.","title":"Flash Layout"},{"location":"reference/boards/redbear_blend2/docs/#board-summary","text":"Microcontroller: NRF52832 Operating Voltage: 3.3V Digital I/O Pins (DIO): 23 Analog Input Pins (ADC): 7 Analog Outputs Pins (DAC): 0 UARTs: 1 SPIs: 2 I2Cs: 2 Flash Memory: 512 Kb SRAM: 64 Kb Clock Speed: 64 MHz Size (LxW mm): 69.0 x 53.0","title":"Board Summary"},{"location":"reference/boards/redbear_blend2/docs/#power","text":"The RedBear Blend 2 can be powered via the USB connector or with an external power supply. The power source is selected automatically. External (non-USB) power can come either from an AC-to-DC adapter (such as a wall-wart) or battery, and can be connected using a 2.1mm center-positive plug connected to the board\u2019s power jack, or directly to the GND and VIN pins.","title":"Power"},{"location":"reference/boards/redbear_blend2/docs/#connect-virtualize-and-program","text":"The RedBear Blend 2 has an on-board DAP Link circuitry that exposes three USB interfaces: A serial port over USB A mass storage device for drag-n-drop programming flash memory A DAP compliant debug channel DAP Link should be supported natively by all platforms. Once connected to a USB port, the RedBear Blend 2 board is recognized by Zerynth Studio. The board can be virtualized by clicking the related Studio button without requiring any other user intervention. Follow these steps to uplink a Zerynth script on a virtualized RedBear Blend 2: Select the Blend 2 on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. After virtualization, the device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked. Important To exploit the BLE chip functionalities of the Blend 2, the lib.nordic.nrf52_ble library must be installed and imported on the Zerynth script. Moreover, in the creation phase, a VM with BLE support must be selected.","title":"Connect, Virtualize and Program"},{"location":"reference/boards/redbear_nano2/docs/","text":"RedBear Nano 2 \u00b6 The RedBear Nano 2 is a microcontroller board based on the Nordic NRF52832 Cortex-M4F MCU . It is a tiny board based on the MB-N2 module by RedBear with an U.FL connector for externak NFC antenna. Pin Mapping \u00b6 Flash Layout \u00b6 The internal flash of the NRF52832 is organized as a single bank of 512Kb, with pages of 4Kb each. The flash begins at address 0x00000. Board Summary \u00b6 Microcontroller: NRF52832 Operating Voltage: 3.3V Digital I/O Pins (DIO): 12 Analog Input Pins (ADC): 6 Analog Outputs Pins (DAC): 0 UARTs: 1 SPIs: 1 I2Cs: 1 Flash Memory: 512 Kb SRAM: 64 Kb Clock Speed: 64 MHz Size (LxW mm): 18.0 x 21.0 Power \u00b6 The RedBear Nano 2 can be powered via the USB connector of the companion DAP Link adapter or with an external power supply. Connect, Virtualize and Program \u00b6 The RedBear Nano 2 can be programmed through the companion DAP Link adapter that exposes three USB interfaces: A serial port over USB A mass storage device for drag-n-drop programming flash memory A DAP compliant debug channel DAP Link should be supported natively by all platforms. Once connected to a USB port, the RedBear Nano 2 + DAP Link board is recognized by Zerynth Studio. The board can be virtualized by clicking the related Studio button without requiring any other user intervention. Follow these steps to uplink a Zerynth script on a virtualized RedBear Nano 2: Select the Nano 2 on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. After virtualization, the device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked. Important To exploit the BLE chip functionalities of the Nano 2, the lib.nordic.nrf52_ble library must be installed and imported on the Zerynth script. Moreover, in the creation phase, a VM with BLE support must be selected.","title":"RedBear Nano 2"},{"location":"reference/boards/redbear_nano2/docs/#redbear-nano-2","text":"The RedBear Nano 2 is a microcontroller board based on the Nordic NRF52832 Cortex-M4F MCU . It is a tiny board based on the MB-N2 module by RedBear with an U.FL connector for externak NFC antenna.","title":"RedBear Nano 2"},{"location":"reference/boards/redbear_nano2/docs/#pin-mapping","text":"","title":"Pin Mapping"},{"location":"reference/boards/redbear_nano2/docs/#flash-layout","text":"The internal flash of the NRF52832 is organized as a single bank of 512Kb, with pages of 4Kb each. The flash begins at address 0x00000.","title":"Flash Layout"},{"location":"reference/boards/redbear_nano2/docs/#board-summary","text":"Microcontroller: NRF52832 Operating Voltage: 3.3V Digital I/O Pins (DIO): 12 Analog Input Pins (ADC): 6 Analog Outputs Pins (DAC): 0 UARTs: 1 SPIs: 1 I2Cs: 1 Flash Memory: 512 Kb SRAM: 64 Kb Clock Speed: 64 MHz Size (LxW mm): 18.0 x 21.0","title":"Board Summary"},{"location":"reference/boards/redbear_nano2/docs/#power","text":"The RedBear Nano 2 can be powered via the USB connector of the companion DAP Link adapter or with an external power supply.","title":"Power"},{"location":"reference/boards/redbear_nano2/docs/#connect-virtualize-and-program","text":"The RedBear Nano 2 can be programmed through the companion DAP Link adapter that exposes three USB interfaces: A serial port over USB A mass storage device for drag-n-drop programming flash memory A DAP compliant debug channel DAP Link should be supported natively by all platforms. Once connected to a USB port, the RedBear Nano 2 + DAP Link board is recognized by Zerynth Studio. The board can be virtualized by clicking the related Studio button without requiring any other user intervention. Follow these steps to uplink a Zerynth script on a virtualized RedBear Nano 2: Select the Nano 2 on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. After virtualization, the device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked. Important To exploit the BLE chip functionalities of the Nano 2, the lib.nordic.nrf52_ble library must be installed and imported on the Zerynth script. Moreover, in the creation phase, a VM with BLE support must be selected.","title":"Connect, Virtualize and Program"},{"location":"reference/boards/renesas_pks5d9/docs/","text":"Renesas PK-S5D9 \u00b6 The PK-S5D9 is a single-board kit for the Renesas Synergy S5D9 Group Microcontrollers (MCUs), with a 176-pin LQFP package. The board provides easy-to-access interfaces to the peripherals of the S5D9 Group MCUs for application development. The PK-S5D9 includes four header connectors for direct access to the I/O pins in the MCU, and connectors for USB, Ethernet, RS-232/485, and CAN. The PK-S5D9 incorporates a 2.4-in. QVGA (240 x 320) TFT display with capacitive touch screen.As a promotion kit, the PK-S5D9 is designed to demonstrate the main features of the Synergy Platform using the S5D9 Group MCUs. This is an initial evaluation platform that you can use to determine which kit is appropriate for further development of your product. Pin Mapping \u00b6 Renesas PK-S5D9 official manual is available here Flash Layout \u00b6 The internal flash of the Renesas PK-S5D9 is organized into one bank of 2Mb with 70 total sectors of different size according to the following table: Start address Size Content 0x00000000 8Kb Reserved 0x00002000 8Kb Reserved 0x00004000 8Kb Reserved 0x00006000 8Kb Reserved 0x00008000 8Kb Reserved 0x0000a000 8Kb Reserved 0x0000c000 8Kb Reserved 0x0000e000 8Kb Reserved 0x00010000 32Kb Reserved 0x00018000 32Kb Reserved 0x00020000 32Kb Virtual Machine 0x00028000 32Kb Bytecode Slot 0 0x00030000 32Kb Bytecode Slot 1 0x00038000 32Kb Bytecode Slot 2 ... ... ... 0x001F8000 32Kb Bytecode Slot 59 Device Summary \u00b6 Microcontroller: ARM 32-bit Cortex\u2122-M4 CPU Core Operating Voltage: 3.3V Input Voltage: 5V Digital I/O Pins (DIO): 116 Analog Input Pins (ADC): 13 SPIs: 3 I2Cs: 1 Flash Memory: 2Mb SRAM: 640 Kb Clock Speed: 120MHz Power \u00b6 Power is supplied to the PK-S5D9 through the debug USB connector (J19). The PK-S5D9 requires 5V applied on this interface (USB standard). Once power is supplied, the power supply indicator lights up in green. The MCU digital power supply power consumption can be measured by removing the J31 jumper and measuring the current draw across it. Power consumption for the MCU analog supply requires removing resistor R114 and measuring current across it. Connect, Register, Virtualize and Program \u00b6 The Renesas PK-S5D9 needs an FTDI USB to Serial converter connected to the SERIAL0 (on the Arduino Shield) to be programmed. Once both the FTDI and the Debug Port are connected on USB ports, the PK-S5D9 is recognized by Zerynth Studio and listed in the Device Management Toolbar . The next steps are: Select the Renesas PK-S5D9 on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the PK-S5D9 device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Important A microcnotroller serial port (UART) is not available over the ST-Link interface (mini USB - J19); to visualize serial messages or debug messages over the Zerynth console and to program the device a second USB cable must be connected to the SERIAL0 by the use of an FTDI USB to Serial . Missing features \u00b6 Not all features have been included in the Renesas PK-S5D9 VMs. In particular the following are missing but will be added in the near future: CDC Driver to program the board without an FTDI device LCD Screen Drivers Ethernet Driver CAN Capacitive Touch Interface driver Audio Output","title":"Renesas PK-S5D9"},{"location":"reference/boards/renesas_pks5d9/docs/#renesas-pk-s5d9","text":"The PK-S5D9 is a single-board kit for the Renesas Synergy S5D9 Group Microcontrollers (MCUs), with a 176-pin LQFP package. The board provides easy-to-access interfaces to the peripherals of the S5D9 Group MCUs for application development. The PK-S5D9 includes four header connectors for direct access to the I/O pins in the MCU, and connectors for USB, Ethernet, RS-232/485, and CAN. The PK-S5D9 incorporates a 2.4-in. QVGA (240 x 320) TFT display with capacitive touch screen.As a promotion kit, the PK-S5D9 is designed to demonstrate the main features of the Synergy Platform using the S5D9 Group MCUs. This is an initial evaluation platform that you can use to determine which kit is appropriate for further development of your product.","title":"Renesas PK-S5D9"},{"location":"reference/boards/renesas_pks5d9/docs/#pin-mapping","text":"Renesas PK-S5D9 official manual is available here","title":"Pin Mapping"},{"location":"reference/boards/renesas_pks5d9/docs/#flash-layout","text":"The internal flash of the Renesas PK-S5D9 is organized into one bank of 2Mb with 70 total sectors of different size according to the following table: Start address Size Content 0x00000000 8Kb Reserved 0x00002000 8Kb Reserved 0x00004000 8Kb Reserved 0x00006000 8Kb Reserved 0x00008000 8Kb Reserved 0x0000a000 8Kb Reserved 0x0000c000 8Kb Reserved 0x0000e000 8Kb Reserved 0x00010000 32Kb Reserved 0x00018000 32Kb Reserved 0x00020000 32Kb Virtual Machine 0x00028000 32Kb Bytecode Slot 0 0x00030000 32Kb Bytecode Slot 1 0x00038000 32Kb Bytecode Slot 2 ... ... ... 0x001F8000 32Kb Bytecode Slot 59","title":"Flash Layout"},{"location":"reference/boards/renesas_pks5d9/docs/#device-summary","text":"Microcontroller: ARM 32-bit Cortex\u2122-M4 CPU Core Operating Voltage: 3.3V Input Voltage: 5V Digital I/O Pins (DIO): 116 Analog Input Pins (ADC): 13 SPIs: 3 I2Cs: 1 Flash Memory: 2Mb SRAM: 640 Kb Clock Speed: 120MHz","title":"Device Summary"},{"location":"reference/boards/renesas_pks5d9/docs/#power","text":"Power is supplied to the PK-S5D9 through the debug USB connector (J19). The PK-S5D9 requires 5V applied on this interface (USB standard). Once power is supplied, the power supply indicator lights up in green. The MCU digital power supply power consumption can be measured by removing the J31 jumper and measuring the current draw across it. Power consumption for the MCU analog supply requires removing resistor R114 and measuring current across it.","title":"Power"},{"location":"reference/boards/renesas_pks5d9/docs/#connect-register-virtualize-and-program","text":"The Renesas PK-S5D9 needs an FTDI USB to Serial converter connected to the SERIAL0 (on the Arduino Shield) to be programmed. Once both the FTDI and the Debug Port are connected on USB ports, the PK-S5D9 is recognized by Zerynth Studio and listed in the Device Management Toolbar . The next steps are: Select the Renesas PK-S5D9 on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the PK-S5D9 device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Important A microcnotroller serial port (UART) is not available over the ST-Link interface (mini USB - J19); to visualize serial messages or debug messages over the Zerynth console and to program the device a second USB cable must be connected to the SERIAL0 by the use of an FTDI USB to Serial .","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/renesas_pks5d9/docs/#missing-features","text":"Not all features have been included in the Renesas PK-S5D9 VMs. In particular the following are missing but will be added in the near future: CDC Driver to program the board without an FTDI device LCD Screen Drivers Ethernet Driver CAN Capacitive Touch Interface driver Audio Output","title":"Missing features"},{"location":"reference/boards/renesas_tbs5d5/docs/","text":"Renesas TB-S5D5 \u00b6 The PK-S5D5 is a single-board kit for the Renesas Synergy S5D5 Group Microcontrollers (MCUs). The board provides easy-to-access interfaces to the peripherals of the S5D5 Group MCUs for application development. This is an initial evaluation platform that you can use to determine which kit is appropriate for further development of your product. Pin Mapping \u00b6 Renesas TB-S5D5 user manual is available here Flash Layout \u00b6 The internal flash of the Renesas TB-S5D5 is organized into one bank of 1Mb with 70 total sectors of different size according to the following table: Start address Size Content 0x00000000 8Kb Reserved 0x00002000 8Kb Reserved 0x00004000 8Kb Reserved 0x00006000 8Kb Reserved 0x00008000 8Kb Reserved 0x0000a000 8Kb Reserved 0x0000c000 8Kb Reserved 0x0000e000 8Kb Reserved 0x00010000 32Kb Reserved 0x00018000 32Kb Reserved 0x00020000 32Kb Virtual Machine 0x00028000 32Kb Bytecode Slot 0 0x00030000 32Kb Bytecode Slot 1 0x00038000 32Kb Bytecode Slot 2 ... ... ... 0x001F8000 32Kb Bytecode Slot 59 Device Summary \u00b6 Microcontroller: ARM 32-bit Cortex\u2122-M4 CPU Core Operating Voltage: 3.3V Input Voltage: 5V Digital I/O Pins (DIO): 116 Analog Input Pins (ADC): 13 SPIs: 3 I2Cs: 1 Flash Memory: 2Mb SRAM: 640 Kb Clock Speed: 120MHz Power \u00b6 Power is supplied to the TB-S5D5 through the debug USB connector (J19). The TB-S5D5 requires 5V applied on this interface (USB standard). Once power is supplied, the power supply indicator lights up in green. The MCU digital power supply power consumption can be measured by removing the J31 jumper and measuring the current draw across it. Power consumption for the MCU analog supply requires removing resistor R114 and measuring current across it. Connect, Register, Virtualize and Program \u00b6 The Renesas PK-S5D9 needs an FTDI USB to Serial converter connected to the SERIAL0 (on the Arduino Shield) to be programmed. Once both the FTDI and the Debug Port are connected on USB ports, the TB-S5D5 is recognized by Zerynth Studio and listed in the Device Management Toolbar . The next steps are: Select the Renesas PK-S5D9 on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the PK-S5D9 device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Important A microcnotroller serial port (UART) is not available over the ST-Link interface (mini USB - J19); to visualize serial messages or debug messages over the Zerynth console and to program the device a second USB cable must be connected to the SERIAL0 by the use of an FTDI USB to Serial . Missing features \u00b6 Not all features have been included in the Renesas PK-S5D9 VMs. In particular the following are missing but will be added in the near future: CDC Driver to program the board without an FTDI device LCD Screen Drivers Ethernet Driver CAN Capacitive Touch Interface driver Audio Output","title":"Renesas TB-S5D5"},{"location":"reference/boards/renesas_tbs5d5/docs/#renesas-tb-s5d5","text":"The PK-S5D5 is a single-board kit for the Renesas Synergy S5D5 Group Microcontrollers (MCUs). The board provides easy-to-access interfaces to the peripherals of the S5D5 Group MCUs for application development. This is an initial evaluation platform that you can use to determine which kit is appropriate for further development of your product.","title":"Renesas TB-S5D5"},{"location":"reference/boards/renesas_tbs5d5/docs/#pin-mapping","text":"Renesas TB-S5D5 user manual is available here","title":"Pin Mapping"},{"location":"reference/boards/renesas_tbs5d5/docs/#flash-layout","text":"The internal flash of the Renesas TB-S5D5 is organized into one bank of 1Mb with 70 total sectors of different size according to the following table: Start address Size Content 0x00000000 8Kb Reserved 0x00002000 8Kb Reserved 0x00004000 8Kb Reserved 0x00006000 8Kb Reserved 0x00008000 8Kb Reserved 0x0000a000 8Kb Reserved 0x0000c000 8Kb Reserved 0x0000e000 8Kb Reserved 0x00010000 32Kb Reserved 0x00018000 32Kb Reserved 0x00020000 32Kb Virtual Machine 0x00028000 32Kb Bytecode Slot 0 0x00030000 32Kb Bytecode Slot 1 0x00038000 32Kb Bytecode Slot 2 ... ... ... 0x001F8000 32Kb Bytecode Slot 59","title":"Flash Layout"},{"location":"reference/boards/renesas_tbs5d5/docs/#device-summary","text":"Microcontroller: ARM 32-bit Cortex\u2122-M4 CPU Core Operating Voltage: 3.3V Input Voltage: 5V Digital I/O Pins (DIO): 116 Analog Input Pins (ADC): 13 SPIs: 3 I2Cs: 1 Flash Memory: 2Mb SRAM: 640 Kb Clock Speed: 120MHz","title":"Device Summary"},{"location":"reference/boards/renesas_tbs5d5/docs/#power","text":"Power is supplied to the TB-S5D5 through the debug USB connector (J19). The TB-S5D5 requires 5V applied on this interface (USB standard). Once power is supplied, the power supply indicator lights up in green. The MCU digital power supply power consumption can be measured by removing the J31 jumper and measuring the current draw across it. Power consumption for the MCU analog supply requires removing resistor R114 and measuring current across it.","title":"Power"},{"location":"reference/boards/renesas_tbs5d5/docs/#connect-register-virtualize-and-program","text":"The Renesas PK-S5D9 needs an FTDI USB to Serial converter connected to the SERIAL0 (on the Arduino Shield) to be programmed. Once both the FTDI and the Debug Port are connected on USB ports, the TB-S5D5 is recognized by Zerynth Studio and listed in the Device Management Toolbar . The next steps are: Select the Renesas PK-S5D9 on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the PK-S5D9 device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Important A microcnotroller serial port (UART) is not available over the ST-Link interface (mini USB - J19); to visualize serial messages or debug messages over the Zerynth console and to program the device a second USB cable must be connected to the SERIAL0 by the use of an FTDI USB to Serial .","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/renesas_tbs5d5/docs/#missing-features","text":"Not all features have been included in the Renesas PK-S5D9 VMs. In particular the following are missing but will be added in the near future: CDC Driver to program the board without an FTDI device LCD Screen Drivers Ethernet Driver CAN Capacitive Touch Interface driver Audio Output","title":"Missing features"},{"location":"reference/boards/riverdi_tft50_iotxxx/docs/","text":"Riverdi IoT Display \u00b6 Riverdi IoT Display RiTFT-50-IOT-xxx is a complete HMI solution equipped with Bridgetek\u2019s BT81x embedded video engine (EVE). It aims to provide the best tool for fast development of touchscreen user interfaces. The ESP32 microcontroller allows easy usage of Wi-Fi and Bluetooth, while the BT81x graphics controller simplifies the process of creating user interfaces. The module has a built-in USB bridge for programming the display directly from the PC. Pin Mapping \u00b6 Flash Layout \u00b6 The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE suport. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved Device Summary \u00b6 Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 7-12V 5\u201d TFT display 800\u00d7480 resolution driven by BT815 graphics controller Digital I/O Pins (DIO): 28 Analog Input Pins (ADC): 8 Analog Outputs Pins (DAC): 2 UARTs: 2 SPIs: 1 I2Cs: 1 Flash Memory: 4 MB SRAM: 520 KB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks Power \u00b6 Power to the Riverdi IoT Display is supplied via the on-board USB Micro B connector or directly with external power supply through related connector. Connect, Register, Virtualize and Program \u00b6 The Riverdi IoT Display comes with a serial-to-usb chip on board that allows programming and opening the UART of the ESP32 module. The FT232H FTDI USB to UART chip is also connected to the boot pins of the module, allowing for a seamless virtualization of the device. The FT232H FTDI USB to UART chip should be supported natively by all platforms. If serial port is not correctly seen, VCP (Virtual COM port) drivers can be downloaded from here Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the Riverdi IoT Display is recognized by Zerynth Studio. The next steps are: Select the Riverdi IoT Display on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the Riverdi IoT Display is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for registration and virtualization process. Important To exploit the 5\u201d TFT display 800\u00d7480 resolution driven by BT815 graphics controller, the lib.riverdi.displays library must be installed and imported on the Zerynth script. Important To test a complete IoT Demo App, just create a new Zerynth project using the \u201cclone from Github\u201d feature with this Github repo link . Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Riverdi IoT Display is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs. Secure Firmware \u00b6 Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section . Zerynth secure socket \u00b6 To be able to use zerynth secure socket on esp32 boards native_mbedtls: true must be used instead of zerynth_ssl: true in the project.yml file. Missing features \u00b6 Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"Riverdi IoT Display"},{"location":"reference/boards/riverdi_tft50_iotxxx/docs/#riverdi-iot-display","text":"Riverdi IoT Display RiTFT-50-IOT-xxx is a complete HMI solution equipped with Bridgetek\u2019s BT81x embedded video engine (EVE). It aims to provide the best tool for fast development of touchscreen user interfaces. The ESP32 microcontroller allows easy usage of Wi-Fi and Bluetooth, while the BT81x graphics controller simplifies the process of creating user interfaces. The module has a built-in USB bridge for programming the display directly from the PC.","title":"Riverdi IoT Display"},{"location":"reference/boards/riverdi_tft50_iotxxx/docs/#pin-mapping","text":"","title":"Pin Mapping"},{"location":"reference/boards/riverdi_tft50_iotxxx/docs/#flash-layout","text":"The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE suport. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved","title":"Flash Layout"},{"location":"reference/boards/riverdi_tft50_iotxxx/docs/#device-summary","text":"Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 7-12V 5\u201d TFT display 800\u00d7480 resolution driven by BT815 graphics controller Digital I/O Pins (DIO): 28 Analog Input Pins (ADC): 8 Analog Outputs Pins (DAC): 2 UARTs: 2 SPIs: 1 I2Cs: 1 Flash Memory: 4 MB SRAM: 520 KB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks","title":"Device Summary"},{"location":"reference/boards/riverdi_tft50_iotxxx/docs/#power","text":"Power to the Riverdi IoT Display is supplied via the on-board USB Micro B connector or directly with external power supply through related connector.","title":"Power"},{"location":"reference/boards/riverdi_tft50_iotxxx/docs/#connect-register-virtualize-and-program","text":"The Riverdi IoT Display comes with a serial-to-usb chip on board that allows programming and opening the UART of the ESP32 module. The FT232H FTDI USB to UART chip is also connected to the boot pins of the module, allowing for a seamless virtualization of the device. The FT232H FTDI USB to UART chip should be supported natively by all platforms. If serial port is not correctly seen, VCP (Virtual COM port) drivers can be downloaded from here Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the Riverdi IoT Display is recognized by Zerynth Studio. The next steps are: Select the Riverdi IoT Display on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the Riverdi IoT Display is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for registration and virtualization process. Important To exploit the 5\u201d TFT display 800\u00d7480 resolution driven by BT815 graphics controller, the lib.riverdi.displays library must be installed and imported on the Zerynth script. Important To test a complete IoT Demo App, just create a new Zerynth project using the \u201cclone from Github\u201d feature with this Github repo link .","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/riverdi_tft50_iotxxx/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Riverdi IoT Display is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs.","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/riverdi_tft50_iotxxx/docs/#secure-firmware","text":"Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section .","title":"Secure Firmware"},{"location":"reference/boards/riverdi_tft50_iotxxx/docs/#zerynth-secure-socket","text":"To be able to use zerynth secure socket on esp32 boards native_mbedtls: true must be used instead of zerynth_ssl: true in the project.yml file.","title":"Zerynth secure socket"},{"location":"reference/boards/riverdi_tft50_iotxxx/docs/#missing-features","text":"Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"Missing features"},{"location":"reference/boards/sodaq_explorer/docs/","text":"SODAQ ExpLoRer \u00b6 The ExpLoRer is a development/evaluation tool based on the Atmel SAMD21J18A ARM Cortex-M0+ CPU . intended for the evaluation of Microchip wireless modules in a Research and Development laboratory environment. It is not a Finished Appliance. Manufacturers who integrate ExpLoRer in a Finished Appliance product must take responsibility to follow regulatory guidelines, for example for CE marking. Note All the reported information are extracted from the official SODAQ ExpLoRer page , visit this page for more details and updates. Pin Mapping \u00b6 SODAQ ExpLoRer Official Schematic, Reference Design and Pin Mapping are available on the official SODAQ ExpLoRer page . Flash Layout \u00b6 The internal flash of the SODAQ ExpLoRer is organized as a single bank of 256k. Device Summary \u00b6 Microcontroller: SAMD21 Cortex-M0+ 32bit low power ARM MCU Operating Voltage: 3.3V I/O Pins: 20 Analog Output Pin: 10-bit DAC DC Current per I/O pin: 7 mA LoRa: Microchip RN2483 module Bluetooth: Microchip RN4871 Module Cyptochip: ATECC508A Temperature sensor: MCP9700AT SPIs: 1 I2Cs: 2 UARTs: 1 Flash Memory: 256 KB and 4 MB (External Flash) SRAM: 32 KB Clock Speed: 48 MHz Power \u00b6 The SODAQ ExpLoRer can be powered via the USB connector or with a coin cell battery of 3.6V. The ExpLoRer can run on a battery. By default the ExpLoRer is delivered with a coincell battery. To charge the battery you need to connect an usb and/or solar panel. The ExpLoRer can only run on one battery at the same time, move the jumper to connect the internal (coincell) or external battery. It will only charge the battery connected with this jumper. Connect any 3.3v \u2013 5.2v power to the solar connector, this source will charge to battery. Note Do not short circuit the Li-Ion coin cell or any of the pins of the ExpLoRer because of risk of heat, smoke, and fire. Connect, Register, Virtualize and Program \u00b6 To recognize the device, all Windows (automatic driver software installation), OSX and Linux machines will recognize the device as a COM port automatically. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. If the device is still not recognized or not working, the following udev rules may need to be added: # Check SUBSYSTEM SUBSYSTEMS == \"hidraw\" , KERNEL == \"hidraw*\" , MODE = \"0666\" , GROUP = \"dialout\" # SODAQ ExpLoRer Device SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"2341\" , ATTRS { idProduct }== \"824e\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"2341\" , ATTRS { idProduct }== \"824e\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" Once connected on a USB port the SODAQ ExpLoRer device is recognized by Zerynth Studio. The next steps are: Put the SODAQ ExpLoRer in Virtualization Mode ; Double click on the RST button; Select the SODAQ ExpLoRer Virtualizable on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note During these operations the MKR1000 device must be in Virtualization Mode. if the device returns in standard mode, it is necessary to put it in DFU Mode again. After virtualization, the SODAQ ExpLoRer is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked. Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the SODAQ ExpLoRer device is available for bytecode only. Flash Layout is shown in table below: Start address Size Content 0x00002000 94Kb VM Slot 0x00019600 77Kb Bytecode Slot 0 0x0002CB00 77Kb Bytecode Slot 1 Power Management and Secure Firmware \u00b6 Power Management feature allows to optimize power consumption by putting the device in low consumption state. Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). Both these features are strongly platform dependent; more information at Power Management - Microchip SAMD21 section and Secure Firmware - Microchip SAMD21 section . Missing features \u00b6 Not all features have been included in the SODAQ ExpLoRer support. In particular the following are missing: Bluetooth support","title":"SODAQ ExpLoRer"},{"location":"reference/boards/sodaq_explorer/docs/#sodaq-explorer","text":"The ExpLoRer is a development/evaluation tool based on the Atmel SAMD21J18A ARM Cortex-M0+ CPU . intended for the evaluation of Microchip wireless modules in a Research and Development laboratory environment. It is not a Finished Appliance. Manufacturers who integrate ExpLoRer in a Finished Appliance product must take responsibility to follow regulatory guidelines, for example for CE marking. Note All the reported information are extracted from the official SODAQ ExpLoRer page , visit this page for more details and updates.","title":"SODAQ ExpLoRer"},{"location":"reference/boards/sodaq_explorer/docs/#pin-mapping","text":"SODAQ ExpLoRer Official Schematic, Reference Design and Pin Mapping are available on the official SODAQ ExpLoRer page .","title":"Pin Mapping"},{"location":"reference/boards/sodaq_explorer/docs/#flash-layout","text":"The internal flash of the SODAQ ExpLoRer is organized as a single bank of 256k.","title":"Flash Layout"},{"location":"reference/boards/sodaq_explorer/docs/#device-summary","text":"Microcontroller: SAMD21 Cortex-M0+ 32bit low power ARM MCU Operating Voltage: 3.3V I/O Pins: 20 Analog Output Pin: 10-bit DAC DC Current per I/O pin: 7 mA LoRa: Microchip RN2483 module Bluetooth: Microchip RN4871 Module Cyptochip: ATECC508A Temperature sensor: MCP9700AT SPIs: 1 I2Cs: 2 UARTs: 1 Flash Memory: 256 KB and 4 MB (External Flash) SRAM: 32 KB Clock Speed: 48 MHz","title":"Device Summary"},{"location":"reference/boards/sodaq_explorer/docs/#power","text":"The SODAQ ExpLoRer can be powered via the USB connector or with a coin cell battery of 3.6V. The ExpLoRer can run on a battery. By default the ExpLoRer is delivered with a coincell battery. To charge the battery you need to connect an usb and/or solar panel. The ExpLoRer can only run on one battery at the same time, move the jumper to connect the internal (coincell) or external battery. It will only charge the battery connected with this jumper. Connect any 3.3v \u2013 5.2v power to the solar connector, this source will charge to battery. Note Do not short circuit the Li-Ion coin cell or any of the pins of the ExpLoRer because of risk of heat, smoke, and fire.","title":"Power"},{"location":"reference/boards/sodaq_explorer/docs/#connect-register-virtualize-and-program","text":"To recognize the device, all Windows (automatic driver software installation), OSX and Linux machines will recognize the device as a COM port automatically. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. If the device is still not recognized or not working, the following udev rules may need to be added: # Check SUBSYSTEM SUBSYSTEMS == \"hidraw\" , KERNEL == \"hidraw*\" , MODE = \"0666\" , GROUP = \"dialout\" # SODAQ ExpLoRer Device SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"2341\" , ATTRS { idProduct }== \"824e\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"2341\" , ATTRS { idProduct }== \"824e\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" Once connected on a USB port the SODAQ ExpLoRer device is recognized by Zerynth Studio. The next steps are: Put the SODAQ ExpLoRer in Virtualization Mode ; Double click on the RST button; Select the SODAQ ExpLoRer Virtualizable on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note During these operations the MKR1000 device must be in Virtualization Mode. if the device returns in standard mode, it is necessary to put it in DFU Mode again. After virtualization, the SODAQ ExpLoRer is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/sodaq_explorer/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the SODAQ ExpLoRer device is available for bytecode only. Flash Layout is shown in table below: Start address Size Content 0x00002000 94Kb VM Slot 0x00019600 77Kb Bytecode Slot 0 0x0002CB00 77Kb Bytecode Slot 1","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/sodaq_explorer/docs/#power-management-and-secure-firmware","text":"Power Management feature allows to optimize power consumption by putting the device in low consumption state. Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). Both these features are strongly platform dependent; more information at Power Management - Microchip SAMD21 section and Secure Firmware - Microchip SAMD21 section .","title":"Power Management and Secure Firmware"},{"location":"reference/boards/sodaq_explorer/docs/#missing-features","text":"Not all features have been included in the SODAQ ExpLoRer support. In particular the following are missing: Bluetooth support","title":"Missing features"},{"location":"reference/boards/sony_spresense/docs/","text":"Sony Spresense \u00b6 Spresense is a compact development board based on Sony\u2019s power-efficient multicore microcontroller CXD5602. Integrated GPS - The embedded GNSS with support for GPS, QZSS and GLONASS enables applications where tracking is required. Multicore microcontroller - Spresense is powered by Sony\u2019s CXD5602 microcontroller (ARM\u00ae Cortex\u00ae-M4F \u00d7 6 cores), with a clock speed of 156 MHz. The Spresense consists of two boards: Main board Extension board Pin Mapping \u00b6 Official reference for Sony Spresense can be found here . Device Summary \u00b6 Sony\u2019s CXD5602 Processor (ARM Cortex-M4F) 8 MB Flash memory PCB with small footprint Dedicated camera connector GNSS (GPS) antenna Pins and LEDs Multiple GPIO (UART, SPI, I2C, I2S) 2 ADC channels Application LED x 4 (Green) Power LED (Blue) USB serial port Power \u00b6 The maximum current that can be drained from the Spresense main board micro USB connector is 500mA. This is true also when both the main board and extension board are mounted and have separate USB power connected. In case that the 500mA current from the micro USB connector is not sufficient it is possible to supply more power using the battery terminal CN1 on the main board. The CN1 battery connector\u2019s recommended operating voltage is 3.6 to 4.4V with an absolute maximum voltage of 7V. It is necessary to solder on the main board to mount a battery connector on CN1. More here on the official documentation . Connect, Register, Virtualize and Program \u00b6 The Sony Spresense Main Board comes with a USB to UART bridge on board that allows programming and opening the serial monitor when the board is plugged. Drivers may be needed depending on your system (Mac or Windows) and can be download from the official Sony documentation page. In Linux systems, the Spresense should work out of the box. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected through the Main USB port, if drivers have been correctly installed, the Spresense device is recognized by Zerynth Studio. The next steps are: Select the Spresense on the Device Management Toolbar (disambiguate if necessary); Burn the Spresense Bootloader clicking the \u201cInfo\u201d button, then \u201cBurn Bootloader\u201d; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the Spresense is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process. Extra notes \u00b6 As reported in the previous section, Spresense Bootloader needs to be burnt on Spresense boards as a preliminary operation. SPI modes: when the pin D10 is chosen as Chip Select pin, SPI modes follow the Motorola SPI Frame Format . If an independent CS control is desired, please choose a different CS pin.","title":"Sony Spresense"},{"location":"reference/boards/sony_spresense/docs/#sony-spresense","text":"Spresense is a compact development board based on Sony\u2019s power-efficient multicore microcontroller CXD5602. Integrated GPS - The embedded GNSS with support for GPS, QZSS and GLONASS enables applications where tracking is required. Multicore microcontroller - Spresense is powered by Sony\u2019s CXD5602 microcontroller (ARM\u00ae Cortex\u00ae-M4F \u00d7 6 cores), with a clock speed of 156 MHz. The Spresense consists of two boards: Main board Extension board","title":"Sony Spresense"},{"location":"reference/boards/sony_spresense/docs/#pin-mapping","text":"Official reference for Sony Spresense can be found here .","title":"Pin Mapping"},{"location":"reference/boards/sony_spresense/docs/#device-summary","text":"Sony\u2019s CXD5602 Processor (ARM Cortex-M4F) 8 MB Flash memory PCB with small footprint Dedicated camera connector GNSS (GPS) antenna Pins and LEDs Multiple GPIO (UART, SPI, I2C, I2S) 2 ADC channels Application LED x 4 (Green) Power LED (Blue) USB serial port","title":"Device Summary"},{"location":"reference/boards/sony_spresense/docs/#power","text":"The maximum current that can be drained from the Spresense main board micro USB connector is 500mA. This is true also when both the main board and extension board are mounted and have separate USB power connected. In case that the 500mA current from the micro USB connector is not sufficient it is possible to supply more power using the battery terminal CN1 on the main board. The CN1 battery connector\u2019s recommended operating voltage is 3.6 to 4.4V with an absolute maximum voltage of 7V. It is necessary to solder on the main board to mount a battery connector on CN1. More here on the official documentation .","title":"Power"},{"location":"reference/boards/sony_spresense/docs/#connect-register-virtualize-and-program","text":"The Sony Spresense Main Board comes with a USB to UART bridge on board that allows programming and opening the serial monitor when the board is plugged. Drivers may be needed depending on your system (Mac or Windows) and can be download from the official Sony documentation page. In Linux systems, the Spresense should work out of the box. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected through the Main USB port, if drivers have been correctly installed, the Spresense device is recognized by Zerynth Studio. The next steps are: Select the Spresense on the Device Management Toolbar (disambiguate if necessary); Burn the Spresense Bootloader clicking the \u201cInfo\u201d button, then \u201cBurn Bootloader\u201d; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the Spresense is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/sony_spresense/docs/#extra-notes","text":"As reported in the previous section, Spresense Bootloader needs to be burnt on Spresense boards as a preliminary operation. SPI modes: when the pin D10 is chosen as Chip Select pin, SPI modes follow the Motorola SPI Frame Format . If an independent CS control is desired, please choose a different CS pin.","title":"Extra notes"},{"location":"reference/boards/sparkfun_esp32thing/docs/","text":"Sparkfun ESP32 Thing \u00b6 The Esp32 Thing device is one of the development board created by Sparkfun to evaluate the ESP-WROOM-32 module. It is based on the ESP32 microcontroller that boasts Wifi, Bluetooth, Ethernet and Low Power support all in a single chip. Pin Mapping \u00b6 Official reference for Sparkfun ESP32 Thing can be found here . Flash Layout \u00b6 The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved Device Summary \u00b6 Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 3.7-6V Digital I/O Pins (DIO): 28 Analog Input Pins (ADC): 4 UARTs: 3 SPIs: 1 I2Cs: 1 Flash Memory: 4 MB SRAM: 520 KB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks Power \u00b6 Power to the Sparkfun ESP32 Thing is supplied via the on-board USB Micro B connector or directly throught the connector for a 3.7/4.2 V battery. The power source is selected automatically. If both USB and the LiPo are plugged into the board, the onboard charge controller will charge the LiPo battery at a rate of up to 500mA. Warning The ESP32\u2019s operating voltage range is 2.2 to 3.6V. Under normal operation the ESP32 Thing will power the chip at 3.3V. The I/O pins are not 5V-tolerant! In addition to USB and battery connectors, the VBAT, and VUSB pins are all broken out to both sides of the board. These pins can be used as an alternative supply input to the Thing. The maximum, allowable voltage input to VUSB is 6V, and VBAT should not be connected to anything other than a LiPo battery. Alternatively, if you have a regulated voltage source between 2.2V and 3.6V, the \u201c3V3\u201d lines can be used to directly supply the ESP32 and its peripherals. Connect, Register, Virtualize and Program \u00b6 The Sparkfun ESP32 Thing comes with a serial-to-usb chip on board that allows programming and opening the UART of the ESP32 module. The FTDI FT231x is also connected to the boot pins of the module, allowing for a seamless virtualization of the device. Note Drivers for the FT231x Module can be downloaded here and are needed for Windows and Mac platforms . In Linux systems, the Sparkfun ESP32 Thing should work out of the box. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the Sparkfun ESP32 Thing device is recognized by Zerynth Studio. The next steps are: Select the Sparkfun ESP32 Thing on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the Sparkfun ESP32 Thing is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process. Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Sparkfun ESP32 Thing device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs. Secure Firmware \u00b6 Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section . Missing features \u00b6 Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"Sparkfun ESP32 Thing"},{"location":"reference/boards/sparkfun_esp32thing/docs/#sparkfun-esp32-thing","text":"The Esp32 Thing device is one of the development board created by Sparkfun to evaluate the ESP-WROOM-32 module. It is based on the ESP32 microcontroller that boasts Wifi, Bluetooth, Ethernet and Low Power support all in a single chip.","title":"Sparkfun ESP32 Thing"},{"location":"reference/boards/sparkfun_esp32thing/docs/#pin-mapping","text":"Official reference for Sparkfun ESP32 Thing can be found here .","title":"Pin Mapping"},{"location":"reference/boards/sparkfun_esp32thing/docs/#flash-layout","text":"The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved","title":"Flash Layout"},{"location":"reference/boards/sparkfun_esp32thing/docs/#device-summary","text":"Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 3.7-6V Digital I/O Pins (DIO): 28 Analog Input Pins (ADC): 4 UARTs: 3 SPIs: 1 I2Cs: 1 Flash Memory: 4 MB SRAM: 520 KB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks","title":"Device Summary"},{"location":"reference/boards/sparkfun_esp32thing/docs/#power","text":"Power to the Sparkfun ESP32 Thing is supplied via the on-board USB Micro B connector or directly throught the connector for a 3.7/4.2 V battery. The power source is selected automatically. If both USB and the LiPo are plugged into the board, the onboard charge controller will charge the LiPo battery at a rate of up to 500mA. Warning The ESP32\u2019s operating voltage range is 2.2 to 3.6V. Under normal operation the ESP32 Thing will power the chip at 3.3V. The I/O pins are not 5V-tolerant! In addition to USB and battery connectors, the VBAT, and VUSB pins are all broken out to both sides of the board. These pins can be used as an alternative supply input to the Thing. The maximum, allowable voltage input to VUSB is 6V, and VBAT should not be connected to anything other than a LiPo battery. Alternatively, if you have a regulated voltage source between 2.2V and 3.6V, the \u201c3V3\u201d lines can be used to directly supply the ESP32 and its peripherals.","title":"Power"},{"location":"reference/boards/sparkfun_esp32thing/docs/#connect-register-virtualize-and-program","text":"The Sparkfun ESP32 Thing comes with a serial-to-usb chip on board that allows programming and opening the UART of the ESP32 module. The FTDI FT231x is also connected to the boot pins of the module, allowing for a seamless virtualization of the device. Note Drivers for the FT231x Module can be downloaded here and are needed for Windows and Mac platforms . In Linux systems, the Sparkfun ESP32 Thing should work out of the box. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the Sparkfun ESP32 Thing device is recognized by Zerynth Studio. The next steps are: Select the Sparkfun ESP32 Thing on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the Sparkfun ESP32 Thing is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/sparkfun_esp32thing/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Sparkfun ESP32 Thing device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs.","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/sparkfun_esp32thing/docs/#secure-firmware","text":"Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section .","title":"Secure Firmware"},{"location":"reference/boards/sparkfun_esp32thing/docs/#missing-features","text":"Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"Missing features"},{"location":"reference/boards/sparkfun_esp8266thingdev/docs/","text":"Sparkfun Esp8266 Thing Dev \u00b6 The SparkFun ESP8266 Thing Dev is a development board that has been solely designed around the ESP8266, with an integrated FTDI USB-to-Serial chip. The ESP8266 is a cost-effective, and very capable WiFi-enabled microcontroller. The ESP8266 Thing Development device breaks out all of the module\u2019s pins, and the USB-to-serial converter means you don\u2019t need any peripheral components to program the chip. The device features 512 KB of flash memory, 80MHz of system clock, around 50k of usable RAM and an on chip Wifi Transceiver. Pin Mapping \u00b6 Official reference for Sparkfun Esp8266 Thing Dev can be found here . Flash Layout \u00b6 The Esp8266 Thing Dev features a 512 KB (4 Mb) flash memory organized in sectors of 4k each. The flash memory address starts at 0x40200000 and can be read and written from a Zerynth program using the internal flash module. Warning If flash memory must be used in a Zerynth program, it is recommended to begin using it from secure addresses towards the end the bytecode (start address of the bytecode can be found in the log console of Zerynth Studio during the uplink operation), leaving a minimum safe place to minimize the chance of clashes. Note The internal flash of Sparkfun Esp8266 Thing Dev can be organized in different ways. The standard VM code beginning at 0x0000, followed by the esp8266 ir0m image at 0x20000 and the esp_init_data at 0x3fc000. The VM is based on the Espressif RTOS SDK 1.4.1. Warning As reported in Sparkfun reviews page , the Firmware Over The Air feature is not implementable because of small flash memory size. Device Summary \u00b6 Microcontroller: Tensilica 32-bit RISC CPU Xtensa LX106 Operating Voltage: 3.3V Input Voltage: 2.5-6V Digital I/O Pins (DIO): 11 Analog Input Pins (ADC): 1 UARTs: 2 SPIs: 1 I2Cs: 1 Flash Memory: 512 KB SRAM: 64 KB Clock Speed: 80 Mhz Wi-Fi: IEEE 802.11 b/g/n: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks Power \u00b6 Power to the Esp8266 Thing Dev is supplied via the on-board USB Micro B connector or directly via the \u201cVIN\u201d pin. The power source is selected automatically. Alternatively, it is possible to solder a variety of connectors into the VIN position to run the device on some other power external supply. The device can operate on an external supply of 2.5 to 6 volts. If using more than 6V, the voltage regulator may overheat and damage the device. Note After powering the device, make sure the ON/OFF switch is slid into the \u201cON\u201d position, and you should see the \u201cPWR\u201d LED illuminate. Connect, Register, Virtualize and Program \u00b6 The Sparkfun Esp8266 Thing Dev comes with a serial-to-usb chip on board that allows programming and opening the UART of the Esp8266 module. The FTDI FT231x is also connected to the boot pins of the module, allowing for a seamless virtualization of the device. Note Drivers for the FT231x Module can be downloaded here and are needed for Windows and Mac platforms . In Linux systems, the Sparkfun Esp8266 Thing Dev should work out of the box. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected to a USB port the Sparkfun Esp8266 Thing Dev can be seen as a Virtual Serial port and it is automatically recognized by Zerynth Studio. The next steps are: Select the Sparkfun Esp8266 Thing Dev on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process After virtualization, the Sparkfun Esp8266 Thing Dev is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the upload process. Important To exploit the Wi-Fi chip functionalities of the Sparkfun Esp8266 Thing Dev, the lib.espressif.esp8266wifi library must be installed (some example code is provided). Power Management \u00b6 Power Management feature allows to optimize power consumption by putting the device in low consumption state. More information in Power Management - ESP8266 section .","title":"Sparkfun Esp8266 Thing Dev"},{"location":"reference/boards/sparkfun_esp8266thingdev/docs/#sparkfun-esp8266-thing-dev","text":"The SparkFun ESP8266 Thing Dev is a development board that has been solely designed around the ESP8266, with an integrated FTDI USB-to-Serial chip. The ESP8266 is a cost-effective, and very capable WiFi-enabled microcontroller. The ESP8266 Thing Development device breaks out all of the module\u2019s pins, and the USB-to-serial converter means you don\u2019t need any peripheral components to program the chip. The device features 512 KB of flash memory, 80MHz of system clock, around 50k of usable RAM and an on chip Wifi Transceiver.","title":"Sparkfun Esp8266 Thing Dev"},{"location":"reference/boards/sparkfun_esp8266thingdev/docs/#pin-mapping","text":"Official reference for Sparkfun Esp8266 Thing Dev can be found here .","title":"Pin Mapping"},{"location":"reference/boards/sparkfun_esp8266thingdev/docs/#flash-layout","text":"The Esp8266 Thing Dev features a 512 KB (4 Mb) flash memory organized in sectors of 4k each. The flash memory address starts at 0x40200000 and can be read and written from a Zerynth program using the internal flash module. Warning If flash memory must be used in a Zerynth program, it is recommended to begin using it from secure addresses towards the end the bytecode (start address of the bytecode can be found in the log console of Zerynth Studio during the uplink operation), leaving a minimum safe place to minimize the chance of clashes. Note The internal flash of Sparkfun Esp8266 Thing Dev can be organized in different ways. The standard VM code beginning at 0x0000, followed by the esp8266 ir0m image at 0x20000 and the esp_init_data at 0x3fc000. The VM is based on the Espressif RTOS SDK 1.4.1. Warning As reported in Sparkfun reviews page , the Firmware Over The Air feature is not implementable because of small flash memory size.","title":"Flash Layout"},{"location":"reference/boards/sparkfun_esp8266thingdev/docs/#device-summary","text":"Microcontroller: Tensilica 32-bit RISC CPU Xtensa LX106 Operating Voltage: 3.3V Input Voltage: 2.5-6V Digital I/O Pins (DIO): 11 Analog Input Pins (ADC): 1 UARTs: 2 SPIs: 1 I2Cs: 1 Flash Memory: 512 KB SRAM: 64 KB Clock Speed: 80 Mhz Wi-Fi: IEEE 802.11 b/g/n: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks","title":"Device Summary"},{"location":"reference/boards/sparkfun_esp8266thingdev/docs/#power","text":"Power to the Esp8266 Thing Dev is supplied via the on-board USB Micro B connector or directly via the \u201cVIN\u201d pin. The power source is selected automatically. Alternatively, it is possible to solder a variety of connectors into the VIN position to run the device on some other power external supply. The device can operate on an external supply of 2.5 to 6 volts. If using more than 6V, the voltage regulator may overheat and damage the device. Note After powering the device, make sure the ON/OFF switch is slid into the \u201cON\u201d position, and you should see the \u201cPWR\u201d LED illuminate.","title":"Power"},{"location":"reference/boards/sparkfun_esp8266thingdev/docs/#connect-register-virtualize-and-program","text":"The Sparkfun Esp8266 Thing Dev comes with a serial-to-usb chip on board that allows programming and opening the UART of the Esp8266 module. The FTDI FT231x is also connected to the boot pins of the module, allowing for a seamless virtualization of the device. Note Drivers for the FT231x Module can be downloaded here and are needed for Windows and Mac platforms . In Linux systems, the Sparkfun Esp8266 Thing Dev should work out of the box. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected to a USB port the Sparkfun Esp8266 Thing Dev can be seen as a Virtual Serial port and it is automatically recognized by Zerynth Studio. The next steps are: Select the Sparkfun Esp8266 Thing Dev on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process After virtualization, the Sparkfun Esp8266 Thing Dev is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the upload process. Important To exploit the Wi-Fi chip functionalities of the Sparkfun Esp8266 Thing Dev, the lib.espressif.esp8266wifi library must be installed (some example code is provided).","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/sparkfun_esp8266thingdev/docs/#power-management","text":"Power Management feature allows to optimize power consumption by putting the device in low consumption state. More information in Power Management - ESP8266 section .","title":"Power Management"},{"location":"reference/boards/sparkfun_photon/docs/","text":"SparkFun Photon RedBoard \u00b6 The SparkFun Photon RedBoard is a complete Wi-Fi enabled development platform for creating connected devices with ease. The Photon RedBoard has been based around the P1 Particle Module. The I/O, USB, and power connectors are all broken out to a familiar Arduino shape. The P1 (P-one) is Particle\u2019s tiny Wi-Fi module that contains both the Broadcom BCM43362 Wi-Fi chip and a reprogrammable STM32F205RGY6 32-bit ARM Cortex M3 microcontroller . In addition to having 1MB of internal flash memory for storing the firmware, the SparkFun Photon also features 128KB of Ram, 1MB of extra SPI flash and 120 MHz of clock. Note All the reported information are extracted from the official SparkFun Photon RedBoard reference page , visit this page for more details and updates. Pin Mapping \u00b6 SparkFun Photon RedBoard Official Schematic, Reference Design & Pin Mapping are available on the official SparkFun Photon datasheet page . Flash Layout \u00b6 The internal flash of the SparkFun Photon RedBoard is organized into sectors of different size according to the following table: Start address Size Content 0x8000000 16Kb BootLoader 0x8004000 16Kb DCT1 0x8008000 16Kb DCT2 0x800C000 16Kb EEPROM1 0x8010000 64Kb EEPROM2 0x8020000 128kb Virtual Machine 0x8040000 128kb Bytecode Bank 0 0x8060000 128kb Bytecode Bank 1 0x8080000 128kb Bytecode Bank 2 0x80A0000 128kb Bytecode Bank 3 0x80C0000 128kb Bytecode Bank 4 0x80E0000 128kb Bytecode Bank 5 Important To avoid deleting the SparkFun Photon configuration it is recommended not to write in sectors between 0x8004000 and 0x8020000. Warning If internal flash is used in a Zerynth program, it is recommended to start from pages at the end of flash (bytecode bank 5) towards the virtual machine, to minimize the chance of clashes. Since writing to a sector entails erasing it first, the write operation can be slow even for small chunks of data, depending on the size of the chosen sector. Device Summary \u00b6 Microcontroller: ARM 32-bit Cortex\u2122-M3 CPU Core Operating Voltage: 3.3V Input Voltage: 3.6-6V Digital I/O Pins (DIO): 24 Analog Input Pins (ADC): 5 Analog Outputs Pins (DAC): 2 UARTs: 2 SPIs: 3 I2Cs: 1 CANs: 1 Flash Memory: 1MB SRAM: 128 KB Extra Flash Memory: 1MB Clock Speed: 120Mhz Size (LxW mm): 36.58 X 20.32 Power \u00b6 Power to the SparkFun Photon device is supplied via the on-board USB micro B connector or directly via the VIN pin: If power is supplied directly to the VIN pin, the voltage should be regulated between 3.6VDC and 5.5VDC. If the device is powered via the USB port, VIN will output a voltage of approximately 4.8VDC due to a reverse polarity protection series schottky diode between V+ of USB and VIN. Note When used as an output, the max load current on VIN is 1 Ampere. Typical current consumption is 80mA with a 5V input. Deep sleep quiescent current is 160uA. When powering the SparkFun Photon from the USB connector, make sure to use a quality cable to minimize voltage drops. If a high resistance cable (i.e., low current) is used, peak currents drawn from the SparkFun Photon when transmitting and receiving will result in voltage sag at the input which may cause a system brown out or intermittent operation. Likewise, the power source should be sufficient enough to source 1A of current to be on the safe side. Connect, Register, Virtualize and Program \u00b6 On Windows machines (Windows 10), the SparkFun Photon RedBoard in Standard Mode is automatically recognized as Virtual Serial port; otherwise Particle USB Drivers for SparkFun Photon are required by Zerynth Studio for accessing the serial port establishing a connection with the STM32 UART. To install the drivers on Windows plug the SparkFun Photon on an USB port, download the *.exe package, and follow the installation steps to complete the operation. Note It could be necessary to temporarily disable the digitally signed driver enforcement policy of Windows to allow driver installation. There are good instructions on how to do that in this guide . On MAC OSX and Linux platforms USB drivers are not required. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. If the device is still not recognized or not working, the following udev rules may need to be added: #SparkFun Photon SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"2b04\" , ATTRS { idProduct }== \"d008\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"2b04\" , ATTRS { idProduct }== \"d008\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"2b04\" , ATTRS { idProduct }== \"c008\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"2b04\" , ATTRS { idProduct }== \"c008\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" Once connected on a USB port, if drivers have been correctly installed, the SparkFun Photon RedBoard can be seen as Virtual Serial port and it is automatically recognized by Zerynth Studio and listed in the Device Management Toolbar as \u201cSparkFun Photon RedBoard DFU Mode\u201d if the device is in DFU Mode, otherwise as \u201cSparkFun Photon RedBoard\u201d. To register and virtualize a Photon RedBoard, it is necessary to put the device in DFU Mode (Device Firmware Upgrade). Note On Windows machines it is necessary to install also the SparkFun Photon DFU drivers for virtualizing the device. The official Particle Core DFU driver and the related installation procedure are reported here but they also work for SparkFun Photon RedBoard . Follow these steps to register and virtualize a Photon RedBoard: Put the SparkFun Photon in DFU Mode (Device Firmware Upgrade): Hold down BOTH buttons (reset and mode); Release only the reset button, while holding down the mode button; Wait for the LED to start flashing magenta, then yellow; Release the mode button; the device is now in DFU Mode (yellow blinking led); Select the SparkFun Photon on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create the unique Zerynth Virtual Machine for the connected device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note During these operations the SparkFun Photon device must be in DFU Mode . if the device returns in standard mode, it is necessary to put it in DFU Mode again. After virtualization, the SparkFun Photon is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked. Important To exploit the Wi-Fi chip functionalities of the SparkFun Photon, the lib.broadcom.bcm43362 library must be installed and imported on the Zerynth script. Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the SparkFun Photon device is available for bytecode. Flash Layout is shown in table below: Start address Size Content 0x08020000 128Kb VM Slot 0 0x08040000 384kb Bytecode Slot 0 0x080A0000 384kb Bytecode Slot 1 Important FOTA Record (small segment of memory where the current and desired state of the firmware is store) for the SparkFun Photon device is allocated in 16kb DCT1 (see Flash Layout) sector at 0x08006000 address. Power Management and Secure Firmware \u00b6 Power Management feature allows to optimize power consumption by putting the device in low consumption state. Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). Both these features are strongly platform dependent; more information at Power Management - STM32F section and Secure Firmware - STM32F section .","title":"SparkFun Photon RedBoard"},{"location":"reference/boards/sparkfun_photon/docs/#sparkfun-photon-redboard","text":"The SparkFun Photon RedBoard is a complete Wi-Fi enabled development platform for creating connected devices with ease. The Photon RedBoard has been based around the P1 Particle Module. The I/O, USB, and power connectors are all broken out to a familiar Arduino shape. The P1 (P-one) is Particle\u2019s tiny Wi-Fi module that contains both the Broadcom BCM43362 Wi-Fi chip and a reprogrammable STM32F205RGY6 32-bit ARM Cortex M3 microcontroller . In addition to having 1MB of internal flash memory for storing the firmware, the SparkFun Photon also features 128KB of Ram, 1MB of extra SPI flash and 120 MHz of clock. Note All the reported information are extracted from the official SparkFun Photon RedBoard reference page , visit this page for more details and updates.","title":"SparkFun Photon RedBoard"},{"location":"reference/boards/sparkfun_photon/docs/#pin-mapping","text":"SparkFun Photon RedBoard Official Schematic, Reference Design & Pin Mapping are available on the official SparkFun Photon datasheet page .","title":"Pin Mapping"},{"location":"reference/boards/sparkfun_photon/docs/#flash-layout","text":"The internal flash of the SparkFun Photon RedBoard is organized into sectors of different size according to the following table: Start address Size Content 0x8000000 16Kb BootLoader 0x8004000 16Kb DCT1 0x8008000 16Kb DCT2 0x800C000 16Kb EEPROM1 0x8010000 64Kb EEPROM2 0x8020000 128kb Virtual Machine 0x8040000 128kb Bytecode Bank 0 0x8060000 128kb Bytecode Bank 1 0x8080000 128kb Bytecode Bank 2 0x80A0000 128kb Bytecode Bank 3 0x80C0000 128kb Bytecode Bank 4 0x80E0000 128kb Bytecode Bank 5 Important To avoid deleting the SparkFun Photon configuration it is recommended not to write in sectors between 0x8004000 and 0x8020000. Warning If internal flash is used in a Zerynth program, it is recommended to start from pages at the end of flash (bytecode bank 5) towards the virtual machine, to minimize the chance of clashes. Since writing to a sector entails erasing it first, the write operation can be slow even for small chunks of data, depending on the size of the chosen sector.","title":"Flash Layout"},{"location":"reference/boards/sparkfun_photon/docs/#device-summary","text":"Microcontroller: ARM 32-bit Cortex\u2122-M3 CPU Core Operating Voltage: 3.3V Input Voltage: 3.6-6V Digital I/O Pins (DIO): 24 Analog Input Pins (ADC): 5 Analog Outputs Pins (DAC): 2 UARTs: 2 SPIs: 3 I2Cs: 1 CANs: 1 Flash Memory: 1MB SRAM: 128 KB Extra Flash Memory: 1MB Clock Speed: 120Mhz Size (LxW mm): 36.58 X 20.32","title":"Device Summary"},{"location":"reference/boards/sparkfun_photon/docs/#power","text":"Power to the SparkFun Photon device is supplied via the on-board USB micro B connector or directly via the VIN pin: If power is supplied directly to the VIN pin, the voltage should be regulated between 3.6VDC and 5.5VDC. If the device is powered via the USB port, VIN will output a voltage of approximately 4.8VDC due to a reverse polarity protection series schottky diode between V+ of USB and VIN. Note When used as an output, the max load current on VIN is 1 Ampere. Typical current consumption is 80mA with a 5V input. Deep sleep quiescent current is 160uA. When powering the SparkFun Photon from the USB connector, make sure to use a quality cable to minimize voltage drops. If a high resistance cable (i.e., low current) is used, peak currents drawn from the SparkFun Photon when transmitting and receiving will result in voltage sag at the input which may cause a system brown out or intermittent operation. Likewise, the power source should be sufficient enough to source 1A of current to be on the safe side.","title":"Power"},{"location":"reference/boards/sparkfun_photon/docs/#connect-register-virtualize-and-program","text":"On Windows machines (Windows 10), the SparkFun Photon RedBoard in Standard Mode is automatically recognized as Virtual Serial port; otherwise Particle USB Drivers for SparkFun Photon are required by Zerynth Studio for accessing the serial port establishing a connection with the STM32 UART. To install the drivers on Windows plug the SparkFun Photon on an USB port, download the *.exe package, and follow the installation steps to complete the operation. Note It could be necessary to temporarily disable the digitally signed driver enforcement policy of Windows to allow driver installation. There are good instructions on how to do that in this guide . On MAC OSX and Linux platforms USB drivers are not required. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. If the device is still not recognized or not working, the following udev rules may need to be added: #SparkFun Photon SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"2b04\" , ATTRS { idProduct }== \"d008\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"2b04\" , ATTRS { idProduct }== \"d008\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"2b04\" , ATTRS { idProduct }== \"c008\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"2b04\" , ATTRS { idProduct }== \"c008\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" Once connected on a USB port, if drivers have been correctly installed, the SparkFun Photon RedBoard can be seen as Virtual Serial port and it is automatically recognized by Zerynth Studio and listed in the Device Management Toolbar as \u201cSparkFun Photon RedBoard DFU Mode\u201d if the device is in DFU Mode, otherwise as \u201cSparkFun Photon RedBoard\u201d. To register and virtualize a Photon RedBoard, it is necessary to put the device in DFU Mode (Device Firmware Upgrade). Note On Windows machines it is necessary to install also the SparkFun Photon DFU drivers for virtualizing the device. The official Particle Core DFU driver and the related installation procedure are reported here but they also work for SparkFun Photon RedBoard . Follow these steps to register and virtualize a Photon RedBoard: Put the SparkFun Photon in DFU Mode (Device Firmware Upgrade): Hold down BOTH buttons (reset and mode); Release only the reset button, while holding down the mode button; Wait for the LED to start flashing magenta, then yellow; Release the mode button; the device is now in DFU Mode (yellow blinking led); Select the SparkFun Photon on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create the unique Zerynth Virtual Machine for the connected device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note During these operations the SparkFun Photon device must be in DFU Mode . if the device returns in standard mode, it is necessary to put it in DFU Mode again. After virtualization, the SparkFun Photon is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked. Important To exploit the Wi-Fi chip functionalities of the SparkFun Photon, the lib.broadcom.bcm43362 library must be installed and imported on the Zerynth script.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/sparkfun_photon/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the SparkFun Photon device is available for bytecode. Flash Layout is shown in table below: Start address Size Content 0x08020000 128Kb VM Slot 0 0x08040000 384kb Bytecode Slot 0 0x080A0000 384kb Bytecode Slot 1 Important FOTA Record (small segment of memory where the current and desired state of the firmware is store) for the SparkFun Photon device is allocated in 16kb DCT1 (see Flash Layout) sector at 0x08006000 address.","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/sparkfun_photon/docs/#power-management-and-secure-firmware","text":"Power Management feature allows to optimize power consumption by putting the device in low consumption state. Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). Both these features are strongly platform dependent; more information at Power Management - STM32F section and Secure Firmware - STM32F section .","title":"Power Management and Secure Firmware"},{"location":"reference/boards/st_discoveryf407vg/docs/","text":"ST Microelectronics Discovery F407VG \u00b6 The ST Discovery F407VG device leverages the capabilities of the STM32F407 high performance microcontrollers, to allow users to easily develop applications. It includes an ST-LINK embedded debug tool, one ST-MEMS digital accelerometer, a digital microphone, one audio DAC with integrated class D speaker driver, LEDs, push-buttons and an USB OTG micro-AB connector. STM32F407xx family is based on the high-performance ARM\u00aeCortex\u00ae-M4 32-bit RISC core. The device needs a 5V power supply and features a STM32F407VG MCU running at 168 MHz with 192Kb of RAM, 1Mb of flash. Pin Mapping \u00b6 ST Discovery F407VG official manual is available here Flash Layout \u00b6 The internal flash of the ST Discovery F407VG is organized into one bank of 1Mb with sectors of different size according to the following table: Start address Size Content 0x8000000 16Kb Virtual Machine 0x8004000 16Kb Virtual Machine 0x8008000 16Kb Virtual Machine 0x800C000 16Kb Virtual Machine 0x8010000 64Kb Virtual Machine 0x8020000 128kb Bytecode Bank 0 0x8040000 128kb Bytecode Bank 1 0x8060000 128kb Bytecode Bank 2 0x8080000 128kb Bytecode Bank 3 0x80A0000 128kb Bytecode Bank 4 0x80C0000 128kb Bytecode Bank 5 0x80E0000 128kb Bytecode Bank 6 Device Summary \u00b6 Microcontroller: ARM 32-bit Cortex\u2122-M4 CPU Core Operating Voltage: 3.3V Input Voltage: 5V Digital I/O Pins (DIO): 80 Analog Input Pins (ADC): 14 UARTs: 7 SPIs: 3 I2Cs: 3 Flash Memory: 1Mb SRAM: 128 KB + 64Kb CCM Clock Speed: 168MHz Power \u00b6 The power supply is provided either by the host PC through the USB cable, or by an external 5V power supply. The D1 and D2 diodes protect the 5V and 3V pins from external power supplies: 5V and 3V can be used as output power supplies when another application board is connected to pins P1 and P2; in this case, the 5V and 3V pins deliver a 5V or 3V power supply and power consumption must be lower than 100 mA. 5V can also be used as input power supplies e.g. when the USB connector is not connected to the PC. In this case, the STM32F4DISCOVERY board must be powered by a power supply unit or by auxiliary equipment complying with standard EN-60950-1: 2006+A11/2009, and must be Safety Extra Low Voltage (SELV) with limited power capability. Connect, Register, Virtualize and Program \u00b6 The ST Discovery F407VG Programming port is connected to the ST-Link uploader creating a virtual COM port on a connected computer. To recognize the device, Windows machines requires drivers that can be downloaded from the ST Nucleo download page , while MAC OSX and Linux machines will recognize the device automatically. The St-Link is also connected to the STM32 hardware UART0. Once connected on a USB port, if drivers have been correctly installed the ST Discovery F407VG device is recognized by Zerynth Studio and listed in the Device Management Toolbar . The next steps are: Select the ST Discovery F407VG on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the ST Discovery F407VG device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked. Note If the reset is not performed within 5 seconds the upload procedure fails. Warning Scripts uploading and serial console connection issues on St Discovery F407VG devices have been reported. If the upload fails also with a correctly performed reset or if the device is not able to print on the console, disconnect the device from the USB port and plug it again on another USB socket. If also this procedure fails, try to update the ST Discovery firmware available at this link Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the ST Discovery F407VG device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x08000000 128Kb VM Slot 0 0x08020000 384kb Bytecode Slot 0 0x08080000 128kb VM Slot 1 0x080A0000 384kb Bytecode Slot 1 Power Management and Secure Firmware \u00b6 Power Management feature allows to optimize power consumption by putting the device in low consumption state. Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). Both these features are strongly platform dependent; more information at Power Management - STM32F section and Secure Firmware - STM32F section . Missing features \u00b6 Not all features have been included in the ST Discovery based VMs. In particular the following are missing but will be added in the near future: LIS302DL or LIS3DSH ST MEMS 3-axis accelerometer driver; MP45DT02 ST-MEMS audio sensor omni-directional digital microphone driver; CS43L22 audio DAC with integrated class D speaker driver;","title":"ST Microelectronics Discovery F407VG"},{"location":"reference/boards/st_discoveryf407vg/docs/#st-microelectronics-discovery-f407vg","text":"The ST Discovery F407VG device leverages the capabilities of the STM32F407 high performance microcontrollers, to allow users to easily develop applications. It includes an ST-LINK embedded debug tool, one ST-MEMS digital accelerometer, a digital microphone, one audio DAC with integrated class D speaker driver, LEDs, push-buttons and an USB OTG micro-AB connector. STM32F407xx family is based on the high-performance ARM\u00aeCortex\u00ae-M4 32-bit RISC core. The device needs a 5V power supply and features a STM32F407VG MCU running at 168 MHz with 192Kb of RAM, 1Mb of flash.","title":"ST Microelectronics Discovery F407VG"},{"location":"reference/boards/st_discoveryf407vg/docs/#pin-mapping","text":"ST Discovery F407VG official manual is available here","title":"Pin Mapping"},{"location":"reference/boards/st_discoveryf407vg/docs/#flash-layout","text":"The internal flash of the ST Discovery F407VG is organized into one bank of 1Mb with sectors of different size according to the following table: Start address Size Content 0x8000000 16Kb Virtual Machine 0x8004000 16Kb Virtual Machine 0x8008000 16Kb Virtual Machine 0x800C000 16Kb Virtual Machine 0x8010000 64Kb Virtual Machine 0x8020000 128kb Bytecode Bank 0 0x8040000 128kb Bytecode Bank 1 0x8060000 128kb Bytecode Bank 2 0x8080000 128kb Bytecode Bank 3 0x80A0000 128kb Bytecode Bank 4 0x80C0000 128kb Bytecode Bank 5 0x80E0000 128kb Bytecode Bank 6","title":"Flash Layout"},{"location":"reference/boards/st_discoveryf407vg/docs/#device-summary","text":"Microcontroller: ARM 32-bit Cortex\u2122-M4 CPU Core Operating Voltage: 3.3V Input Voltage: 5V Digital I/O Pins (DIO): 80 Analog Input Pins (ADC): 14 UARTs: 7 SPIs: 3 I2Cs: 3 Flash Memory: 1Mb SRAM: 128 KB + 64Kb CCM Clock Speed: 168MHz","title":"Device Summary"},{"location":"reference/boards/st_discoveryf407vg/docs/#power","text":"The power supply is provided either by the host PC through the USB cable, or by an external 5V power supply. The D1 and D2 diodes protect the 5V and 3V pins from external power supplies: 5V and 3V can be used as output power supplies when another application board is connected to pins P1 and P2; in this case, the 5V and 3V pins deliver a 5V or 3V power supply and power consumption must be lower than 100 mA. 5V can also be used as input power supplies e.g. when the USB connector is not connected to the PC. In this case, the STM32F4DISCOVERY board must be powered by a power supply unit or by auxiliary equipment complying with standard EN-60950-1: 2006+A11/2009, and must be Safety Extra Low Voltage (SELV) with limited power capability.","title":"Power"},{"location":"reference/boards/st_discoveryf407vg/docs/#connect-register-virtualize-and-program","text":"The ST Discovery F407VG Programming port is connected to the ST-Link uploader creating a virtual COM port on a connected computer. To recognize the device, Windows machines requires drivers that can be downloaded from the ST Nucleo download page , while MAC OSX and Linux machines will recognize the device automatically. The St-Link is also connected to the STM32 hardware UART0. Once connected on a USB port, if drivers have been correctly installed the ST Discovery F407VG device is recognized by Zerynth Studio and listed in the Device Management Toolbar . The next steps are: Select the ST Discovery F407VG on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the ST Discovery F407VG device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked. Note If the reset is not performed within 5 seconds the upload procedure fails. Warning Scripts uploading and serial console connection issues on St Discovery F407VG devices have been reported. If the upload fails also with a correctly performed reset or if the device is not able to print on the console, disconnect the device from the USB port and plug it again on another USB socket. If also this procedure fails, try to update the ST Discovery firmware available at this link","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/st_discoveryf407vg/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the ST Discovery F407VG device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x08000000 128Kb VM Slot 0 0x08020000 384kb Bytecode Slot 0 0x08080000 128kb VM Slot 1 0x080A0000 384kb Bytecode Slot 1","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/st_discoveryf407vg/docs/#power-management-and-secure-firmware","text":"Power Management feature allows to optimize power consumption by putting the device in low consumption state. Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). Both these features are strongly platform dependent; more information at Power Management - STM32F section and Secure Firmware - STM32F section .","title":"Power Management and Secure Firmware"},{"location":"reference/boards/st_discoveryf407vg/docs/#missing-features","text":"Not all features have been included in the ST Discovery based VMs. In particular the following are missing but will be added in the near future: LIS302DL or LIS3DSH ST MEMS 3-axis accelerometer driver; MP45DT02 ST-MEMS audio sensor omni-directional digital microphone driver; CS43L22 audio DAC with integrated class D speaker driver;","title":"Missing features"},{"location":"reference/boards/st_nucleof401re/docs/","text":"ST Microelectronics Nucleo F401RE \u00b6 The STM32 Nucleo device provides an affordable and flexible way for users to try out new ideas and build prototypes with STM32 microcontrollers . The Arduino connectivity support and ST Morpho headers make it easy to expand the functionality of the STM32 Nucleo device with a wide choice of specialized shields and sensors. This device does not require any separate probe as it integrates the ST-LINK/V2-1 debugger/programmer. Important ST Nucleo uploader requires a firmware upgrade to properly work with Zerynth and with other serial terminal. ST-Link firmware can be upgraded following the ST official procedure . Warning Unlike other Arduino-like devices, the ST Nucleo device runs at 3.3V. The maximum voltage that the I/O pins can tolerate is 3.3V. Providing higher voltages, like 5V to an I/O pin, could damage the device. Note All the reported information are extracted from the official ST Nucelo F401RE reference page , visit this page for more details and updates. Pin Mapping \u00b6 ST Nucleo Official Schematic, Reference Design and Pin Mapping are available on the official ST Nucelo F401RE datasheet page Flash Layout \u00b6 The internal flash of the ST Nucleo F401RE is organized into sectors of different size according to the following table: Start address Size Content 0x8000000 16Kb Virtual Machine 0x8004000 16Kb Virtual Machine 0x8008000 16Kb Virtual Machine 0x800C000 16Kb Virtual Machine 0x8010000 64Kb Virtual Machine 0x8020000 128kb Bytecode Bank 0 0x8040000 128kb Bytecode Bank 1 0x8060000 128kb Bytecode Bank 2 Warning If internal flash is used in a Zerynth program, it is suggested to begin using pages from the end of flash (bytecode bank 2) towards the virtual machine, to minimize the chance of clashes. Since writing to a sector entails erasing it first, the write operation can be slow even for small chunks of data, depending on the size of the choosen sector. Device Summary \u00b6 Microcontroller: STM32F401RET6 ARM\u00ae32-bit Cortex\u00ae-M4 CPU Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 50 Analog Input Pins (ADC): 16 Analog Outputs Pins (DAC): 0 UARTs: 3 SPIs: 3 I2Cs: 3 CANs: 0 Flash Memory: 512 KB SRAM: 96 KB Clock Speed: 84 MHz Size (LxW mm):82.5 x 70.0 Power \u00b6 On the ST Nucleo the power supply is provided either by the host PC through the USB cable, or by an external Source: VIN (7V-12V), E5V (5V) or +3V3 power supply pins on CN6 or CN7. In case VIN, E5V or +3V3 is used to power the Nucleo device, using an external power supply unit or an auxiliary equipment, this power source must comply with the standard EN-60950-1: 2006+A11/2009, and must be Safety Extra Low Voltage (SELV) with limited power capability. The ST-LINK/V2-1 supports USB power management allowing to request more than 100 mA current to the host PC. All parts of the STM32 Nucleo device and shield can be powered from the ST-LINK USB connector CN1 (U5V or VBUS). Note During the USB enumeration, the STM32 Nucleo device requires 300 mA of current to the Host PC. If the host is able to provide the required power, the targeted STM32 microcontroller is powered and the red LED 3 is turned ON, thus the STM32 Nucleo device and its shield can consume a maximum of 300 mA current, not more. Warning When the device is power supplied by USB (U5V) a jumper must be connected between pin 1 and pin 2 of JP5. The jumper must be connected between pin 2 and pin 3 if external power sources are used. Connect, Register, Virtualize and Program \u00b6 The ST Nucleo Programming port is connected to the ST-Link uploader creating a virtual COM port on a connected computer. To recognize the device, Windows machines requires drivers that can be downloaded from the ST Nucleo download page , while MAC OSX and Linux machines will recognize the device automatically. The St-Link is also connected to the STM32 hardware UART0 also connected with pins RX0 and TX0 available on the Arduino headers. Once connected on a USB port, if drivers have been correctly installed the ST Nucleo device is recognized by Zerynth Studio and listed in the Device Management Toolbar . The next steps are: Select the ST Nucleo on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the ST Nucleo device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked. Note If the reset is not performed within 5 seconds the upload procedure fails. Warning Scripts uploading and serial console connection issues on St Nucleo devices have been reported. If the upload fails also with a correctly performed reset or if the device is not able to print on the console, disconnect the device from the USB port and plug it again on another USB socket. If also this procedure fails, try to update the ST Nucleo firmware available at this link Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the ST Nucleo F401RE device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x08000000 128Kb VM Slot 0 0x08020000 128kb Bytecode Slot 0 0x08040000 128kb VM Slot 1 0x08060000 128kb Bytecode Slot 1 Important FOTA Record (small segment of memory where the current and desired state of the firmware is store) for the ST Nucleo device is allocated in 16kb sector inside the VM Slot 0 at 0x08004000 address. Power Management and Secure Firmware \u00b6 Power Management feature allows to optimize power consumption by putting the device in low consumption state. Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). Both these features are strongly platform dependent; more information at Power Management - STM32F section and Secure Firmware - STM32F section .","title":"ST Microelectronics Nucleo F401RE"},{"location":"reference/boards/st_nucleof401re/docs/#st-microelectronics-nucleo-f401re","text":"The STM32 Nucleo device provides an affordable and flexible way for users to try out new ideas and build prototypes with STM32 microcontrollers . The Arduino connectivity support and ST Morpho headers make it easy to expand the functionality of the STM32 Nucleo device with a wide choice of specialized shields and sensors. This device does not require any separate probe as it integrates the ST-LINK/V2-1 debugger/programmer. Important ST Nucleo uploader requires a firmware upgrade to properly work with Zerynth and with other serial terminal. ST-Link firmware can be upgraded following the ST official procedure . Warning Unlike other Arduino-like devices, the ST Nucleo device runs at 3.3V. The maximum voltage that the I/O pins can tolerate is 3.3V. Providing higher voltages, like 5V to an I/O pin, could damage the device. Note All the reported information are extracted from the official ST Nucelo F401RE reference page , visit this page for more details and updates.","title":"ST Microelectronics Nucleo F401RE"},{"location":"reference/boards/st_nucleof401re/docs/#pin-mapping","text":"ST Nucleo Official Schematic, Reference Design and Pin Mapping are available on the official ST Nucelo F401RE datasheet page","title":"Pin Mapping"},{"location":"reference/boards/st_nucleof401re/docs/#flash-layout","text":"The internal flash of the ST Nucleo F401RE is organized into sectors of different size according to the following table: Start address Size Content 0x8000000 16Kb Virtual Machine 0x8004000 16Kb Virtual Machine 0x8008000 16Kb Virtual Machine 0x800C000 16Kb Virtual Machine 0x8010000 64Kb Virtual Machine 0x8020000 128kb Bytecode Bank 0 0x8040000 128kb Bytecode Bank 1 0x8060000 128kb Bytecode Bank 2 Warning If internal flash is used in a Zerynth program, it is suggested to begin using pages from the end of flash (bytecode bank 2) towards the virtual machine, to minimize the chance of clashes. Since writing to a sector entails erasing it first, the write operation can be slow even for small chunks of data, depending on the size of the choosen sector.","title":"Flash Layout"},{"location":"reference/boards/st_nucleof401re/docs/#device-summary","text":"Microcontroller: STM32F401RET6 ARM\u00ae32-bit Cortex\u00ae-M4 CPU Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 50 Analog Input Pins (ADC): 16 Analog Outputs Pins (DAC): 0 UARTs: 3 SPIs: 3 I2Cs: 3 CANs: 0 Flash Memory: 512 KB SRAM: 96 KB Clock Speed: 84 MHz Size (LxW mm):82.5 x 70.0","title":"Device Summary"},{"location":"reference/boards/st_nucleof401re/docs/#power","text":"On the ST Nucleo the power supply is provided either by the host PC through the USB cable, or by an external Source: VIN (7V-12V), E5V (5V) or +3V3 power supply pins on CN6 or CN7. In case VIN, E5V or +3V3 is used to power the Nucleo device, using an external power supply unit or an auxiliary equipment, this power source must comply with the standard EN-60950-1: 2006+A11/2009, and must be Safety Extra Low Voltage (SELV) with limited power capability. The ST-LINK/V2-1 supports USB power management allowing to request more than 100 mA current to the host PC. All parts of the STM32 Nucleo device and shield can be powered from the ST-LINK USB connector CN1 (U5V or VBUS). Note During the USB enumeration, the STM32 Nucleo device requires 300 mA of current to the Host PC. If the host is able to provide the required power, the targeted STM32 microcontroller is powered and the red LED 3 is turned ON, thus the STM32 Nucleo device and its shield can consume a maximum of 300 mA current, not more. Warning When the device is power supplied by USB (U5V) a jumper must be connected between pin 1 and pin 2 of JP5. The jumper must be connected between pin 2 and pin 3 if external power sources are used.","title":"Power"},{"location":"reference/boards/st_nucleof401re/docs/#connect-register-virtualize-and-program","text":"The ST Nucleo Programming port is connected to the ST-Link uploader creating a virtual COM port on a connected computer. To recognize the device, Windows machines requires drivers that can be downloaded from the ST Nucleo download page , while MAC OSX and Linux machines will recognize the device automatically. The St-Link is also connected to the STM32 hardware UART0 also connected with pins RX0 and TX0 available on the Arduino headers. Once connected on a USB port, if drivers have been correctly installed the ST Nucleo device is recognized by Zerynth Studio and listed in the Device Management Toolbar . The next steps are: Select the ST Nucleo on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the ST Nucleo device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked. Note If the reset is not performed within 5 seconds the upload procedure fails. Warning Scripts uploading and serial console connection issues on St Nucleo devices have been reported. If the upload fails also with a correctly performed reset or if the device is not able to print on the console, disconnect the device from the USB port and plug it again on another USB socket. If also this procedure fails, try to update the ST Nucleo firmware available at this link","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/st_nucleof401re/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the ST Nucleo F401RE device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x08000000 128Kb VM Slot 0 0x08020000 128kb Bytecode Slot 0 0x08040000 128kb VM Slot 1 0x08060000 128kb Bytecode Slot 1 Important FOTA Record (small segment of memory where the current and desired state of the firmware is store) for the ST Nucleo device is allocated in 16kb sector inside the VM Slot 0 at 0x08004000 address.","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/st_nucleof401re/docs/#power-management-and-secure-firmware","text":"Power Management feature allows to optimize power consumption by putting the device in low consumption state. Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). Both these features are strongly platform dependent; more information at Power Management - STM32F section and Secure Firmware - STM32F section .","title":"Power Management and Secure Firmware"},{"location":"reference/boards/st_nucleof429zi/docs/","text":"ST Microelectronics Nucleo F429ZI \u00b6 The ST Nucleo F429ZI device is an STM32 Nucleo-144 boards that provides an affordable and flexible way for users to try out new concepts and build prototypes, by choosing from the various combinations of performance and power consumption features provided by the STM32 microcontroller. The ST Zio connector and the ST morpho headers provide an easy means of expanding the functionality of the Nucleo open development platform with a wide choice of specialized shields. The STM32 Nucleo-144 boards do not require any separate probe as they integrate the ST-LINK/V2-1 debugger/programmer. The device needs a 5V power supply and features a STM32F429 MCU running at 180MHz with 192Kb of RAM, 2Mb of flash. Pin Mapping \u00b6 ST Nucleo F429ZI official manual is available here Flash Layout \u00b6 The internal flash of the ST Nucleo F429ZI is organized into two banks of 1Mb each. Each bank has sectors of different size according to the following table: .tg {border-collapse:collapse;border-spacing:0;} .tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px; overflow:hidden;padding:10px 5px;word-break:normal;} .tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px; font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;} .tg .tg-wh69{background-color:#F3F6F6;color:#404040;text-align:left;vertical-align:middle} .tg .tg-htbt{background-color:#FFF;border-color:inherit;color:#404040;text-align:left;vertical-align:middle} .tg .tg-vfhj{background-color:#FFF;color:#404040;font-weight:bold;text-align:left;vertical-align:bottom} .tg .tg-zatc{background-color:#FFF;border-color:inherit;color:#404040;font-weight:bold;text-align:left;vertical-align:bottom} .tg .tg-5ncm{background-color:#F3F6F6;border-color:inherit;color:#404040;text-align:left;vertical-align:middle} .tg .tg-3me6{background-color:#FFF;color:#404040;text-align:left;vertical-align:middle} Bank 1 Bank 2 Start address Size Content Start address Size Content 0x8000000 16Kb Virtual Machine 0x8100000 16Kb Bytecode Bank 7 0x8004000 16Kb Virtual Machine 0x8104000 16Kb Bytecode Bank 8 0x8008000 16Kb Virtual Machine 0x8108000 16Kb Bytecode Bank 9 0x800C000 16Kb Virtual Machine 0x810C000 16Kb Bytecode Bank 10 0x8010000 64Kb Virtual Machine 0x8110000 64Kb Bytecode Bank 11 0x8020000 128kb Bytecode Bank 0 0x8120000 128kb Bytecode Bank 12 0x8040000 128kb Bytecode Bank 1 0x8140000 128kb Bytecode Bank 13 0x8060000 128kb Bytecode Bank 2 0x8160000 128kb Bytecode Bank 14 0x8080000 128kb Bytecode Bank 3 0x8180000 128kb Bytecode Bank 15 0x80A0000 128kb Bytecode Bank 4 0x81A0000 128kb Bytecode Bank 16 0x80C0000 128kb Bytecode Bank 5 0x81C0000 128kb Bytecode Bank 17 0x80E0000 128kb Bytecode Bank 6 0x81E0000 128kb Bytecode Bank 18 Device Summary \u00b6 Microcontroller: ARM 32-bit Cortex\u2122-M4 CPU Core Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 105 Analog Input Pins (ADC): 19 UARTs: 6 SPIs: 5 I2Cs: 3 Flash Memory: 2Mb SRAM: 192 KB + 64Kb CCM Clock Speed: 180MHz Power \u00b6 On the ST Nucleo F429ZI, the power supply is provided either by the host PC through the USB cable, or by an external Source: VIN (7V-12V), E5V (5V) or +3V3 power supply pins on CN11 or CN8. In case VIN, E5V or +3V3 is used to power the Nucleo device, using an external power supply unit or an auxiliary equipment, this power source must comply with the standard EN-60950-1: 2006+A11/2009, and must be Safety Extra Low Voltage (SELV) with limited power capability. The ST-LINK/V2-1 supports USB power management allowing to request more than 100 mA current to the host PC. All parts of the STM32 Nucleo device and shield can be powered from the ST-LINK USB connector CN1 (U5V or VBUS). Warning Depending on the type of power supply choosen, the jumper JP3 must be correclty selected: JP3 between pin 1 and pin 2 for E5V power supply; JP3 between pin 3 and pin 4 for U5V power supply (ST-Link VBUS); JP3 between pin 5 and pin 6 for VIN-5V power supply. Connect, Register, Virtualize and Program \u00b6 The ST Nucleo F429ZI Programming port is connected to the ST-Link uploader creating a virtual COM port on a connected computer. To recognize the device, Windows machines requires drivers that can be downloaded from the ST Nucleo download page , while MAC OSX and Linux machines will recognize the device automatically. The St-Link is also connected to the STM32 hardware UART0. Once connected on a USB port, if drivers have been correctly installed the ST Nucleo F429ZI device is recognized by Zerynth Studio and listed in the Device Management Toolbar . The next steps are: Select the ST Nucleo F429ZI on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the ST Nucleo F429ZI device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked. Note If the reset is not performed within 5 seconds the upload procedure fails. Warning Scripts uploading and serial console connection issues on St Nucleo devices have been reported. If the upload fails also with a correctly performed reset or if the device is not able to print on the console, disconnect the device from the USB port and plug it again on another USB socket. If also this procedure fails, try to update the ST Nucleo firmware available at this link Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the ST Nucleo F429ZI device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x08000000 128Kb VM Slot 0 0x08020000 384kb Bytecode Slot 0 0x08080000 128kb VM Slot 1 0x080A0000 384kb Bytecode Slot 1 Important FOTA Record (small segment of memory where the current and desired state of the firmware is store) for the ST Nucleo F429ZI device is allocated in 16kb sector inside the VM Slot 0 at 0x08004000 address. Power Management and Secure Firmware \u00b6 Power Management feature allows to optimize power consumption by putting the device in low consumption state. Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). Both these features are strongly platform dependent; more information at Power Management - STM32F section and Secure Firmware - STM32F section .","title":"ST Microelectronics Nucleo F429ZI"},{"location":"reference/boards/st_nucleof429zi/docs/#st-microelectronics-nucleo-f429zi","text":"The ST Nucleo F429ZI device is an STM32 Nucleo-144 boards that provides an affordable and flexible way for users to try out new concepts and build prototypes, by choosing from the various combinations of performance and power consumption features provided by the STM32 microcontroller. The ST Zio connector and the ST morpho headers provide an easy means of expanding the functionality of the Nucleo open development platform with a wide choice of specialized shields. The STM32 Nucleo-144 boards do not require any separate probe as they integrate the ST-LINK/V2-1 debugger/programmer. The device needs a 5V power supply and features a STM32F429 MCU running at 180MHz with 192Kb of RAM, 2Mb of flash.","title":"ST Microelectronics Nucleo F429ZI"},{"location":"reference/boards/st_nucleof429zi/docs/#pin-mapping","text":"ST Nucleo F429ZI official manual is available here","title":"Pin Mapping"},{"location":"reference/boards/st_nucleof429zi/docs/#flash-layout","text":"The internal flash of the ST Nucleo F429ZI is organized into two banks of 1Mb each. Each bank has sectors of different size according to the following table: .tg {border-collapse:collapse;border-spacing:0;} .tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px; overflow:hidden;padding:10px 5px;word-break:normal;} .tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px; font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;} .tg .tg-wh69{background-color:#F3F6F6;color:#404040;text-align:left;vertical-align:middle} .tg .tg-htbt{background-color:#FFF;border-color:inherit;color:#404040;text-align:left;vertical-align:middle} .tg .tg-vfhj{background-color:#FFF;color:#404040;font-weight:bold;text-align:left;vertical-align:bottom} .tg .tg-zatc{background-color:#FFF;border-color:inherit;color:#404040;font-weight:bold;text-align:left;vertical-align:bottom} .tg .tg-5ncm{background-color:#F3F6F6;border-color:inherit;color:#404040;text-align:left;vertical-align:middle} .tg .tg-3me6{background-color:#FFF;color:#404040;text-align:left;vertical-align:middle} Bank 1 Bank 2 Start address Size Content Start address Size Content 0x8000000 16Kb Virtual Machine 0x8100000 16Kb Bytecode Bank 7 0x8004000 16Kb Virtual Machine 0x8104000 16Kb Bytecode Bank 8 0x8008000 16Kb Virtual Machine 0x8108000 16Kb Bytecode Bank 9 0x800C000 16Kb Virtual Machine 0x810C000 16Kb Bytecode Bank 10 0x8010000 64Kb Virtual Machine 0x8110000 64Kb Bytecode Bank 11 0x8020000 128kb Bytecode Bank 0 0x8120000 128kb Bytecode Bank 12 0x8040000 128kb Bytecode Bank 1 0x8140000 128kb Bytecode Bank 13 0x8060000 128kb Bytecode Bank 2 0x8160000 128kb Bytecode Bank 14 0x8080000 128kb Bytecode Bank 3 0x8180000 128kb Bytecode Bank 15 0x80A0000 128kb Bytecode Bank 4 0x81A0000 128kb Bytecode Bank 16 0x80C0000 128kb Bytecode Bank 5 0x81C0000 128kb Bytecode Bank 17 0x80E0000 128kb Bytecode Bank 6 0x81E0000 128kb Bytecode Bank 18","title":"Flash Layout"},{"location":"reference/boards/st_nucleof429zi/docs/#device-summary","text":"Microcontroller: ARM 32-bit Cortex\u2122-M4 CPU Core Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 105 Analog Input Pins (ADC): 19 UARTs: 6 SPIs: 5 I2Cs: 3 Flash Memory: 2Mb SRAM: 192 KB + 64Kb CCM Clock Speed: 180MHz","title":"Device Summary"},{"location":"reference/boards/st_nucleof429zi/docs/#power","text":"On the ST Nucleo F429ZI, the power supply is provided either by the host PC through the USB cable, or by an external Source: VIN (7V-12V), E5V (5V) or +3V3 power supply pins on CN11 or CN8. In case VIN, E5V or +3V3 is used to power the Nucleo device, using an external power supply unit or an auxiliary equipment, this power source must comply with the standard EN-60950-1: 2006+A11/2009, and must be Safety Extra Low Voltage (SELV) with limited power capability. The ST-LINK/V2-1 supports USB power management allowing to request more than 100 mA current to the host PC. All parts of the STM32 Nucleo device and shield can be powered from the ST-LINK USB connector CN1 (U5V or VBUS). Warning Depending on the type of power supply choosen, the jumper JP3 must be correclty selected: JP3 between pin 1 and pin 2 for E5V power supply; JP3 between pin 3 and pin 4 for U5V power supply (ST-Link VBUS); JP3 between pin 5 and pin 6 for VIN-5V power supply.","title":"Power"},{"location":"reference/boards/st_nucleof429zi/docs/#connect-register-virtualize-and-program","text":"The ST Nucleo F429ZI Programming port is connected to the ST-Link uploader creating a virtual COM port on a connected computer. To recognize the device, Windows machines requires drivers that can be downloaded from the ST Nucleo download page , while MAC OSX and Linux machines will recognize the device automatically. The St-Link is also connected to the STM32 hardware UART0. Once connected on a USB port, if drivers have been correctly installed the ST Nucleo F429ZI device is recognized by Zerynth Studio and listed in the Device Management Toolbar . The next steps are: Select the ST Nucleo F429ZI on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the ST Nucleo F429ZI device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked. Note If the reset is not performed within 5 seconds the upload procedure fails. Warning Scripts uploading and serial console connection issues on St Nucleo devices have been reported. If the upload fails also with a correctly performed reset or if the device is not able to print on the console, disconnect the device from the USB port and plug it again on another USB socket. If also this procedure fails, try to update the ST Nucleo firmware available at this link","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/st_nucleof429zi/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the ST Nucleo F429ZI device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x08000000 128Kb VM Slot 0 0x08020000 384kb Bytecode Slot 0 0x08080000 128kb VM Slot 1 0x080A0000 384kb Bytecode Slot 1 Important FOTA Record (small segment of memory where the current and desired state of the firmware is store) for the ST Nucleo F429ZI device is allocated in 16kb sector inside the VM Slot 0 at 0x08004000 address.","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/st_nucleof429zi/docs/#power-management-and-secure-firmware","text":"Power Management feature allows to optimize power consumption by putting the device in low consumption state. Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). Both these features are strongly platform dependent; more information at Power Management - STM32F section and Secure Firmware - STM32F section .","title":"Power Management and Secure Firmware"},{"location":"reference/boards/st_nucleof746zg/docs/","text":"ST Microelectronics Nucleo F746ZG \u00b6 The ST Microelectronics Nucleo F746ZG boards provide an affordable and flexible way for users to try out new concepts and build prototypes by choosing from the various combinations of performance and power consumption features, provided by the STM32 microcontroller. The ST Zio connector, which extends the Arduino\u2122 Uno V3 connectivity, and the ST morpho headers provide an easy means of expanding the functionality of the Nucleo open development platform with a wide choice of specialized shields. The STM32 Nucleo-144 board does not require any separate probe as it integrates the ST-LINK debugger/programmer. Pin Mapping \u00b6 Flash Layout \u00b6 The internal flash of the is ST Nucleo F746ZG is organized into sectors of different size according to the following table: Start address Size Content 0x8000000 32Kb Virtual Machine 0x8008000 32Kb Virtual Machine 0x8010000 32Kb Virtual Machine 0x8018000 32Kb Virtual Machine 0x8020000 128Kb Bytecode Bank 0 0x8040000 256kb Bytecode Bank 1 0x8080000 256kb Bytecode Bank 2 0x80C0000 256kb Bytecode Bank 3 Warning If internal flash is used in a Zerynth program, it is suggested to begin using pages from the end of flash (bytecode bank 3) towards the virtual machine, to minimize the chance of clashes. Since writing to a sector entails erasing it first, the write operation can be slow even for small chunks of data, depending on the size of the choosen sector. Device Summary \u00b6 Microcontroller: STM32F746 ARM\u00ae32-bit Cortex\u00ae-M7 CPU Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 84 Analog Input Pins (ADC): 9 UARTs: 4 SPIs: 2 I2Cs: 2 Flash Memory: 1024 KB SRAM: 320 KB Power \u00b6 On the ST Nucleo F746ZG, the power supply is provided either by the host PC through the USB cable, or by an external Source: VIN (7V-12V), E5V (5V) or +3V3 power supply pins on CN11 or CN8. In case VIN, E5V or +3V3 is used to power the Nucleo device, using an external power supply unit or an auxiliary equipment, this power source must comply with the standard EN-60950-1: 2006+A11/2009, and must be Safety Extra Low Voltage (SELV) with limited power capability. The ST-LINK/V2-1 supports USB power management allowing to request more than 100 mA current to the host PC. All parts of the STM32 Nucleo device and shield can be powered from the ST-LINK USB connector CN1 (U5V or VBUS). Warning Depending on the type of power supply choosen, the jumper JP3 must be correclty selected: JP3 between pin 1 and pin 2 for E5V power supply; JP3 between pin 3 and pin 4 for U5V power supply (ST-Link VBUS); JP3 between pin 5 and pin 6 for VIN-5V power supply. Connect, Register, Virtualize and Program \u00b6 The ST Nucleo F746ZG Programming port is connected to the ST-Link uploader creating a virtual COM port on a connected computer. To recognize the device, Windows machines requires drivers that can be downloaded from the ST Nucleo download page while MAC OSX and Linux machines will recognize the device automatically. On MAC OSX and Linux USB drivers are not required. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. If the device is still not recognized or not working, the following udev rules may need to be added: #ST Nucleo F746ZG Device SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"0483\" , ATTRS { idProduct }== \"374b\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" Select the ST Nucleo F746ZG on the Device Management Toolbar (Disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. After virtualization, the ST Nucleo F746ZG device is ready to be programmed and the Zerynth scripts uploaded. Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked. Missing Features \u00b6 Not all features have been included in the ST Nucleo F746ZG support. In particular the following are missing: ICU Ethernet USB","title":"ST Microelectronics Nucleo F746ZG"},{"location":"reference/boards/st_nucleof746zg/docs/#st-microelectronics-nucleo-f746zg","text":"The ST Microelectronics Nucleo F746ZG boards provide an affordable and flexible way for users to try out new concepts and build prototypes by choosing from the various combinations of performance and power consumption features, provided by the STM32 microcontroller. The ST Zio connector, which extends the Arduino\u2122 Uno V3 connectivity, and the ST morpho headers provide an easy means of expanding the functionality of the Nucleo open development platform with a wide choice of specialized shields. The STM32 Nucleo-144 board does not require any separate probe as it integrates the ST-LINK debugger/programmer.","title":"ST Microelectronics Nucleo F746ZG"},{"location":"reference/boards/st_nucleof746zg/docs/#pin-mapping","text":"","title":"Pin Mapping"},{"location":"reference/boards/st_nucleof746zg/docs/#flash-layout","text":"The internal flash of the is ST Nucleo F746ZG is organized into sectors of different size according to the following table: Start address Size Content 0x8000000 32Kb Virtual Machine 0x8008000 32Kb Virtual Machine 0x8010000 32Kb Virtual Machine 0x8018000 32Kb Virtual Machine 0x8020000 128Kb Bytecode Bank 0 0x8040000 256kb Bytecode Bank 1 0x8080000 256kb Bytecode Bank 2 0x80C0000 256kb Bytecode Bank 3 Warning If internal flash is used in a Zerynth program, it is suggested to begin using pages from the end of flash (bytecode bank 3) towards the virtual machine, to minimize the chance of clashes. Since writing to a sector entails erasing it first, the write operation can be slow even for small chunks of data, depending on the size of the choosen sector.","title":"Flash Layout"},{"location":"reference/boards/st_nucleof746zg/docs/#device-summary","text":"Microcontroller: STM32F746 ARM\u00ae32-bit Cortex\u00ae-M7 CPU Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 84 Analog Input Pins (ADC): 9 UARTs: 4 SPIs: 2 I2Cs: 2 Flash Memory: 1024 KB SRAM: 320 KB","title":"Device Summary"},{"location":"reference/boards/st_nucleof746zg/docs/#power","text":"On the ST Nucleo F746ZG, the power supply is provided either by the host PC through the USB cable, or by an external Source: VIN (7V-12V), E5V (5V) or +3V3 power supply pins on CN11 or CN8. In case VIN, E5V or +3V3 is used to power the Nucleo device, using an external power supply unit or an auxiliary equipment, this power source must comply with the standard EN-60950-1: 2006+A11/2009, and must be Safety Extra Low Voltage (SELV) with limited power capability. The ST-LINK/V2-1 supports USB power management allowing to request more than 100 mA current to the host PC. All parts of the STM32 Nucleo device and shield can be powered from the ST-LINK USB connector CN1 (U5V or VBUS). Warning Depending on the type of power supply choosen, the jumper JP3 must be correclty selected: JP3 between pin 1 and pin 2 for E5V power supply; JP3 between pin 3 and pin 4 for U5V power supply (ST-Link VBUS); JP3 between pin 5 and pin 6 for VIN-5V power supply.","title":"Power"},{"location":"reference/boards/st_nucleof746zg/docs/#connect-register-virtualize-and-program","text":"The ST Nucleo F746ZG Programming port is connected to the ST-Link uploader creating a virtual COM port on a connected computer. To recognize the device, Windows machines requires drivers that can be downloaded from the ST Nucleo download page while MAC OSX and Linux machines will recognize the device automatically. On MAC OSX and Linux USB drivers are not required. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. If the device is still not recognized or not working, the following udev rules may need to be added: #ST Nucleo F746ZG Device SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"0483\" , ATTRS { idProduct }== \"374b\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" Select the ST Nucleo F746ZG on the Device Management Toolbar (Disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. After virtualization, the ST Nucleo F746ZG device is ready to be programmed and the Zerynth scripts uploaded. Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/st_nucleof746zg/docs/#missing-features","text":"Not all features have been included in the ST Nucleo F746ZG support. In particular the following are missing: ICU Ethernet USB","title":"Missing Features"},{"location":"reference/boards/wemos_d1_mini/docs/","text":"Wemos D1 Mini \u00b6 Wemos D1 Mini is a mini Wi-Fi device based on ESP8266EX chip. This device is a very compact solution for prototyping small smart objects linked to the World Wide Web thanks to the Espressif ESP8266 Wi-Fi functionalities. The Wemos D1 Mini features 4MB of flash memory, 80MHz of system clock, around 50k of usable RAM and an on chip Wi-fi Transceiver. Note All the reported information are extracted from the official Wemos D1 Mini reference page , visit this page for more details and updates. Pin Mapping \u00b6 Official reference for Wemos D1 Mini can be found here . Flash Layout \u00b6 The Wemos D1 Mini device features a 4 MB (32 Mb) flash memory organized in sectors of 4k each. The flash memory address starts at 0x40200000 and can be read and written from a Zerynth program using the internal flash module. Warning If flash memory must be used in a Zerynth program, it is recommended to begin using it from secure addresses towards the end the bytecode (start address of the bytecode can be found in the log console of Zerynth Studio during the uplink operation), leaving a minimum safe place to minimize the chance of clashes. Note The internal flash of Wemos D1 Mini can be organized in different ways. The standard VM is a non-FOTA VM with the VM code beginning at 0x0000, followed by the esp8266 ir0m image at 0x20000 and the esp_init_data at 0x3fc000. The VM is based on the Espressif RTOS SDK 1.4.1. Device Summary \u00b6 Microcontroller: Tensilica 32-bit RISC CPU Xtensa LX106 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 11 Analog Input Pins (ADC): 1 UARTs: 1 SPIs: 1 I2Cs: 1 Flash Memory: 4 MB SRAM: 64 KB Clock Speed: 80 Mhz Wi-Fi: IEEE 802.11 b/g/n: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks Power \u00b6 Power to the Wemos D1 Mini is supplied via the on-board USB Micro B connector or directly via the \u201cVIN\u201d pin. The power source is selected automatically. The device can operate on an external supply of 6 to 20 volts. If using more than 12V, the voltage regulator may overheat and damage the device. The recommended range is 7 to 12 volts. Connect, Register, Virtualize and Program \u00b6 The Wemos D1 Mini exposes the serial port of the ESP8266 module via CH340 USB to UART chip which is also connected to the boot pins of the module, allowing for a seamless virtualization of the device. Note Drivers for the CH340 Module can be downloaded here and are needed for Windows and Mac platforms . Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected to a USB port the Wemos D1 Mini device can be seen as a Virtual Serial port and it is automatically recognized by Zerynth Studio. The next steps are: Select the Wemos D1 Mini on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the Wemos D1 Mini device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the upload process. Important To exploit the Wi-Fi chip functionalities of the Wemos D1 Mini, the lib.espressif.esp8266wifi library must be installed (some example code is provided). Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Wemos D1 Mini device is available for bytecode only. Flash Layout is shown in table below: Start address Size Content 0x40200000 448Kb VM Slot 0x40270000 256Kb Bytecode Slot 0 0x402B0000 320Kb Bytecode Slot 1 Important FOTA Record (small segment of memory where the current and desired state of the firmware is store) for the Wemos D1 Mini is allocated in the RTC memory. Power Management \u00b6 Power Management feature allows to optimize power consumption by putting the device in low consumption state. More information in Power Management - ESP8266 section .","title":"Wemos D1 Mini"},{"location":"reference/boards/wemos_d1_mini/docs/#wemos-d1-mini","text":"Wemos D1 Mini is a mini Wi-Fi device based on ESP8266EX chip. This device is a very compact solution for prototyping small smart objects linked to the World Wide Web thanks to the Espressif ESP8266 Wi-Fi functionalities. The Wemos D1 Mini features 4MB of flash memory, 80MHz of system clock, around 50k of usable RAM and an on chip Wi-fi Transceiver. Note All the reported information are extracted from the official Wemos D1 Mini reference page , visit this page for more details and updates.","title":"Wemos D1 Mini"},{"location":"reference/boards/wemos_d1_mini/docs/#pin-mapping","text":"Official reference for Wemos D1 Mini can be found here .","title":"Pin Mapping"},{"location":"reference/boards/wemos_d1_mini/docs/#flash-layout","text":"The Wemos D1 Mini device features a 4 MB (32 Mb) flash memory organized in sectors of 4k each. The flash memory address starts at 0x40200000 and can be read and written from a Zerynth program using the internal flash module. Warning If flash memory must be used in a Zerynth program, it is recommended to begin using it from secure addresses towards the end the bytecode (start address of the bytecode can be found in the log console of Zerynth Studio during the uplink operation), leaving a minimum safe place to minimize the chance of clashes. Note The internal flash of Wemos D1 Mini can be organized in different ways. The standard VM is a non-FOTA VM with the VM code beginning at 0x0000, followed by the esp8266 ir0m image at 0x20000 and the esp_init_data at 0x3fc000. The VM is based on the Espressif RTOS SDK 1.4.1.","title":"Flash Layout"},{"location":"reference/boards/wemos_d1_mini/docs/#device-summary","text":"Microcontroller: Tensilica 32-bit RISC CPU Xtensa LX106 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 11 Analog Input Pins (ADC): 1 UARTs: 1 SPIs: 1 I2Cs: 1 Flash Memory: 4 MB SRAM: 64 KB Clock Speed: 80 Mhz Wi-Fi: IEEE 802.11 b/g/n: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks","title":"Device Summary"},{"location":"reference/boards/wemos_d1_mini/docs/#power","text":"Power to the Wemos D1 Mini is supplied via the on-board USB Micro B connector or directly via the \u201cVIN\u201d pin. The power source is selected automatically. The device can operate on an external supply of 6 to 20 volts. If using more than 12V, the voltage regulator may overheat and damage the device. The recommended range is 7 to 12 volts.","title":"Power"},{"location":"reference/boards/wemos_d1_mini/docs/#connect-register-virtualize-and-program","text":"The Wemos D1 Mini exposes the serial port of the ESP8266 module via CH340 USB to UART chip which is also connected to the boot pins of the module, allowing for a seamless virtualization of the device. Note Drivers for the CH340 Module can be downloaded here and are needed for Windows and Mac platforms . Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected to a USB port the Wemos D1 Mini device can be seen as a Virtual Serial port and it is automatically recognized by Zerynth Studio. The next steps are: Select the Wemos D1 Mini on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the Wemos D1 Mini device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the upload process. Important To exploit the Wi-Fi chip functionalities of the Wemos D1 Mini, the lib.espressif.esp8266wifi library must be installed (some example code is provided).","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/wemos_d1_mini/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Wemos D1 Mini device is available for bytecode only. Flash Layout is shown in table below: Start address Size Content 0x40200000 448Kb VM Slot 0x40270000 256Kb Bytecode Slot 0 0x402B0000 320Kb Bytecode Slot 1 Important FOTA Record (small segment of memory where the current and desired state of the firmware is store) for the Wemos D1 Mini is allocated in the RTC memory.","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/wemos_d1_mini/docs/#power-management","text":"Power Management feature allows to optimize power consumption by putting the device in low consumption state. More information in Power Management - ESP8266 section .","title":"Power Management"},{"location":"reference/boards/wemos_esp32_oled/docs/","text":"Wemos ESP32 OLED \u00b6 Wemos ESP32 OLED is a classic IoT dev-board designed and produced by Wemos. It is based on the ESP32 microcontroller that boasts Wi-Fi, Bluetooth, Ethernet and Low Power support all in a single chip; Li-Po battery management system, 0.96\u2033 OLED are also included. It is one of the best choice for smart solutions, smart farms, smart home, and IoT makers. Pin Mapping \u00b6 Flash Layout \u00b6 The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved Device Summary \u00b6 Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 28 Analog Input Pins (ADC): 8 Analog Outputs Pins (DAC): 2 UARTs: 3 SPIs: 2 I2Cs: 3 OLED: 0.96\u201d Display driven by Solomon SSD1306 (I2C) Flash Memory: 4 MB SRAM: 520 KB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks Power \u00b6 Power to the Wemos ESP32 OLED is supplied via the on-board USB Micro B connector. Connect, Register, Virtualize and Program \u00b6 The Wemos ESP32 OLED comes with a serial-to-usb chip on board that allows programming and opening the UART of the ESP32 module. Drivers may be needed depending on your system (Mac or Windows) and can be download from the official Espressif documentation page. In Linux systems, the Wemos ESP32 OLED should work out of the box. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the Wemos ESP32 OLED device is recognized by Zerynth Studio. The next steps are: Select the Wemos ESP32 OLED on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process After virtualization, the Wemos ESP32 OLED is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process. Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Wemos ESP32 OLED device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs. Secure Firmware \u00b6 Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section . Zerynth Secure Socket \u00b6 To be able to use Zerynth Secure Socket on esp32 boards NATIVE_MBEDTLS: true must be used instead of ZERYNTH_SSL: true in the project.yml file. Missing features \u00b6 Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"Wemos ESP32 OLED"},{"location":"reference/boards/wemos_esp32_oled/docs/#wemos-esp32-oled","text":"Wemos ESP32 OLED is a classic IoT dev-board designed and produced by Wemos. It is based on the ESP32 microcontroller that boasts Wi-Fi, Bluetooth, Ethernet and Low Power support all in a single chip; Li-Po battery management system, 0.96\u2033 OLED are also included. It is one of the best choice for smart solutions, smart farms, smart home, and IoT makers.","title":"Wemos ESP32 OLED"},{"location":"reference/boards/wemos_esp32_oled/docs/#pin-mapping","text":"","title":"Pin Mapping"},{"location":"reference/boards/wemos_esp32_oled/docs/#flash-layout","text":"The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved","title":"Flash Layout"},{"location":"reference/boards/wemos_esp32_oled/docs/#device-summary","text":"Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 28 Analog Input Pins (ADC): 8 Analog Outputs Pins (DAC): 2 UARTs: 3 SPIs: 2 I2Cs: 3 OLED: 0.96\u201d Display driven by Solomon SSD1306 (I2C) Flash Memory: 4 MB SRAM: 520 KB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks","title":"Device Summary"},{"location":"reference/boards/wemos_esp32_oled/docs/#power","text":"Power to the Wemos ESP32 OLED is supplied via the on-board USB Micro B connector.","title":"Power"},{"location":"reference/boards/wemos_esp32_oled/docs/#connect-register-virtualize-and-program","text":"The Wemos ESP32 OLED comes with a serial-to-usb chip on board that allows programming and opening the UART of the ESP32 module. Drivers may be needed depending on your system (Mac or Windows) and can be download from the official Espressif documentation page. In Linux systems, the Wemos ESP32 OLED should work out of the box. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the Wemos ESP32 OLED device is recognized by Zerynth Studio. The next steps are: Select the Wemos ESP32 OLED on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process After virtualization, the Wemos ESP32 OLED is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/wemos_esp32_oled/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Wemos ESP32 OLED device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs.","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/wemos_esp32_oled/docs/#secure-firmware","text":"Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section .","title":"Secure Firmware"},{"location":"reference/boards/wemos_esp32_oled/docs/#zerynth-secure-socket","text":"To be able to use Zerynth Secure Socket on esp32 boards NATIVE_MBEDTLS: true must be used instead of ZERYNTH_SSL: true in the project.yml file.","title":"Zerynth Secure Socket"},{"location":"reference/boards/wemos_esp32_oled/docs/#missing-features","text":"Not all IDF features have been included in the Esp32 based VMs. In particular the following are missing but will be added in the near future: Touch detection support","title":"Missing features"},{"location":"reference/boards/wio_link/docs/","text":"Wio Link \u00b6 The SeeedStudio Wio Link is an ESP8266 SoC based open-source Wi-Fi development board, that allows users to create IoT custom applications by adding plug and play Grove modules in its 6 dedicated Grove slot. The Wio Link features 4MB of flash memory, Tensilica microcontroller (80MHz of system clock), around 50k of usable RAM and an Espressif ESP8266 chip Wi-fi Transceiver. Pin Mapping \u00b6 Official reference for Wio Link can be found here . Flash Layout \u00b6 The Wio Link device features a 4 MB (32 Mb) flash memory organized in sectors of 4k each. The flash memory address starts at 0x40200000 and can be read and written from a Zerynth program using the internal flash module. Warning If flash memory must be used in a Zerynth program, it is recommended to begin using it from secure addresses towards the end the bytecode (start address of the bytecode can be found in the log console of Zerynth Studio during the uplink operation), leaving a minimum safe place to minimize the chance of clashes. Note The internal flash of Wio Link can be organized in different ways. The standard VM is a non-FOTA VM with the VM code beginning at 0x0000, followed by the esp8266 ir0m image at 0x20000 and the esp_init_data at 0x3fc000. The VM is based on the Espressif RTOS SDK 1.4.1. Device Summary \u00b6 Microcontroller: Tensilica 32-bit RISC CPU Xtensa LX106 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 10 Analog Input Pins (ADC): 1 UARTs: 1 SPIs: 1 I2Cs: 1 Flash Memory: 4 MB SRAM: 64 KB Clock Speed: 80 Mhz Wi-Fi: IEEE 802.11 b/g/n: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks Power \u00b6 Power to the Wio Link is supplied via the on-board USB Micro B connector or directly throught the connector for a 3.7/4.2 V battery. The power source is selected automatically. The device can operate on an external supply of 2.5 to 6 volts. If using more than 6V, the voltage regulator may overheat and damage the device. Connect, Register, Virtualize and Program \u00b6 The Wio Link exposes the serial port of the ESP8266 module via a CP2102 usb bridge which is also connected to the boot pins of the module, allowing for a seamless virtualization of the device. Note Drivers for the bridge can be downloaded here and are needed for Windows and Mac platforms . Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group Once connected to a USB port the Wio Link device can be seen as a Virtual Serial port and it is automatically recognized by Zerynth Studio. The next steps are: Select the Wio Link on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process After virtualization, the Wio Link device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the upload process. Important To exploit the Wi-Fi chip functionalities of the Wio Link, the lib.espressif.esp8266wifi library must be installed (some example code is provided). Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Wio Link device is available for bytecode only. Flash Layout is shown in table below: Start address Size Content 0x40200000 448Kb VM Slot 0x40270000 256Kb Bytecode Slot 0 0x402B0000 320Kb Bytecode Slot 1 Important FOTA Record (small segment of memory where the current and desired state of the firmware is store) for the Wio Link device is allocated in the RTC memory. Power Management \u00b6 Power Management feature allows to optimize power consumption by putting the device in low consumption state. More information in Power Management - ESP8266 section .","title":"Wio Link"},{"location":"reference/boards/wio_link/docs/#wio-link","text":"The SeeedStudio Wio Link is an ESP8266 SoC based open-source Wi-Fi development board, that allows users to create IoT custom applications by adding plug and play Grove modules in its 6 dedicated Grove slot. The Wio Link features 4MB of flash memory, Tensilica microcontroller (80MHz of system clock), around 50k of usable RAM and an Espressif ESP8266 chip Wi-fi Transceiver.","title":"Wio Link"},{"location":"reference/boards/wio_link/docs/#pin-mapping","text":"Official reference for Wio Link can be found here .","title":"Pin Mapping"},{"location":"reference/boards/wio_link/docs/#flash-layout","text":"The Wio Link device features a 4 MB (32 Mb) flash memory organized in sectors of 4k each. The flash memory address starts at 0x40200000 and can be read and written from a Zerynth program using the internal flash module. Warning If flash memory must be used in a Zerynth program, it is recommended to begin using it from secure addresses towards the end the bytecode (start address of the bytecode can be found in the log console of Zerynth Studio during the uplink operation), leaving a minimum safe place to minimize the chance of clashes. Note The internal flash of Wio Link can be organized in different ways. The standard VM is a non-FOTA VM with the VM code beginning at 0x0000, followed by the esp8266 ir0m image at 0x20000 and the esp_init_data at 0x3fc000. The VM is based on the Espressif RTOS SDK 1.4.1.","title":"Flash Layout"},{"location":"reference/boards/wio_link/docs/#device-summary","text":"Microcontroller: Tensilica 32-bit RISC CPU Xtensa LX106 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 10 Analog Input Pins (ADC): 1 UARTs: 1 SPIs: 1 I2Cs: 1 Flash Memory: 4 MB SRAM: 64 KB Clock Speed: 80 Mhz Wi-Fi: IEEE 802.11 b/g/n: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks","title":"Device Summary"},{"location":"reference/boards/wio_link/docs/#power","text":"Power to the Wio Link is supplied via the on-board USB Micro B connector or directly throught the connector for a 3.7/4.2 V battery. The power source is selected automatically. The device can operate on an external supply of 2.5 to 6 volts. If using more than 6V, the voltage regulator may overheat and damage the device.","title":"Power"},{"location":"reference/boards/wio_link/docs/#connect-register-virtualize-and-program","text":"The Wio Link exposes the serial port of the ESP8266 module via a CP2102 usb bridge which is also connected to the boot pins of the module, allowing for a seamless virtualization of the device. Note Drivers for the bridge can be downloaded here and are needed for Windows and Mac platforms . Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group Once connected to a USB port the Wio Link device can be seen as a Virtual Serial port and it is automatically recognized by Zerynth Studio. The next steps are: Select the Wio Link on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process After virtualization, the Wio Link device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the upload process. Important To exploit the Wi-Fi chip functionalities of the Wio Link, the lib.espressif.esp8266wifi library must be installed (some example code is provided).","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/wio_link/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Wio Link device is available for bytecode only. Flash Layout is shown in table below: Start address Size Content 0x40200000 448Kb VM Slot 0x40270000 256Kb Bytecode Slot 0 0x402B0000 320Kb Bytecode Slot 1 Important FOTA Record (small segment of memory where the current and desired state of the firmware is store) for the Wio Link device is allocated in the RTC memory.","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/wio_link/docs/#power-management","text":"Power Management feature allows to optimize power consumption by putting the device in low consumption state. More information in Power Management - ESP8266 section .","title":"Power Management"},{"location":"reference/boards/wt8266_s2/docs/","text":"Wireless Tag WT8266-DK V2 \u00b6 Wireless Tag WT8266-DK V2 provides specialized UART_WiFi functional test board to facilitate the customers to test the Wi-Fi module. Thanks to WT8266-DK V2, the user can simulate serial devices to access WiFi network and realize data transmission, but also can simulate WT8266-DK V2 works as the main control chip to access data of other devices and control. The WT8266-DK V2 device features 4MB of flash memory, 80MHz of system clock, around 50k of usable RAM and an on chip Wifi Transceiver. Pin Mapping \u00b6 Official reference for Wireless Tag WT8266-DK V2 can be found here . Flash Layout \u00b6 The Wireless Tag WT8266-DK V2 device features a 4 MB (32 Mb) flash memory organized in sectors of 4k each. The flash memory address starts at 0x40200000 and can be read and written from a Zerynth program using the internal flash module. Warning If flash memory must be used in a Zerynth program, it is recommended to begin using it from secure addresses towards the end the bytecode (start address of the bytecode can be found in the log console of Zerynth Studio during the uplink operation), leaving a minimum safe place to minimize the chance of clashes. Note The internal flash of Wireless Tag WT8266-DK V2 can be organized in different ways. The standard VM is a non-FOTA VM with the VM code beginning at 0x0000, followed by the esp8266 ir0m image at 0x20000 and the esp_init_data at 0x3fc000. The VM is based on the Espressif RTOS SDK 1.4.1. Device Summary \u00b6 Microcontroller: Tensilica 32-bit RISC CPU Xtensa LX106 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 11 Analog Input Pins (ADC): 1 UARTs: 1 SPIs: 1 I2Cs: 1 Flash Memory: 4 MB SRAM: 64 KB Clock Speed: 80 Mhz Wi-Fi: IEEE 802.11 b/g/n: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks Power \u00b6 Power to the WT8266-DK V2 is supplied via the on-board USB Micro B connector. The device provides an USB-to-UART chip to link the USB port to the Tensilica chip and voltage regulator to adjust the onboard voltage to 3.3 V both fed via USB connector. The recommended range is 4.0 to 5.25 volts. Connect, Register, Virtualize and Program \u00b6 The Wireless Tag WT8266-DK V2 exposes the serial port of the ESP8266 module via a CP2102 usb bridge which is also connected to the boot pins of the module, allowing for a seamless virtualization of the device. Note Drivers for the bridge can be downloaded here and are needed for Windows and Mac platforms . Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected to a USB port the WT8266-DK V2 device can be seen as a Virtual Serial port and it is automatically recognized by Zerynth Studio. The next steps are: Put the WT8266-DK V2 in Download Mode : Hold down BOTH buttons (Reset and Download); Release only the Reset button, while holding down the Download button; Wait for the onboard LED2 turning on while all other leds turn off; Release the Download button; the device is now in Download Mode; Select the WT8266-DK V2 on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note During these operations the WT8266-DK V2 device must be in Download Mode . if the device returns in standard mode, it is necessary to put it in Download Mode again After virtualization, the WT8266-DK V2 device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked. Important To exploit the Wi-Fi chip functionalities of the WT8266-DK V2, the lib.espressif.esp8266wifi library must be installed (some example code is provided). Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the WT8266-DK V2 device is available for bytecode only. Flash Layout is shown in table below: Start address Size Content 0x40200000 448Kb VM Slot 0x40270000 256Kb Bytecode Slot 0 0x402B0000 320Kb Bytecode Slot 1 Power Management \u00b6 Important FOTA Record (small segment of memory where the current and desired state of the firmware is store) for the WT8266-DK V2 is allocated in the RTC memory. Power Management feature allows to optimize power consumption by putting the device in low consumption state. More information in Power Management - ESP8266 section .","title":"Wireless Tag WT8266-DK V2"},{"location":"reference/boards/wt8266_s2/docs/#wireless-tag-wt8266-dk-v2","text":"Wireless Tag WT8266-DK V2 provides specialized UART_WiFi functional test board to facilitate the customers to test the Wi-Fi module. Thanks to WT8266-DK V2, the user can simulate serial devices to access WiFi network and realize data transmission, but also can simulate WT8266-DK V2 works as the main control chip to access data of other devices and control. The WT8266-DK V2 device features 4MB of flash memory, 80MHz of system clock, around 50k of usable RAM and an on chip Wifi Transceiver.","title":"Wireless Tag WT8266-DK V2"},{"location":"reference/boards/wt8266_s2/docs/#pin-mapping","text":"Official reference for Wireless Tag WT8266-DK V2 can be found here .","title":"Pin Mapping"},{"location":"reference/boards/wt8266_s2/docs/#flash-layout","text":"The Wireless Tag WT8266-DK V2 device features a 4 MB (32 Mb) flash memory organized in sectors of 4k each. The flash memory address starts at 0x40200000 and can be read and written from a Zerynth program using the internal flash module. Warning If flash memory must be used in a Zerynth program, it is recommended to begin using it from secure addresses towards the end the bytecode (start address of the bytecode can be found in the log console of Zerynth Studio during the uplink operation), leaving a minimum safe place to minimize the chance of clashes. Note The internal flash of Wireless Tag WT8266-DK V2 can be organized in different ways. The standard VM is a non-FOTA VM with the VM code beginning at 0x0000, followed by the esp8266 ir0m image at 0x20000 and the esp_init_data at 0x3fc000. The VM is based on the Espressif RTOS SDK 1.4.1.","title":"Flash Layout"},{"location":"reference/boards/wt8266_s2/docs/#device-summary","text":"Microcontroller: Tensilica 32-bit RISC CPU Xtensa LX106 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 11 Analog Input Pins (ADC): 1 UARTs: 1 SPIs: 1 I2Cs: 1 Flash Memory: 4 MB SRAM: 64 KB Clock Speed: 80 Mhz Wi-Fi: IEEE 802.11 b/g/n: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks","title":"Device Summary"},{"location":"reference/boards/wt8266_s2/docs/#power","text":"Power to the WT8266-DK V2 is supplied via the on-board USB Micro B connector. The device provides an USB-to-UART chip to link the USB port to the Tensilica chip and voltage regulator to adjust the onboard voltage to 3.3 V both fed via USB connector. The recommended range is 4.0 to 5.25 volts.","title":"Power"},{"location":"reference/boards/wt8266_s2/docs/#connect-register-virtualize-and-program","text":"The Wireless Tag WT8266-DK V2 exposes the serial port of the ESP8266 module via a CP2102 usb bridge which is also connected to the boot pins of the module, allowing for a seamless virtualization of the device. Note Drivers for the bridge can be downloaded here and are needed for Windows and Mac platforms . Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected to a USB port the WT8266-DK V2 device can be seen as a Virtual Serial port and it is automatically recognized by Zerynth Studio. The next steps are: Put the WT8266-DK V2 in Download Mode : Hold down BOTH buttons (Reset and Download); Release only the Reset button, while holding down the Download button; Wait for the onboard LED2 turning on while all other leds turn off; Release the Download button; the device is now in Download Mode; Select the WT8266-DK V2 on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note During these operations the WT8266-DK V2 device must be in Download Mode . if the device returns in standard mode, it is necessary to put it in Download Mode again After virtualization, the WT8266-DK V2 device is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked. Important To exploit the Wi-Fi chip functionalities of the WT8266-DK V2, the lib.espressif.esp8266wifi library must be installed (some example code is provided).","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/wt8266_s2/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the WT8266-DK V2 device is available for bytecode only. Flash Layout is shown in table below: Start address Size Content 0x40200000 448Kb VM Slot 0x40270000 256Kb Bytecode Slot 0 0x402B0000 320Kb Bytecode Slot 1","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/wt8266_s2/docs/#power-management","text":"Important FOTA Record (small segment of memory where the current and desired state of the firmware is store) for the WT8266-DK V2 is allocated in the RTC memory. Power Management feature allows to optimize power consumption by putting the device in low consumption state. More information in Power Management - ESP8266 section .","title":"Power Management"},{"location":"reference/boards/xinabox_esp32/docs/","text":"XinaBox CW02 (ESP32) \u00b6 The CW02 is one of the development board created by XinaBox that mounts on-board the official WROOM32 module. The XinaBox CW02 contains a dual-core ESP32 microcontroller , that has both WiFi and Bluetooth Classic/LE support, 4 MB of SPI Flash, tuned antenna. Pin Mapping \u00b6 Official reference for XinaBox CW02 can be found here . Flash Layout \u00b6 The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved Device Summary \u00b6 Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 7 UARTs: 1 I2Cs: 1 Flash Memory: 4 MB SRAM: 520 KB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks Power \u00b6 Power to the XinaBox CW02 is supplied via the XinaBox IP01 module (USB Programming Interface). This module has an on-board USB A connector and can be connected to the CW02 core module through the \u2612BUS connector . Connect, Register, Virtualize and Program \u00b6 The XinaBox IP01 programming module, connected to the CW02 core module, exposes the serial port of the ESP32 module via a FT232R FTDI which is also connected to the boot pins of the module, allowing for a seamless virtualization of the device. Note Drivers for the FTDI can be downloaded here and are needed for Windows and Mac platforms . Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Important Switch positioning on XinaBox IP01 programming module must be: Switch 1: B position; Switch 2: DCE position. To program the CW02 module, also the XinaBox IP02 programming module (Advanced USB Programming Interface) can be used; with this module switches must be: Switch 1: A position; Switch 2: DCE position. Once connected on a USB port, if drivers have been correctly installed, the XinaBox CW02 device is recognized by Zerynth Studio. The next steps are: Select the XinaBox CW02 on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process After virtualization, the XinaBox CW02 is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process. Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the XinaBox CW02 device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs. zerynth secure socket \u00b6 To be able to use zerynth secure socket on esp32 boards native_mbedtls: true must be used instead of zerynth_ssl: true in the project.yml file. Secure Firmware \u00b6 Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section .","title":"XinaBox CW02 (ESP32)"},{"location":"reference/boards/xinabox_esp32/docs/#xinabox-cw02-esp32","text":"The CW02 is one of the development board created by XinaBox that mounts on-board the official WROOM32 module. The XinaBox CW02 contains a dual-core ESP32 microcontroller , that has both WiFi and Bluetooth Classic/LE support, 4 MB of SPI Flash, tuned antenna.","title":"XinaBox CW02 (ESP32)"},{"location":"reference/boards/xinabox_esp32/docs/#pin-mapping","text":"Official reference for XinaBox CW02 can be found here .","title":"Pin Mapping"},{"location":"reference/boards/xinabox_esp32/docs/#flash-layout","text":"The internal flash of the ESP32 module is organized in a single flash area with pages of 4096 bytes each. The flash starts at address 0x00000, but many areas are reserved for Esp32 IDF SDK and Zerynth VM. There exist two different layouts based on the presence of BLE support. In particular, for non-BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1Mb Zerynth VM 0x00110000 1Mb Zerynth VM (FOTA) 0x00210000 512Kb Zerynth Bytecode 0x00290000 512Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved For BLE VMs: Start address Size Content 0x00009000 16Kb Esp32 NVS area 0x0000D000 8Kb Esp32 OTA data 0x0000F000 4Kb Esp32 PHY data 0x00010000 1216Kb Zerynth VM 0x00140000 1216Kb Zerynth VM (FOTA) 0x00270000 320Kb Zerynth Bytecode 0x002C0000 320Kb Zerynth Bytecode (FOTA) 0x00310000 512Kb Free for user storage 0x00390000 448Kb Reserved","title":"Flash Layout"},{"location":"reference/boards/xinabox_esp32/docs/#device-summary","text":"Microcontroller: Tensilica 32-bit Single-/Dual-core CPU Xtensa LX6 Operating Voltage: 3.3V Input Voltage: 7-12V Digital I/O Pins (DIO): 7 UARTs: 1 I2Cs: 1 Flash Memory: 4 MB SRAM: 520 KB Clock Speed: 240 Mhz Wi-Fi: IEEE 802.11 b/g/n/e/i: Integrated TR switch, balun, LNA, power amplifier and matching network WEP or WPA/WPA2 authentication, or open networks","title":"Device Summary"},{"location":"reference/boards/xinabox_esp32/docs/#power","text":"Power to the XinaBox CW02 is supplied via the XinaBox IP01 module (USB Programming Interface). This module has an on-board USB A connector and can be connected to the CW02 core module through the \u2612BUS connector .","title":"Power"},{"location":"reference/boards/xinabox_esp32/docs/#connect-register-virtualize-and-program","text":"The XinaBox IP01 programming module, connected to the CW02 core module, exposes the serial port of the ESP32 module via a FT232R FTDI which is also connected to the boot pins of the module, allowing for a seamless virtualization of the device. Note Drivers for the FTDI can be downloaded here and are needed for Windows and Mac platforms . Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Important Switch positioning on XinaBox IP01 programming module must be: Switch 1: B position; Switch 2: DCE position. To program the CW02 module, also the XinaBox IP02 programming module (Advanced USB Programming Interface) can be used; with this module switches must be: Switch 1: A position; Switch 2: DCE position. Once connected on a USB port, if drivers have been correctly installed, the XinaBox CW02 device is recognized by Zerynth Studio. The next steps are: Select the XinaBox CW02 on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process After virtualization, the XinaBox CW02 is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/xinabox_esp32/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the XinaBox CW02 device is available for bytecode and VM. Flash Layout is shown in table below: Start address Size Content 0x00010000 1Mb Zerynth VM (slot 0) 0x00110000 1Mb Zerynth VM (slot 1) 0x00210000 512Kb Zerynth Bytecode (slot 0) 0x00290000 512Kb Zerynth Bytecode (slot 1) For BLE VMs: Start address Size Content 0x00010000 1216Kb Zerynth VM (slot 0) 0x00140000 1216Kb Zerynth VM (slot 1) 0x00270000 320Kb Zerynth Bytecode (slot 0) 0x002C0000 320Kb Zerynth Bytecode (slot 1) For Esp32 based devices, the FOTA process is implemented mostly by using the provided system calls in the IDF framework. The selection of the next VM to be run is therefore a duty of the Espressif bootloader; the bootloader however, does not provide a failsafe mechanism to revert to the previous VM in case the currently selected one fails to start. At the moment this lack of a safety feature can not be circumvented, unless by changing the bootloader. As soon as Espressif relases a new IDF with such feature, we will release updated VMs.","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/xinabox_esp32/docs/#zerynth-secure-socket","text":"To be able to use zerynth secure socket on esp32 boards native_mbedtls: true must be used instead of zerynth_ssl: true in the project.yml file.","title":"zerynth secure socket"},{"location":"reference/boards/xinabox_esp32/docs/#secure-firmware","text":"Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - ESP32 section .","title":"Secure Firmware"},{"location":"reference/boards/xmc4200_digitalpowercc/docs/","text":"Infineon XMC4200 Digital Power Control Card \u00b6 Infineon XMC4200 Digital Power Control Card is equipped with the ARM Cortex-M4 based XMC4200 microcontroller (MCU) from Infineon Technologies. Official reference for Infineon XMC4200 Digital Power Control Card can be found here . This board is designed to be used with the XMC Digital Power Explorer Kit . The kit\u2019s power board features synchronous buck converter with on-board resistive load banks. The load banks can be switched between 10%, 55% and 100% of the maximum load, so that the transient response and the quality of the control loop under different load conditions can be tested (for example continuous conduction mode vs. discontinuous conduction mode). Pin Mapping \u00b6 Flash Layout \u00b6 The internal flash of the XMC4200 module is organized in a single flash area with 9 sectors. The flash starts at address 0xC000000. Start address Size Content 0xC000000 16Kb Zerynth VM 0xC004000 16Kb Zerynth VM 0xC008000 16Kb Zerynth VM 0xC00C000 16Kb Zerynth VM 0xC010000 16Kb Zerynth VM 0xC014000 16Kb Zerynth VM 0xC018000 16Kb Zerynth VM 0xC01C000 16Kb Zerynth VM 0xC020000 128Kb Bytecode Bank 0 Note If flash memory must be used in a Zerynth program, it is recommended to begin using it from secure addresses towards the end the bytecode (start address of the bytecode can be found in the log console of Zerynth Studio during the uplink operation), leaving a minimum safe place to minimize the chance of clashes. Device Summary \u00b6 XMC4200 Microcontroller based on ARM\u00ae Cortex\u00ae-M4F, 256kB Flash On-Board Debugger Connection to power board like Digital Power Explorer, via the power board connectors Power over USB 2 x user LED Power \u00b6 The XMC4200 Digital Power Control Cardboard is designed with two galvanically isolated supply domains. On the left side, there is the debug domainor isolated domain, which contains a XMC4200 MCU as on-board debug controller (OBD). The isolateddomain ispowered via the USB plug (5V) The rest of the control card is calledpower GND supply domain. This part is supplied from the power board connector and the control card will step down the input voltage to the 3.3V that XMC4200requires.This supply domain is usually powered from the power board connector. The typicalcurrent drawn bythe drive card at the power GND domain is about 65mAat 12 V input voltage. Connect, Register, Virtualize and Program \u00b6 The Infineon XMC4200 comes with a usb debugger chip on board that allows programming and opening the UART of the module. Drivers might be needed (Linux, Mac or Windows) and can be downloaded from the official JLink software page. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group Once connected on a USB port, if drivers have been correctly installed, the XMC4200 device is recognized by Zerynth Studio. The next steps are: Select the XMC4200 on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process After virtualization, the DevKitC is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process.","title":"Infineon XMC4200 Digital Power Control Card"},{"location":"reference/boards/xmc4200_digitalpowercc/docs/#infineon-xmc4200-digital-power-control-card","text":"Infineon XMC4200 Digital Power Control Card is equipped with the ARM Cortex-M4 based XMC4200 microcontroller (MCU) from Infineon Technologies. Official reference for Infineon XMC4200 Digital Power Control Card can be found here . This board is designed to be used with the XMC Digital Power Explorer Kit . The kit\u2019s power board features synchronous buck converter with on-board resistive load banks. The load banks can be switched between 10%, 55% and 100% of the maximum load, so that the transient response and the quality of the control loop under different load conditions can be tested (for example continuous conduction mode vs. discontinuous conduction mode).","title":"Infineon XMC4200 Digital Power Control Card"},{"location":"reference/boards/xmc4200_digitalpowercc/docs/#pin-mapping","text":"","title":"Pin Mapping"},{"location":"reference/boards/xmc4200_digitalpowercc/docs/#flash-layout","text":"The internal flash of the XMC4200 module is organized in a single flash area with 9 sectors. The flash starts at address 0xC000000. Start address Size Content 0xC000000 16Kb Zerynth VM 0xC004000 16Kb Zerynth VM 0xC008000 16Kb Zerynth VM 0xC00C000 16Kb Zerynth VM 0xC010000 16Kb Zerynth VM 0xC014000 16Kb Zerynth VM 0xC018000 16Kb Zerynth VM 0xC01C000 16Kb Zerynth VM 0xC020000 128Kb Bytecode Bank 0 Note If flash memory must be used in a Zerynth program, it is recommended to begin using it from secure addresses towards the end the bytecode (start address of the bytecode can be found in the log console of Zerynth Studio during the uplink operation), leaving a minimum safe place to minimize the chance of clashes.","title":"Flash Layout"},{"location":"reference/boards/xmc4200_digitalpowercc/docs/#device-summary","text":"XMC4200 Microcontroller based on ARM\u00ae Cortex\u00ae-M4F, 256kB Flash On-Board Debugger Connection to power board like Digital Power Explorer, via the power board connectors Power over USB 2 x user LED","title":"Device Summary"},{"location":"reference/boards/xmc4200_digitalpowercc/docs/#power","text":"The XMC4200 Digital Power Control Cardboard is designed with two galvanically isolated supply domains. On the left side, there is the debug domainor isolated domain, which contains a XMC4200 MCU as on-board debug controller (OBD). The isolateddomain ispowered via the USB plug (5V) The rest of the control card is calledpower GND supply domain. This part is supplied from the power board connector and the control card will step down the input voltage to the 3.3V that XMC4200requires.This supply domain is usually powered from the power board connector. The typicalcurrent drawn bythe drive card at the power GND domain is about 65mAat 12 V input voltage.","title":"Power"},{"location":"reference/boards/xmc4200_digitalpowercc/docs/#connect-register-virtualize-and-program","text":"The Infineon XMC4200 comes with a usb debugger chip on board that allows programming and opening the UART of the module. Drivers might be needed (Linux, Mac or Windows) and can be downloaded from the official JLink software page. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group Once connected on a USB port, if drivers have been correctly installed, the XMC4200 device is recognized by Zerynth Studio. The next steps are: Select the XMC4200 on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process After virtualization, the DevKitC is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/xmc4400_enterprisekit/docs/","text":"Infineon XMC4400 Enterprise Kit \u00b6 Infineon XMC4400 Enterprise Kit is equipped with the ARM Cortex-M4 based XMC4400 microcontroller (MCU) from Infineon Technologies. These kits are designed to evaluate the capabilities of the XMC4400 MCU. Pin Mapping \u00b6 Official reference for Infineon XMC4400 Enterprise Kit can be found here . Flash Layout \u00b6 The internal flash of the XMC4400 module is organized in a single flash area with 16 sectors. The flash starts at address 0xC000000. Start address Size Content 0xC000000 16Kb Zerynth VM 0xC004000 16Kb Zerynth VM 0xC008000 16Kb Zerynth VM 0xC00C000 16Kb Zerynth VM 0xC010000 16Kb Zerynth VM 0xC014000 16Kb Zerynth VM 0xC018000 16Kb Zerynth VM 0xC01C000 16Kb Zerynth VM 0xC020000 128Kb Bytecode Bank 0 0xC040000 256Kb Bytecode Bank 1 Note If flash memory must be used in a Zerynth program, it is recommended to begin using it from secure addresses towards the end the bytecode (start address of the bytecode can be found in the log console of Zerynth Studio during the uplink operation), leaving a minimum safe place to minimize the chance of clashes. Device Summary \u00b6 XMC4400 Microcontroller based on ARM\u00ae Cortex\u00ae-M4, 512Kb Flash On-Board Debugger Power over USB ESD and reverse current protection 1 x user button and 3 x user LEDs of which an RGB one Real Time Clock crystal Battery holder for an RTC backup battery Ethernet PHY and RJ45 Jack 3 Satellite Connectors 1 potentiometer Power \u00b6 Power to the XMC4400 is supplied via one of the two on-board USB Micro B connectors. However there is a current limit that can be drawn from the host PC through USB. If the board is used to drive other satellite cards and the total system current reuired exceeds 500 mA, then the xmc4400 needs to be powered by a satellite cards, which can support external power supply. Connect, Register, Virtualize and Program \u00b6 The Infineon XMC4400 comes with a usb debugger chip on board that allows programming and opening the UART of the module. Drivers are needed (Linux, Mac or Windows) and can be downloaded from the official JLink software page. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the XMC4400 device is recognized by Zerynth Studio. The next steps are: Select the XMC4400 on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the DevKitC is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process.","title":"Infineon XMC4400 Enterprise Kit"},{"location":"reference/boards/xmc4400_enterprisekit/docs/#infineon-xmc4400-enterprise-kit","text":"Infineon XMC4400 Enterprise Kit is equipped with the ARM Cortex-M4 based XMC4400 microcontroller (MCU) from Infineon Technologies. These kits are designed to evaluate the capabilities of the XMC4400 MCU.","title":"Infineon XMC4400 Enterprise Kit"},{"location":"reference/boards/xmc4400_enterprisekit/docs/#pin-mapping","text":"Official reference for Infineon XMC4400 Enterprise Kit can be found here .","title":"Pin Mapping"},{"location":"reference/boards/xmc4400_enterprisekit/docs/#flash-layout","text":"The internal flash of the XMC4400 module is organized in a single flash area with 16 sectors. The flash starts at address 0xC000000. Start address Size Content 0xC000000 16Kb Zerynth VM 0xC004000 16Kb Zerynth VM 0xC008000 16Kb Zerynth VM 0xC00C000 16Kb Zerynth VM 0xC010000 16Kb Zerynth VM 0xC014000 16Kb Zerynth VM 0xC018000 16Kb Zerynth VM 0xC01C000 16Kb Zerynth VM 0xC020000 128Kb Bytecode Bank 0 0xC040000 256Kb Bytecode Bank 1 Note If flash memory must be used in a Zerynth program, it is recommended to begin using it from secure addresses towards the end the bytecode (start address of the bytecode can be found in the log console of Zerynth Studio during the uplink operation), leaving a minimum safe place to minimize the chance of clashes.","title":"Flash Layout"},{"location":"reference/boards/xmc4400_enterprisekit/docs/#device-summary","text":"XMC4400 Microcontroller based on ARM\u00ae Cortex\u00ae-M4, 512Kb Flash On-Board Debugger Power over USB ESD and reverse current protection 1 x user button and 3 x user LEDs of which an RGB one Real Time Clock crystal Battery holder for an RTC backup battery Ethernet PHY and RJ45 Jack 3 Satellite Connectors 1 potentiometer","title":"Device Summary"},{"location":"reference/boards/xmc4400_enterprisekit/docs/#power","text":"Power to the XMC4400 is supplied via one of the two on-board USB Micro B connectors. However there is a current limit that can be drawn from the host PC through USB. If the board is used to drive other satellite cards and the total system current reuired exceeds 500 mA, then the xmc4400 needs to be powered by a satellite cards, which can support external power supply.","title":"Power"},{"location":"reference/boards/xmc4400_enterprisekit/docs/#connect-register-virtualize-and-program","text":"The Infineon XMC4400 comes with a usb debugger chip on board that allows programming and opening the UART of the module. Drivers are needed (Linux, Mac or Windows) and can be downloaded from the official JLink software page. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. Once connected on a USB port, if drivers have been correctly installed, the XMC4400 device is recognized by Zerynth Studio. The next steps are: Select the XMC4400 on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the DevKitC is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/xmc4700_relaxkit/docs/","text":"Infineon XMC4700 Relax Kit \u00b6 Infineon XMC4700/4800 Relax Kit is equipped with the ARM Cortex-M4 based XMC4700 microcontroller (MCU) from Infineon Technologies. These kits are designed to evaluate the capabilities of the XMC4700 MCU. The Relax Kits feature an Ethernet-enabled communication option. XMC4700 Relax Kit. Copyright Infineon Pin Mapping \u00b6 Official reference for Infineon XMC4700 Relax Kit can be found here . Flash Layout \u00b6 Start address Size Content 0xC000000 16Kb Zerynth VM 0xC004000 16Kb Zerynth VM 0xC008000 16Kb Zerynth VM 0xC00C000 16Kb Zerynth VM 0xC010000 16Kb Zerynth VM 0xC014000 16Kb Zerynth VM 0xC018000 16Kb Zerynth VM 0xC01C000 16Kb Zerynth VM 0xC020000 128Kb Bytecode Bank 0 0xC040000 256Kb Bytecode Bank 1 0xC080000 256Kb Bytecode Bank 2 0xC0C0000 256Kb Bytecode Bank 3 0xC100000 256Kb Bytecode Bank 4 0xC140000 256Kb Bytecode Bank 5 0xC180000 256Kb Bytecode Bank 6 0xC1C0000 256Kb Bytecode Bank 7 Note If flash memory must be used in a Zerynth program, it is recommended to begin using it from secure addresses towards the end the bytecode (start address of the bytecode can be found in the log console of Zerynth Studio during the uplink operation), leaving a minimum safe place to minimize the chance of clashes. Device Summary \u00b6 XMC4700-F144 Microcontroller based on ARM\u00ae Cortex\u00ae-M4 @ 144MHz, 2MB Flash and 352KB RAM On-Board Debugger Power over USB ESD and reverse current protection 2 x user button and 2 x user LED Arduino hardware compatible 3.3V pinout Real Time Clock crystal microSD Card Slot Ethernet PHY and RJ45 Jack Power \u00b6 Power to the XMC4700 is supplied via one of the two on-board USB Micro B connectors. Connect, Register, Virtualize and Program \u00b6 The Infineon XMC4700 comes with a usb debugger chip on board that allows programming and opening the UART of the module. Drivers are needed (Linux, Mac or Windows) and can be downloaded from the official JLink software page. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group Once connected on a USB port, if drivers have been correctly installed, the XMC4700 device is recognized by Zerynth Studio. The next steps are: Select the XMC4700 on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process After virtualization, the DevKitC is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process.","title":"Infineon XMC4700 Relax Kit"},{"location":"reference/boards/xmc4700_relaxkit/docs/#infineon-xmc4700-relax-kit","text":"Infineon XMC4700/4800 Relax Kit is equipped with the ARM Cortex-M4 based XMC4700 microcontroller (MCU) from Infineon Technologies. These kits are designed to evaluate the capabilities of the XMC4700 MCU. The Relax Kits feature an Ethernet-enabled communication option. XMC4700 Relax Kit. Copyright Infineon","title":"Infineon XMC4700 Relax Kit"},{"location":"reference/boards/xmc4700_relaxkit/docs/#pin-mapping","text":"Official reference for Infineon XMC4700 Relax Kit can be found here .","title":"Pin Mapping"},{"location":"reference/boards/xmc4700_relaxkit/docs/#flash-layout","text":"Start address Size Content 0xC000000 16Kb Zerynth VM 0xC004000 16Kb Zerynth VM 0xC008000 16Kb Zerynth VM 0xC00C000 16Kb Zerynth VM 0xC010000 16Kb Zerynth VM 0xC014000 16Kb Zerynth VM 0xC018000 16Kb Zerynth VM 0xC01C000 16Kb Zerynth VM 0xC020000 128Kb Bytecode Bank 0 0xC040000 256Kb Bytecode Bank 1 0xC080000 256Kb Bytecode Bank 2 0xC0C0000 256Kb Bytecode Bank 3 0xC100000 256Kb Bytecode Bank 4 0xC140000 256Kb Bytecode Bank 5 0xC180000 256Kb Bytecode Bank 6 0xC1C0000 256Kb Bytecode Bank 7 Note If flash memory must be used in a Zerynth program, it is recommended to begin using it from secure addresses towards the end the bytecode (start address of the bytecode can be found in the log console of Zerynth Studio during the uplink operation), leaving a minimum safe place to minimize the chance of clashes.","title":"Flash Layout"},{"location":"reference/boards/xmc4700_relaxkit/docs/#device-summary","text":"XMC4700-F144 Microcontroller based on ARM\u00ae Cortex\u00ae-M4 @ 144MHz, 2MB Flash and 352KB RAM On-Board Debugger Power over USB ESD and reverse current protection 2 x user button and 2 x user LED Arduino hardware compatible 3.3V pinout Real Time Clock crystal microSD Card Slot Ethernet PHY and RJ45 Jack","title":"Device Summary"},{"location":"reference/boards/xmc4700_relaxkit/docs/#power","text":"Power to the XMC4700 is supplied via one of the two on-board USB Micro B connectors.","title":"Power"},{"location":"reference/boards/xmc4700_relaxkit/docs/#connect-register-virtualize-and-program","text":"The Infineon XMC4700 comes with a usb debugger chip on board that allows programming and opening the UART of the module. Drivers are needed (Linux, Mac or Windows) and can be downloaded from the official JLink software page. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group Once connected on a USB port, if drivers have been correctly installed, the XMC4700 device is recognized by Zerynth Studio. The next steps are: Select the XMC4700 on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process After virtualization, the DevKitC is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/xmc4800_connectivitykit/docs/","text":"Infineon XMC4800 Connectivity Kit \u00b6 Infineon XMC4800 connectivity Kit is equipped with the ARM Cortex-M4 based XMC4800 microcontroller (MCU) from Infineon Technologies. These kits are designed to evaluate the capabilities of the XMC4800 MCU. The connectivity Kits feature an Ethernet-enabled communication option. XMC4800 Connectivity Kit. Copyright Infineon Pin Mapping \u00b6 Official reference for Infineon XMC4800 connectivity Kit can be found here . Flash Layout \u00b6 The internal flash of the XMC4800 module is organized in a single flash area with 16 sectors. The flash starts at address 0xC000000. Start address Size Content 0xC000000 16Kb Zerynth VM 0xC004000 16Kb Zerynth VM 0xC008000 16Kb Zerynth VM 0xC00C000 16Kb Zerynth VM 0xC010000 16Kb Zerynth VM 0xC014000 16Kb Zerynth VM 0xC018000 16Kb Zerynth VM 0xC01C000 16Kb Zerynth VM 0xC020000 128Kb Bytecode Bank 0 0xC040000 256Kb Bytecode Bank 1 0xC080000 256Kb Bytecode Bank 2 0xC0C0000 256Kb Bytecode Bank 3 0xC100000 256Kb Bytecode Bank 4 0xC140000 256Kb Bytecode Bank 5 0xC180000 256Kb Bytecode Bank 6 0xC1C0000 256Kb Bytecode Bank 7 Note If flash memory must be used in a Zerynth program, it is recommended to begin using it from secure addresses towards the end the bytecode (start address of the bytecode can be found in the log console of Zerynth Studio during the uplink operation), leaving a minimum safe place to minimize the chance of clashes. Device Summary \u00b6 XMC4800-F144 Microcontroller based on ARM\u00ae Cortex\u00ae-M4 @ 144MHz, 2MB Flash and 352KB RAM On-Board Debugger Power over USB MikroBUS connector ESD and reverse current protection 1 x user button and 2 x user LED Arduino hardware compatible 3.3V pinout Power \u00b6 Power to the XMC4800 is supplied via one of the two on-board USB Micro B connectors. Connect, Register, Virtualize and Program \u00b6 The Infineon XMC4800 comes with a usb debugger chip on board that allows programming and opening the UART of the module. Drivers are needed (Linux, Mac or Windows) and can be downloaded from the official JLink software page. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group Once connected on a USB port, if drivers have been correctly installed, the XMC4800 device is recognized by Zerynth Studio. The next steps are: Select the XMC4800 on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process After virtualization, the DevKitC is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process. Missing Features \u00b6 Not all features have been included in the XMC4800 Connectivity Kit support. In particular the following are missing: CDC USB Serial Driver CAN Ethercat","title":"Infineon XMC4800 Connectivity Kit"},{"location":"reference/boards/xmc4800_connectivitykit/docs/#infineon-xmc4800-connectivity-kit","text":"Infineon XMC4800 connectivity Kit is equipped with the ARM Cortex-M4 based XMC4800 microcontroller (MCU) from Infineon Technologies. These kits are designed to evaluate the capabilities of the XMC4800 MCU. The connectivity Kits feature an Ethernet-enabled communication option. XMC4800 Connectivity Kit. Copyright Infineon","title":"Infineon XMC4800 Connectivity Kit"},{"location":"reference/boards/xmc4800_connectivitykit/docs/#pin-mapping","text":"Official reference for Infineon XMC4800 connectivity Kit can be found here .","title":"Pin Mapping"},{"location":"reference/boards/xmc4800_connectivitykit/docs/#flash-layout","text":"The internal flash of the XMC4800 module is organized in a single flash area with 16 sectors. The flash starts at address 0xC000000. Start address Size Content 0xC000000 16Kb Zerynth VM 0xC004000 16Kb Zerynth VM 0xC008000 16Kb Zerynth VM 0xC00C000 16Kb Zerynth VM 0xC010000 16Kb Zerynth VM 0xC014000 16Kb Zerynth VM 0xC018000 16Kb Zerynth VM 0xC01C000 16Kb Zerynth VM 0xC020000 128Kb Bytecode Bank 0 0xC040000 256Kb Bytecode Bank 1 0xC080000 256Kb Bytecode Bank 2 0xC0C0000 256Kb Bytecode Bank 3 0xC100000 256Kb Bytecode Bank 4 0xC140000 256Kb Bytecode Bank 5 0xC180000 256Kb Bytecode Bank 6 0xC1C0000 256Kb Bytecode Bank 7 Note If flash memory must be used in a Zerynth program, it is recommended to begin using it from secure addresses towards the end the bytecode (start address of the bytecode can be found in the log console of Zerynth Studio during the uplink operation), leaving a minimum safe place to minimize the chance of clashes.","title":"Flash Layout"},{"location":"reference/boards/xmc4800_connectivitykit/docs/#device-summary","text":"XMC4800-F144 Microcontroller based on ARM\u00ae Cortex\u00ae-M4 @ 144MHz, 2MB Flash and 352KB RAM On-Board Debugger Power over USB MikroBUS connector ESD and reverse current protection 1 x user button and 2 x user LED Arduino hardware compatible 3.3V pinout","title":"Device Summary"},{"location":"reference/boards/xmc4800_connectivitykit/docs/#power","text":"Power to the XMC4800 is supplied via one of the two on-board USB Micro B connectors.","title":"Power"},{"location":"reference/boards/xmc4800_connectivitykit/docs/#connect-register-virtualize-and-program","text":"The Infineon XMC4800 comes with a usb debugger chip on board that allows programming and opening the UART of the module. Drivers are needed (Linux, Mac or Windows) and can be downloaded from the official JLink software page. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group Once connected on a USB port, if drivers have been correctly installed, the XMC4800 device is recognized by Zerynth Studio. The next steps are: Select the XMC4800 on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process After virtualization, the DevKitC is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio. Note No user intervention on the device is required for the uplink process.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/xmc4800_connectivitykit/docs/#missing-features","text":"Not all features have been included in the XMC4800 Connectivity Kit support. In particular the following are missing: CDC USB Serial Driver CAN Ethercat","title":"Missing Features"},{"location":"reference/boards/xplained_c21/docs/","text":"Xplained Pro Sam C21 \u00b6 The Xplained Pro Sam C21 is a microcontroller device based on the Atmel SAMC21J18A ARM Cortex-M0+ CPU . The Xplained Pro extension kits offers additional peripherals to extend the features of the device and ease the development of custom designs. One of its most important features is the Atmel Embedded Debugger (EDBG), which provides a full debug interface without the need for additional hardware, significantly increasing the ease-of-use for software debugging. EDBG also supports a virtual COM port that can be used for device and bootloader programming. Note All the reported information are extracted from the official Xplained Pro Sam C21 page , visit this page for more details and updates. Pin Mapping \u00b6 Xplained Pro Sam C21 Official Schematic, Reference Design and Pin Mapping are available on the official Atmel User Guide . Flash Layout \u00b6 The internal flash of the Xplained Pro Sam C21 is organized as a single bank of 256k. Zerynth VM starts at first address of the flash memory. Device Summary \u00b6 Microcontroller: ATSAMC21J18 Operating Voltage: 3.3V or 5.0V USARTs: 2 SPIs: 2 I2Cs: 1 Flash Memory: 256 KB SRAM: 32 KB Clock Speed: 48 MHz Power \u00b6 The Xplained Pro Sam C21 can be powered via the USB connector or with an external power supply via \u201cGND\u201d and \u201c5.0 IN\u201d pins of the PWR header. The device can operate on an external supply of 5V \u00b12% (\u00b1100mV) for USB host operation or from 4.3V to 5.5V if USB host operation is not required. Current recommended requirements, in external power supply mode, are: minimum 1A to be able to provide enough current for connected USB devices and the device itself. maximum is 2A due to the input protection maximum current specification Note External power is required when 500mA from a USB connector is not enough to power the device with possible extension boards. A connected USB device in a USB host application might easily exceed this limit. Connect, Register, Virtualize and Program \u00b6 The Xplained Pro Sam C21 debug port is connected to EDBG, which provides a virtual COM port to software on a connected computer. To recognize the device, all Windows (automatic driver software installation), OSX and Linux machines will recognize the device as a COM port automatically. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. If the device is still not recognized or not working, the following udev rules may need to be added: # Check SUBSYSTEM SUBSYSTEMS == \"hidraw\" , KERNEL == \"hidraw*\" , MODE = \"0666\" , GROUP = \"dialout\" # Xplained Pro SamC21 Device SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"03eb\" , ATTRS { idProduct }== \"2111\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"03eb\" , ATTRS { idProduct }== \"2111\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" EDBG is also connected to the SAMC21 hardware UART. Serial on pins RX0 and TX0 provides Serial-to-USB communication for programming the device through Atmel EDBG. Once connected on a USB port the Xplained Pro Sam C21 device is recognized by Zerynth Studio. The next steps are: Select the Xplained Pro Sam C21 on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the Xplained Pro Sam C21 is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and rese the device by pressing the Reset on-board button when asked. Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Xplained Pro Sam C21 device is available for bytecode only. Flash Layout is shown in table below: Start address Size Content 0x00002000 88Kb VM Slot 0x00018000 80Kb Bytecode Slot 0 0x0002C000 80Kb Bytecode Slot 1 Secure Firmware \u00b6 Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - Microchip SAMC21 section . Missing features \u00b6 Not all features have been included in the Xplained Pro SamC21 support. In particular the following are missing: ICU Powersave firmware","title":"Xplained Pro Sam C21"},{"location":"reference/boards/xplained_c21/docs/#xplained-pro-sam-c21","text":"The Xplained Pro Sam C21 is a microcontroller device based on the Atmel SAMC21J18A ARM Cortex-M0+ CPU . The Xplained Pro extension kits offers additional peripherals to extend the features of the device and ease the development of custom designs. One of its most important features is the Atmel Embedded Debugger (EDBG), which provides a full debug interface without the need for additional hardware, significantly increasing the ease-of-use for software debugging. EDBG also supports a virtual COM port that can be used for device and bootloader programming. Note All the reported information are extracted from the official Xplained Pro Sam C21 page , visit this page for more details and updates.","title":"Xplained Pro Sam C21"},{"location":"reference/boards/xplained_c21/docs/#pin-mapping","text":"Xplained Pro Sam C21 Official Schematic, Reference Design and Pin Mapping are available on the official Atmel User Guide .","title":"Pin Mapping"},{"location":"reference/boards/xplained_c21/docs/#flash-layout","text":"The internal flash of the Xplained Pro Sam C21 is organized as a single bank of 256k. Zerynth VM starts at first address of the flash memory.","title":"Flash Layout"},{"location":"reference/boards/xplained_c21/docs/#device-summary","text":"Microcontroller: ATSAMC21J18 Operating Voltage: 3.3V or 5.0V USARTs: 2 SPIs: 2 I2Cs: 1 Flash Memory: 256 KB SRAM: 32 KB Clock Speed: 48 MHz","title":"Device Summary"},{"location":"reference/boards/xplained_c21/docs/#power","text":"The Xplained Pro Sam C21 can be powered via the USB connector or with an external power supply via \u201cGND\u201d and \u201c5.0 IN\u201d pins of the PWR header. The device can operate on an external supply of 5V \u00b12% (\u00b1100mV) for USB host operation or from 4.3V to 5.5V if USB host operation is not required. Current recommended requirements, in external power supply mode, are: minimum 1A to be able to provide enough current for connected USB devices and the device itself. maximum is 2A due to the input protection maximum current specification Note External power is required when 500mA from a USB connector is not enough to power the device with possible extension boards. A connected USB device in a USB host application might easily exceed this limit.","title":"Power"},{"location":"reference/boards/xplained_c21/docs/#connect-register-virtualize-and-program","text":"The Xplained Pro Sam C21 debug port is connected to EDBG, which provides a virtual COM port to software on a connected computer. To recognize the device, all Windows (automatic driver software installation), OSX and Linux machines will recognize the device as a COM port automatically. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. If the device is still not recognized or not working, the following udev rules may need to be added: # Check SUBSYSTEM SUBSYSTEMS == \"hidraw\" , KERNEL == \"hidraw*\" , MODE = \"0666\" , GROUP = \"dialout\" # Xplained Pro SamC21 Device SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"03eb\" , ATTRS { idProduct }== \"2111\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"03eb\" , ATTRS { idProduct }== \"2111\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" EDBG is also connected to the SAMC21 hardware UART. Serial on pins RX0 and TX0 provides Serial-to-USB communication for programming the device through Atmel EDBG. Once connected on a USB port the Xplained Pro Sam C21 device is recognized by Zerynth Studio. The next steps are: Select the Xplained Pro Sam C21 on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the Xplained Pro Sam C21 is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and rese the device by pressing the Reset on-board button when asked.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/xplained_c21/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Xplained Pro Sam C21 device is available for bytecode only. Flash Layout is shown in table below: Start address Size Content 0x00002000 88Kb VM Slot 0x00018000 80Kb Bytecode Slot 0 0x0002C000 80Kb Bytecode Slot 1","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/xplained_c21/docs/#secure-firmware","text":"Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - Microchip SAMC21 section .","title":"Secure Firmware"},{"location":"reference/boards/xplained_c21/docs/#missing-features","text":"Not all features have been included in the Xplained Pro SamC21 support. In particular the following are missing: ICU Powersave firmware","title":"Missing features"},{"location":"reference/boards/xplained_c21n/docs/","text":"Xplained Pro Sam C21N \u00b6 The Xplained Pro Sam C21N is a microcontroller device based on the Atmel SAMC21N18A ARM Cortex-M0+ CPU . The Xplained Pro extension kits offers additional peripherals to extend the features of the device and ease the development of custom designs. One of its most important features is the Atmel Embedded Debugger (EDBG), which provides a full debug interface without the need for additional hardware, significantly increasing the ease-of-use for software debugging. EDBG also supports a virtual COM port that can be used for device and bootloader programming. Note All the reported information are extracted from the official Xplained Pro Sam C21N page , visit this page for more details and updates. Pin Mapping \u00b6 Xplained Pro Sam C21N Official Schematic, Reference Design and Pin Mapping are available on the official Atmel User Guide . Flash Layout \u00b6 The internal flash of the Xplained Pro Sam C21N is organized as a single bank of 256k. Zerynth VM starts at first address of the flash memory. Device Summary \u00b6 Microcontroller: ATSAMC21N18 Operating Voltage: 3.3V or 5.0V USARTs: 4 SPIs: 3 I2Cs: 2 Flash Memory: 256 KB SRAM: 32 KB Clock Speed: 48 MHz Power \u00b6 The Xplained Pro Sam C21N can be powered via the USB connector or with an external power supply via \u201cGND\u201d and \u201c5.0 IN\u201d pins of the PWR header. The device can operate on an external supply of 5V \u00b12% (\u00b1100mV) for USB host operation or from 4.3V to 5.5V if USB host operation is not required. Current recommended requirements, in external power supply mode, are: minimum 1A to be able to provide enough current for connected USB devices and the device itself. maximum is 2A due to the input protection maximum current specification Note External power is required when 500mA from a USB connector is not enough to power the device with possible extension boards. A connected USB device in a USB host application might easily exceed this limit. Connect, Register, Virtualize and Program \u00b6 The Xplained Pro Sam C21N debug port is connected to EDBG, which provides a virtual COM port to software on a connected computer. To recognize the device, all Windows (automatic driver software installation), OSX and Linux machines will recognize the device as a COM port automatically. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. If the device is still not recognized or not working, the following udev rules may need to be added: # Check SUBSYSTEM SUBSYSTEMS == \"hidraw\" , KERNEL == \"hidraw*\" , MODE = \"0666\" , GROUP = \"dialout\" # Xplained Pro SamC21N Device SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"03eb\" , ATTRS { idProduct }== \"2111\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"03eb\" , ATTRS { idProduct }== \"2111\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" EDBG is also connected to the SAMC21N hardware UART. Serial on pins RX0 and TX0 provides Serial-to-USB communication for programming the device through Atmel EDBG. Once connected on a USB port the Xplained Pro Sam C21N device is recognized by Zerynth Studio. The next steps are: Select the Xplained Pro Sam C21N on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process After virtualization, the Xplained Pro Sam C21N is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked. Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Xplained Pro Sam C21 device is available for bytecode only. Flash Layout is shown in table below: Start address Size Content 0x00002000 88Kb VM Slot 0x00018000 80Kb Bytecode Slot 0 0x0002C000 80Kb Bytecode Slot 1 Secure Firmware \u00b6 Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - Microchip SAMC21 section . Missing features \u00b6 Not all features have been included in the Xplained Pro SamC21 support. In particular the following are missing: ICU Powersave firmware","title":"Xplained Pro Sam C21N"},{"location":"reference/boards/xplained_c21n/docs/#xplained-pro-sam-c21n","text":"The Xplained Pro Sam C21N is a microcontroller device based on the Atmel SAMC21N18A ARM Cortex-M0+ CPU . The Xplained Pro extension kits offers additional peripherals to extend the features of the device and ease the development of custom designs. One of its most important features is the Atmel Embedded Debugger (EDBG), which provides a full debug interface without the need for additional hardware, significantly increasing the ease-of-use for software debugging. EDBG also supports a virtual COM port that can be used for device and bootloader programming. Note All the reported information are extracted from the official Xplained Pro Sam C21N page , visit this page for more details and updates.","title":"Xplained Pro Sam C21N"},{"location":"reference/boards/xplained_c21n/docs/#pin-mapping","text":"Xplained Pro Sam C21N Official Schematic, Reference Design and Pin Mapping are available on the official Atmel User Guide .","title":"Pin Mapping"},{"location":"reference/boards/xplained_c21n/docs/#flash-layout","text":"The internal flash of the Xplained Pro Sam C21N is organized as a single bank of 256k. Zerynth VM starts at first address of the flash memory.","title":"Flash Layout"},{"location":"reference/boards/xplained_c21n/docs/#device-summary","text":"Microcontroller: ATSAMC21N18 Operating Voltage: 3.3V or 5.0V USARTs: 4 SPIs: 3 I2Cs: 2 Flash Memory: 256 KB SRAM: 32 KB Clock Speed: 48 MHz","title":"Device Summary"},{"location":"reference/boards/xplained_c21n/docs/#power","text":"The Xplained Pro Sam C21N can be powered via the USB connector or with an external power supply via \u201cGND\u201d and \u201c5.0 IN\u201d pins of the PWR header. The device can operate on an external supply of 5V \u00b12% (\u00b1100mV) for USB host operation or from 4.3V to 5.5V if USB host operation is not required. Current recommended requirements, in external power supply mode, are: minimum 1A to be able to provide enough current for connected USB devices and the device itself. maximum is 2A due to the input protection maximum current specification Note External power is required when 500mA from a USB connector is not enough to power the device with possible extension boards. A connected USB device in a USB host application might easily exceed this limit.","title":"Power"},{"location":"reference/boards/xplained_c21n/docs/#connect-register-virtualize-and-program","text":"The Xplained Pro Sam C21N debug port is connected to EDBG, which provides a virtual COM port to software on a connected computer. To recognize the device, all Windows (automatic driver software installation), OSX and Linux machines will recognize the device as a COM port automatically. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. If the device is still not recognized or not working, the following udev rules may need to be added: # Check SUBSYSTEM SUBSYSTEMS == \"hidraw\" , KERNEL == \"hidraw*\" , MODE = \"0666\" , GROUP = \"dialout\" # Xplained Pro SamC21N Device SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"03eb\" , ATTRS { idProduct }== \"2111\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"03eb\" , ATTRS { idProduct }== \"2111\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" EDBG is also connected to the SAMC21N hardware UART. Serial on pins RX0 and TX0 provides Serial-to-USB communication for programming the device through Atmel EDBG. Once connected on a USB port the Xplained Pro Sam C21N device is recognized by Zerynth Studio. The next steps are: Select the Xplained Pro Sam C21N on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process After virtualization, the Xplained Pro Sam C21N is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/xplained_c21n/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Xplained Pro Sam C21 device is available for bytecode only. Flash Layout is shown in table below: Start address Size Content 0x00002000 88Kb VM Slot 0x00018000 80Kb Bytecode Slot 0 0x0002C000 80Kb Bytecode Slot 1","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/xplained_c21n/docs/#secure-firmware","text":"Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). This feature is strongly platform dependent; more information at Secure Firmware - Microchip SAMC21 section .","title":"Secure Firmware"},{"location":"reference/boards/xplained_c21n/docs/#missing-features","text":"Not all features have been included in the Xplained Pro SamC21 support. In particular the following are missing: ICU Powersave firmware","title":"Missing features"},{"location":"reference/boards/xplained_d21/docs/","text":"Xplained Pro Sam D21 \u00b6 The Xplained Pro Sam D21 is a microcontroller device based on the Atmel SAMD21J18A ARM Cortex-M0+ CPU . The Xplained Pro extension kits offers additional peripherals to extend the features of the device and ease the development of custom designs. It has 22 digital input/output pins, 20 analog inputs, 2 UARTs (hardware serial ports), a 48 MHz clock, 1 TWI, 3 SPI header, a reset button. One of its most important features is the Atmel Embedded Debugger (EDBG), which provides a full debug interface without the need for additional hardware, significantly increasing the ease-of-use for software debugging. EDBG also supports a virtual COM port that can be used for device and bootloader programming. Note All the reported information are extracted from the official Xplained Pro Sam D21 page , visit this page for more details and updates. Pin Mapping \u00b6 Xplained Pro Sam D21 Official Schematic, Reference Design and Pin Mapping are available on the official Atmel User Guide . Flash Layout \u00b6 The internal flash of the Xplained Pro Sam D21 is organized as a single bank of 256k. Zerynth VM starts at first address of the flash memory. Device Summary \u00b6 Microcontroller: ATSAMD21J18 Operating Voltage: 3.3V Digital I/O Pins (DIO): 22 Analog Input Pins (ADC): 20 UARTs: 2 SPIs: 3 I2Cs: 1 Flash Memory: 256 KB SRAM: 32 KB Clock Speed: 48 MHz Power \u00b6 The Xplained Pro Sam D21 can be powered via the USB connector or with an external power supply via \u201cGND\u201d and \u201c5.0 IN\u201d pins of the PWR header. The device can operate on an external supply of 5V \u00b12% (\u00b1100mV) for USB host operation or from 4.3V to 5.5V if USB host operation is not required. Current recommended requirements, in external power supply mode, are: minimum 1A to be able to provide enough current for connected USB devices and the device itself. maximum is 2A due to the input protection maximum current specification Note External power is required when 500mA from a USB connector is not enough to power the device with possible extension boards. A connected USB device in a USB host application might easily exceed this limit. Connect, Register, Virtualize and Program \u00b6 The Xplained Pro Sam D21 debug port is connected to EDBG, which provides a virtual COM port to software on a connected computer. To recognize the device, all Windows (automatic driver software installation), OSX and Linux machines will recognize the device as a COM port automatically. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. If the device is still not recognized or not working, the following udev rules may need to be added: # Check SUBSYSTEM SUBSYSTEMS == \"hidraw\" , KERNEL == \"hidraw*\" , MODE = \"0666\" , GROUP = \"dialout\" # Xplained Pro SamD21 Device SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"03eb\" , ATTRS { idProduct }== \"2111\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"03eb\" , ATTRS { idProduct }== \"2111\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" EDBG is also connected to the SAMD21 hardware UART. Serial on pins RX0 and TX0 provides Serial-to-USB communication for programming the device through Atmel EDBG. Once connected on a USB port the Xplained Pro Sam D21 device is recognized by Zerynth Studio. The next steps are: Select the Xplained Pro Sam D21 on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process After virtualization, the Xplained Pro Sam D21 is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked. Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Xplained Pro Sam D21 device is available for bytecode only. Flash Layout is shown in table below: Start address Size Content 0x00002000 88Kb VM Slot 0x00018000 80Kb Bytecode Slot 0 0x0002C000 80Kb Bytecode Slot 1 Power Management and Secure Firmware \u00b6 Power Management feature allows to optimize power consumption by putting the device in low consumption state. Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). Both these features are strongly platform dependent; more information at Power Management - Microchip SAMD21 section and Secure Firmware - Microchip SAMD21 section .","title":"Xplained Pro Sam D21"},{"location":"reference/boards/xplained_d21/docs/#xplained-pro-sam-d21","text":"The Xplained Pro Sam D21 is a microcontroller device based on the Atmel SAMD21J18A ARM Cortex-M0+ CPU . The Xplained Pro extension kits offers additional peripherals to extend the features of the device and ease the development of custom designs. It has 22 digital input/output pins, 20 analog inputs, 2 UARTs (hardware serial ports), a 48 MHz clock, 1 TWI, 3 SPI header, a reset button. One of its most important features is the Atmel Embedded Debugger (EDBG), which provides a full debug interface without the need for additional hardware, significantly increasing the ease-of-use for software debugging. EDBG also supports a virtual COM port that can be used for device and bootloader programming. Note All the reported information are extracted from the official Xplained Pro Sam D21 page , visit this page for more details and updates.","title":"Xplained Pro Sam D21"},{"location":"reference/boards/xplained_d21/docs/#pin-mapping","text":"Xplained Pro Sam D21 Official Schematic, Reference Design and Pin Mapping are available on the official Atmel User Guide .","title":"Pin Mapping"},{"location":"reference/boards/xplained_d21/docs/#flash-layout","text":"The internal flash of the Xplained Pro Sam D21 is organized as a single bank of 256k. Zerynth VM starts at first address of the flash memory.","title":"Flash Layout"},{"location":"reference/boards/xplained_d21/docs/#device-summary","text":"Microcontroller: ATSAMD21J18 Operating Voltage: 3.3V Digital I/O Pins (DIO): 22 Analog Input Pins (ADC): 20 UARTs: 2 SPIs: 3 I2Cs: 1 Flash Memory: 256 KB SRAM: 32 KB Clock Speed: 48 MHz","title":"Device Summary"},{"location":"reference/boards/xplained_d21/docs/#power","text":"The Xplained Pro Sam D21 can be powered via the USB connector or with an external power supply via \u201cGND\u201d and \u201c5.0 IN\u201d pins of the PWR header. The device can operate on an external supply of 5V \u00b12% (\u00b1100mV) for USB host operation or from 4.3V to 5.5V if USB host operation is not required. Current recommended requirements, in external power supply mode, are: minimum 1A to be able to provide enough current for connected USB devices and the device itself. maximum is 2A due to the input protection maximum current specification Note External power is required when 500mA from a USB connector is not enough to power the device with possible extension boards. A connected USB device in a USB host application might easily exceed this limit.","title":"Power"},{"location":"reference/boards/xplained_d21/docs/#connect-register-virtualize-and-program","text":"The Xplained Pro Sam D21 debug port is connected to EDBG, which provides a virtual COM port to software on a connected computer. To recognize the device, all Windows (automatic driver software installation), OSX and Linux machines will recognize the device as a COM port automatically. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. If the device is still not recognized or not working, the following udev rules may need to be added: # Check SUBSYSTEM SUBSYSTEMS == \"hidraw\" , KERNEL == \"hidraw*\" , MODE = \"0666\" , GROUP = \"dialout\" # Xplained Pro SamD21 Device SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"03eb\" , ATTRS { idProduct }== \"2111\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"03eb\" , ATTRS { idProduct }== \"2111\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" EDBG is also connected to the SAMD21 hardware UART. Serial on pins RX0 and TX0 provides Serial-to-USB communication for programming the device through Atmel EDBG. Once connected on a USB port the Xplained Pro Sam D21 device is recognized by Zerynth Studio. The next steps are: Select the Xplained Pro Sam D21 on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process After virtualization, the Xplained Pro Sam D21 is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/xplained_d21/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Xplained Pro Sam D21 device is available for bytecode only. Flash Layout is shown in table below: Start address Size Content 0x00002000 88Kb VM Slot 0x00018000 80Kb Bytecode Slot 0 0x0002C000 80Kb Bytecode Slot 1","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/xplained_d21/docs/#power-management-and-secure-firmware","text":"Power Management feature allows to optimize power consumption by putting the device in low consumption state. Secure Firmware feature allows to detect and recover from malfunctions and, when supported, to protect the running firmware (e.g. disabling the external access to flash or assigning protected RAM memory to critical parts of the system). Both these features are strongly platform dependent; more information at Power Management - Microchip SAMD21 section and Secure Firmware - Microchip SAMD21 section .","title":"Power Management and Secure Firmware"},{"location":"reference/boards/xplained_l21b/docs/","text":"Xplained Pro Sam L21 \u00b6 The SAM L21 Xplained Pro evaluation kit is a hardware platform to evaluate the ATSAML21J18B ARM Cortex-M0+ CPU . The device provides easy access to the features of the Atmel ATSAML21J18B and explains how to integrate the device in a custom design. The Xplained Pro MCU series evaluation kits include an on-board Embedded Debugger, and no external tools are necessary to program or debug the ATSAML21J18B. The Xplained Pro extension kits offers additional peripherals to extend the features of the device and ease the development of custom designs. It has 43 digital input/output pins, 19 analog inputs, 3 UARTs (hardware serial ports), a 48 MHz clock, 1 I2C, 2 SPI header, a reset button. One of its most important features is the Atmel Embedded Debugger (EDBG), which provides a full debug interface without the need for additional hardware, significantly increasing the ease-of-use for software debugging. EDBG also supports a virtual COM port that can be used for device and bootloader programming. Note All the reported information are extracted from the official Xplained Pro Sam L21 page , visit this page for more details and updates. Pin Mapping \u00b6 Xplained Pro Sam L21 Official Schematic, Reference Design and Pin Mapping are available on the official Atmel User Guide . Flash Layout \u00b6 The internal flash of the Xplained Pro Sam L21 is organized as a single bank of 256k. Zerynth VM starts at first address of the flash memory. Device Summary \u00b6 Microcontroller: ATSAML21J18B Operating Voltage: 3.3V Digital I/O Pins (DIO): 43 Analog Input Pins (ADC): 19 UARTs: 3 SPIs: 2 I2Cs: 1 Flash Memory: 256 KB SRAM: 32 KB Clock Speed: 48 MHz Power \u00b6 The Xplained Pro Sam L21 can be powered via the USB connector or with an external power supply via \u201cGND\u201d and \u201c5.0 IN\u201d pins of the PWR header. The device can operate on an external supply of 5V \u00b12% (\u00b1100mV) for USB host operation or from 4.3V to 5.5V if USB host operation is not required. Current recommended requirements, in external power supply mode, are: minimum 1A to be able to provide enough current for connected USB devices and the device itself. maximum is 2A due to the input protection maximum current specification The SAM L21 Xplained Pro has a backup battery for use with the SAM L21 backup module. The battery can be connected to the device by placing a jumper over pin 1-2 on the 3-pin VBAT SELECT header. By default the jumper is placed over pin 2-3 to select the board power supply. This configuration is selected to avoid draining the battery and can be used during development. Note External power is required when 500mA from a USB connector is not enough to power the device with possible extension boards. A connected USB device in a USB host application might easily exceed this limit. Connect, Register, Virtualize and Program \u00b6 The Xplained Pro Sam L21 debug port is connected to EDBG, which provides a virtual COM port to software on a connected computer. To recognize the device, all Windows (automatic driver software installation), OSX and Linux machines will recognize the device as a COM port automatically. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. If the device is still not recognized or not working, the following udev rules may need to be added: # Check SUBSYSTEM SUBSYSTEMS == \"hidraw\" , KERNEL == \"hidraw*\" , MODE = \"0666\" , GROUP = \"dialout\" # Xplained Pro SamL21 Device SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"03eb\" , ATTRS { idProduct }== \"2111\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"03eb\" , ATTRS { idProduct }== \"2111\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" EDBG is also connected to the SAML21 hardware UART. Serial on pins RX0 and TX0 provides Serial-to-USB communication for programming the device through Atmel EDBG. Once connected on a USB port the Xplained Pro Sam L21 device is recognized by Zerynth Studio. The next steps are: Select the Xplained Pro Sam L21 on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the Xplained Pro Sam L21 is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked. Firmware Over the Air update (FOTA) \u00b6 The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Xplained Pro Sam L21 device is available for bytecode only. Flash Layout is shown in table below: Start address Size Content 0x00002000 88Kb VM Slot 0x00018000 80Kb Bytecode Slot 0 0x0002C000 80Kb Bytecode Slot 1","title":"Xplained Pro Sam L21"},{"location":"reference/boards/xplained_l21b/docs/#xplained-pro-sam-l21","text":"The SAM L21 Xplained Pro evaluation kit is a hardware platform to evaluate the ATSAML21J18B ARM Cortex-M0+ CPU . The device provides easy access to the features of the Atmel ATSAML21J18B and explains how to integrate the device in a custom design. The Xplained Pro MCU series evaluation kits include an on-board Embedded Debugger, and no external tools are necessary to program or debug the ATSAML21J18B. The Xplained Pro extension kits offers additional peripherals to extend the features of the device and ease the development of custom designs. It has 43 digital input/output pins, 19 analog inputs, 3 UARTs (hardware serial ports), a 48 MHz clock, 1 I2C, 2 SPI header, a reset button. One of its most important features is the Atmel Embedded Debugger (EDBG), which provides a full debug interface without the need for additional hardware, significantly increasing the ease-of-use for software debugging. EDBG also supports a virtual COM port that can be used for device and bootloader programming. Note All the reported information are extracted from the official Xplained Pro Sam L21 page , visit this page for more details and updates.","title":"Xplained Pro Sam L21"},{"location":"reference/boards/xplained_l21b/docs/#pin-mapping","text":"Xplained Pro Sam L21 Official Schematic, Reference Design and Pin Mapping are available on the official Atmel User Guide .","title":"Pin Mapping"},{"location":"reference/boards/xplained_l21b/docs/#flash-layout","text":"The internal flash of the Xplained Pro Sam L21 is organized as a single bank of 256k. Zerynth VM starts at first address of the flash memory.","title":"Flash Layout"},{"location":"reference/boards/xplained_l21b/docs/#device-summary","text":"Microcontroller: ATSAML21J18B Operating Voltage: 3.3V Digital I/O Pins (DIO): 43 Analog Input Pins (ADC): 19 UARTs: 3 SPIs: 2 I2Cs: 1 Flash Memory: 256 KB SRAM: 32 KB Clock Speed: 48 MHz","title":"Device Summary"},{"location":"reference/boards/xplained_l21b/docs/#power","text":"The Xplained Pro Sam L21 can be powered via the USB connector or with an external power supply via \u201cGND\u201d and \u201c5.0 IN\u201d pins of the PWR header. The device can operate on an external supply of 5V \u00b12% (\u00b1100mV) for USB host operation or from 4.3V to 5.5V if USB host operation is not required. Current recommended requirements, in external power supply mode, are: minimum 1A to be able to provide enough current for connected USB devices and the device itself. maximum is 2A due to the input protection maximum current specification The SAM L21 Xplained Pro has a backup battery for use with the SAM L21 backup module. The battery can be connected to the device by placing a jumper over pin 1-2 on the 3-pin VBAT SELECT header. By default the jumper is placed over pin 2-3 to select the board power supply. This configuration is selected to avoid draining the battery and can be used during development. Note External power is required when 500mA from a USB connector is not enough to power the device with possible extension boards. A connected USB device in a USB host application might easily exceed this limit.","title":"Power"},{"location":"reference/boards/xplained_l21b/docs/#connect-register-virtualize-and-program","text":"The Xplained Pro Sam L21 debug port is connected to EDBG, which provides a virtual COM port to software on a connected computer. To recognize the device, all Windows (automatic driver software installation), OSX and Linux machines will recognize the device as a COM port automatically. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. If the device is still not recognized or not working, the following udev rules may need to be added: # Check SUBSYSTEM SUBSYSTEMS == \"hidraw\" , KERNEL == \"hidraw*\" , MODE = \"0666\" , GROUP = \"dialout\" # Xplained Pro SamL21 Device SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"03eb\" , ATTRS { idProduct }== \"2111\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"03eb\" , ATTRS { idProduct }== \"2111\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" EDBG is also connected to the SAML21 hardware UART. Serial on pins RX0 and TX0 provides Serial-to-USB communication for programming the device through Atmel EDBG. Once connected on a USB port the Xplained Pro Sam L21 device is recognized by Zerynth Studio. The next steps are: Select the Xplained Pro Sam L21 on the Device Management Toolbar (disambiguate if necessary); Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process. After virtualization, the Xplained Pro Sam L21 is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/boards/xplained_l21b/docs/#firmware-over-the-air-update-fota","text":"The Firmware Over the Air feature allows to update the device firmware at runtime. Zerynth FOTA in the Xplained Pro Sam L21 device is available for bytecode only. Flash Layout is shown in table below: Start address Size Content 0x00002000 88Kb VM Slot 0x00018000 80Kb Bytecode Slot 0 0x0002C000 80Kb Bytecode Slot 1","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/boards/xplained_samg55/docs/","text":"Xplained Pro Sam G55 \u00b6 The SAM G55 Xplained Pro evaluation kit is ideal for evaluation and prototyping with the SAM G55 Cortex-M4 processor-based microcontrollers . The Xplained Pro extension kits offer additional peripherals to extend the features of the device and ease the development of custom designs. The SAM G55 Xplained Pro features 2 UARTs, a 120 MHz clock, 3 TWIs, 1 SPI and a reset button. One of its most important features is the Atmel Embedded Debugger (EDBG), which provides a full debug interface without the need for additional hardware, significantly increasing the ease-of-use for software debugging. EDBG also supports a virtual COM port. Note All the reported information are extracted from the official Xplained Pro Sam G55 page , visit this page for more details and updates. Pin Mapping \u00b6 Xplained Pro Sam G55 Official Schematic, Reference Design and Pin Mapping are available on the official Microchip User Guide . Flash Layout \u00b6 The internal flash of the Xplained Pro Sam G55 is organized as a single bank of 512k. Zerynth VM starts at address 0x400000. Device Summary \u00b6 Microcontroller: ATSAMG55J19 Operating Voltage: 3.3V UARTs: 3 SPIs: 1 I2Cs: 3 Flash Memory: 512 KB Clock Speed: 120 MHz Power \u00b6 The Xplained Pro Sam G55 can be powered via the USB connector or with an external power supply via \u201cGND\u201d and \u201cEXT\u201d pins of the PWR header. The device can operate on an external supply of 5V \u00b12% (\u00b1100mV) for USB host operation or from 4.3V to 5.5V if USB host operation is not required. Current recommended requirements, in external power supply mode, are: minimum 1A to be able to provide enough current for connected USB devices and the device itself. maximum is 2A due to the input protection maximum current specification Note External power is required when 500mA from a USB connector is not enough to power the device with possible extension boards. A connected USB device in a USB host application might easily exceed this limit. Connect, Register, Virtualize and Program \u00b6 The Xplained Pro Sam G55 debug port is connected to EDBG, which provides a virtual COM port to software on a connected computer. To recognize the device, all Windows (automatic driver software installation), OSX and Linux machines will recognize the device as a COM port automatically. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. If the device is still not recognized or not working, the following udev rules may need to be added: # Check SUBSYSTEM SUBSYSTEMS == \"hidraw\" , KERNEL == \"hidraw*\" , MODE = \"0666\" , GROUP = \"dialout\" # Xplained Pro SamG55 Device SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"03eb\" , ATTRS { idProduct }== \"2111\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"03eb\" , ATTRS { idProduct }== \"2111\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" EDBG is also connected to the SAMG55 hardware UART. Serial on pins RX0 and TX0 provides Serial-to-USB communication for programming the device through Atmel EDBG. Once connected on a USB port the Xplained Pro Sam G55 device is recognized by Zerynth Studio. The next steps are: Select the Xplained Pro Sam G55 on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process After virtualization, the Xplained Pro Sam G55 is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked. Note Advanced programming and debugging through EDBG are available in Device Management Advanced Mode selecting Atmel EDBG interface.","title":"Xplained Pro Sam G55"},{"location":"reference/boards/xplained_samg55/docs/#xplained-pro-sam-g55","text":"The SAM G55 Xplained Pro evaluation kit is ideal for evaluation and prototyping with the SAM G55 Cortex-M4 processor-based microcontrollers . The Xplained Pro extension kits offer additional peripherals to extend the features of the device and ease the development of custom designs. The SAM G55 Xplained Pro features 2 UARTs, a 120 MHz clock, 3 TWIs, 1 SPI and a reset button. One of its most important features is the Atmel Embedded Debugger (EDBG), which provides a full debug interface without the need for additional hardware, significantly increasing the ease-of-use for software debugging. EDBG also supports a virtual COM port. Note All the reported information are extracted from the official Xplained Pro Sam G55 page , visit this page for more details and updates.","title":"Xplained Pro Sam G55"},{"location":"reference/boards/xplained_samg55/docs/#pin-mapping","text":"Xplained Pro Sam G55 Official Schematic, Reference Design and Pin Mapping are available on the official Microchip User Guide .","title":"Pin Mapping"},{"location":"reference/boards/xplained_samg55/docs/#flash-layout","text":"The internal flash of the Xplained Pro Sam G55 is organized as a single bank of 512k. Zerynth VM starts at address 0x400000.","title":"Flash Layout"},{"location":"reference/boards/xplained_samg55/docs/#device-summary","text":"Microcontroller: ATSAMG55J19 Operating Voltage: 3.3V UARTs: 3 SPIs: 1 I2Cs: 3 Flash Memory: 512 KB Clock Speed: 120 MHz","title":"Device Summary"},{"location":"reference/boards/xplained_samg55/docs/#power","text":"The Xplained Pro Sam G55 can be powered via the USB connector or with an external power supply via \u201cGND\u201d and \u201cEXT\u201d pins of the PWR header. The device can operate on an external supply of 5V \u00b12% (\u00b1100mV) for USB host operation or from 4.3V to 5.5V if USB host operation is not required. Current recommended requirements, in external power supply mode, are: minimum 1A to be able to provide enough current for connected USB devices and the device itself. maximum is 2A due to the input protection maximum current specification Note External power is required when 500mA from a USB connector is not enough to power the device with possible extension boards. A connected USB device in a USB host application might easily exceed this limit.","title":"Power"},{"location":"reference/boards/xplained_samg55/docs/#connect-register-virtualize-and-program","text":"The Xplained Pro Sam G55 debug port is connected to EDBG, which provides a virtual COM port to software on a connected computer. To recognize the device, all Windows (automatic driver software installation), OSX and Linux machines will recognize the device as a COM port automatically. Note For Linux Platform : to allow the access to serial ports the user needs read/write access to the serial device file. Adding the user to the group, that owns this file, gives the required read/write access: Ubuntu distribution \u2013> dialout group; Arch Linux distribution \u2013> uucp group. If the device is still not recognized or not working, the following udev rules may need to be added: # Check SUBSYSTEM SUBSYSTEMS == \"hidraw\" , KERNEL == \"hidraw*\" , MODE = \"0666\" , GROUP = \"dialout\" # Xplained Pro SamG55 Device SUBSYSTEMS == \"usb\" , ATTRS { idVendor }== \"03eb\" , ATTRS { idProduct }== \"2111\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" SUBSYSTEMS == \"tty\" , ATTRS { idVendor }== \"03eb\" , ATTRS { idProduct }== \"2111\" , MODE = \"0666\" , GROUP = \"users\" , ENV { ID_MM_DEVICE_IGNORE }= \"1\" EDBG is also connected to the SAMG55 hardware UART. Serial on pins RX0 and TX0 provides Serial-to-USB communication for programming the device through Atmel EDBG. Once connected on a USB port the Xplained Pro Sam G55 device is recognized by Zerynth Studio. The next steps are: Select the Xplained Pro Sam G55 on the Device Management Toolbar ; Register the device by clicking the \u201cZ\u201d button from the Zerynth Studio; Create a Virtual Machine for the device by clicking the \u201cZ\u201d button for the second time; Virtualize the device by clicking the \u201cZ\u201d button for the third time. Note No user intervention on the device is required for registration and virtualization process After virtualization, the Xplained Pro Sam G55 is ready to be programmed and the Zerynth scripts uploaded . Just Select the virtualized device from the \u201cDevice Management Toolbar\u201d and click the dedicated \u201cupload\u201d button of Zerynth Studio and reset the device by pressing the Reset on-board button when asked. Note Advanced programming and debugging through EDBG are available in Device Management Advanced Mode selecting Atmel EDBG interface.","title":"Connect, Register, Virtualize and Program"},{"location":"reference/core/stdlib/docs/","text":"Standard Library \u00b6 The Zerynth standard library is composed of many modules ranging from hardware interfaces to high level functionalities.","title":"Standard Library"},{"location":"reference/core/stdlib/docs/#standard-library","text":"The Zerynth standard library is composed of many modules ranging from hardware interfaces to high level functionalities.","title":"Standard Library"},{"location":"reference/core/stdlib/docs/adc/","text":"Analog to Digital Conversion \u00b6 This module loads the Analog to Digital Converter (adc) driver of the embedded device. When imported, automatically sets the system adc driver to the default one. init(drvname, samples_per_second=800000) Loads the adc driver identified by drvname and sets it up to read samples_per_second samples per second. The default is a sampling frequency of 0.8 MHz, valid values are dependent on the board. Returns the previous driver without disabling it. done(drvname) Unloads the adc driver identified by drvname . read(pin, samples=1) Reads analog values from pin that must be one of the Ax pins. If samples is 1 or not given, returns the integer value read from pin . If samples is greater than 1, returns a tuple of integers of size samples . The maximum value returned by analogRead depends on the analog resolution of the board. read also accepts lists or tuples of pins and returns the corresponding tuple of tuples of samples: import adc x = adc . read ([ A4 , A3 , A5 ], 6 ) this piece of code sets x to ((\u2026),(\u2026),(\u2026)) where each inner tuple contains 6 samples taken from the corresponding channel. To use less memory, the inner tuples can be bytes() , or shorts() or normal tuples, depending on the hardware resolution of the adc unit. The number of sequentials pins that can be read in a single call depends on the specific board.","title":"Analog to Digital Conversion"},{"location":"reference/core/stdlib/docs/adc/#analog-to-digital-conversion","text":"This module loads the Analog to Digital Converter (adc) driver of the embedded device. When imported, automatically sets the system adc driver to the default one. init(drvname, samples_per_second=800000) Loads the adc driver identified by drvname and sets it up to read samples_per_second samples per second. The default is a sampling frequency of 0.8 MHz, valid values are dependent on the board. Returns the previous driver without disabling it. done(drvname) Unloads the adc driver identified by drvname . read(pin, samples=1) Reads analog values from pin that must be one of the Ax pins. If samples is 1 or not given, returns the integer value read from pin . If samples is greater than 1, returns a tuple of integers of size samples . The maximum value returned by analogRead depends on the analog resolution of the board. read also accepts lists or tuples of pins and returns the corresponding tuple of tuples of samples: import adc x = adc . read ([ A4 , A3 , A5 ], 6 ) this piece of code sets x to ((\u2026),(\u2026),(\u2026)) where each inner tuple contains 6 samples taken from the corresponding channel. To use less memory, the inner tuples can be bytes() , or shorts() or normal tuples, depending on the hardware resolution of the adc unit. The number of sequentials pins that can be read in a single call depends on the specific board.","title":"Analog to Digital Conversion"},{"location":"reference/core/stdlib/docs/base64/","text":"Base64 \u00b6 This module provides functions for encoding binary data to printable ASCII characters and decoding such encodings back to binary data. It provides some of the encoding and decoding functions for the encodings specified in RFC 3548 , which defines the Base64 algorithm. The RFC 3548 encodings are suitable for encoding binary data so that it can safely sent by email, used as parts of URLs, or included as part of an HTTP POST request. standard_b64encode() standard_b64encode(s) Encode s (either bytes, bytearray or string) using the standard Base64 alphabet and return the encoded object as bytes. standard_b64decode() standard_b64decode(s) Decode s (either bytes, bytearray or string) using the standard Base64 alphabet and return the decoded object as bytes.","title":"Base64"},{"location":"reference/core/stdlib/docs/base64/#base64","text":"This module provides functions for encoding binary data to printable ASCII characters and decoding such encodings back to binary data. It provides some of the encoding and decoding functions for the encodings specified in RFC 3548 , which defines the Base64 algorithm. The RFC 3548 encodings are suitable for encoding binary data so that it can safely sent by email, used as parts of URLs, or included as part of an HTTP POST request. standard_b64encode() standard_b64encode(s) Encode s (either bytes, bytearray or string) using the standard Base64 alphabet and return the encoded object as bytes. standard_b64decode() standard_b64decode(s) Decode s (either bytes, bytearray or string) using the standard Base64 alphabet and return the decoded object as bytes.","title":"Base64"},{"location":"reference/core/stdlib/docs/bignum_bignum/","text":"Bignum \u00b6 This module provides function and classes to operate on arbitrary precision integers. It is based on the very perfomant library TomMath slightly modified to be compatible with Zerynth memory manager. The Bignum class \u00b6 BigNum(val=0) This class represents a big integer number with arbitrary precision. A big number instance can be initialized with a value val . val can be a standard integer or a string representing the number. The string is accepted if it is in base 16 prefixed with \u20180x\u2019 or in base 10. Signed number are accepted. At the moment, bytearray or bytes representation are not supported. BigNum instances are compatible with streams and, if printed, are automatically converted to the base 10 string format. BigNum instances are easy to use: from bignum import bignum as bg import streams streams . serial () big = bg . BigNum ( \"1234567890987654321\" ) one = bg . BigNum ( 1 ) while True : print ( big ) big . iadd ( one ) sleep ( 1000 ) add(b) Return a new big number instance equal to the addition of the current instance and b . iadd(b) Add to the current instance the big number b . Return None sub(b) Return a new big number instance equal to the difference of the current instance and b . isub(b) Subtracts to the current instance the big number b . Return None mul(b) Return a new big number instance equal to the multiplication of the current instance and b . imul(b) Multiply the current instance for the big number b . Return None div(b) Return a new big number instance equal to the division of the current instance by b . idiv(b) Divides the current instance for the big number b . Return None mod(b) Return a new big number instance equal to the remainder of the division of the current instance by b . imod(b) Set the current instance to the remainder of the division by b . Return None divmod(b) Return a tuple (q,r) of new big number instances representing the quotient q and the remainder r of the division of the current instance by b . ..method:: eq(b) Return True if the current instance is equal to the big number b , False otherwise. ..method:: lt(b) Return True if the current instance is less than the big number b , False otherwise. ..method:: gt(b) Return True if the current instance is greater than the big number b , False otherwise. ..method:: lte(b) Return True if the current instance is less than or equal to the big number b , False otherwise. ..method:: gte(b) Return True if the current instance is greater than or equal to the big number b , False otherwise. ..method:: sign() Return 1 if the current instance is a positive number, -1 if the current instance is a negative number, 0 if it is equal to zero. to_base(base) Return a string representation of the big number in base base . Allowed values for base are in the range 2..64.","title":"Bignum"},{"location":"reference/core/stdlib/docs/bignum_bignum/#bignum","text":"This module provides function and classes to operate on arbitrary precision integers. It is based on the very perfomant library TomMath slightly modified to be compatible with Zerynth memory manager.","title":"Bignum"},{"location":"reference/core/stdlib/docs/bignum_bignum/#the-bignum-class","text":"BigNum(val=0) This class represents a big integer number with arbitrary precision. A big number instance can be initialized with a value val . val can be a standard integer or a string representing the number. The string is accepted if it is in base 16 prefixed with \u20180x\u2019 or in base 10. Signed number are accepted. At the moment, bytearray or bytes representation are not supported. BigNum instances are compatible with streams and, if printed, are automatically converted to the base 10 string format. BigNum instances are easy to use: from bignum import bignum as bg import streams streams . serial () big = bg . BigNum ( \"1234567890987654321\" ) one = bg . BigNum ( 1 ) while True : print ( big ) big . iadd ( one ) sleep ( 1000 ) add(b) Return a new big number instance equal to the addition of the current instance and b . iadd(b) Add to the current instance the big number b . Return None sub(b) Return a new big number instance equal to the difference of the current instance and b . isub(b) Subtracts to the current instance the big number b . Return None mul(b) Return a new big number instance equal to the multiplication of the current instance and b . imul(b) Multiply the current instance for the big number b . Return None div(b) Return a new big number instance equal to the division of the current instance by b . idiv(b) Divides the current instance for the big number b . Return None mod(b) Return a new big number instance equal to the remainder of the division of the current instance by b . imod(b) Set the current instance to the remainder of the division by b . Return None divmod(b) Return a tuple (q,r) of new big number instances representing the quotient q and the remainder r of the division of the current instance by b . ..method:: eq(b) Return True if the current instance is equal to the big number b , False otherwise. ..method:: lt(b) Return True if the current instance is less than the big number b , False otherwise. ..method:: gt(b) Return True if the current instance is greater than the big number b , False otherwise. ..method:: lte(b) Return True if the current instance is less than or equal to the big number b , False otherwise. ..method:: gte(b) Return True if the current instance is greater than or equal to the big number b , False otherwise. ..method:: sign() Return 1 if the current instance is a positive number, -1 if the current instance is a negative number, 0 if it is equal to zero. to_base(base) Return a string representation of the big number in base base . Allowed values for base are in the range 2..64.","title":"The Bignum class"},{"location":"reference/core/stdlib/docs/builtins/","text":"Builtins \u00b6 This module contains builtins functions and constants. It is automatically loaded and you don\u2019t need to prefix the module name to call its functions. For example it is not necessary to write __builtins__.print() but only print() will suffice. The explicit name __builtins__ must be used when there is a need to modify a builtin name. For example, to change the default stream it is necessary to write __builtins__.__default_stream=mystream . Builtins Constants \u00b6 Zerynth VM defines the following Python builtin constants: False() The false value of the bool() type. Assignments to False are illegal and raise a :exc: SyntaxError . True() The true value of the bool() type. Assignments to True are illegal and raise a :exc: SyntaxError . None() The sole value of the type NoneType . None is frequently used to represent the absence of a value, as when default arguments are not passed to a function. Assignments to None are illegal and raise a :exc: SyntaxError . Zerynth VM recognizes a set of pre-defined uppercase names representing constants: Pin Names: D0 to D127 representing the names of digital pins. A0 to A127 representing the names of analog pins. LED0 to LED32 representing the names of the board leds. BTN0 to BTN32 representing the names of the board buttons. Pin Modes and Values: INPUT, OUTPUT, INPUT_PULLUP, INPUT_PULLDOWN, OUTPUT_PUSHPULL, OUTPUT_OPENDRAIN, INPUT_ANALOG representing pin modes. LOW, HIGH representing digital pin states. Time Units: MICROS to select microseconds MILLIS to select milliseconds SECONDS to select seconds Peripherals Names: SERIAL0 to SERIAL7 representing the name of the nth serial port of a board. ADC0 to ADC7 representing the name of the nth analog to digital converter of a board. Builtin Exceptions \u00b6 Zerynth VM exceptions are different from Python exceptions. In Python, exceptions are very powerful because they are implemented as classes, contain error messages, and one can examine the full exceution stack when an exception is raised. However, in the embedded world, resources are precious and keeping class definition in memory, creating a class instance everytime an exception is raised, can be very resource-consuming. Zerynth VM exceptions are therefore implemented as error codes with optional static error messages organized as a tree: Exception +-- StopIteration +-- ArithmeticError | +-- FloatingPointError | +-- OverflowError | +-- ZeroDivisionError +-- AttributeError +-- LookupError | +-- IndexError | +-- KeyError +-- MemoryError +-- NameError +-- PeripheralError | +-- InvalidPinError | +-- InvalidHardwareStatusError | +-- HardwareInitializationError +-- IOError | +-- ConnectionError | | +-- ConnectionAbortedError | | +-- ConnectionRefusedError | | +-- ConnectionResetError | +-- TimeoutError +-- RuntimeError | +-- NotImplementedError | +-- UnsupportedError +-- TypeError +-- ValueError This way, the inheritance mechanism of classes is mantained and trasposed to the exception matching mechanism transparently. The following is valid Zerynth code: try : # raise ZeroDivisionError x = 1 / 0 except ArithmeticError as e : print ( e ) The main difference between Zerynth exceptions and Python exceptions is in the way new exceptions are created and used. To create a user defined exception in Zerynth you need to use the following code: new_exception ( MyExceptionName , MyExceptionParent , MyErrorMessage ) The builtin function new_exception always needs 2 arguments and an optional message: the first one is the user defined exception name the second is the name of the parent exception in the exception tree the third one is a static error message, where static in this context means both that it is not stored in ram as a Python string and that it can be defined only once and never changed later. Behind the scenes MyExceptionName is created and placed under MyExceptionParent in the exception tree. An exception object is returned. The exception object can only be compared to other exceptions, printed (as an error code plus message error) or raised again. When an exception is printed, the error message is concatenated with the error code and, if the exception has been raised, with the bytecode position where the error happened. Zerynth exceptions are not garbage collected. They also are not scoped: this means that an exception defined in a module is not contained in that module, but it is moved at builtin scope, so that it can be accessible by all other modules simply by name. This feature has a drawback: two modules defining an exception with the same name, can\u2019t be compiled in the same program. Exception names must be manually scoped by correctly choosing them (i.e. preprending the module name to the actual name). Builtin GPIO Functions \u00b6 Zerynth VM extends Python with builtins functions to handle the General Purpose Input Output pins of the embedded device. These functions resembles the ones used by Arduino, but are more flexible. pinMode(pin, mode) Sets the pin pin in mode mode . Allowed values for mode are INPUT, OUTPUT, INPUT_PULLUP, INPUT_PULLDOWN, OUTPUT_PUSHPULL, OUTPUT_OPENDRAIN, INPUT_ANALOG digitalRead(pin) Returns the state of the pin pin . The state can be LOW or HIGH digitalWrite(pin, val) Sets the pin pin to the value val . If val is zero, pin is set to LOW , otherwise to HIGH pinToggle(pin) Sets the pin pin to the value opposite to the current pin value. If value is zero, pin is set to HIGH , otherwise to LOW analogRead(pin, samples=1) Reads analog values from pin that must be one of the Ax pins. If samples is 1 or not given, returns the integer value read from pin . If samples is greater than 1, returns a tuple of integers of size samples . The maximum value returned by analogRead depends on the analog resolution of the board. analogRead works by calling the adc driver (Analog to Digital Converter) that must be imported and configured: # import the adc driver import adc # adc is now configured with default parameters, analogRead can be used as x = analogRead ( A3 ) analogRead also accepts lists or tuples of pins and returns the corresponding tuple of tuples of samples: import adc x = analogRead ([ A4 , A3 , A5 ], 6 ) this piece of code sets x to ((\u2026),(\u2026),(\u2026)) where each inner tuple contains 6 samples taken from the corresponding channel. To used less memory, the inner tuples can be bytes() , or shorts() or normal tuples, depending on the hardware resolution of the adc unit. The number of sequentials pins that can be read in a single analogRead call depends on the specific board. The analogRead function is provided as a builtin to ease the passage from the Arduino Wiring to Zerynth. However the preferred way to read an analog pin in Zerynth is: # import the adc driver import adc x = adc . read ( A3 ) analogWrite(pin, period, pulse, time_unit=MILLIS, npulses=0) Activate PWM (Pulse Width Modulation) on pin pin (must be one of the PWMx pins). The state of pin is periodically switched between LOW and HIGH according to parameters: period is the duration of a pwm square wave pulse is the time the pwm square wave stays in the HIGH state time_unit is the unit of time period and pulse are expressed in time_unit A PWM wave can be depicted as a train of elements like this: HIGH _________________ _________________ | | | | | | | | _____| |________| |____ LOW <-----PULSE------> <-----PERIOD--------------> Here are some examples: #Remember to import the pwm module import pwm # A 1000 milliseconds wave that stays HIGH for 100 milliseconds and LOW for 900 analogWrite ( D5 . PWM , 1000 , 100 ) # A 500 microseconds wave that stays HIGH for 10 microseconds and LOW for 490 analogWrite ( D5 . PWM , 500 , 10 , MICROS ) # Disable pwm analogWrite ( D5 . PWM , 0 , 0 ) Some boards have restrictions on how pwm pins can be used, refer to the single board documentation for details. The parameter npulses is used to specify a limited train of pulses. When npulses is zero or less, PWM is activated on the pin and the function returns. When npulses is more than zero, analogWrite becomes blocking and returns only after a number of pulses equal to npulses has been generated on the pin; PWM is disabled on return. For very small pulses in the range of a few ten microseconds, the actual number of pulses produced may be greater than npulses by one or two units. The analogWrite function is provided as a builtin to ease the passage from the Arduino Wiring to Zerynth. However the preferred way to use pwm in Zerynth is: # import the pwm driver import pwm pwm . write ( D3 . PWM , 400 , 10 , MICROS ) onPinRise(pin, fun, \\*args, debounce=0, time_unit=MILLIS) Executes fun with arguments \\*args everytime pin goes from LOW to HIGH . If fun is None the corresponding interrupt is disabled. Each Zerynth VM has its own maximum number of slots for pin interrupts: if they are all full, a RuntimeError is raised. Can be used together with onPinFall() on the same pin. fun is executed in a high priority thread that takes control of the mcu and puts to sleep every other thread. Therefore fun should contains fast code. debounce and time_unit are used to define a timeout such that fun is called only if pin stays high for all the duration of the timeout. onPinFall(pin, fun, \\*args, debounce=0, time_unit=MILLIS) Executes fun with arguments \\*args everytime pin goes from HIGH to LOW . If fun is None the corresponding interrupt is disabled. Each Zerynth VM has its own maximum number of slots for pin interrupts: if they are all full, a RuntimeError is raised. Can be used together with onPinRise() on the same pin. fun is executed in a high priority thread that takes control of the mcu and puts to sleep every other thread. Therefore fun should contains fast code. debounce and time_unit are used to define a timeout such that fun is called only if pin stays high for all the duration of the timeout. Builtin Functions \u00b6 int(x=0, base=10) Return an integer object constructed from a number or string x , or return 0 if no arguments are given. If x is a floating point number, it is truncated towards zero. If x is not a number or if base is given, then x must be a string, bytes() , or bytearray() instance representing an :integer in radix base . Optionally, the literal can be preceded by + or - (with no space in between) and surrounded by whitespace. A base-n literal consists of the digits 0 to n-1, with a to z (or A to Z ) having values 10 to 35. The default base is 10. The allowed values are 0 and 2-36. Base-2, -8, and -16 literals can be optionally prefixed with 0b / 0B , 0o / 0O , or 0x / 0X , as with integer literals in code. Base 0 means to interpret exactly as a code literal, so that the actual base is 2, 8, 10, or 16, and so that int('010', 0) is not legal, while int('010') is, as well as int('010', 8) . type(x) Return an integer representing the type of x. The following are the builtin constants returned by type(): PSMALLINT, PINTEGER, PFLOAT, PBOOL, PSTRING, PBYTES, PBYTEARRAY, PSHORTS, PSHORTARRAY, PLIST, PTUPLE, PRANGE, PFROZENSET, PSET, PDICT, PFUNCTION, PMETHOD, PCLASS, PINSTANCE, PMODULE, PITERATOR, PNONE, PEXCEPTION, PNATIVE, PSYSOBJ, PDRIVER, PTHREAD thread(fun, \\*args, prio=PRIO_NORMAL, size=-1) Function fun is launched in a new thread using args as its parameters. fun must be a normal function or a methods, other callables are not supported yet. prio sets the thread priority and accepts one of PRIO_LOWEST , PRIO_LOWER , PRIO_LOW , PRIO_NORMAL , PRIO_HIGH , PRIO_HIGHER , PRIO_HIGHEST . size is the memory in bytes , reserved for the thread inner workings. Negative values select the VM default size. Returns the created thread, already started. Raises :exc: RuntimeError if no more threads can be created. sleep(time, time_unit=MILLIS) Suspend the current thread for time expressed in time_units . All the other threads are free to continue their execution. If time_unit is MICROS, sleep does not suspend the current thread, but starts polling the cycles counter in a loop. For high precision sleep refer to :mod:`hwtimers random() random(a, b) Returns a random integer. If a and b are given, the random integer is contained in the range [a,b]. If the board has a builtin Random Number Generator, it is used. range(stop) range(start, stop, ) Creates a range object. bytearray() Return a new array of bytes. A bytearray is a mutable sequence of integers in the range 0 <= x < 256. It has most of the usual methods of mutable sequences, described in typesseq-mutable, as well as most methods that the bytes() type has, see Bytes and Bytearray Operations. The optional source parameter can be used to initialize the array in a few different ways: If it is a string , bytearray() then converts the string to bytes. If it is an integer , the array will have that size and will be initialized with null bytes. Without an argument, an array of size 0 is created. bytes() Return a new \u201cbytes\u201d object, which is an immutable sequence of integers in the range 0 <= x < 256 . bytes() is an immutable version of bytearray() \u2013 it has the same non-mutating methods and the same indexing and slicing behavior. Accordingly, constructor arguments are interpreted as for bytearray() . shortarray() Return a new array of shorts. A shortarray is a mutable sequence of integers in the range 0 <= x < 65536. It has most of the usual methods of mutable sequences, described in typesseq-mutable, as well as most methods that the shorts() type has, see shorts-methods. The optional source parameter can be used to initialize the array in a few different ways: If it is an integer , the array will have that size and will be initialized with zeros. If it is a sequence, the array will be a copy of source with its elements converted into shorts. If the conversion is not possible, an exception is raised. Without an argument, an array of size 0 is created. shorts() Return a new shorts object, which is an immutable sequence of integers in the range 0 <= x < 65536 . shorts() is an immutable version of shortarray() \u2013 it has the same non-mutating methods and the same indexing and slicing behavior. Accordingly, constructor arguments are interpreted as for shortarray() . enumerate(iterable, start=0) Return an enumerate object. iterable must be a sequence, an iterator, or some other object which supports iteration. The __next__() method of the iterator returned by enumerate() returns a tuple containing a count (from start which defaults to 0) and the values obtained from iterating over iterable . It is normally used in for loops: ints = [ 10 , 20 , 30 ] for idx , val in enumerate ( ints ): print ( idx , val ) # prints out the following: >>> 0 10 >>> 1 20 >>> 2 30 In this version of the VM, enumerate works only for primitive iterable types, not yet for instances with __next__ and __iter__ methods. reversed(seq) Return a reverse iterator. seq must be an object which has a __reversed__() method or supports the sequence protocol (the __len__() method and the __getitem__() method with integer arguments starting at 0 ). In this version of the VM, reversed works only for primitive iterable types, not yet for instances with __next__ and __iter__ methods. ord(c) Given a string representing one character, return an integer representing that character. For example, ord('a') returns the integer 97 . This is the inverse of chr() . When c is a literal string, the compiler macro __ORD\u00a9 can be used to reduce code size. For example: x = ord ( \":\" ) is valid Zerynth code. During its execution a string must be created containing \u201c:\u201d and ord must be called on it. After ord is executed the created string is probably immediately garbage collected. In the embedded world, this is time and resource consuming. The operation ord(\":\") can be executed during compilation because the result is known before the execution of the Zerynth program. To enable this feature use the following code: x = __ORD ( \":\" ) Now, no string is created and no function is called, because the compiler knows that you want to assign to x the result of ord(\":\") (which is 58). The compiler transforms our program to a faster and equivalent version: x = 58 chr(i) Return the string representing a character whose byte representation is the integer i . For example, chr(97) returns the string 'a' . This is the inverse of ord() . ValueError will be raised if i is outside the valid range. isinstance(object, class) Return true if the object argument is an instance of the class argument, or of a (direct, indirect) subclass thereof. If object is not an object of the given type, the function always returns false. If class is not a class, a TypeError exception is raised. In this version of the VM, isinstance is still not compliant with the Python one. It is suggested to use isinstance to determine the hierarchy of instances and to use type() for primitive types. print(\\*args, sep=\" \", end=\"\\\\n\", stream=None) Print objects to the stream stream , separated by sep and followed by end . sep , end and stream , if present, must be given as keyword arguments. All non-keyword arguments are converted to strings like str() does and written to the stream, separated by sep and followed by end . Both sep and end must be strings. If no objects are given, print() will just write end . The stream argument must be an object with a write(string) method; if it is not present or None , __default_stream will be used. Whether output is buffered is usually determined by stream . abs(x) Return the absolute value of a number. The argument may be an integer or a floating point number. all(iterable) Return True if all elements of the iterable are true (or if the iterable is empty). Equivalent to: def all ( iterable ): for element in iterable : if not element : return False return True any(iterable) Return True if any element of the iterable is true. If the iterable is empty, return False . Equivalent to: def any ( iterable ): for element in iterable : if element : return True return False sum(iterable, ) Sums start and the items of an iterable from left to right and returns the total. start defaults to 0 . max(\\*args) Return the largest item in args. min(\\*args) Return the smallest item in args. len(s) Return the length (the number of items) of an object. The argument may be a sequence (such as a string, bytes, tuple, list, or range) or a collection (such as a dictionary, set, or frozen set), or any instance defining the method __len__ . hex(x, prefix=\"0x\") Convert an integer number to a lowercase hexadecimal string prefixed with prefix (if not given \u201c0x\u201d is used), for example: >>> hex ( 255 ) '0xff' >>> hex ( - 42 ) '-0x2a' See also int() for converting a hexadecimal string to an integer using a base of 16. str(x=\"\") Return a string version of x . If x is not provided, returns the empty string. Returns the \u201cinformal\u201d or nicely printable string representation of object . For string objects, this is the string itself. For primitive types like list, tuples, dicts a standard representation is returned. For all other types, the method str is called. dict() dict(\\*args) Return a new dictionary initialized from an optional *args. If no *args is given, an empty dictionary is created. If a single positional argument is given and it is a mapping object, a dictionary is created with the same key-value pairs as the mapping object. Otherwise, if more than a positional argument is given, each pair of arguments is inserted in the dictionary with the first argument of the pair being the key and the second argument the value. If a key occurs more than once, the last value for that key becomes the corresponding value in the new dictionary. If the number of positional arguments is odd, the value for the last key is None. set() set(\\*args) Return a new set initialized from an optional *args. If no *args is given, an empty set is created. If a single positional argument is given and it is an iterable object, a set is created and filled with the values of the iterable. Otherwise, if more than a positional argument is given, each argument is inserted in the set. frozenset() frozenset(\\*args) Return a new frozenset initialized from an optional *args. If no *args. If no *args is given, an empty frozenset is created. If a single positional argument is given and it is an iterable object, a frozenset is created and filled with the values of the iterable. Otherwise, if more than a positional argument is given, each argument is inserted in the frozenset. open(file, mode=\"rb\") Return an object similar to a stream with read and write methods. The object class depends on the type of file opened. If file starts with \u201cresource://\u201d, open returns a ResourceStream of a flash saved resource.","title":"Builtins"},{"location":"reference/core/stdlib/docs/builtins/#builtins","text":"This module contains builtins functions and constants. It is automatically loaded and you don\u2019t need to prefix the module name to call its functions. For example it is not necessary to write __builtins__.print() but only print() will suffice. The explicit name __builtins__ must be used when there is a need to modify a builtin name. For example, to change the default stream it is necessary to write __builtins__.__default_stream=mystream .","title":"Builtins"},{"location":"reference/core/stdlib/docs/builtins/#builtins-constants","text":"Zerynth VM defines the following Python builtin constants: False() The false value of the bool() type. Assignments to False are illegal and raise a :exc: SyntaxError . True() The true value of the bool() type. Assignments to True are illegal and raise a :exc: SyntaxError . None() The sole value of the type NoneType . None is frequently used to represent the absence of a value, as when default arguments are not passed to a function. Assignments to None are illegal and raise a :exc: SyntaxError . Zerynth VM recognizes a set of pre-defined uppercase names representing constants: Pin Names: D0 to D127 representing the names of digital pins. A0 to A127 representing the names of analog pins. LED0 to LED32 representing the names of the board leds. BTN0 to BTN32 representing the names of the board buttons. Pin Modes and Values: INPUT, OUTPUT, INPUT_PULLUP, INPUT_PULLDOWN, OUTPUT_PUSHPULL, OUTPUT_OPENDRAIN, INPUT_ANALOG representing pin modes. LOW, HIGH representing digital pin states. Time Units: MICROS to select microseconds MILLIS to select milliseconds SECONDS to select seconds Peripherals Names: SERIAL0 to SERIAL7 representing the name of the nth serial port of a board. ADC0 to ADC7 representing the name of the nth analog to digital converter of a board.","title":"Builtins Constants"},{"location":"reference/core/stdlib/docs/builtins/#builtin-exceptions","text":"Zerynth VM exceptions are different from Python exceptions. In Python, exceptions are very powerful because they are implemented as classes, contain error messages, and one can examine the full exceution stack when an exception is raised. However, in the embedded world, resources are precious and keeping class definition in memory, creating a class instance everytime an exception is raised, can be very resource-consuming. Zerynth VM exceptions are therefore implemented as error codes with optional static error messages organized as a tree: Exception +-- StopIteration +-- ArithmeticError | +-- FloatingPointError | +-- OverflowError | +-- ZeroDivisionError +-- AttributeError +-- LookupError | +-- IndexError | +-- KeyError +-- MemoryError +-- NameError +-- PeripheralError | +-- InvalidPinError | +-- InvalidHardwareStatusError | +-- HardwareInitializationError +-- IOError | +-- ConnectionError | | +-- ConnectionAbortedError | | +-- ConnectionRefusedError | | +-- ConnectionResetError | +-- TimeoutError +-- RuntimeError | +-- NotImplementedError | +-- UnsupportedError +-- TypeError +-- ValueError This way, the inheritance mechanism of classes is mantained and trasposed to the exception matching mechanism transparently. The following is valid Zerynth code: try : # raise ZeroDivisionError x = 1 / 0 except ArithmeticError as e : print ( e ) The main difference between Zerynth exceptions and Python exceptions is in the way new exceptions are created and used. To create a user defined exception in Zerynth you need to use the following code: new_exception ( MyExceptionName , MyExceptionParent , MyErrorMessage ) The builtin function new_exception always needs 2 arguments and an optional message: the first one is the user defined exception name the second is the name of the parent exception in the exception tree the third one is a static error message, where static in this context means both that it is not stored in ram as a Python string and that it can be defined only once and never changed later. Behind the scenes MyExceptionName is created and placed under MyExceptionParent in the exception tree. An exception object is returned. The exception object can only be compared to other exceptions, printed (as an error code plus message error) or raised again. When an exception is printed, the error message is concatenated with the error code and, if the exception has been raised, with the bytecode position where the error happened. Zerynth exceptions are not garbage collected. They also are not scoped: this means that an exception defined in a module is not contained in that module, but it is moved at builtin scope, so that it can be accessible by all other modules simply by name. This feature has a drawback: two modules defining an exception with the same name, can\u2019t be compiled in the same program. Exception names must be manually scoped by correctly choosing them (i.e. preprending the module name to the actual name).","title":"Builtin Exceptions"},{"location":"reference/core/stdlib/docs/builtins/#builtin-gpio-functions","text":"Zerynth VM extends Python with builtins functions to handle the General Purpose Input Output pins of the embedded device. These functions resembles the ones used by Arduino, but are more flexible. pinMode(pin, mode) Sets the pin pin in mode mode . Allowed values for mode are INPUT, OUTPUT, INPUT_PULLUP, INPUT_PULLDOWN, OUTPUT_PUSHPULL, OUTPUT_OPENDRAIN, INPUT_ANALOG digitalRead(pin) Returns the state of the pin pin . The state can be LOW or HIGH digitalWrite(pin, val) Sets the pin pin to the value val . If val is zero, pin is set to LOW , otherwise to HIGH pinToggle(pin) Sets the pin pin to the value opposite to the current pin value. If value is zero, pin is set to HIGH , otherwise to LOW analogRead(pin, samples=1) Reads analog values from pin that must be one of the Ax pins. If samples is 1 or not given, returns the integer value read from pin . If samples is greater than 1, returns a tuple of integers of size samples . The maximum value returned by analogRead depends on the analog resolution of the board. analogRead works by calling the adc driver (Analog to Digital Converter) that must be imported and configured: # import the adc driver import adc # adc is now configured with default parameters, analogRead can be used as x = analogRead ( A3 ) analogRead also accepts lists or tuples of pins and returns the corresponding tuple of tuples of samples: import adc x = analogRead ([ A4 , A3 , A5 ], 6 ) this piece of code sets x to ((\u2026),(\u2026),(\u2026)) where each inner tuple contains 6 samples taken from the corresponding channel. To used less memory, the inner tuples can be bytes() , or shorts() or normal tuples, depending on the hardware resolution of the adc unit. The number of sequentials pins that can be read in a single analogRead call depends on the specific board. The analogRead function is provided as a builtin to ease the passage from the Arduino Wiring to Zerynth. However the preferred way to read an analog pin in Zerynth is: # import the adc driver import adc x = adc . read ( A3 ) analogWrite(pin, period, pulse, time_unit=MILLIS, npulses=0) Activate PWM (Pulse Width Modulation) on pin pin (must be one of the PWMx pins). The state of pin is periodically switched between LOW and HIGH according to parameters: period is the duration of a pwm square wave pulse is the time the pwm square wave stays in the HIGH state time_unit is the unit of time period and pulse are expressed in time_unit A PWM wave can be depicted as a train of elements like this: HIGH _________________ _________________ | | | | | | | | _____| |________| |____ LOW <-----PULSE------> <-----PERIOD--------------> Here are some examples: #Remember to import the pwm module import pwm # A 1000 milliseconds wave that stays HIGH for 100 milliseconds and LOW for 900 analogWrite ( D5 . PWM , 1000 , 100 ) # A 500 microseconds wave that stays HIGH for 10 microseconds and LOW for 490 analogWrite ( D5 . PWM , 500 , 10 , MICROS ) # Disable pwm analogWrite ( D5 . PWM , 0 , 0 ) Some boards have restrictions on how pwm pins can be used, refer to the single board documentation for details. The parameter npulses is used to specify a limited train of pulses. When npulses is zero or less, PWM is activated on the pin and the function returns. When npulses is more than zero, analogWrite becomes blocking and returns only after a number of pulses equal to npulses has been generated on the pin; PWM is disabled on return. For very small pulses in the range of a few ten microseconds, the actual number of pulses produced may be greater than npulses by one or two units. The analogWrite function is provided as a builtin to ease the passage from the Arduino Wiring to Zerynth. However the preferred way to use pwm in Zerynth is: # import the pwm driver import pwm pwm . write ( D3 . PWM , 400 , 10 , MICROS ) onPinRise(pin, fun, \\*args, debounce=0, time_unit=MILLIS) Executes fun with arguments \\*args everytime pin goes from LOW to HIGH . If fun is None the corresponding interrupt is disabled. Each Zerynth VM has its own maximum number of slots for pin interrupts: if they are all full, a RuntimeError is raised. Can be used together with onPinFall() on the same pin. fun is executed in a high priority thread that takes control of the mcu and puts to sleep every other thread. Therefore fun should contains fast code. debounce and time_unit are used to define a timeout such that fun is called only if pin stays high for all the duration of the timeout. onPinFall(pin, fun, \\*args, debounce=0, time_unit=MILLIS) Executes fun with arguments \\*args everytime pin goes from HIGH to LOW . If fun is None the corresponding interrupt is disabled. Each Zerynth VM has its own maximum number of slots for pin interrupts: if they are all full, a RuntimeError is raised. Can be used together with onPinRise() on the same pin. fun is executed in a high priority thread that takes control of the mcu and puts to sleep every other thread. Therefore fun should contains fast code. debounce and time_unit are used to define a timeout such that fun is called only if pin stays high for all the duration of the timeout.","title":"Builtin GPIO Functions"},{"location":"reference/core/stdlib/docs/builtins/#builtin-functions","text":"int(x=0, base=10) Return an integer object constructed from a number or string x , or return 0 if no arguments are given. If x is a floating point number, it is truncated towards zero. If x is not a number or if base is given, then x must be a string, bytes() , or bytearray() instance representing an :integer in radix base . Optionally, the literal can be preceded by + or - (with no space in between) and surrounded by whitespace. A base-n literal consists of the digits 0 to n-1, with a to z (or A to Z ) having values 10 to 35. The default base is 10. The allowed values are 0 and 2-36. Base-2, -8, and -16 literals can be optionally prefixed with 0b / 0B , 0o / 0O , or 0x / 0X , as with integer literals in code. Base 0 means to interpret exactly as a code literal, so that the actual base is 2, 8, 10, or 16, and so that int('010', 0) is not legal, while int('010') is, as well as int('010', 8) . type(x) Return an integer representing the type of x. The following are the builtin constants returned by type(): PSMALLINT, PINTEGER, PFLOAT, PBOOL, PSTRING, PBYTES, PBYTEARRAY, PSHORTS, PSHORTARRAY, PLIST, PTUPLE, PRANGE, PFROZENSET, PSET, PDICT, PFUNCTION, PMETHOD, PCLASS, PINSTANCE, PMODULE, PITERATOR, PNONE, PEXCEPTION, PNATIVE, PSYSOBJ, PDRIVER, PTHREAD thread(fun, \\*args, prio=PRIO_NORMAL, size=-1) Function fun is launched in a new thread using args as its parameters. fun must be a normal function or a methods, other callables are not supported yet. prio sets the thread priority and accepts one of PRIO_LOWEST , PRIO_LOWER , PRIO_LOW , PRIO_NORMAL , PRIO_HIGH , PRIO_HIGHER , PRIO_HIGHEST . size is the memory in bytes , reserved for the thread inner workings. Negative values select the VM default size. Returns the created thread, already started. Raises :exc: RuntimeError if no more threads can be created. sleep(time, time_unit=MILLIS) Suspend the current thread for time expressed in time_units . All the other threads are free to continue their execution. If time_unit is MICROS, sleep does not suspend the current thread, but starts polling the cycles counter in a loop. For high precision sleep refer to :mod:`hwtimers random() random(a, b) Returns a random integer. If a and b are given, the random integer is contained in the range [a,b]. If the board has a builtin Random Number Generator, it is used. range(stop) range(start, stop, ) Creates a range object. bytearray() Return a new array of bytes. A bytearray is a mutable sequence of integers in the range 0 <= x < 256. It has most of the usual methods of mutable sequences, described in typesseq-mutable, as well as most methods that the bytes() type has, see Bytes and Bytearray Operations. The optional source parameter can be used to initialize the array in a few different ways: If it is a string , bytearray() then converts the string to bytes. If it is an integer , the array will have that size and will be initialized with null bytes. Without an argument, an array of size 0 is created. bytes() Return a new \u201cbytes\u201d object, which is an immutable sequence of integers in the range 0 <= x < 256 . bytes() is an immutable version of bytearray() \u2013 it has the same non-mutating methods and the same indexing and slicing behavior. Accordingly, constructor arguments are interpreted as for bytearray() . shortarray() Return a new array of shorts. A shortarray is a mutable sequence of integers in the range 0 <= x < 65536. It has most of the usual methods of mutable sequences, described in typesseq-mutable, as well as most methods that the shorts() type has, see shorts-methods. The optional source parameter can be used to initialize the array in a few different ways: If it is an integer , the array will have that size and will be initialized with zeros. If it is a sequence, the array will be a copy of source with its elements converted into shorts. If the conversion is not possible, an exception is raised. Without an argument, an array of size 0 is created. shorts() Return a new shorts object, which is an immutable sequence of integers in the range 0 <= x < 65536 . shorts() is an immutable version of shortarray() \u2013 it has the same non-mutating methods and the same indexing and slicing behavior. Accordingly, constructor arguments are interpreted as for shortarray() . enumerate(iterable, start=0) Return an enumerate object. iterable must be a sequence, an iterator, or some other object which supports iteration. The __next__() method of the iterator returned by enumerate() returns a tuple containing a count (from start which defaults to 0) and the values obtained from iterating over iterable . It is normally used in for loops: ints = [ 10 , 20 , 30 ] for idx , val in enumerate ( ints ): print ( idx , val ) # prints out the following: >>> 0 10 >>> 1 20 >>> 2 30 In this version of the VM, enumerate works only for primitive iterable types, not yet for instances with __next__ and __iter__ methods. reversed(seq) Return a reverse iterator. seq must be an object which has a __reversed__() method or supports the sequence protocol (the __len__() method and the __getitem__() method with integer arguments starting at 0 ). In this version of the VM, reversed works only for primitive iterable types, not yet for instances with __next__ and __iter__ methods. ord(c) Given a string representing one character, return an integer representing that character. For example, ord('a') returns the integer 97 . This is the inverse of chr() . When c is a literal string, the compiler macro __ORD\u00a9 can be used to reduce code size. For example: x = ord ( \":\" ) is valid Zerynth code. During its execution a string must be created containing \u201c:\u201d and ord must be called on it. After ord is executed the created string is probably immediately garbage collected. In the embedded world, this is time and resource consuming. The operation ord(\":\") can be executed during compilation because the result is known before the execution of the Zerynth program. To enable this feature use the following code: x = __ORD ( \":\" ) Now, no string is created and no function is called, because the compiler knows that you want to assign to x the result of ord(\":\") (which is 58). The compiler transforms our program to a faster and equivalent version: x = 58 chr(i) Return the string representing a character whose byte representation is the integer i . For example, chr(97) returns the string 'a' . This is the inverse of ord() . ValueError will be raised if i is outside the valid range. isinstance(object, class) Return true if the object argument is an instance of the class argument, or of a (direct, indirect) subclass thereof. If object is not an object of the given type, the function always returns false. If class is not a class, a TypeError exception is raised. In this version of the VM, isinstance is still not compliant with the Python one. It is suggested to use isinstance to determine the hierarchy of instances and to use type() for primitive types. print(\\*args, sep=\" \", end=\"\\\\n\", stream=None) Print objects to the stream stream , separated by sep and followed by end . sep , end and stream , if present, must be given as keyword arguments. All non-keyword arguments are converted to strings like str() does and written to the stream, separated by sep and followed by end . Both sep and end must be strings. If no objects are given, print() will just write end . The stream argument must be an object with a write(string) method; if it is not present or None , __default_stream will be used. Whether output is buffered is usually determined by stream . abs(x) Return the absolute value of a number. The argument may be an integer or a floating point number. all(iterable) Return True if all elements of the iterable are true (or if the iterable is empty). Equivalent to: def all ( iterable ): for element in iterable : if not element : return False return True any(iterable) Return True if any element of the iterable is true. If the iterable is empty, return False . Equivalent to: def any ( iterable ): for element in iterable : if element : return True return False sum(iterable, ) Sums start and the items of an iterable from left to right and returns the total. start defaults to 0 . max(\\*args) Return the largest item in args. min(\\*args) Return the smallest item in args. len(s) Return the length (the number of items) of an object. The argument may be a sequence (such as a string, bytes, tuple, list, or range) or a collection (such as a dictionary, set, or frozen set), or any instance defining the method __len__ . hex(x, prefix=\"0x\") Convert an integer number to a lowercase hexadecimal string prefixed with prefix (if not given \u201c0x\u201d is used), for example: >>> hex ( 255 ) '0xff' >>> hex ( - 42 ) '-0x2a' See also int() for converting a hexadecimal string to an integer using a base of 16. str(x=\"\") Return a string version of x . If x is not provided, returns the empty string. Returns the \u201cinformal\u201d or nicely printable string representation of object . For string objects, this is the string itself. For primitive types like list, tuples, dicts a standard representation is returned. For all other types, the method str is called. dict() dict(\\*args) Return a new dictionary initialized from an optional *args. If no *args is given, an empty dictionary is created. If a single positional argument is given and it is a mapping object, a dictionary is created with the same key-value pairs as the mapping object. Otherwise, if more than a positional argument is given, each pair of arguments is inserted in the dictionary with the first argument of the pair being the key and the second argument the value. If a key occurs more than once, the last value for that key becomes the corresponding value in the new dictionary. If the number of positional arguments is odd, the value for the last key is None. set() set(\\*args) Return a new set initialized from an optional *args. If no *args is given, an empty set is created. If a single positional argument is given and it is an iterable object, a set is created and filled with the values of the iterable. Otherwise, if more than a positional argument is given, each argument is inserted in the set. frozenset() frozenset(\\*args) Return a new frozenset initialized from an optional *args. If no *args. If no *args is given, an empty frozenset is created. If a single positional argument is given and it is an iterable object, a frozenset is created and filled with the values of the iterable. Otherwise, if more than a positional argument is given, each argument is inserted in the frozenset. open(file, mode=\"rb\") Return an object similar to a stream with read and write methods. The object class depends on the type of file opened. If file starts with \u201cresource://\u201d, open returns a ResourceStream of a flash saved resource.","title":"Builtin Functions"},{"location":"reference/core/stdlib/docs/can/","text":"CAN \u00b6 This module loads the Controller Area Network (CAN) driver. A Controller Area Network (CAN bus) is a robust vehicle bus standard designed to allow microcontrollers and devices to communicate with each other\u2019s applications without a host computer. It is a message-based protocol, designed originally for multiplex electrical wiring within automobiles to save on copper, but can also be used in many other contexts. For each device the data in a frame is transmitted sequentially but in such a way that if more than one device transmits at the same time the highest priority device is able to continue while the others back off. Frames are received by all devices, including by the transmitting device. The Can class \u00b6 Can(drvname, baud, options=0, sample_point=75.0, prop=0, phase1=0, phase2=0, sjw=1) This class implements CAN controller functionalities. Can is initialized by passing the driver name drvname , in the form of CAN0, CAN1, etc\u2026 depending on the board capabilities. Refer to the board pinout to locate the actual pins belonging to the driver. The bus speed must be also specified in the baud argument. Optional timing parameters can specify either the bit sample point sample_point , as a percentage of the bit time, or standard CAN parameters as propagation segment prop , phase segment 1 phase1 and phase segment 2 phase2 . When the sample point is used, the bit timing arguments must be zero and they are calculated automatically. The synchronization jump width sjw can be specified in any case. Arguments drvname \u2013 peripheral driver identifier (one of CAN0, CAN1, etc\u2026) baud \u2013 bus speed, in bits per second (up to 1000000) sample_point \u2013 bit sample point, in percent (0 to 100.0) prop \u2013 propagation segment, in time quanta (1 to 8) phase1 \u2013 phase segment 1, in time quanta (1 to 8) phase2 \u2013 phase segment 2, in time quanta (1 to 8) sjw \u2013 synchronization jump width, in time quanta (1 to 4) options \u2013 a combination of the following option flags: OPTION_NO_RETRY to prevent automatic retransmission (one-shot mode) OPTION_NO_AUTO_OFF to prevent automatic recovery from Bus-Off errors OPTION_KEEP_ORDER to maintain the chronological order of messages OPTION_LISTEN_ONLY to silently listen to the bus (Ack is sent internally), receive-only mode, no transmission possible OPTION_LOOPBACK to activate internal loopback test mode (can be combined with listen-only) add_filter(id, mask) Add a message acceptance filter for this CAN controller. A received message is accepted if: (received_id ^ id) & mask == 0 The returned value is a number that uniquely identifies the filter and can be used to remove the filter at a later time. Arguments id \u2013 contains the message identifier (11-bit for standard frames, 29-bit for extended frames), plus the ID Extension (IDE) flag FRAME_EXT_FLAG and the Remote Transmission Request (RTR) flag FRAME_RTR_FLAG . mask \u2013 is a bit mask where each bit is 1 if the received message id must match the corresponding bit in the message id or 0 if the corresponding bit in the message id is ignored. To match a single id you can use FRAME_STD_MASK for standard frames or FRAME_EXT_MASK combined with FRAME_EXT_FLAG for extended frames. Returns the index of the filter added. del_filter(filter) Remove a previously added message acceptance filter. Arguments filter \u2013 the index of the filter to remove. transmit(id, dlc, data=None, timeout=-1) Send a message to the CAN bus output mailboxes. Arguments id \u2013 contains the message identifier (11-bit for standard frames, 29-bit for extended frames), plus the ID Extension (IDE) flag FRAME_EXT_FLAG and the Remote Transmission Request (RTR) flag FRAME_RTR_FLAG . dlc \u2013 is the Data Length Code (DLC) used in a Data Frame or a Remote Frame. For Data Frames it is the number of data bytes included in the message. data \u2013 is a byte array that contains the message data (up to 8 bytes for classic CAN), not used for Remote Frames (RTR bit set). timeout \u2013 the maximum time to wait for queuing the message or -1 to wait indefinitely receive(data=None, timeout=-1) Receive a message from the CAN bus input mailboxes. If a data bytearray is provided it is used to store received data, otherwise a new buffer is created. Arguments data \u2013 a bytes or bytearray object to receive message data or None timeout \u2013 the maximum time to wait for a message or -1 to wait indefinitely Returns a tuple of the form (id,dlc,data), where: id contains the message identifier (11-bit for standard frames, 29-bit for extended frames), plus the ID Extension (IDE) flag FRAME_EXT_FLAG and the Remote Transmission Request (RTR) flag FRAME_RTR_FLAG . dlc is the Data Length Code (DLC) used in a Data Frame or a Remote Frame. For Data Frames it is the number of data bytes included in the message. data is a byte array that contains the message data (up to 8 bytes for classic CAN), not used for Remote Frames (RTR bit set). get_errors() Get the accumulated error information. Returns a tuple of the form (flags,rx_count,tx_count), where: flags contains the error flags, a combinations of: * `ERROR_WARNING` in Error - Active mode , when the error counter is over the warning threshold ( usually >= 96 ) * `ERROR_PASSIVE` in Error - Passive mode ( error counter >= 128 ) * `ERROR_BUSOFF` in Bus - Off mode ( error counter > 255 ) * `ERROR_STUFF` if Bit - Stuffing errors have been detected ( more than 5 bits at the same level ) * `ERROR_FORM` if Form errors have been detected ( Dominant bits detected during Recessive spaces ) * `ERROR_ACK` if no Ack bit is detected for a transmitted message * `ERROR_RECESSIVE` if error detected when trasmitting Recessive bits * `ERROR_DOMINANT` if error detected when trasmitting Dominant bits * `ERROR_CRC` if CRC mismatch have been detected * `ERROR_RX_OVERRUN` if the receive queue is full when receiving a new message * `ERROR_TX_ARBLOST` if transmitted message lost abitration due to higher priority message on the bus * `ERROR_TX_ERROR` if some error has been detected during transmission rx_count is the current value of the Receive error counter. tx_count is the current value of the Transmit error counter. abort_receive() Abort any pending receive() calls, that will raise a TimeoutError , and prevent further messages to be received, raising ConnectionAbortedError , until resumed. abort_transmit() Abort any pending transmit() calls, that will raise a TimeoutError , and prevent further messages to be transmitted, raising ConnectionAbortedError , until resumed. resume_receive() Resume receiving messages from the bus. resume_transmit() Resume transmitting messages to the bus. done() Close this CAN driver instance and release used resources. Any pending function call or subsequent calls will raise an IOError exception.","title":"CAN"},{"location":"reference/core/stdlib/docs/can/#can","text":"This module loads the Controller Area Network (CAN) driver. A Controller Area Network (CAN bus) is a robust vehicle bus standard designed to allow microcontrollers and devices to communicate with each other\u2019s applications without a host computer. It is a message-based protocol, designed originally for multiplex electrical wiring within automobiles to save on copper, but can also be used in many other contexts. For each device the data in a frame is transmitted sequentially but in such a way that if more than one device transmits at the same time the highest priority device is able to continue while the others back off. Frames are received by all devices, including by the transmitting device.","title":"CAN"},{"location":"reference/core/stdlib/docs/can/#the-can-class","text":"Can(drvname, baud, options=0, sample_point=75.0, prop=0, phase1=0, phase2=0, sjw=1) This class implements CAN controller functionalities. Can is initialized by passing the driver name drvname , in the form of CAN0, CAN1, etc\u2026 depending on the board capabilities. Refer to the board pinout to locate the actual pins belonging to the driver. The bus speed must be also specified in the baud argument. Optional timing parameters can specify either the bit sample point sample_point , as a percentage of the bit time, or standard CAN parameters as propagation segment prop , phase segment 1 phase1 and phase segment 2 phase2 . When the sample point is used, the bit timing arguments must be zero and they are calculated automatically. The synchronization jump width sjw can be specified in any case. Arguments drvname \u2013 peripheral driver identifier (one of CAN0, CAN1, etc\u2026) baud \u2013 bus speed, in bits per second (up to 1000000) sample_point \u2013 bit sample point, in percent (0 to 100.0) prop \u2013 propagation segment, in time quanta (1 to 8) phase1 \u2013 phase segment 1, in time quanta (1 to 8) phase2 \u2013 phase segment 2, in time quanta (1 to 8) sjw \u2013 synchronization jump width, in time quanta (1 to 4) options \u2013 a combination of the following option flags: OPTION_NO_RETRY to prevent automatic retransmission (one-shot mode) OPTION_NO_AUTO_OFF to prevent automatic recovery from Bus-Off errors OPTION_KEEP_ORDER to maintain the chronological order of messages OPTION_LISTEN_ONLY to silently listen to the bus (Ack is sent internally), receive-only mode, no transmission possible OPTION_LOOPBACK to activate internal loopback test mode (can be combined with listen-only) add_filter(id, mask) Add a message acceptance filter for this CAN controller. A received message is accepted if: (received_id ^ id) & mask == 0 The returned value is a number that uniquely identifies the filter and can be used to remove the filter at a later time. Arguments id \u2013 contains the message identifier (11-bit for standard frames, 29-bit for extended frames), plus the ID Extension (IDE) flag FRAME_EXT_FLAG and the Remote Transmission Request (RTR) flag FRAME_RTR_FLAG . mask \u2013 is a bit mask where each bit is 1 if the received message id must match the corresponding bit in the message id or 0 if the corresponding bit in the message id is ignored. To match a single id you can use FRAME_STD_MASK for standard frames or FRAME_EXT_MASK combined with FRAME_EXT_FLAG for extended frames. Returns the index of the filter added. del_filter(filter) Remove a previously added message acceptance filter. Arguments filter \u2013 the index of the filter to remove. transmit(id, dlc, data=None, timeout=-1) Send a message to the CAN bus output mailboxes. Arguments id \u2013 contains the message identifier (11-bit for standard frames, 29-bit for extended frames), plus the ID Extension (IDE) flag FRAME_EXT_FLAG and the Remote Transmission Request (RTR) flag FRAME_RTR_FLAG . dlc \u2013 is the Data Length Code (DLC) used in a Data Frame or a Remote Frame. For Data Frames it is the number of data bytes included in the message. data \u2013 is a byte array that contains the message data (up to 8 bytes for classic CAN), not used for Remote Frames (RTR bit set). timeout \u2013 the maximum time to wait for queuing the message or -1 to wait indefinitely receive(data=None, timeout=-1) Receive a message from the CAN bus input mailboxes. If a data bytearray is provided it is used to store received data, otherwise a new buffer is created. Arguments data \u2013 a bytes or bytearray object to receive message data or None timeout \u2013 the maximum time to wait for a message or -1 to wait indefinitely Returns a tuple of the form (id,dlc,data), where: id contains the message identifier (11-bit for standard frames, 29-bit for extended frames), plus the ID Extension (IDE) flag FRAME_EXT_FLAG and the Remote Transmission Request (RTR) flag FRAME_RTR_FLAG . dlc is the Data Length Code (DLC) used in a Data Frame or a Remote Frame. For Data Frames it is the number of data bytes included in the message. data is a byte array that contains the message data (up to 8 bytes for classic CAN), not used for Remote Frames (RTR bit set). get_errors() Get the accumulated error information. Returns a tuple of the form (flags,rx_count,tx_count), where: flags contains the error flags, a combinations of: * `ERROR_WARNING` in Error - Active mode , when the error counter is over the warning threshold ( usually >= 96 ) * `ERROR_PASSIVE` in Error - Passive mode ( error counter >= 128 ) * `ERROR_BUSOFF` in Bus - Off mode ( error counter > 255 ) * `ERROR_STUFF` if Bit - Stuffing errors have been detected ( more than 5 bits at the same level ) * `ERROR_FORM` if Form errors have been detected ( Dominant bits detected during Recessive spaces ) * `ERROR_ACK` if no Ack bit is detected for a transmitted message * `ERROR_RECESSIVE` if error detected when trasmitting Recessive bits * `ERROR_DOMINANT` if error detected when trasmitting Dominant bits * `ERROR_CRC` if CRC mismatch have been detected * `ERROR_RX_OVERRUN` if the receive queue is full when receiving a new message * `ERROR_TX_ARBLOST` if transmitted message lost abitration due to higher priority message on the bus * `ERROR_TX_ERROR` if some error has been detected during transmission rx_count is the current value of the Receive error counter. tx_count is the current value of the Transmit error counter. abort_receive() Abort any pending receive() calls, that will raise a TimeoutError , and prevent further messages to be received, raising ConnectionAbortedError , until resumed. abort_transmit() Abort any pending transmit() calls, that will raise a TimeoutError , and prevent further messages to be transmitted, raising ConnectionAbortedError , until resumed. resume_receive() Resume receiving messages from the bus. resume_transmit() Resume transmitting messages to the bus. done() Close this CAN driver instance and release used resources. Any pending function call or subsequent calls will raise an IOError exception.","title":"The Can class"},{"location":"reference/core/stdlib/docs/cbor/","text":"CBOR \u00b6 This module define functions to serialize and deserialize objects to and from CBOR format. The serialization and deserialization of objects is performed using a wrapped version of the awesome and lighting fast libcbor loads(data) Returns a Python object represented by the byte sequence data . For CBOR specific structures such as tags and undefined values, the function returns instances of the Tag() and Undefined() classes. Raises ValueError when data contains bad or unsupported CBOR. dumps(obj) Returns a bytes object containing the CBOR representation of obj . If a Python object is not serializable to CBOR, it is serialized to Undefined() . The function always produces definite major types (bytestrings, string, arrays and maps). To generate CBOR specific structures such as tags and undefined values, pass as argument instances of the Tag() and Undefined() classes. Raises RuntimeError when obj can\u2019t be serialized. Tag class \u00b6 Tag(tag, value) Create a Tag instance. Tag instances have two attributes, tag and value that can be manually changed if needed. tag must be an integer while value can be any CBOR serializable python object. An instance of this class is returned during deserialization if a tag is found. Undefined class \u00b6 Undefined() Create an Undefined instance. Since Python has no undefined values, this class is used to both serialize and deserialize this kind of data.","title":"CBOR"},{"location":"reference/core/stdlib/docs/cbor/#cbor","text":"This module define functions to serialize and deserialize objects to and from CBOR format. The serialization and deserialization of objects is performed using a wrapped version of the awesome and lighting fast libcbor loads(data) Returns a Python object represented by the byte sequence data . For CBOR specific structures such as tags and undefined values, the function returns instances of the Tag() and Undefined() classes. Raises ValueError when data contains bad or unsupported CBOR. dumps(obj) Returns a bytes object containing the CBOR representation of obj . If a Python object is not serializable to CBOR, it is serialized to Undefined() . The function always produces definite major types (bytestrings, string, arrays and maps). To generate CBOR specific structures such as tags and undefined values, pass as argument instances of the Tag() and Undefined() classes. Raises RuntimeError when obj can\u2019t be serialized.","title":"CBOR"},{"location":"reference/core/stdlib/docs/cbor/#tag-class","text":"Tag(tag, value) Create a Tag instance. Tag instances have two attributes, tag and value that can be manually changed if needed. tag must be an integer while value can be any CBOR serializable python object. An instance of this class is returned during deserialization if a tag is found.","title":"Tag class"},{"location":"reference/core/stdlib/docs/cbor/#undefined-class","text":"Undefined() Create an Undefined instance. Since Python has no undefined values, this class is used to both serialize and deserialize this kind of data.","title":"Undefined class"},{"location":"reference/core/stdlib/docs/crypto/","text":"Cryptography \u00b6 The Zerynth standard library offers useful cryptographic primitives Contents: MD5 secure hash The MD5 class SHA1 secure hash The SHA1 class SHA2 secure hash The module is based on the C library cifra. The SHA2 class SHA3 secure hash The module is based on the C library cifra. The SHA3 class Keccak secure hash The module is based on a patched version of the C library cifra. The Keccak class HMAC Elliptic Curve Cryptography","title":"Cryptography"},{"location":"reference/core/stdlib/docs/crypto/#cryptography","text":"The Zerynth standard library offers useful cryptographic primitives Contents: MD5 secure hash The MD5 class SHA1 secure hash The SHA1 class SHA2 secure hash The module is based on the C library cifra. The SHA2 class SHA3 secure hash The module is based on the C library cifra. The SHA3 class Keccak secure hash The module is based on a patched version of the C library cifra. The Keccak class HMAC Elliptic Curve Cryptography","title":"Cryptography"},{"location":"reference/core/stdlib/docs/crypto_ecc_ecc/","text":"Elliptic Curve Cryptography \u00b6 This module offer cryptographic primitives based on Elliptic Curves. In particular it provides key generation and validation, signing, and verifying, for the following curves: secp160r1 secp192r1 (NISTP192) secp224r1 (NISTP224) secp256r1 (NISTP256) secp256k1 (used by Bitcoin) For an awesome introduction to ECC check here . For an online ECC calculator check here The module is based on MicroECC patched with functions to enable public key recovery (mainly for blockchain applications). The module defines the following constants defining curves: SECP160R1 SECP192R1 SECP224R1 SECP256R1 SECP256K1 make_keys(curve) Return a tuple of two elements. The first element is a byte object containing the uncompressed representation of the generated public key. The second element is a byte object containing the representation of the generated public key. curve specifies the curve to use This function uses the random number generator provided by the VM. For real world usage and enhanced security the random number generator must be of cryptographic quality (generally implemented in hardware). check_public_key(curve, pbkey) Return True if pbkey (in uncompressed format) is a valid public key for curve . derive_public_key(curve, pvkey) Return a byte object containing the uncompressed representation of the public key matching pvkey for curve curve . Raise ValueError if derivation is not possible. compress_key(curve, key) Return a compressed representation of key . decompress_key(curve, key) Return a uncompressed representation of key . verify(curve, message, signature, pbkey) Return True if signature is a valid signature for message message given curve and a public key pbkey . sign(curve, message, pvkey, deterministic = False, recoverable = False) Return the signature of message with pvkey for curve curve . Usually the message to sign is not the entire message but a hash of it. The deterministic parameter, if given, creates a deterministic signature according to RFC6979 . If given, the deterministic parameter must be an instance of a hash class from module crypto.hash . Deterministic signatures are not dependent on a good random number generator for their security and can therefore be used in hardware without such capabilities. If recoverable is given and True, the returned object is a tuple such that the first element is the recovery id and the second element is the signature. The recovery id is a parameter that can be used to derive the public key from a just a valid signature. For more info refer to this paper .","title":"Elliptic Curve Cryptography"},{"location":"reference/core/stdlib/docs/crypto_ecc_ecc/#elliptic-curve-cryptography","text":"This module offer cryptographic primitives based on Elliptic Curves. In particular it provides key generation and validation, signing, and verifying, for the following curves: secp160r1 secp192r1 (NISTP192) secp224r1 (NISTP224) secp256r1 (NISTP256) secp256k1 (used by Bitcoin) For an awesome introduction to ECC check here . For an online ECC calculator check here The module is based on MicroECC patched with functions to enable public key recovery (mainly for blockchain applications). The module defines the following constants defining curves: SECP160R1 SECP192R1 SECP224R1 SECP256R1 SECP256K1 make_keys(curve) Return a tuple of two elements. The first element is a byte object containing the uncompressed representation of the generated public key. The second element is a byte object containing the representation of the generated public key. curve specifies the curve to use This function uses the random number generator provided by the VM. For real world usage and enhanced security the random number generator must be of cryptographic quality (generally implemented in hardware). check_public_key(curve, pbkey) Return True if pbkey (in uncompressed format) is a valid public key for curve . derive_public_key(curve, pvkey) Return a byte object containing the uncompressed representation of the public key matching pvkey for curve curve . Raise ValueError if derivation is not possible. compress_key(curve, key) Return a compressed representation of key . decompress_key(curve, key) Return a uncompressed representation of key . verify(curve, message, signature, pbkey) Return True if signature is a valid signature for message message given curve and a public key pbkey . sign(curve, message, pvkey, deterministic = False, recoverable = False) Return the signature of message with pvkey for curve curve . Usually the message to sign is not the entire message but a hash of it. The deterministic parameter, if given, creates a deterministic signature according to RFC6979 . If given, the deterministic parameter must be an instance of a hash class from module crypto.hash . Deterministic signatures are not dependent on a good random number generator for their security and can therefore be used in hardware without such capabilities. If recoverable is given and True, the returned object is a tuple such that the first element is the recovery id and the second element is the signature. The recovery id is a parameter that can be used to derive the public key from a just a valid signature. For more info refer to this paper .","title":"Elliptic Curve Cryptography"},{"location":"reference/core/stdlib/docs/crypto_hash_hmac/","text":"HMAC \u00b6 This module implements the HMAC algorithm as described by RFC 2104 . The module is based on the C library cifra . HMAC(key, hashfn) Return a new hmac object. key is a bytes or bytearray or string object giving the secret key. hashfn is an instance of a hash function to use in hmac generation. It supports any class in the crypto.hash module. update(data) Update the hmac object with the string data . Repeated calls are equivalent to a single call with the concatenation of all the arguments: m.update(a); m.update(b) is equivalent to m.update(a+b). digest() Return the digest of the strings passed to the update method so far. The size depends on hashfn . hexdigest() Like digest except the digest is returned as a string containing only hexadecimal digits.","title":"HMAC"},{"location":"reference/core/stdlib/docs/crypto_hash_hmac/#hmac","text":"This module implements the HMAC algorithm as described by RFC 2104 . The module is based on the C library cifra . HMAC(key, hashfn) Return a new hmac object. key is a bytes or bytearray or string object giving the secret key. hashfn is an instance of a hash function to use in hmac generation. It supports any class in the crypto.hash module. update(data) Update the hmac object with the string data . Repeated calls are equivalent to a single call with the concatenation of all the arguments: m.update(a); m.update(b) is equivalent to m.update(a+b). digest() Return the digest of the strings passed to the update method so far. The size depends on hashfn . hexdigest() Like digest except the digest is returned as a string containing only hexadecimal digits.","title":"HMAC"},{"location":"reference/core/stdlib/docs/crypto_hash_keccak/","text":"Keccak secure hash \u00b6 This module implements the interface to Keccak secure hash functions. There is a lot of confusion about the relation between Keccak hash functions and SHA3 hash functions. The NIST organized a contest to develop the next standard secure hash function to use in place of SHA2. The Keccak team won the competition with its reference implementation known as Keccak secure hash. However the NIST changed the Keccak implementation before making it a standard known as SHA3 in 2015. The standard SHA3, described in FIPS202 is therefore different from the original Keccak (by the value of the padding bytes). Even if SHA3 is now the standard, Keccak hash is still important because, since the contest lasted from 2008 to 2015, in that time many software projects recognized the enhanced security of Keccak and included the original implementation before the standard was published. One of such project is the blockchain Ethereum . Sadly, both Keccak and official SHA3 are often simply called SHA3, arising much confusion. One simple way to test an implementation of a SHA3 algorithm is to generate the hash of the empty string: c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is the original Keccak-256 a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a is the NIST SHA3-256 The module is used in the same way as all crypto hash modules: an instance of the Keccak class is created, then feed this object with arbitrary strings/bytes using the update() method, and at any point you can ask it for the digest of the concatenation of the strings fed to it so far. The class supports 4 variants of Keccak, selectable in the constructor with one of the following constants: KECCAK224 KECCAK256 KECCAK284 KECCAK512 The module is based on a patched version of the C library cifra . \u00b6 The Keccak class \u00b6 class Keccak(hashtype=KECCAK256) This class allows the generation of Keccak hashes. It is thread safe. By default, it calculates the Keccak-256 variant. This behaviour can be changed by passing a different value for hashtype update(data) Update the sha object with the string data . Repeated calls are equivalent to a single call with the concatenation of all the arguments: m.update(a); m.update(b) is equivalent to m.update(a+b). digest() Return the digest of the strings passed to the update method so far. This is a byte object with length depending on the Keccak variant. hexdigest() Like digest except the digest is returned as a string containing only hexadecimal digits.","title":"Crypto hash keccak"},{"location":"reference/core/stdlib/docs/crypto_hash_keccak/#keccak-secure-hash","text":"This module implements the interface to Keccak secure hash functions. There is a lot of confusion about the relation between Keccak hash functions and SHA3 hash functions. The NIST organized a contest to develop the next standard secure hash function to use in place of SHA2. The Keccak team won the competition with its reference implementation known as Keccak secure hash. However the NIST changed the Keccak implementation before making it a standard known as SHA3 in 2015. The standard SHA3, described in FIPS202 is therefore different from the original Keccak (by the value of the padding bytes). Even if SHA3 is now the standard, Keccak hash is still important because, since the contest lasted from 2008 to 2015, in that time many software projects recognized the enhanced security of Keccak and included the original implementation before the standard was published. One of such project is the blockchain Ethereum . Sadly, both Keccak and official SHA3 are often simply called SHA3, arising much confusion. One simple way to test an implementation of a SHA3 algorithm is to generate the hash of the empty string: c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is the original Keccak-256 a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a is the NIST SHA3-256 The module is used in the same way as all crypto hash modules: an instance of the Keccak class is created, then feed this object with arbitrary strings/bytes using the update() method, and at any point you can ask it for the digest of the concatenation of the strings fed to it so far. The class supports 4 variants of Keccak, selectable in the constructor with one of the following constants: KECCAK224 KECCAK256 KECCAK284 KECCAK512","title":"Keccak secure hash"},{"location":"reference/core/stdlib/docs/crypto_hash_keccak/#the-module-is-based-on-a-patched-version-of-the-c-library-cifra","text":"","title":"The module is based on a patched version of the C library cifra."},{"location":"reference/core/stdlib/docs/crypto_hash_keccak/#the-keccak-class","text":"class Keccak(hashtype=KECCAK256) This class allows the generation of Keccak hashes. It is thread safe. By default, it calculates the Keccak-256 variant. This behaviour can be changed by passing a different value for hashtype update(data) Update the sha object with the string data . Repeated calls are equivalent to a single call with the concatenation of all the arguments: m.update(a); m.update(b) is equivalent to m.update(a+b). digest() Return the digest of the strings passed to the update method so far. This is a byte object with length depending on the Keccak variant. hexdigest() Like digest except the digest is returned as a string containing only hexadecimal digits.","title":"The Keccak class"},{"location":"reference/core/stdlib/docs/crypto_hash_md5/","text":"MD5 secure hash \u00b6 This module implements the interface to MD5 secure hash algorithm. It is used in the same way as all crypto hash modules: an instance of the MD5 class is created, then feed this object with arbitrary strings/bytes using the update() method, and at any point you can ask it for the digest of the concatenation of the strings fed to it so far. The MD5 class \u00b6 class MD5() This class allows the generation of MD5 hashes. It is thread safe. update(data) Update the md5 object with the string data . Repeated calls are equivalent to a single call with the concatenation of all the arguments: m.update(a); m.update(b) is equivalent to m.update(a+b). digest() Return the digest of the strings passed to the update method so far. This is a 16-byte bytes object. hexdigest() Like digest except the digest is returned as a string of length 32, containing only hexadecimal digits.","title":"Crypto hash md5"},{"location":"reference/core/stdlib/docs/crypto_hash_md5/#md5-secure-hash","text":"This module implements the interface to MD5 secure hash algorithm. It is used in the same way as all crypto hash modules: an instance of the MD5 class is created, then feed this object with arbitrary strings/bytes using the update() method, and at any point you can ask it for the digest of the concatenation of the strings fed to it so far.","title":"MD5 secure hash"},{"location":"reference/core/stdlib/docs/crypto_hash_md5/#the-md5-class","text":"class MD5() This class allows the generation of MD5 hashes. It is thread safe. update(data) Update the md5 object with the string data . Repeated calls are equivalent to a single call with the concatenation of all the arguments: m.update(a); m.update(b) is equivalent to m.update(a+b). digest() Return the digest of the strings passed to the update method so far. This is a 16-byte bytes object. hexdigest() Like digest except the digest is returned as a string of length 32, containing only hexadecimal digits.","title":"The MD5 class"},{"location":"reference/core/stdlib/docs/crypto_hash_sha1/","text":"SHA1 secure hash \u00b6 This module implements the interface to NIST\u2019s secure hash algorithm, known as SHA-1. SHA-1 is an improved version of the original SHA hash algorithm. It is used in the same way as all crypto hash modules: an instance of the SHA class is created, then feed this object with arbitrary strings/bytes using the update() method, and at any point you can ask it for the digest of the concatenation of the strings fed to it so far. The module is based on the C library cifra . The SHA1 class \u00b6 class SHA1() This class allows the generation of SHA1 hashes. It is thread safe. update(data) Update the sha object with the string data . Repeated calls are equivalent to a single call with the concatenation of all the arguments: m.update(a); m.update(b) is equivalent to m.update(a+b). digest() Return the digest of the strings passed to the update method so far. This is a 20-byte bytes object. hexdigest() Like digest except the digest is returned as a string of length 40, containing only hexadecimal digits.","title":"Crypto hash sha1"},{"location":"reference/core/stdlib/docs/crypto_hash_sha1/#sha1-secure-hash","text":"This module implements the interface to NIST\u2019s secure hash algorithm, known as SHA-1. SHA-1 is an improved version of the original SHA hash algorithm. It is used in the same way as all crypto hash modules: an instance of the SHA class is created, then feed this object with arbitrary strings/bytes using the update() method, and at any point you can ask it for the digest of the concatenation of the strings fed to it so far. The module is based on the C library cifra .","title":"SHA1 secure hash"},{"location":"reference/core/stdlib/docs/crypto_hash_sha1/#the-sha1-class","text":"class SHA1() This class allows the generation of SHA1 hashes. It is thread safe. update(data) Update the sha object with the string data . Repeated calls are equivalent to a single call with the concatenation of all the arguments: m.update(a); m.update(b) is equivalent to m.update(a+b). digest() Return the digest of the strings passed to the update method so far. This is a 20-byte bytes object. hexdigest() Like digest except the digest is returned as a string of length 40, containing only hexadecimal digits.","title":"The SHA1 class"},{"location":"reference/core/stdlib/docs/crypto_hash_sha2/","text":"SHA2 secure hash \u00b6 This module implements the interface to NIST\u2019s secure hash algorithm, known as SHA-2. It is used in the same way as all crypto hash modules: an instance of the SHA2 class is created, then feed this object with arbitrary strings/bytes using the update() method, and at any point you can ask it for the digest of the concatenation of the strings fed to it so far. The class supports 4 variants of SHA2, selectable in the constructor with one of the following constants: SHA224 SHA256 SHA284 SHA512 The module is based on the C library cifra . \u00b6 The SHA2 class \u00b6 class SHA2(hashtype=SHA256) This class allows the generation of SHA2 hashes. It is thread safe. By default, it calculates the SHA256 variant of SHA2. This behaviour can be changed by passing a different value for hashtype update(data) Update the sha object with the string data . Repeated calls are equivalent to a single call with the concatenation of all the arguments: m.update(a); m.update(b) is equivalent to m.update(a+b). digest() Return the digest of the strings passed to the update method so far. This is a byte object with length depending on the SHA2 variant. hexdigest() Like digest except the digest is returned as a string containing only hexadecimal digits.","title":"Crypto hash sha2"},{"location":"reference/core/stdlib/docs/crypto_hash_sha2/#sha2-secure-hash","text":"This module implements the interface to NIST\u2019s secure hash algorithm, known as SHA-2. It is used in the same way as all crypto hash modules: an instance of the SHA2 class is created, then feed this object with arbitrary strings/bytes using the update() method, and at any point you can ask it for the digest of the concatenation of the strings fed to it so far. The class supports 4 variants of SHA2, selectable in the constructor with one of the following constants: SHA224 SHA256 SHA284 SHA512","title":"SHA2 secure hash"},{"location":"reference/core/stdlib/docs/crypto_hash_sha2/#the-module-is-based-on-the-c-library-cifra","text":"","title":"The module is based on the C library cifra."},{"location":"reference/core/stdlib/docs/crypto_hash_sha2/#the-sha2-class","text":"class SHA2(hashtype=SHA256) This class allows the generation of SHA2 hashes. It is thread safe. By default, it calculates the SHA256 variant of SHA2. This behaviour can be changed by passing a different value for hashtype update(data) Update the sha object with the string data . Repeated calls are equivalent to a single call with the concatenation of all the arguments: m.update(a); m.update(b) is equivalent to m.update(a+b). digest() Return the digest of the strings passed to the update method so far. This is a byte object with length depending on the SHA2 variant. hexdigest() Like digest except the digest is returned as a string containing only hexadecimal digits.","title":"The SHA2 class"},{"location":"reference/core/stdlib/docs/crypto_hash_sha3/","text":"SHA3 secure hash \u00b6 This module implements the interface to NIST\u2019s secure hash algorithm, known as SHA-3. It is used in the same way as all crypto hash modules: an instance of the SHA3 class is created, then feed this object with arbitrary strings/bytes using the update() method, and at any point you can ask it for the digest of the concatenation of the strings fed to it so far. The class supports 4 variants of SHA3, selectable in the constructor with one of the following constants: SHA224 SHA256 SHA284 SHA512 The module is based on the C library cifra . \u00b6 The SHA3 class \u00b6 class SHA3(hashtype=SHA256) This class allows the generation of SHA3 hashes. It is thread safe. By default, it calculates the SHA256 variant of SHA3. This behaviour can be changed by passing a different value for hashtype update(data) Update the sha object with the string data . Repeated calls are equivalent to a single call with the concatenation of all the arguments: m.update(a); m.update(b) is equivalent to m.update(a+b). digest() Return the digest of the strings passed to the update method so far. This is a byte object with length depending on the SHA3 variant. hexdigest() Like digest except the digest is returned as a string containing only hexadecimal digits.","title":"Crypto hash sha3"},{"location":"reference/core/stdlib/docs/crypto_hash_sha3/#sha3-secure-hash","text":"This module implements the interface to NIST\u2019s secure hash algorithm, known as SHA-3. It is used in the same way as all crypto hash modules: an instance of the SHA3 class is created, then feed this object with arbitrary strings/bytes using the update() method, and at any point you can ask it for the digest of the concatenation of the strings fed to it so far. The class supports 4 variants of SHA3, selectable in the constructor with one of the following constants: SHA224 SHA256 SHA284 SHA512","title":"SHA3 secure hash"},{"location":"reference/core/stdlib/docs/crypto_hash_sha3/#the-module-is-based-on-the-c-library-cifra","text":"","title":"The module is based on the C library cifra."},{"location":"reference/core/stdlib/docs/crypto_hash_sha3/#the-sha3-class","text":"class SHA3(hashtype=SHA256) This class allows the generation of SHA3 hashes. It is thread safe. By default, it calculates the SHA256 variant of SHA3. This behaviour can be changed by passing a different value for hashtype update(data) Update the sha object with the string data . Repeated calls are equivalent to a single call with the concatenation of all the arguments: m.update(a); m.update(b) is equivalent to m.update(a+b). digest() Return the digest of the strings passed to the update method so far. This is a byte object with length depending on the SHA3 variant. hexdigest() Like digest except the digest is returned as a string containing only hexadecimal digits.","title":"The SHA3 class"},{"location":"reference/core/stdlib/docs/dac/","text":"DAC \u00b6 This module loads the DAC (Digital Analog Converter) interface. A digital to analog converter is a module to convert digital values into analog ones. While builtin analogWrite simulates an analog value through the PWM peripheral, DAC output is a pure analog one. This means higher accuracy, specially with high speed signals. Example: import streams import adc # for analogRead import dac def readInput (): while True : print ( \"reading A1: \" , analogRead ( A1 )) sleep ( 500 ) streams . serial () pinMode ( A1 , INPUT ) # read input in a separate thread thread ( readInput ) my_dac = dac . DAC ( D8 . DAC ) my_dac . start () my_dac . write ([ 100 , 200 , 900 , 800 ], 1000 , MILLIS , circular = True ) The DAC class \u00b6 DAC(pin) Creates a DAC instance on pin pin (look at board pinmap to see which pins are enabled for using the DAC peripheral). start() DAC is started. It is necessary to start the driver before writing any value. write(data, timestep, timeunit, circular=False) data is output on selected pin. data parameter can be: * a single integer value: my_dac . write ( 666 ) a list of values to be output every timestep *timeunit*econds until the end of the list is reached and last value is kept on output: my_dac . write ([ 555 , 666 , 777 ], 500 , MILLIS ) # one sample every 500 MILLISeconds a list of values to be output every timestep timeunit*econds, restarting from the beginning as soon as the end of the list is reached, until write method is called again: my_dac . write ([ 555 , 666 , 777 ], 500 , MILLIS , circular = True ) stop() dac is stopped and low level configuration disabled. lock() Locks the driver. It is useful when the same dac object is used by multiple threads to avoid interferences. unlock() Unlocks the driver. It is useful when the same dac object is used by multiple threads to avoid interferences. remap(values, lowflex=660, highflex=3415) Some DAC chips have a limited voltage range (i.e. Sam3X by Atmel maps from ~3.3/6 V to ~3.3*(\u215a) V) and remap given output values according to their operative ranges. This helper function allows the user to obtain the voltage value he would expect from a proportional DAC. Given a value in values list, DAC output will respect the following formula: output_voltage = board_voltage * ( value / 4096 ) Each value in the list must be an integer between lowflex and highflex in order to avoid a TypeError exception. lowflex and highflex default values are set to the correct values for Sam3X mcu.","title":"DAC"},{"location":"reference/core/stdlib/docs/dac/#dac","text":"This module loads the DAC (Digital Analog Converter) interface. A digital to analog converter is a module to convert digital values into analog ones. While builtin analogWrite simulates an analog value through the PWM peripheral, DAC output is a pure analog one. This means higher accuracy, specially with high speed signals. Example: import streams import adc # for analogRead import dac def readInput (): while True : print ( \"reading A1: \" , analogRead ( A1 )) sleep ( 500 ) streams . serial () pinMode ( A1 , INPUT ) # read input in a separate thread thread ( readInput ) my_dac = dac . DAC ( D8 . DAC ) my_dac . start () my_dac . write ([ 100 , 200 , 900 , 800 ], 1000 , MILLIS , circular = True )","title":"DAC"},{"location":"reference/core/stdlib/docs/dac/#the-dac-class","text":"DAC(pin) Creates a DAC instance on pin pin (look at board pinmap to see which pins are enabled for using the DAC peripheral). start() DAC is started. It is necessary to start the driver before writing any value. write(data, timestep, timeunit, circular=False) data is output on selected pin. data parameter can be: * a single integer value: my_dac . write ( 666 ) a list of values to be output every timestep *timeunit*econds until the end of the list is reached and last value is kept on output: my_dac . write ([ 555 , 666 , 777 ], 500 , MILLIS ) # one sample every 500 MILLISeconds a list of values to be output every timestep timeunit*econds, restarting from the beginning as soon as the end of the list is reached, until write method is called again: my_dac . write ([ 555 , 666 , 777 ], 500 , MILLIS , circular = True ) stop() dac is stopped and low level configuration disabled. lock() Locks the driver. It is useful when the same dac object is used by multiple threads to avoid interferences. unlock() Unlocks the driver. It is useful when the same dac object is used by multiple threads to avoid interferences. remap(values, lowflex=660, highflex=3415) Some DAC chips have a limited voltage range (i.e. Sam3X by Atmel maps from ~3.3/6 V to ~3.3*(\u215a) V) and remap given output values according to their operative ranges. This helper function allows the user to obtain the voltage value he would expect from a proportional DAC. Given a value in values list, DAC output will respect the following formula: output_voltage = board_voltage * ( value / 4096 ) Each value in the list must be an integer between lowflex and highflex in order to avoid a TypeError exception. lowflex and highflex default values are set to the correct values for Sam3X mcu.","title":"The DAC class"},{"location":"reference/core/stdlib/docs/eth/","text":"Ethernet \u00b6 This module implements a generic ethernet interface. To function correctly it needs an ethernet driver to be loaded, so that the module can use the driver to access the underlying hardware. The link between the eth module and the ethernet driver is established without the programmer intervention by the driver itself. gethostbyname(hostname) Translate a host name to IPv4 address format. The IPv4 address is returned as a string, such as \u201c192.168.0.5\u201d. select(rlist, wlist, xlist, timeout=None) This is equivalent to the Unix select system call. The first three arguments are sequences of socket instances. rlist : wait until ready for reading wlist : wait until ready for writing xlist : wait for an \u201cexceptional condition\u201d (not supported by every wifi driver) Empty sequences are allowed. The optional timeout argument specifies a time-out as an integer number in milliseconds. When the timeout argument is omitted the function blocks until at least one socket is ready. A timeout value of zero specifies a poll and never blocks. The return value is a triple of lists of objects that are ready: subsets of the first three arguments. When the time-out is reached without a socket becoming ready, three empty lists are returned. link() Activate the Ethernet PHY and try to establish a link. An exception can be raised if the link is not successful. unlink() Disable the Ethernet PHY and disconnect from the currently linked network. is_linked() Return True if linked set_link_info(ip, mask, gw, dns) Set desired eth interface parameters: ip, the static ipv4 address mask, the network mask gw, the default gateway dns, the default dns If 0.0.0.0 is given, a default address will be used. link_info() Return information on the currently established link. The result is a tuple where the elements are, in order: The assigned IP as a string The network mask as a string The gateway IP as a string The DNS IP as a string The MAC address of the eth interface as a sequence of 6 bytes","title":"Ethernet"},{"location":"reference/core/stdlib/docs/eth/#ethernet","text":"This module implements a generic ethernet interface. To function correctly it needs an ethernet driver to be loaded, so that the module can use the driver to access the underlying hardware. The link between the eth module and the ethernet driver is established without the programmer intervention by the driver itself. gethostbyname(hostname) Translate a host name to IPv4 address format. The IPv4 address is returned as a string, such as \u201c192.168.0.5\u201d. select(rlist, wlist, xlist, timeout=None) This is equivalent to the Unix select system call. The first three arguments are sequences of socket instances. rlist : wait until ready for reading wlist : wait until ready for writing xlist : wait for an \u201cexceptional condition\u201d (not supported by every wifi driver) Empty sequences are allowed. The optional timeout argument specifies a time-out as an integer number in milliseconds. When the timeout argument is omitted the function blocks until at least one socket is ready. A timeout value of zero specifies a poll and never blocks. The return value is a triple of lists of objects that are ready: subsets of the first three arguments. When the time-out is reached without a socket becoming ready, three empty lists are returned. link() Activate the Ethernet PHY and try to establish a link. An exception can be raised if the link is not successful. unlink() Disable the Ethernet PHY and disconnect from the currently linked network. is_linked() Return True if linked set_link_info(ip, mask, gw, dns) Set desired eth interface parameters: ip, the static ipv4 address mask, the network mask gw, the default gateway dns, the default dns If 0.0.0.0 is given, a default address will be used. link_info() Return information on the currently established link. The result is a tuple where the elements are, in order: The assigned IP as a string The network mask as a string The gateway IP as a string The DNS IP as a string The MAC address of the eth interface as a sequence of 6 bytes","title":"Ethernet"},{"location":"reference/core/stdlib/docs/examples/","text":"Examples \u00b6 The following are a list of examples for core.zerynth.stdlib Hello World \u00b6 The simplest example to be tried for starting with embedded development tags: [First Steps, Serial] groups:[First Steps] main.py ############################################################################### # Hello Zerynth # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ############################################################################### # import the streams module, it is needed to send data around import streams # open the default serial port, the output will be visible in the serial console streams . serial () # loop forever while True : print ( \"Hello Zerynth!\" ) # print automatically knows where to print! sleep ( 1000 ) Basic LED Blink \u00b6 The \"Hello World\" of embedded devices Just configure a digital pin as output driving it ON and OFF every sec to blink the attached LED. tags: [Digital I/O, First Steps] groups:[First Steps] main.py ############################################################################### # Led Blink # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ############################################################################### # D0 to D127 represent the names of digital pins # On most Arduino-like boards Pin D13 has an on-board LED connected. # However Zerynth abstracts the board layout allowing to use LED0, LED1, etc as led names. # In this example LED0 is used. pinMode ( LED0 , OUTPUT ) # loop forever while True : digitalWrite ( LED0 , HIGH ) # turn the LED ON by setting the voltage HIGH sleep ( 1000 ) # wait for a second digitalWrite ( LED0 , LOW ) # turn the LED OFF by setting the voltage LOW sleep ( 1000 ) # wait for a second Digital Read Basics \u00b6 The basic definition of digitalRead() in ZERYNTH has the same behaviour of Arduino digitalRead(). In this example simple digitalRead use is reported tags: [First Steps,Digital Read ADC] groups:[First Steps] main.py ################################################################################ # Digital Read Basics # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams # create a serial port stream with default parameters streams . serial () # configure pin D5 in input mode pinMode ( D5 , INPUT_PULLUP ) # loop forever, printing the value of D5 while True : print ( digitalRead ( D5 )) sleep ( 500 ) ADC Analog to Digital Acquisition Basics \u00b6 The function for Analog to Digital convertion in ZERYNTH is adc.read() The complete definition is adc.read(pin, samples=1) In this example simple ADC single pin acquisition and advanced multi sample ADC acquisition are reported. In ZERYNTH ADC is also available as builtin analogRead() with the same signature of adc.read(). analogRead() is available only for compatibility with the Arduino world and will be deprecated in future versions of ZERYNTH. tags: [First Steps,Analog Read ADC] groups:[First Steps] main.py ################################################################################ # Analog Read # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams # import the streams module import adc # import the adc driver # create a stream linked to the default serial port streams . serial () while True : # Basic usage of ADC for acquiring the analog signal from a pin value = adc . read ( A0 ) print ( \"One sample:\" , value ) # The complete definition of adc.read() is adc.read(pin, samples=1) # For an advanced usage of adc.read refer to the official Zerynth documentation #acquire 10 samples with default sampling period value2 = adc . read ( A0 , 10 ) print ( \"10 samples: \\n \" , value2 ) #acquire 3 samples from the first 4 analog pins of the board with default sampling period value3 = adc . read ([ A0 , A1 , A2 , A3 ], 3 ) print ( \"3 samples from A0, A1, A2 and A3: \\n \" , value3 ) print () sleep ( 300 ) ADC Analog to Digital Acquisition with Voltage Conversion \u00b6 This basic examples shows how to read an analog voltage from pin 0, converts it to the corresponding voltage, and prints the result to the serial monitor. To test it user can attach the center pin of a potentiometer to pin A0, and the other pins respectively to to +3.3V and GND. tags: [Analog Read ADC, Sensors, First Steps] groups:[First Steps] main.py ################################################################################ # Analog Read to Voltage # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams import adc # import the adc module #create a serial port stream with default parameters streams . serial () while True : #read the input on analog pin 0 sensor_value = adc . read ( A0 ) #convert the analog reading (which goes from 0 - 4095.0) to a voltage (0 - 3.3V): voltage = sensor_value * ( 3.3 / 4095.0 ) #print out the raw and converted values: print ( \"sensor raw value:\" , sensor_value , \"Voltage:\" , voltage ) sleep ( 300 ) ZERYNTH Oscilloscope \u00b6 Simple usage of the analog acquisition and of the Python smart print functions. The example shows how to print to the serial console the values read on an analog pin in a \"scope\" like graphicspretty way. tags: [First Steps, Analog Read ADC, Serial] groups:[First Steps] main.py ############################################################################### # Zerynth oscilloscope # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ############################################################################### import streams import adc streams . serial () while True : value = adc . read ( A4 ) conv = value * 80 // 4095 print ( \"|\" , \"#\" * conv , \" \" * ( 80 - conv ), \"|\" ) sleep ( 200 ) Serial Port Read/Write Basics \u00b6 Basic examples of read and write data through a serial port. In this example a serial port instance is created allowing use of various methods. tags:[Serial, First Steps] groups:[First Steps] main.py ################################################################################ # Serial Port Basics # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams # creates a serial port and name it \"s\" s = streams . serial () while True : print ( \"Write some chars on the serial port and terminate with \\\\ n (new line)\" ) line = s . readline () # read and return any single character available on the serial port until a \\n is found print ( \"You wrote:\" , line ) print () sleep ( 300 ) Sensor driven Multi-Blink \u00b6 This examples shows how to drive various behaviours taking as input an analog signal acquired through ADC fro driving three loop implemented as separated threads. In particular, the implemented scripts drives three LEDs at three different frequencies calculated on the basis of the acquired analog signal. The example is implemented using 4 threads that run in parallel. One thread is used for acquiring the analog signal and convert the acquired raw value in blinking frequencies usable by the LED driving threads. The other three threads are used to instantiate a generic blinking function that drive a PIN where a LED is connected. tags:[Multi-Thread, First Steps, Analog Read ADC] groups:[First Steps] main.py ################################################################################ # Sensor Driven Multi-Blink # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ # This example requires an analog sensor and three LEDs import streams import adc # create a serial port stream with default parameters streams . serial () # set the A1 pin as analog input and D8, D9, D10 as outputs to drive the LEDs. pinMode ( A1 , INPUT_ANALOG ) pinMode ( D10 , OUTPUT ) pinMode ( D9 , OUTPUT ) pinMode ( D8 , OUTPUT ) # creates two arrays for storing global variables to be used in the blinking threads freq = [ 1 , 1 , 1 ] pin = [ D8 , D9 , D10 ] # define the generic blinking function to be used for driving the LEDs # this function takes as input the index identifying the LED, then uses the global freq and pin arrays to dynamically drive the LEDs def blink ( Npin ): while True : digitalWrite ( pin [ Npin ], HIGH ) sleep ( freq [ Npin ]) digitalWrite ( pin [ Npin ], LOW ) sleep ( freq [ Npin ]) # define an analog sensor sampling function that acquires the raw data and converts it to the three LED frequencies def sampling (): global freq while True : value = adc . read ( A1 ) freq [ 0 ] = value // 10 freq [ 1 ] = freq [ 0 ] * 2 freq [ 2 ] = freq [ 0 ] * 4 sleep ( 50 ) # launch the four threads thread ( sampling ) thread ( blink , 0 ) thread ( blink , 1 ) thread ( blink , 2 ) # The main loop is used only for printing out at reasonable speed the calculated frequencies in term of waiting times while True : print ( \"Wait times are\" , freq ) sleep ( 500 ) Multi-Thread Basics \u00b6 This examples shows the basics of ZERYNTH multi-threading In ZERYNTH a thread require a function to be executed as input for the definition the same function can be instanced by various thread giving you the possibility to write very concise and readable code. In this example 4 threads are created as instances of the same function where different parameters are passed to the function when the thread is initialized Note that the while True main loop typical of imperative programming is not present in this code. ZERYNTH allows pure thread driven implementation! tags: [First Steps, Multi-Thread] groups:[First Steps] main.py ################################################################################ # Multi-Thread Basics # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams # create a serial port with default parameters streams . serial () # Define a function to be used in the various threads. # Parameters are passed to the function when the thread is created and then used in the thread loop. # To be continuously executed by a thread a function requires an infinite loop, # otherwise when the function terminates the thread is closed def threadfn ( number , delay ): while True : print ( \"I am the thread\" , number ) print ( \"I run every:\" , delay , \"msec\" ) print () # just add an empty line for console output readability sleep ( delay ) # create the various threads using the same function but passing different parameters thread ( threadfn , 1 , 500 ) thread ( threadfn , 2 , 1000 ) thread ( threadfn , 3 , 1300 ) thread ( threadfn , 4 , 800 ) Multi LEDs Blink with threads \u00b6 This examples shows how to use ZERYNTH threads for driving three LEDs with asymmetric and different blinking rates. Each Thread in ZERYNTH is a sort of separated and parallel process that runs autonomously on your board. With threads you can design your algorithm architecture assuming parallelism that is typical of high level programming languages. In this code a function is defined and then instanced by three threads creating a pool of parallel processes where three LEDs are driven at different frequencies. Moreover, thanks to Python argument passing, default values can be defined for function inputs. This way you can launch threads without specifying all the inputs required by the function, default values will fill the holes. In this case all the parameters following 'blink' are passed to the functions as arguments. thread(blink,pin,delayON,delayOFF) is equivalent to thread(blink(pin,delayON,delayOFF)). tags: [Multi-Thread, First Steps, Digital I/O] groups:[First Steps] main.py ################################################################################ # Multi-Blink # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ # Initialize the digital pins where the LEDs are connected as output pinMode ( D2 , OUTPUT ) pinMode ( D8 , OUTPUT ) pinMode ( D5 , OUTPUT ) # Define the 'blink' function to be used by the threads def blink ( pin , timeON = 100 , timeOFF = 100 ): # delayON and delayOFF are optional parameters, used as default # if not specified when you call the function while True : digitalWrite ( pin , HIGH ) # turn the LED ON by making the voltage HIGH sleep ( timeON ) # wait for timeON digitalWrite ( pin , LOW ) # turn the LED OFF by making the voltage LOW sleep ( timeOFF ) # wait for timeOFF # Create three threads that execute instances of the 'blink' function. thread ( blink , D2 ) # D2 is ON for 100 ms and OFF for 100 ms, the default values of delayON an delayOFF thread ( blink , D8 , 200 ) # D8 is ON for 200 ms and OFF for 100 ms, the default value of delayOFF thread ( blink , D5 , 500 , 200 ) # D5 is ON for 500 ms and OFF for 200 ms Serial Port Advanced \u00b6 Advanced example of using a serial port for writing and sending data The examples shows how to read the entire serial port buffer or how to read a defined number of chars from the buffer. Moreover is also shown how to read a buffer until a \\n newline terminator is found. tags:[Serial, First Steps] groups:[First Steps] main.py ################################################################################ # Serial Advanced # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams s = streams . serial () # Testing various serial port reading methods while True : print ( \"write some chars and send it to the board\" ) char = s . read () # read and return any single character available on the serial port one by one print ( \"This is the first char you wrote:\" , char ) print () # add a line space for improving the serial console ouput readability sleep ( 500 ) # waiting for the serial buffer to fill length = s . available () # check if data are available on the port and count them chars = s . read ( length ) # read all the bytes available in the buffer an return the bytearray print ( \"This are the other\" , length , \"chars you wrote:\" , chars ) print () # add a line space for improving the serial console view print ( \"write a line ending it with return or enter\" ) line = s . readline () # read until a line terminator \\n is found, then return a bytearray print ( \"This is the line you wrote:\" , line ) Input Capture Unit as PWM Analyzer \u00b6 This examples shows how to use the Input Capture Unit of the board MCU for analysing a PWM signal The PWM is generated on PIN13 in order to have a feedbakc on the board embedded LED PIN13 is also connected through a wire with PIN2 on which the ICU capture is activated An interrupt is also attached on a PIN where a button is connected for changing the PWM duty. Very Important: ICU and PWM are both timer powered embedded feature, it is impossible to run an ICU and a PWM on two pin controlled by the same timer channel. Please refer to the board pinout in order to select the proper pins for your board e.i: on a ST Nucleo this example use PWM2/1 for PIN13 and PWM\u2153 for PIN2 so we are using two diferent embedded timers (first number on the PEM pin descrition) Board setup: PIN13-----PIN2 (shortcut the pins) BTNPin----GND (connect a button between a pin and GND) tags: [First Steps, Input Capture Unit ICU, Interrupts, Analog Write PWM] groups:[First Steps] main.py ################################################################################ # Input Capture Unit as PWM Analyzer # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import pwm import icu import streams # create the serial port using default parameters streams . serial () # define a pin where a button is connected, you can use the Nucleo button pin as input or change it with any other digital pin available # this is the pin the button is connected to; for the various supported boards, Zerynth automatically translates it # to the board button. On Arduino DUE the user button isn't installed, so this line rises a compilation error. # On Arduino DUE, change it to the pin your button is connected to or comment this line (see below) buttonPin = BTN0 # define the ICU pin. D5 works with Arduino footprint boards while with Particle boards D0 can be used captPin = D5 . ICU # On Arduino like boards #captPin=D0.ICU # On Particle boards # define the PWM pin. D13 works with Arduino footprint boards (and is also connected to a LED) while with Particle boards A4 can be used pwmPin = D13 . PWM # On Arduino like boards #pwmPin=A4.PWM # On Particle boards # set the pin as input with PullUp, the button will be connected to ground pinMode ( buttonPin , INPUT_PULLUP ) # define a function for printing capture results on the serial port def print_results ( y ): print ( \"Time ON is:\" , y [ 0 ], \"micros\" ) print ( \"Time OFF is:\" , y [ 1 ], \"micros\" ) print ( \"Period is:\" , y [ 0 ] + y [ 1 ], \"micros\" ) print () # define a global variable for PWM duty cycle and turn on the PWM duty = 10 pwm . write ( pwmPin , 100 , duty , MICROS ) #pwm.write needs (pn, period, duty, time_unit) # define the function to be called for changing the PWM duty when the button is pressed def pwm_control (): global duty duty = duty + 10 if duty >= 100 : duty = 0 pwm . write ( pwmPin , 100 , duty , MICROS ) print ( \"Duty:\" , duty , \"millis\" ) # Attach an interrupt on the button pin waiting for signal going from high to low when the button is pressed. # pwm_control will be called when the interrupt is fired. # If you are on Arduino DUE and you haven't connected any button comment the following line # you will not change the PWM duty but you can still test the ICU capture onPinFall ( buttonPin , pwm_control ) while True : # start an icu capture to be triggered when the pin rise. # this routine acquires 10 steps (HIGH or LOW states) or terminates after 50000 micros # this is a blocking function x = icu . capture ( captPin , LOW_TO_HIGH , 10 , 50000 , MICROS ) print ( \"captured\" ) # x is a list of step durations in microseconds, pass it to the printing function and check the serial console print_results ( x ) sleep ( 1000 ) Timers Basics \u00b6 Basic example of use of the timer module for monitoring the time during the program execution. Timers can be used as alternative to the Arduino Millis(). tags=[First Steps, Timers] groups:[First Steps] main.py ################################################################################ # Timers Basics # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import timers import streams # create a serial port with default parameters streams . serial () # create a new timer t = timers . timer () # start the timer t . start () minutes = 0 while True : if t . get () >= 60000 : #check if 60 seconds are passed t . reset () #timer can be reset minutes += 1 seconds = t . get () // 1000 print ( \"time is:\" , minutes , \":\" , seconds ) #just print the current value since timer start or last reset print ( \"System time is:\" , timers . now (), \"(millis)\" ) #timers.now() gives the system time in milliseconds since program start print () sleep ( 500 ) #run every 500 millisec String Formatting \u00b6 Some example of Python string formatting with the modulo operator. main.py ################################################################################ # strformat # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams streams . serial () print ( \"Starting!\" ) sleep ( 1000 ) # a data tuple tt = ( \"string\" , - 21 , 15.23 , 32 ) # a data dictionary dd = { \"thing\" : \"string\" , \"number\" : 1 , \"float\" : 1.0 , \"hex\" : 32 } # let's format :) while True : try : # basic formatting print ( \" %% this is a %s , this is a %d , this is a %f , this is a %x , this is a %% \" % tt ) # named keys formatting print ( \" %% this is a %(thing)s , this is a %(number)d , this is a %(float)f , this is a %(hex)x , this is a %% \" % dd ) # width & precision print ( \" %s %8d %f %d \" % tt ) print ( \" %s %08.7d %f %d \" % tt ) # width & precision & left alignment & sign print ( \" %s %-010.9d %f %d \" % tt ) print ( \" %s %-010.9d %2.0f %d \" % tt ) print ( \" %s %-010.9d %2.5f %d \" % tt ) print ( \" %s %-010.9d %12.5f %d \" % tt ) print ( \" %s %-010.9d %-12.5f %d \" % tt ) print ( \" %s %-010.9d %012.15f %d \" % tt ) print ( \" %s %+010.9d %012.15f %d \" % tt ) print ( \" %s % 010.9d %012.15f %d \" % tt ) # width & precision for strings print ( \" %15.3s % 010.9d %012.15f %d \" % tt ) # variable width & precision print ( \" %x %3.*d \" % ( 123456 , 5 , 6 )) except Exception as e : print ( e ) sleep ( 5000 ) Serial Port Read/Write Basics \u00b6 Basic examples of read and write data through a serial port. In this example a serial port instance is created allowing use of various methods. tags:[Serial, First Steps] groups:[First Steps] main.py ################################################################################ # Serial Port Basics # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams # creates a serial port and name it \"s\" s = streams . serial () while True : print ( \"Write some chars on the serial port and terminate with \\\\ n (new line)\" ) line = s . readline () # read and return any single character available on the serial port until a \\n is found print ( \"You wrote:\" , line ) print () sleep ( 300 ) Serial Port Advanced \u00b6 Advanced example of using a serial port for writing and sending data The examples shows how to read the entire serial port buffer or how to read a defined number of chars from the buffer. Moreover is also shown how to read a buffer until a \\n newline terminator is found. tags:[Serial, First Steps] groups:[First Steps] main.py ################################################################################ # Serial Advanced # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams s = streams . serial () # Testing various serial port reading methods while True : print ( \"write some chars and send it to the board\" ) char = s . read () # read and return any single character available on the serial port one by one print ( \"This is the first char you wrote:\" , char ) print () # add a line space for improving the serial console ouput readability sleep ( 500 ) # waiting for the serial buffer to fill length = s . available () # check if data are available on the port and count them chars = s . read ( length ) # read all the bytes available in the buffer an return the bytearray print ( \"This are the other\" , length , \"chars you wrote:\" , chars ) print () # add a line space for improving the serial console view print ( \"write a line ending it with return or enter\" ) line = s . readline () # read until a line terminator \\n is found, then return a bytearray print ( \"This is the line you wrote:\" , line ) Digital Read Basics \u00b6 The basic definition of digitalRead() in ZERYNTH has the same behaviour of Arduino digitalRead(). In this example simple digitalRead use is reported tags: [First Steps,Digital Read ADC] groups:[First Steps] main.py ################################################################################ # Digital Read Basics # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams # create a serial port stream with default parameters streams . serial () # configure pin D5 in input mode pinMode ( D5 , INPUT_PULLUP ) # loop forever, printing the value of D5 while True : print ( digitalRead ( D5 )) sleep ( 500 ) Basic LED Blink \u00b6 The \"Hello World\" of embedded devices Just configure a digital pin as output driving it ON and OFF every sec to blink the attached LED. tags: [Digital I/O, First Steps] groups:[First Steps] main.py ############################################################################### # Led Blink # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ############################################################################### # D0 to D127 represent the names of digital pins # On most Arduino-like boards Pin D13 has an on-board LED connected. # However Zerynth abstracts the board layout allowing to use LED0, LED1, etc as led names. # In this example LED0 is used. pinMode ( LED0 , OUTPUT ) # loop forever while True : digitalWrite ( LED0 , HIGH ) # turn the LED ON by setting the voltage HIGH sleep ( 1000 ) # wait for a second digitalWrite ( LED0 , LOW ) # turn the LED OFF by setting the voltage LOW sleep ( 1000 ) # wait for a second ADC Analog to Digital Acquisition Basics \u00b6 The function for Analog to Digital convertion in ZERYNTH is adc.read() The complete definition is adc.read(pin, samples=1) In this example simple ADC single pin acquisition and advanced multi sample ADC acquisition are reported. In ZERYNTH ADC is also available as builtin analogRead() with the same signature of adc.read(). analogRead() is available only for compatibility with the Arduino world and will be deprecated in future versions of ZERYNTH. tags: [First Steps,Analog Read ADC] groups:[First Steps] main.py ################################################################################ # Analog Read # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams # import the streams module import adc # import the adc driver # create a stream linked to the default serial port streams . serial () while True : # Basic usage of ADC for acquiring the analog signal from a pin value = adc . read ( A0 ) print ( \"One sample:\" , value ) # The complete definition of adc.read() is adc.read(pin, samples=1) # For an advanced usage of adc.read refer to the official Zerynth documentation #acquire 10 samples with default sampling period value2 = adc . read ( A0 , 10 ) print ( \"10 samples: \\n \" , value2 ) #acquire 3 samples from the first 4 analog pins of the board with default sampling period value3 = adc . read ([ A0 , A1 , A2 , A3 ], 3 ) print ( \"3 samples from A0, A1, A2 and A3: \\n \" , value3 ) print () sleep ( 300 ) ADC Analog to Digital Acquisition with Voltage Conversion \u00b6 This basic examples shows how to read an analog voltage from pin 0, converts it to the corresponding voltage, and prints the result to the serial monitor. To test it user can attach the center pin of a potentiometer to pin A0, and the other pins respectively to to +3.3V and GND. tags: [Analog Read ADC, Sensors, First Steps] groups:[First Steps] main.py ################################################################################ # Analog Read to Voltage # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams import adc # import the adc module #create a serial port stream with default parameters streams . serial () while True : #read the input on analog pin 0 sensor_value = adc . read ( A0 ) #convert the analog reading (which goes from 0 - 4095.0) to a voltage (0 - 3.3V): voltage = sensor_value * ( 3.3 / 4095.0 ) #print out the raw and converted values: print ( \"sensor raw value:\" , sensor_value , \"Voltage:\" , voltage ) sleep ( 300 ) ZERYNTH Oscilloscope \u00b6 Simple usage of the analog acquisition and of the Python smart print functions. The example shows how to print to the serial console the values read on an analog pin in a \"scope\" like graphicspretty way. tags: [First Steps, Analog Read ADC, Serial] groups:[First Steps] main.py ############################################################################### # Zerynth oscilloscope # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ############################################################################### import streams import adc streams . serial () while True : value = adc . read ( A4 ) conv = value * 80 // 4095 print ( \"|\" , \"#\" * conv , \" \" * ( 80 - conv ), \"|\" ) sleep ( 200 ) Sensor driven Multi-Blink \u00b6 This examples shows how to drive various behaviours taking as input an analog signal acquired through ADC fro driving three loop implemented as separated threads. In particular, the implemented scripts drives three LEDs at three different frequencies calculated on the basis of the acquired analog signal. The example is implemented using 4 threads that run in parallel. One thread is used for acquiring the analog signal and convert the acquired raw value in blinking frequencies usable by the LED driving threads. The other three threads are used to instantiate a generic blinking function that drive a PIN where a LED is connected. tags:[Multi-Thread, First Steps, Analog Read ADC] groups:[First Steps] main.py ################################################################################ # Sensor Driven Multi-Blink # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ # This example requires an analog sensor and three LEDs import streams import adc # create a serial port stream with default parameters streams . serial () # set the A1 pin as analog input and D8, D9, D10 as outputs to drive the LEDs. pinMode ( A1 , INPUT_ANALOG ) pinMode ( D10 , OUTPUT ) pinMode ( D9 , OUTPUT ) pinMode ( D8 , OUTPUT ) # creates two arrays for storing global variables to be used in the blinking threads freq = [ 1 , 1 , 1 ] pin = [ D8 , D9 , D10 ] # define the generic blinking function to be used for driving the LEDs # this function takes as input the index identifying the LED, then uses the global freq and pin arrays to dynamically drive the LEDs def blink ( Npin ): while True : digitalWrite ( pin [ Npin ], HIGH ) sleep ( freq [ Npin ]) digitalWrite ( pin [ Npin ], LOW ) sleep ( freq [ Npin ]) # define an analog sensor sampling function that acquires the raw data and converts it to the three LED frequencies def sampling (): global freq while True : value = adc . read ( A1 ) freq [ 0 ] = value // 10 freq [ 1 ] = freq [ 0 ] * 2 freq [ 2 ] = freq [ 0 ] * 4 sleep ( 50 ) # launch the four threads thread ( sampling ) thread ( blink , 0 ) thread ( blink , 1 ) thread ( blink , 2 ) # The main loop is used only for printing out at reasonable speed the calculated frequencies in term of waiting times while True : print ( \"Wait times are\" , freq ) sleep ( 500 ) CAN Auto-baudrate \u00b6 This example shows how to use the CAN interface library and how to detect baudrate. main.py # CAN Auto-baudrate # Created at 2020-02-10 16:39:24.048614 from fortebit.polaris import polaris import can polaris . init () print ( \"CAN Bus Auto-Baudrate Example\" ) # Initialize CAN transceiver pinMode ( polaris . internal . PIN_CAN_STANDBY , OUTPUT ) digitalWrite ( polaris . internal . PIN_CAN_STANDBY , LOW ) sleep ( 100 ) def can_auto_baudrate (): print ( \"Start auto baudrate...\" ) for bps in ( 1000000 , 800000 , 500000 , 250000 , 125000 , 100000 , 50000 , 10000 ): print ( \"Try\" , bps , \"bps\" ) try : canbus = can . Can ( CAN0 , bps , options = can . OPTION_LISTEN_ONLY ) except Exception as e : print ( e ) continue try : canbus . add_filter ( 0 , 0 ) canbus . receive ( timeout = 500 ) print ( \"Found baudrate:\" , bps ) canbus . done () return bps except TimeoutError : pass except Exception as e : print ( e ) print ( \"Errors\" , canbus . get_errors ()) canbus . done () print ( \"Auto baudrate failed!\" ) return None bps = None while bps is None : bps = can_auto_baudrate () sleep ( 1000 ) print ( \"Start active listening at\" , bps , \"bps\" ) canbus = can . Can ( CAN0 , bps ) canbus . add_filter ( 0 , 0 ) while True : try : msg = canbus . receive () print ( \"ID\" , hex ( msg [ 0 ] & can . FRAME_EXT_MASK ), \"IDE\" ,( msg [ 0 ] & can . FRAME_EXT_FLAG ) != 0 , \"RTR\" ,( msg [ 0 ] & can . FRAME_RTR_FLAG ) != 0 , \"DLC\" , msg [ 1 ], \"DATA\" ,[ hex ( b ) for b in msg [ 2 ]]) except Exception as e : print ( e ) Can Bus Example \u00b6 This example shows how to use the CAN interface library. main.py # Can Bus Example # Created at 2019-12-17 16:21:55.938660 from fortebit.polaris import polaris import can polaris . init () print ( \"CAN Bus Auto-Baudrate Example\" ) # Initialize CAN transceiver pinMode ( polaris . internal . PIN_CAN_STANDBY , OUTPUT ) digitalWrite ( polaris . internal . PIN_CAN_STANDBY , LOW ) sleep ( 100 ) canbus = can . Can ( CAN0 , 500000 ) def can_rx ( timeout =- 1 ): print ( \"rx, listening...\" ) msg = canbus . receive ( timeout = timeout ) print ( \"ID\" , hex ( msg [ 0 ] & can . FRAME_EXT_MASK ), \"IDE\" ,( msg [ 0 ] & can . FRAME_EXT_FLAG ) != 0 , \"RTR\" ,( msg [ 0 ] & can . FRAME_RTR_FLAG ) != 0 , \"DLC\" , msg [ 1 ], \"DATA\" ,[ hex ( b ) for b in msg [ 2 ]]) def abort_rx (): sleep ( 1000 ) print ( \"abort rx\" ) canbus . abort_receive () sleep ( 500 ) print ( \"resume rx\" ) canbus . resume_receive () def abort_tx (): sleep ( 1000 ) print ( \"abort tx\" ) canbus . abort_transmit () sleep ( 500 ) print ( \"resume tx\" ) canbus . resume_transmit () f0 = canbus . add_filter ( 0 , 0 ) f1 = canbus . add_filter ( 0x123 | can . FRAME_EXT_FLAG , can . FRAME_EXT_MASK | can . FRAME_EXT_FLAG ) print ( \"Filters\" , f0 , f1 ) canbus . del_filter ( f0 ) f2 = canbus . add_filter ( 0x456 , can . FRAME_STD_MASK ) f3 = canbus . add_filter ( 0x88 | can . FRAME_RTR_FLAG , can . FRAME_STD_MASK | can . FRAME_RTR_FLAG ) print ( \"Filters\" , f1 , f2 , f3 ) print ( \"tx std data\" ) canbus . transmit ( 0x456 , 8 , b 'abcdefgh' ) print ( \"tx ext remote\" ) canbus . transmit ( 0x123 | can . FRAME_EXT_FLAG | can . FRAME_RTR_FLAG , 8 ) print ( \"Errors\" , canbus . get_errors ()) thread ( abort_rx ) try : can_rx () except Exception as e : print ( e ) sleep ( 1000 ) can_rx () canbus . done () # test standby/wakeup digitalWrite ( polaris . internal . PIN_CAN_STANDBY , HIGH ) sleep ( 100 ) sleeping = True def wakeup (): global sleeping if sleeping : sleeping = False onPinFall ( CANRX0 , None ) print ( \"CAN wakeup\" ) pinMode ( CANRX0 , INPUT_PULLUP ) onPinFall ( CANRX0 , wakeup ) print ( \"Going to sleep...\" ) while sleeping : sleep ( 10 ) digitalWrite ( polaris . internal . PIN_CAN_STANDBY , LOW ) canbus = can . Can ( CAN0 , 500000 ) f0 = canbus . add_filter ( 0 , 0 ) print ( \"Timeout rx 3s...\" ) try : can_rx ( timeout = 3000 ) except Exception as e : print ( e ) thread ( abort_tx ) id = 0 while id <= can . FRAME_STD_MASK : try : canbus . transmit (( id << 18 ) | can . FRAME_EXT_FLAG | can . FRAME_RTR_FLAG , id & 7 ) canbus . transmit ( id + 6 ,( id & 7 ) + 1 , b 'abcdefgh' ) except Exception as e : print ( e ) sleep ( 100 ) #sleep(50) id += 15 print ( \"Errors\" , canbus . get_errors ()) while True : can_rx () print ( \"Errors\" , canbus . get_errors ()) canbus . done () DAC Basic \u00b6 A simple example to introduce Dac features. main.py ################################################################################ # Dac Basic # # Created by Zerynth Team 2015 CC # Authors: L. Rizzello ################################################################################ import streams import adc # for analogRead import dac def readInput (): while True : print ( \"reading A1: \" , analogRead ( A1 )) sleep ( 500 ) streams . serial () pinMode ( A1 , INPUT ) # read input in a separate thread thread ( readInput ) my_dac = dac . DAC ( D8 . DAC ) my_dac . start () # circular mode: continuously repeat the input buffer my_dac . write ([ 100 , 200 , 900 , 800 ], 1000 , MILLIS , circular = True ) Buzzer Driven through PWM \u00b6 This example shows how to drive a buzzer using PWM. In the example a frequency ramp going from 100 Hz to 5 KHz is generated as drive. The frequency is converted in period to be used as input of the pwm.rite function that require period and pulse to be expressed in milli or micro seconds (measure unit can be selected as extra parameter of the pwm.write function). The PWM duty cycle is set to 50% driving the buzzer with a symmetric square wave. tags:[First Steps, Input Capture Unit ICU, Sound] groups:[First Steps] main.py ################################################################################ # Buzzer with PWM # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams import pwm #create a serial port stream with default parameters streams . serial () # the pin where the buzzer is attached to buzzerpin = D8 . PWM pinMode ( buzzerpin , OUTPUT ) #set buzzerpin to output mode frequency = 100 #define a variable to hold the played tone frequency while True : period = 1000000 // frequency #we are using MICROS so every sec is 1000000 of micros. // is the int division, pwm.write period doesn't accept floats print ( \"frequency is\" , frequency , \"Hz\" ) #set the period of the buzzer and the duty to 50% of the period pwm . write ( buzzerpin , period , period // 2 , MICROS ) # increment the frequency every loop frequency = frequency + 20 # reset period if frequency >= 5000 : frequency = 100 sleep ( 100 ) LED Fade \u00b6 This example shows hot to use PWM for fading a LED by changing the duty cycle in a for loop. main.py ################################################################################ # LED Fade # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ############################################################################### import pwm duty = 0 pinMode ( LED0 , OUTPUT ) # set the LED pin as output: while True : for i in range ( - 100 , 100 , 1 ): # create a loop for ranging the duty cycle from 0 to 100 MICROS duty = 100 - abs ( i ) pwm . write ( LED0 . PWM , 100 , duty , MICROS ) # set the pwm at the calculated duty with a fixed period of 100 MICROS sleep ( 10 ) # update the PWM every 10 millis Input Capture Unit as PWM Analyzer \u00b6 This examples shows how to use the Input Capture Unit of the board MCU for analysing a PWM signal The PWM is generated on PIN13 in order to have a feedbakc on the board embedded LED PIN13 is also connected through a wire with PIN2 on which the ICU capture is activated An interrupt is also attached on a PIN where a button is connected for changing the PWM duty. Very Important: ICU and PWM are both timer powered embedded feature, it is impossible to run an ICU and a PWM on two pin controlled by the same timer channel. Please refer to the board pinout in order to select the proper pins for your board e.i: on a ST Nucleo this example use PWM2/1 for PIN13 and PWM\u2153 for PIN2 so we are using two diferent embedded timers (first number on the PEM pin descrition) Board setup: PIN13-----PIN2 (shortcut the pins) BTNPin----GND (connect a button between a pin and GND) tags: [First Steps, Input Capture Unit ICU, Interrupts, Analog Write PWM] groups:[First Steps] main.py ################################################################################ # Input Capture Unit as PWM Analyzer # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import pwm import icu import streams # create the serial port using default parameters streams . serial () # define a pin where a button is connected, you can use the Nucleo button pin as input or change it with any other digital pin available # this is the pin the button is connected to; for the various supported boards, Zerynth automatically translates it # to the board button. On Arduino DUE the user button isn't installed, so this line rises a compilation error. # On Arduino DUE, change it to the pin your button is connected to or comment this line (see below) buttonPin = BTN0 # define the ICU pin. D5 works with Arduino footprint boards while with Particle boards D0 can be used captPin = D5 . ICU # On Arduino like boards #captPin=D0.ICU # On Particle boards # define the PWM pin. D13 works with Arduino footprint boards (and is also connected to a LED) while with Particle boards A4 can be used pwmPin = D13 . PWM # On Arduino like boards #pwmPin=A4.PWM # On Particle boards # set the pin as input with PullUp, the button will be connected to ground pinMode ( buttonPin , INPUT_PULLUP ) # define a function for printing capture results on the serial port def print_results ( y ): print ( \"Time ON is:\" , y [ 0 ], \"micros\" ) print ( \"Time OFF is:\" , y [ 1 ], \"micros\" ) print ( \"Period is:\" , y [ 0 ] + y [ 1 ], \"micros\" ) print () # define a global variable for PWM duty cycle and turn on the PWM duty = 10 pwm . write ( pwmPin , 100 , duty , MICROS ) #pwm.write needs (pn, period, duty, time_unit) # define the function to be called for changing the PWM duty when the button is pressed def pwm_control (): global duty duty = duty + 10 if duty >= 100 : duty = 0 pwm . write ( pwmPin , 100 , duty , MICROS ) print ( \"Duty:\" , duty , \"millis\" ) # Attach an interrupt on the button pin waiting for signal going from high to low when the button is pressed. # pwm_control will be called when the interrupt is fired. # If you are on Arduino DUE and you haven't connected any button comment the following line # you will not change the PWM duty but you can still test the ICU capture onPinFall ( buttonPin , pwm_control ) while True : # start an icu capture to be triggered when the pin rise. # this routine acquires 10 steps (HIGH or LOW states) or terminates after 50000 micros # this is a blocking function x = icu . capture ( captPin , LOW_TO_HIGH , 10 , 50000 , MICROS ) print ( \"captured\" ) # x is a list of step durations in microseconds, pass it to the printing function and check the serial console print_results ( x ) sleep ( 1000 ) ICU Capture IR Packets \u00b6 Basic example of use of the ICU feature for capturing IR signals acquired through an IR demodulator. main.py ################################################################################ # ICU Capture IR Packets # # Created by Zerynth Team 2015 CC # Authors: L. Rizzello, G. Baldi, D. Mazzei ################################################################################ import icu import streams import pwm streams . serial () # Set the pin the IR receiver is connected to. # In this example D2 is used: if you happen to have a TOI Shield on an Arduino compatible board # you are good to go. ir_pin = D2 . ICU # when you want to use a particular pin function, just use the dot notation def IR_capture (): while True : print ( \"Capturing...\" ) # Starts capturing from the icu configured pin. # The capture starts from a selected trigger (in this case capture will start when the pin first goes from # HIGH to LOW). # The max number of samples to be collected and a maximum time window are specified. # Play with max number and time window to fit your remote protocol. # The following values are for the NEC IR (used by LG) protocol x = icu . capture ( ir_pin , LOW , 67 , 68 , pull = HIGH ) print ( x , \" \\n captured n samples:\" , len ( x )) # captures in a different thread thread ( IR_capture ) while True : print ( \"alive!\" ) sleep ( 1000 ) Timers Basics \u00b6 Basic example of use of the timer module for monitoring the time during the program execution. Timers can be used as alternative to the Arduino Millis(). tags=[First Steps, Timers] groups:[First Steps] main.py ################################################################################ # Timers Basics # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import timers import streams # create a serial port with default parameters streams . serial () # create a new timer t = timers . timer () # start the timer t . start () minutes = 0 while True : if t . get () >= 60000 : #check if 60 seconds are passed t . reset () #timer can be reset minutes += 1 seconds = t . get () // 1000 print ( \"time is:\" , minutes , \":\" , seconds ) #just print the current value since timer start or last reset print ( \"System time is:\" , timers . now (), \"(millis)\" ) #timers.now() gives the system time in milliseconds since program start print () sleep ( 500 ) #run every 500 millisec Timers Advanced Use \u00b6 This example shows how ZERYNTH soft timers can be used to schedule functions execution. ZERYNTH timers can be used as program time counter through the timer.start attribute or as recursive callers through the timer.interval method that takes as input the elapsing interval and the function to be called. Moreover, it is also possible to activate a timer in one shot mode. In this case the function si called after the requested interval and then the timer stops tags: [Timers, First Steps] groups:[First Steps] main.py ################################################################################ # Timers Advanced Use # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import timers import streams # create a serial port with default parameters streams . serial () # create new timers tsec = timers . timer () tminute = timers . timer () tshoot = timers . timer () seconds = 0 minutes = 0 # define a function to call when the timer for seconds elapses def secondpassed (): global seconds seconds += 1 print ( seconds , \" seconds\" ) if seconds == 60 : seconds = 0 # define a function to call when the timer for minutes elapses def minutepassed (): global minutes minutes += 1 print ( minutes , \" minutes\" ) # define a function to call when the one shot timer elapses def shootpassed (): print ( \"1 second ago was 1:30\" ) # start the timers for minutes and seconds tsec . interval ( 1000 , secondpassed ) tminute . interval ( 60000 , minutepassed ) tsec . start () tminute . start () while True : if seconds == 30 and minutes == 1 : # do a check on passed time to trigger a oneshot timer tshoot . one_shot ( 1000 , shootpassed ) # this is a oneshot timer, it executes only one time print ( \"timer minutes runs since:\" , tminute . get (), \"timer seconds runs since:\" , tsec . get (), \"millisec\" ) #just print the current value since start or last reset sleep ( 2500 ) #run every 2500 millisec Multi-Thread Basics \u00b6 This examples shows the basics of ZERYNTH multi-threading In ZERYNTH a thread require a function to be executed as input for the definition the same function can be instanced by various thread giving you the possibility to write very concise and readable code. In this example 4 threads are created as instances of the same function where different parameters are passed to the function when the thread is initialized Note that the while True main loop typical of imperative programming is not present in this code. ZERYNTH allows pure thread driven implementation! tags: [First Steps, Multi-Thread] groups:[First Steps] main.py ################################################################################ # Multi-Thread Basics # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams # create a serial port with default parameters streams . serial () # Define a function to be used in the various threads. # Parameters are passed to the function when the thread is created and then used in the thread loop. # To be continuously executed by a thread a function requires an infinite loop, # otherwise when the function terminates the thread is closed def threadfn ( number , delay ): while True : print ( \"I am the thread\" , number ) print ( \"I run every:\" , delay , \"msec\" ) print () # just add an empty line for console output readability sleep ( delay ) # create the various threads using the same function but passing different parameters thread ( threadfn , 1 , 500 ) thread ( threadfn , 2 , 1000 ) thread ( threadfn , 3 , 1300 ) thread ( threadfn , 4 , 800 ) Multi LEDs Blink with threads \u00b6 This examples shows how to use ZERYNTH threads for driving three LEDs with asymmetric and different blinking rates. Each Thread in ZERYNTH is a sort of separated and parallel process that runs autonomously on your board. With threads you can design your algorithm architecture assuming parallelism that is typical of high level programming languages. In this code a function is defined and then instanced by three threads creating a pool of parallel processes where three LEDs are driven at different frequencies. Moreover, thanks to Python argument passing, default values can be defined for function inputs. This way you can launch threads without specifying all the inputs required by the function, default values will fill the holes. In this case all the parameters following 'blink' are passed to the functions as arguments. thread(blink,pin,delayON,delayOFF) is equivalent to thread(blink(pin,delayON,delayOFF)). tags: [Multi-Thread, First Steps, Digital I/O] groups:[First Steps] main.py ################################################################################ # Multi-Blink # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ # Initialize the digital pins where the LEDs are connected as output pinMode ( D2 , OUTPUT ) pinMode ( D8 , OUTPUT ) pinMode ( D5 , OUTPUT ) # Define the 'blink' function to be used by the threads def blink ( pin , timeON = 100 , timeOFF = 100 ): # delayON and delayOFF are optional parameters, used as default # if not specified when you call the function while True : digitalWrite ( pin , HIGH ) # turn the LED ON by making the voltage HIGH sleep ( timeON ) # wait for timeON digitalWrite ( pin , LOW ) # turn the LED OFF by making the voltage LOW sleep ( timeOFF ) # wait for timeOFF # Create three threads that execute instances of the 'blink' function. thread ( blink , D2 ) # D2 is ON for 100 ms and OFF for 100 ms, the default values of delayON an delayOFF thread ( blink , D8 , 200 ) # D8 is ON for 200 ms and OFF for 100 ms, the default value of delayOFF thread ( blink , D5 , 500 , 200 ) # D5 is ON for 500 ms and OFF for 200 ms Sensor driven Multi-Blink \u00b6 This examples shows how to drive various behaviours taking as input an analog signal acquired through ADC fro driving three loop implemented as separated threads. In particular, the implemented scripts drives three LEDs at three different frequencies calculated on the basis of the acquired analog signal. The example is implemented using 4 threads that run in parallel. One thread is used for acquiring the analog signal and convert the acquired raw value in blinking frequencies usable by the LED driving threads. The other three threads are used to instantiate a generic blinking function that drive a PIN where a LED is connected. tags:[Multi-Thread, First Steps, Analog Read ADC] groups:[First Steps] main.py ################################################################################ # Sensor Driven Multi-Blink # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ # This example requires an analog sensor and three LEDs import streams import adc # create a serial port stream with default parameters streams . serial () # set the A1 pin as analog input and D8, D9, D10 as outputs to drive the LEDs. pinMode ( A1 , INPUT_ANALOG ) pinMode ( D10 , OUTPUT ) pinMode ( D9 , OUTPUT ) pinMode ( D8 , OUTPUT ) # creates two arrays for storing global variables to be used in the blinking threads freq = [ 1 , 1 , 1 ] pin = [ D8 , D9 , D10 ] # define the generic blinking function to be used for driving the LEDs # this function takes as input the index identifying the LED, then uses the global freq and pin arrays to dynamically drive the LEDs def blink ( Npin ): while True : digitalWrite ( pin [ Npin ], HIGH ) sleep ( freq [ Npin ]) digitalWrite ( pin [ Npin ], LOW ) sleep ( freq [ Npin ]) # define an analog sensor sampling function that acquires the raw data and converts it to the three LED frequencies def sampling (): global freq while True : value = adc . read ( A1 ) freq [ 0 ] = value // 10 freq [ 1 ] = freq [ 0 ] * 2 freq [ 2 ] = freq [ 0 ] * 4 sleep ( 50 ) # launch the four threads thread ( sampling ) thread ( blink , 0 ) thread ( blink , 1 ) thread ( blink , 2 ) # The main loop is used only for printing out at reasonable speed the calculated frequencies in term of waiting times while True : print ( \"Wait times are\" , freq ) sleep ( 500 ) Queues \u00b6 Simple producer/consumer example based on thread safe queues. main.py ################################################################################ # Queues # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import threading import streams import queue streams . serial () # create a bounded queue q = queue . Queue ( maxsize = 20 ) # keep producing an element every 100 millis def producer ( id ): while True : try : x = random ( 0 , 100 ) print ( \"producer\" , id , \"->\" , x ) q . put ( x ) except Exception as e : print ( e ) sleep ( 100 ) # keep consuming an element every 1 second def consumer ( id ): while True : try : print ( \"consumer\" , id , \"<-\" , q . get ()) except Exception as e : print ( e ) sleep ( 1000 ) # start everyone thread ( producer , 0 ) thread ( consumer , 1 ) thread ( consumer , 2 ) while True : isfull = q . full () print ( \"Queue is full?\" , isfull ) if isfull : # clear queue if full print ( \"Clearing queue\" ) q . clear () sleep ( 5000 ) Interrupt Basics \u00b6 This example shows how to use interrupts for monitoring pin state changes. A button is used to connect a pin to ground when pressed. The pin is set as INPUT_PULLUP putting HIGH voltage on it while activated as digital input. It is possible to use onboard embedded button like in the case of ST Nucleo. Otherwise an external button can be connected to any digital pin available on the board and then to GND. In this case the pin number have to be changed with the pin used for connecting the button Note that the main loop (while True) is not present in this example. With ZERYNTH it is possible to write pure event driven code! tags: [First Steps, Interrupts, Digital I/O] groups:[First Steps] main.py ################################################################################ # Interrupt Basics # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams # create a serial port stream with default parameters streams . serial () # define where the button and the LED are connected # in this case BTN0 will be automatically configured according to the selected board button # change this definition to connect external buttons on any other digital pin buttonPin = BTN0 ledPin = LED0 # LED0 will be configured to the selected board led # configure the pin behaviour to drive the LED and to read from the button pinMode ( buttonPin , INPUT_PULLUP ) pinMode ( ledPin , OUTPUT ) # define the function to be called when the button is pressed def pressed (): print ( \"touched!\" ) digitalWrite ( ledPin , HIGH ) # just blink the LED for 100 millisec when the button is pressed sleep ( 100 ) digitalWrite ( ledPin , LOW ) # attach an interrupt on the button pin and call the pressed function when it falls # being BTN0 configured as pullup, when the button is pressed the signal goes to from HIGH to LOW. # opposite behaviour can be obtained with the equivalent \"rise\" interrupt function: onPinRise(pin,fun) # hint: onPinFall and onPinRise can be used together on the same pin, even with different functions onPinFall ( buttonPin , pressed ) Interrupt Advanced \u00b6 This example uses pwm to show the advanced feature of interrupt debouncing. PWM triggers fall and rise events at different speeds, but interrupts are triggered only if the debounce time (i.e. the stable time after and event) is in the correct range. main.py ################################################################################ # Interrupt Debounce # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ # import streams import streams # import pwm for testing import pwm # CONNECT pin D3 to PIN D2 for this example to work! streams . serial () def on_touch_up (): print ( \"touched UP\" ) def on_touch_dn (): print ( \"touched DN\" ) try : # D2 will call touch_up on rise and touch_dn on fall with different debounce times onPinRise ( D2 , on_touch_up , debounce = 500 ) onPinFall ( D2 , on_touch_dn , debounce = 300 ) except Exception as e : print ( e ) while True : for x in [ 100 , 200 , 300 , 400 , 500 , 600 , 700 , 800 , 900 ]: print ( \"--->\" , x , 1000 - x ) # start pwm on D3 with the current period pwm . write ( D3 . PWM , 1000 , x ) # now wait and check if debounce is working sleep ( 5000 ) Exceptions-Debugger Basic \u00b6 Basic example of how to use the ZERYNTH Exceptions class to monitor and analyze programs behavior without crashing the execution. The examples shows how a \"division by zero\" is identified in the code without causing any crash. In ZERYNTH exceptions reported on the IDE serial console can be opened and analyzed through the integrated debugger window. tags:[First Steps, Exceptions] groups:[First Steps] main.py ################################################################################ # Exception-Debugger Basics # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ############################################################################### import streams streams . serial () while True : for x in range ( - 10 , 10 , 1 ): # create a loop ranging on the integers between -10 and 10 try : # open the Exception monitoring scope value = 100 // x # when x=0 this will results in a DivisionByZero! print ( value ) except Exception as e : # capture any raised exception as e print ( e ) # print the content of e to monitor where the program is faulting # click on the console X icon to open the Zerynth debugger window sleep ( 1000 ) Math Module \u00b6 Some fun with math functions main.py ############################################################################### # Math module # # Created by Zerynth Team 2017 CC # Authors: G. Baldi ############################################################################### import streams import math streams . serial () while True : # loop over angles in degrees print ( \"---> TRIGONOMETRY!\" ) for angle in range ( 0 , 360 * 3 , 10 ): # convert to radians r = math . radians ( angle ) # take the sin s = math . sin ( r ) # calculate offset... sl = int ( 40 * s ) # ...and print! if sl >= 0 : print ( \" \" * 40 , \"#\" * sl ) else : print ( \" \" * ( 40 + sl ), \"#\" * ( - sl )) sleep ( 50 ) sleep ( 1000 ) # loop from -5 to 0 in 0.05 increments print ( \"---> EXPONENTIALS\" ) x = - 5 incr = 0.05 while x < 0 : # take the exp... y = math . exp ( x ) # ...and print! print ( \"#\" * int ( y * 80 )) # do not forget to increment x x = x + incr sleep ( 50 ) sleep ( 1000 ) print ( \"---> ROOTS and POWERS\" ) # loop from 1 to 100 print ( \" a | b | c | math.sqrt(a*a*+b*b)\" ) print ( \"----------------------------------------\" ) for i in range ( 0 , 100 ): # let's generate and test Pythagorean Triples! # select n and m m = 1 n = 0 while m >= n : n = random ( 1 , 30 ) m = random ( 1 , 30 ) a = math . pow ( n , 2 ) - math . pow ( m , 2 ) b = 2 * m * n c = math . pow ( n , 2 ) + math . pow ( m , 2 ) a2 = math . pow ( a , 2 ) b2 = math . pow ( b , 2 ) p = math . sqrt ( a2 + b2 ) print ( \" %4.0f | %4.0f | %4.0f | %4.0f \" % ( a , b , c , p )) sleep ( 100 ) sleep ( 1000 ) Mini Web Server \u00b6 This example implements a very minimal web server by opening a TCP socket in listening mode, reading HTTP headers and sending out some HTML. It prints the IP to connect to in the serial console. Type it in your browser and test your mini web server! It uses the CC3000 wireless driver, however any network driver can be used changing only a few lines of code. main.py ############################################################################### # Mini Web Server # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ############################################################################### # import streams & socket import streams import socket # import the wifi interface from wireless import wifi # the wifi module needs a networking driver to be loaded # in order to control the board hardware. # FOR THIS EXAMPLE TO WORK, A NETWORK DRIVER MUST BE SELECTED BELOW # uncomment the following line to use the CC3000 driver (Particle Core or CC3000 Wifi shields) # from texas.cc3000 import cc3000 as wifi_driver # uncomment the following line to use the BCM43362 driver (Particle Photon) # from broadcom.bcm43362 import bcm43362 as wifi_driver streams . serial () # init the wifi driver! # The driver automatically registers itself to the wifi interface # with the correct configuration for the selected board wifi_driver . auto_init () # use the wifi interface to link to the Access Point # change network name, security and password as needed print ( \"Establishing Link...\" ) try : # FOR THIS EXAMPLE TO WORK, \"Network-Name\" AND \"Wifi-Password\" MUST BE SET # TO MATCH YOUR ACTUAL NETWORK CONFIGURATION wifi . link ( \"Network-Name\" , wifi . WIFI_WPA2 , \"Wifi-Password\" ) except Exception as e : print ( \"ooops, something wrong while linking :(\" , e ) while True : sleep ( 1000 ) # Yes! we are connected print ( \"Linked!\" ) # Let's print our ip, it will be needed soon info = wifi . link_info () print ( \"My IP is:\" , info [ 0 ]) # Now let's create a socket and listen for incoming connections on port 80 sock = socket . socket () sock . bind ( 80 ) sock . listen () while True : try : # Type in your browser the board ip! print ( \"Waiting for connection...\" ) # here we wait for a connection clientsock , addr = sock . accept () print ( \"Incoming connection from\" , addr ) # yes! a connection is ready to use # first let's create a SocketStream # it's like a serial stream, but with a socket underneath. # This way we can read and print to the socket client = streams . SocketStream ( clientsock ) # let's read all the HTTP headers from the browser # stop when a blank line is received line = client . readline () while line != \" \\n \" and line != \" \\r\\n \" : line = client . readline () print ( \"HTTP request received!\" ) # let's now send our headers (very minimal) # hint: \\n is added by print print ( \"HTTP/1.1 200 OK \\r \" , stream = client ) print ( \"Content-Type: text/html \\r \" , stream = client ) print ( \"Connection: close \\r\\n\\r \" , stream = client ) # see? as easy as print! print ( \"<html><body>Hello Zerynth!\" , random ( 0 , 100 ), \"</body></html>\" , stream = client ) # close connection and go waiting for another one client . close () except Exception as e : print ( \"ooops, something wrong:\" , e ) ZERYNTH UDP pinger \u00b6 This example demonstrates the use of UDP sockets. A writer thread sends UDP broadcast packets while a reader threads catches them. Uplink this script on more than one board for some pinger fun! main.py ################################################################################ # Zerynth UDP pinger # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ # import streams & socket import streams import socket # import the wifi interface from wireless import wifi # the wifi module needs a networking driver to be loaded # in order to control the board hardware. # FOR THIS EXAMPLE TO WORK, A NETWORK DRIVER MUST BE SELECTED BELOW # uncomment the following line to use the CC3000 driver (Particle Core or CC3000 Wifi shields) # from texas.cc3000 import cc3000 as wifi_driver # uncomment the following line to use the BCM43362 driver (Particle Photon) # from broadcom.bcm43362 import bcm43362 as wifi_driver streams . serial () # init the wifi driver! # The driver automatically registers itself to the wifi interface # with the correct configuration for the selected board wifi_driver . auto_init () # use the wifi interface to link to the Access Point # change network name, security and password as needed print ( \"Establishing Link...\" ) try : # FOR THIS EXAMPLE TO WORK, \"Network-Name\" AND \"Wifi-Password\" MUST BE SET # TO MATCH YOUR ACTUAL NETWORK CONFIGURATION wifi . link ( \"Network-Name\" , wifi . WIFI_WPA2 , \"Wifi-Password\" ) # get our ip myip = wifi . link_info ()[ 0 ] # convert myip to a tuple with the socket.ip_to_tuple function # \"x.y.z.w\" becomes (x,y,z,w) ip_tuple = socket . ip_to_tuple ( myip ) # generate a broadcast address to port 9999 # (it's ok and easier to generate it as a 5 number tuple) broadcast = ( ip_tuple [ 0 ], ip_tuple [ 1 ], ip_tuple [ 2 ], 255 , 9999 ) print ( myip , ip_tuple , broadcast ) # create an UDP socket and bind it to port 9999 sock = socket . socket ( type = socket . SOCK_DGRAM ) sock . bind ( 9999 ) except Exception as e : print ( \"ooops, something wrong while linking :(\" , e ) while True : sleep ( 1000 ) # this function will be used as a thread # sending every 2 seconds a message to all # the udp sockets listening on port 9999 def ping (): while True : print ( \"Sending\" ) sock . sendto ( \"Hello Zerynth!\" , broadcast ) sleep ( 2000 ) # launch it! thread ( ping ) # in the main thread we listen for incoming udp packets while True : print ( \"Receiving pings\" ) try : # recvfrom returns both the packet data and the address of the sender data , address = sock . recvfrom ( 32 ) # since we bind to 9999 we also receive the packets we sent # check for it by comparing just the ip address (without the port) if address [ 0 ] != myip : print ( \"Received ping from\" , address , \"=>\" , str ( data )) else : print ( \"Received ping from myself!\" ) except Exception as e : print ( e ) # uplink this script to more than one board and check UDP NTP Time \u00b6 This example uses UDP socket to make client requests to an NTP server. The received timestamp is printed on the serial console in a human-readable form. main.py # UDP NTP Time # Created at 2019-02-19 08:07:55.144570 import streams import socket # import the wifi interface from wireless import wifi # the wifi module needs a networking driver to be loaded # in order to control the board hardware. # This example can be used as is with ESP32 based devices from espressif.esp32net import esp32wifi as wifi_driver def ntc_ts_to_datetime ( t ): # convert NTP timestamp (seconds since January 1st 1900) to datetime formatted string # YYYY-mm-dd HH:MM:SS ts = t - 2208988800 s = ts % 60 ts //= 60 m = ts % 60 ts //= 60 h = ts % 24 ts //= 24 a = ( 4 * ts + 102032 ) // 146097 + 15 b = ( ts + 2442113 + a - ( a // 4 )) c = ( 20 * b - 2442 ) // 7305 d = b - 365 * c - ( c // 4 ) e = d * 1000 // 30601 f = d - e * 30 - e * 601 // 1000 if e <= 13 : c -= 4716 e -= 1 else : c -= 4715 e -= 13 Y = c M = e D = f return \" %d - %02d - %02d %02d : %02d : %02d \" % ( Y , M , D , h , m , s ) try : streams . serial () # init the wifi driver! # The driver automatically registers itself to the wifi interface # with the correct configuration for the selected board wifi_driver . auto_init () # use the wifi interface to link to the Access Point # change network name, security and password as needed print ( \"Establishing WiFi Link...\" ) for retry in range ( 5 ): try : # FOR THIS EXAMPLE TO WORK, \"Network-Name\" AND \"Wifi-Password\" MUST BE SET # TO MATCH YOUR ACTUAL NETWORK CONFIGURATION wifi . link ( \"Network-Name\" , wifi . WIFI_WPA2 , \"Wifi-Password\" ) print ( \"...done!\" ) break except Exception as e : pass else : print ( \":( can't connect to wifi\" ) raise IOError # create an UDP socket and set a timeout of 1 second sock = socket . socket ( type = socket . SOCK_DGRAM ) sock . settimeout ( 1000 ) # create an NTP request packet pkt = bytearray ([ 0 ] * 48 ) pkt [ 0 ] = 0x1B while True : try : # resolve the NTP server hostname to get its IP address ip_string = wifi . gethostbyname ( \"0.pool.ntp.org\" ) ip = socket . ip_to_tuple ( ip_string ) # create a tuple containing NTP server ip address and port addr = ( ip [ 0 ], ip [ 1 ], ip [ 2 ], ip [ 3 ], 123 ) print ( \"Sending NTP request to %s : %d \" % ( ip_string , 123 )) # send the NTP request packet to the NTP server sock . sendto ( pkt , addr ) # read the response from the server res = sock . recv ( 48 ) # extract the \"transmit timestamp\" field from the received packet ts = ( res [ 40 ] << 24 ) | ( res [ 41 ] << 16 ) | ( res [ 42 ] << 8 ) | res [ 43 ] # convert NTP timestamp to human readable datetime print ( \" >\" , ntc_ts_to_datetime ( ts )) print ( \" \" ) except Exception as e : print ( \" >\" , e ) sleep ( 10000 ) except Exception as e : print ( e ) ZERYNTH wifi scan \u00b6 This example explains how to scan for wifi networks. main.py ################################################################################ # Zerynth wifi scan # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ # import streams & socket import streams import socket # import the wifi interface from wireless import wifi # the wifi module needs a networking driver to be loaded # in order to control the board hardware. # FOR THIS EXAMPLE TO WORK, A NETWORK DRIVER MUST BE SELECTED BELOW # uncomment the following line to use the CC3000 driver (Particle Core or CC3000 Wifi shields) # from texas.cc3000 import cc3000 as wifi_driver # uncomment the following line to use the BCM43362 driver (Particle Photon) # from broadcom.bcm43362 import bcm43362 as wifi_driver streams . serial () # init the wifi driver! # The driver automatically registers itself to the wifi interface # with the correct configuration for the selected board wifi_driver . auto_init () # a list of security strings wifi_sec = [ \"Open\" , \"WEP\" , \"WPA\" , \"WPA2\" ] try : print ( \"Scanning for 15 seconds...\" ) # start scanning for 15000 milliseconds res = wifi . scan ( 15000 ) # if everything goes well, res is a sequence of tuples # each tuple contains: # -ssid: the name of the network # -sec: the security type of the network, from 0 to 3 # -rssi: the strength of the signal, from 0 to 127 # -bssid: the mac address of the access point for ssid , sec , rssi , bssid in res : print ( ssid , \"::\" , wifi_sec [ sec ], \":: strength \" , rssi * 100 / 127 ) except Exception as e : print ( e ) ZERYNTH Time API \u00b6 This example connects via HTTP to timeapi.org to get the current UTC time main.py ################################################################################ # Zerynth Time API # # Created: 2015-08-17 16:44:58.640097 # ################################################################################ # import streams import streams import json # import the wifi interface from wireless import wifi # import the http module import requests # the wifi module needs a networking driver to be loaded # in order to control the board hardware. # THIS EXAMPLE IS SET TO WORK WITH BCM43362 WIFI DRIVER # uncomment the following line to use the espressif esp8266 wifi driver (NodeMcu v2, Adafruit Feather Huzzah, Wemos d1 Mini, ...) # from espressif.esp8266wifi import esp8266wifi as wifi_driver # uncomment the following line to use the BCM43362 driver (Particle Photon) from broadcom.bcm43362 import bcm43362 as wifi_driver # uncomment the following line to use the ESP32 driver (Sparkfun Esp32 Thing, Olimex Esp32, ...) # from espressif.esp32net import esp32wifi as wifi_driver streams . serial () # init the wifi driver! # The driver automatically registers itself to the wifi interface # with the correct configuration for the selected board wifi_driver . auto_init () # use the wifi interface to link to the Access Point # change network name, security and password as needed print ( \"Establishing Link...\" ) try : # FOR THIS EXAMPLE TO WORK, \"Network-Name\" AND \"Wifi-Password\" MUST BE SET # TO MATCH YOUR ACTUAL NETWORK CONFIGURATION wifi . link ( \"Network-Name\" , wifi . WIFI_WPA2 , \"Wifi-Password\" ) except Exception as e : print ( \"ooops, something wrong while linking :(\" , e ) while True : sleep ( 1000 ) ## let's try to connect to timeapi.org to get the current UTC time for i in range ( 3 ): try : print ( \"Trying to connect...\" ) # go get that time! # url resolution and http protocol handling are hidden inside the requests module response = requests . get ( \"http://now.zerynth.com/\" ) # let's check the http response status: if different than 200, something went wrong print ( \"Http Status:\" , response . status ) # if we get here, there has been no exception, exit the loop break except Exception as e : print ( e ) try : # check status and print the result #if response.status==200: print ( \"Success!!\" ) print ( \"-------------\" ) print ( \"And the result is:\" , response . content ) print ( \"-------------\" ) js = json . loads ( response . content ) print ( \"Date:\" , js [ \"now\" ][ \"rfc2822\" ][: 16 ]) print ( \"Time:\" , js [ \"now\" ][ \"rfc2822\" ][ 17 :]) except Exception as e : print ( \"ooops, something very wrong! :(\" , e ) ZERYNTH Weather \u00b6 This example connects to openweathermap.org, queries for weather conditions and prints the result. main.py ################################################################################ # Zerynth Weather # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ # import streams & socket import streams import socket # import json parser, will be needed later import json # import the wifi interface from wireless import wifi # import the http module import requests # the wifi module needs a networking driver to be loaded # in order to control the board hardware. # THIS EXAMPLE IS SET TO WORK WITH ESP8266 WIFI DRIVER # uncomment the following line to use the espressif esp8266 wifi driver (NodeMcu v2, Adafruit Feather Huzzah, Wemos d1 Mini, ...) from espressif.esp8266wifi import esp8266wifi as wifi_driver # uncomment the following line to use the BCM43362 driver (Particle Photon) # from broadcom.bcm43362 import bcm43362 as wifi_driver # uncomment the following line to use the ESP32 driver (Sparkfun Esp32 Thing, Olimex Esp32, ...) # from espressif.esp32net import esp32wifi as wifi_driver streams . serial () # init the wifi driver! # The driver automatically registers itself to the wifi interface # with the correct configuration for the selected board wifi_driver . auto_init () # use the wifi interface to link to the Access Point # change network name, security and password as needed print ( \"Establishing Link...\" ) try : # FOR THIS EXAMPLE TO WORK, \"Network-Name\" AND \"Wifi-Password\" MUST BE SET # TO MATCH YOUR ACTUAL NETWORK CONFIGURATION wifi . link ( \"Network-Name\" , wifi . WIFI_WPA2 , \"Wifi-Password\" ) except Exception as e : print ( \"ooops, something wrong while linking :(\" , e ) while True : sleep ( 1000 ) # let's try to connect to openweathermap.org to get some weather info # for this example to work you need a openweathermap API key # if you don't have one, you can get one for free here: http://openweathermap.org/price # type here your API key! # or you can use ours...however, if our calls quota is exceded # the example won't work :( api_key = \"bd4ba90e2b397e24a925e436a9d8fed9\" for i in range ( 3 ): try : print ( \"Trying to connect...\" ) # to get weather info you need to specify a correct api url # there are a lot of different urls with different functions # they are all documented here http://openweathermap.org/api # let's put the http query parameters in a dict params = { \"APPID\" : api_key , \"q\" : \"Pisa\" # <----- here it goes your city } # the following url gets weather information in json based on the name of the city url = \"http://api.openweathermap.org/data/2.5/weather\" # url resolution and http protocol handling are hidden inside the requests module response = requests . get ( url , params = params ) # if we get here, there has been no exception, exit the loop break except Exception as e : print ( e ) try : # check status and print the result if response . status == 200 : print ( \"Success!!\" ) print ( \"-------------\" ) # it's time to parse the json response js = json . loads ( response . content ) # super easy! print ( \"Weather:\" , js [ \"weather\" ][ 0 ][ \"description\" ], js [ \"main\" ][ \"temp\" ] - 273 , \"degrees\" ) print ( \"-------------\" ) except Exception as e : print ( \"ooops, something very wrong! :(\" , e ) HTTP Methods \u00b6 This example connects via HTTP to httpbin.org and tests each Zerynth supported HTTP method main.py ################################################################################ # Zerynth HTTP Methods # # Created: 2017-09-19 12:35:25.155721 # Authors: M. Cipriani ################################################################################ # import streams import streams import json # import the wifi interface from wireless import wifi # import the http module import requests # the wifi module needs a networking driver to be loaded # in order to control the board hardware. # THIS EXAMPLE IS SET TO WORK WITH ESP32 WIFI DRIVER # uncomment the following line to use the espressif esp8266 wifi driver (NodeMcu v2, Adafruit Feather Huzzah, Wemos d1 Mini, ...) # from espressif.esp8266wifi import esp8266wifi as wifi_driver # uncomment the following line to use the BCM43362 driver (Particle Photon) # from broadcom.bcm43362 import bcm43362 as wifi_driver # uncomment the following line to use the ESP32 driver (Sparkfun Esp32 Thing, Olimex Esp32, ...) from espressif.esp32net import esp32wifi as wifi_driver streams . serial () # init the wifi driver! # The driver automatically registers itself to the wifi interface # with the correct configuration for the selected board wifi_driver . auto_init () # use the wifi interface to link to the Access Point # change network name, security and password as needed print ( \"Establishing Link...\" ) try : # FOR THIS EXAMPLE TO WORK, \"Network-Name\" AND \"Wifi-Password\" MUST BE SET # TO MATCH YOUR ACTUAL NETWORK CONFIGURATION wifi . link ( \"Zerynth\" , wifi . WIFI_WPA2 , \"zerynthwifi\" ) except Exception as e : print ( \"ooops, something wrong while linking :(\" , e ) while True : sleep ( 1000 ) url = \"http://httpbin.org/\" tests = [ { \"title\" : \"Testing GET Method...\" , \"method\" : requests . get , \"url\" : url + \"get\" , \"params\" : { \"test\" : \"query_string\" } }, { \"title\" : \"Testing POST Method...\" , \"method\" : requests . post , \"url\" : url + \"post\" , \"json\" : { \"test\" : \"json_data\" } }, { \"title\" : \"Testing PUT Method...\" , \"method\" : requests . put , \"url\" : url + \"put\" , \"data\" : { \"test\" : \"urlencoded_data\" } }, { \"title\" : \"Testing PATCH Method...\" , \"method\" : requests . patch , \"url\" : url + \"patch\" , \"data\" : { \"test\" : \"urlencoded_data\" } }, { \"title\" : \"Testing DELETE Method...\" , \"method\" : requests . delete , \"url\" : url + \"delete\" , }, { \"title\" : \"Testing HEAD Method...\" , \"method\" : requests . head , \"url\" : url + \"get\" , }, { \"title\" : \"Testing OPTIONS Method...\" , \"method\" : requests . options , \"url\" : url + \"get\" , } ] print ( \"---------------------------------\" ) for test in tests : try : print ( test [ \"title\" ]) if \"params\" in test : response = test [ \"method\" ]( test [ \"url\" ], params = test [ \"params\" ]) elif \"json\" in test : response = test [ \"method\" ]( test [ \"url\" ], json = test [ \"json\" ]) elif \"data\" in test : response = test [ \"method\" ]( test [ \"url\" ], data = test [ \"data\" ]) else : response = test [ \"method\" ]( test [ \"url\" ]) print ( \"Http Status:\" , response . status ) print ( \"Http Headers:\" , response . headers ) print ( \"Http Content:\" , response . content ) print ( \"---------------------------------\" ) response = None except Exception as e : print ( e ) sleep ( 2000 ) Secure HTTP \u00b6 This example connects to https://howsmyssl.com/a/check and displays info about the SSL/TLS connection main.py ################################################################################ # Zerynth Secure Sockets # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams import json # import the wifi interface from wireless import wifi # import the http module import requests import ssl # the wifi module needs a networking driver to be loaded # in order to control the board hardware. # This example can be used as is with ESP32 based devices from espressif.esp32net import esp32wifi as wifi_driver streams . serial () # init the wifi driver! # The driver automatically registers itself to the wifi interface # with the correct configuration for the selected board wifi_driver . auto_init () # use the wifi interface to link to the Access Point # change network name, security and password as needed print ( \"Establishing Link...\" ) try : # FOR THIS EXAMPLE TO WORK, \"Network-Name\" AND \"Wifi-Password\" MUST BE SET # TO MATCH YOUR ACTUAL NETWORK CONFIGURATION wifi . link ( \"Network-Name\" , wifi . WIFI_WPA2 , \"Wifi-Password\" ) except Exception as e : print ( \"ooops, something wrong while linking :(\" , e ) while True : sleep ( 1000 ) # let's try to connect to https://www.howsmyssl.com/a/check to get some info # on the SSL/TLS connection # retrieve the CA certificate used to sign the howsmyssl.com certificate cacert = __lookup ( SSL_CACERT_DST_ROOT_CA_X3 ) # create a SSL context to require server certificate verification ctx = ssl . create_ssl_context ( cacert = cacert , options = ssl . CERT_REQUIRED | ssl . SERVER_AUTH ) # NOTE: if the underlying SSL driver does not support certificate validation # uncomment the following line! # ctx = None for i in range ( 3 ): try : print ( \"Trying to connect...\" ) url = \"https://www.howsmyssl.com/a/check\" # url resolution and http protocol handling are hidden inside the requests module user_agent = { \"User-Agent\" : \"curl/7.53.1\" , \"Accept\" : \"*/*\" } # pass the ssl context together with the request response = requests . get ( url , headers = user_agent , ctx = ctx ) # if we get here, there has been no exception, exit the loop break except Exception as e : print ( e ) try : # check status and print the result if response . status == 200 : print ( \"Success!!\" ) print ( \"-------------\" ) # it's time to parse the json response js = json . loads ( response . content ) # super easy! for k , v in js . items (): if k == \"given_cipher_suites\" : print ( \"Supported Ciphers\" ) for cipher in v : print ( cipher ) print ( \"-----\" ) else : print ( k , \"::\" , v ) print ( \"-------------\" ) except Exception as e : print ( \"ooops, something very wrong! :(\" , e ) NTPClient \u00b6 A simple example showing how to obtain a timestamp from an NTP server and how to convert it to UTC datetime. main.py ################################################################################ # NTPClient using UDP # # Created: 2019-06-16 # Author: L. Marsicano ################################################################################ import streams import ntpclient streams . serial () # import the wifi interface from wireless import wifi # the wifi module needs a networking driver to be loaded # in order to control the board hardware. # This example can be used as is with ESP32 based devices from espressif.esp32net import esp32wifi as wifi_driver def ntc_ts_to_datetime ( t ): ts = t - 2208988800 s = ts % 60 ts //= 60 m = ts % 60 ts //= 60 h = ts % 24 ts //= 24 a = ( 4 * ts + 102032 ) // 146097 + 15 b = ( ts + 2442113 + a - ( a // 4 )) c = ( 20 * b - 2442 ) // 7305 d = b - 365 * c - ( c // 4 ) e = d * 1000 // 30601 f = d - e * 30 - e * 601 // 1000 if e <= 13 : c -= 4716 e -= 1 else : c -= 4715 e -= 13 Y = c M = e D = f return \" %d - %02d - %02d %02d : %02d : %02d \" % ( Y , M , D , h , m , s ) try : wifi_driver . auto_init () for i in range ( 0 , 5 ): try : # Change this line to match your network configuration wifi . link ( \"SSID\" , wifi . WIFI_WPA2 , \"PASSWORD\" ) break except Exception as e : print ( e ) sleep ( 500 ) else : print ( \"Could not link :(\" ) raise IOError client = ntpclient . NTPClient ( wifi_driver ) t = client . get_time () print ( \"Time is\" , t ) print ( \"Converted time is:\" , ntc_ts_to_datetime ( t )) except Exception as e : print ( e ) Secure HTTP \u00b6 This example connects to https://howsmyssl.com/a/check and displays info about the SSL/TLS connection main.py ################################################################################ # Zerynth Secure Sockets # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams import json # import the wifi interface from wireless import wifi # import the http module import requests import ssl # the wifi module needs a networking driver to be loaded # in order to control the board hardware. # This example can be used as is with ESP32 based devices from espressif.esp32net import esp32wifi as wifi_driver streams . serial () # init the wifi driver! # The driver automatically registers itself to the wifi interface # with the correct configuration for the selected board wifi_driver . auto_init () # use the wifi interface to link to the Access Point # change network name, security and password as needed print ( \"Establishing Link...\" ) try : # FOR THIS EXAMPLE TO WORK, \"Network-Name\" AND \"Wifi-Password\" MUST BE SET # TO MATCH YOUR ACTUAL NETWORK CONFIGURATION wifi . link ( \"Network-Name\" , wifi . WIFI_WPA2 , \"Wifi-Password\" ) except Exception as e : print ( \"ooops, something wrong while linking :(\" , e ) while True : sleep ( 1000 ) # let's try to connect to https://www.howsmyssl.com/a/check to get some info # on the SSL/TLS connection # retrieve the CA certificate used to sign the howsmyssl.com certificate cacert = __lookup ( SSL_CACERT_DST_ROOT_CA_X3 ) # create a SSL context to require server certificate verification ctx = ssl . create_ssl_context ( cacert = cacert , options = ssl . CERT_REQUIRED | ssl . SERVER_AUTH ) # NOTE: if the underlying SSL driver does not support certificate validation # uncomment the following line! # ctx = None for i in range ( 3 ): try : print ( \"Trying to connect...\" ) url = \"https://www.howsmyssl.com/a/check\" # url resolution and http protocol handling are hidden inside the requests module user_agent = { \"User-Agent\" : \"curl/7.53.1\" , \"Accept\" : \"*/*\" } # pass the ssl context together with the request response = requests . get ( url , headers = user_agent , ctx = ctx ) # if we get here, there has been no exception, exit the loop break except Exception as e : print ( e ) try : # check status and print the result if response . status == 200 : print ( \"Success!!\" ) print ( \"-------------\" ) # it's time to parse the json response js = json . loads ( response . content ) # super easy! for k , v in js . items (): if k == \"given_cipher_suites\" : print ( \"Supported Ciphers\" ) for cipher in v : print ( cipher ) print ( \"-----\" ) else : print ( k , \"::\" , v ) print ( \"-------------\" ) except Exception as e : print ( \"ooops, something very wrong! :(\" , e ) RTC Keep Time \u00b6 This example downloads a time reference for the Real-Time Clock from the Internet and retrieves updated time from the RTC itself for subsequent use. main.py ################################################################################ # RTC Keep Time # # Created by Zerynth Team 2018 CC # Authors: G. Baldi, L. Rizzello ################################################################################ import streams import json import requests from wireless import wifi # import a wifi driver to connect and retrieve base timestamp from espressif.esp32net import esp32wifi as wifi_driver # import Real-Time Clock module import rtc def get_epoch (): user_agent = { \"user-agent\" : \"curl/7.56.0\" } return int ( json . loads ( requests . get ( \"http://now.zerynth.com/\" , headers = user_agent ) . content )[ 'now' ][ 'epoch' ]) streams . serial () wifi_driver . auto_init () print ( 'connecting to wifi...' ) try : wifi . link ( \"SSID\" , wifi . WIFI_WPA2 , \"PSW\" ) except Exception as e : print ( \"ooops, something wrong while linking :(\" , e ) while True : sleep ( 1000 ) timestamp = get_epoch () rtc . set_utc ( timestamp ) while True : tm = rtc . get_utc () print ( tm . tv_seconds ) print ( tm . tm_year , '/' , tm . tm_month , '/' , tm . tm_mday , sep = '' ) print ( tm . tm_hour , ':' , tm . tm_min , ':' , tm . tm_sec , sep = '' ) sleep ( 1000 ) ZERYNTH Resources \u00b6 This example explains the use of flash resources. main.py ################################################################################ # Zerynth Resources # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams streams . serial () # new_resource is a builtin that includes the file specified # in the generated bytecode # remember: the file used as a resource must be added to the project! new_resource ( \"mytxt.txt\" ) # to open resources saved by new_resource # a specific url must be passed to open # once opened, methods like read, readline and seek can be used! ff = open ( \"resource://mytxt.txt\" ) print ( \"Opening resource...\" ) while True : # let's read line by line and print line = ff . readline () # if line is empty, we are at the end of file if not line : break print ( \"Line:\" , line ) # easy! print ( \"Done!\" ) Struct Example \u00b6 Test pack and unpack methods with different formats main.py ################################################################################ # struct # # Created by Zerynth Team 2017 CC # Authors: G. Baldi, M. Cipriani ################################################################################ import streams import struct streams . serial () def print_res ( b ): print ( \"Pack --> \\n \" , end = \"\" ) for x in b : print ( hex ( x , prefix = \"\" ), end = \"\" ) print ( \"\" ) try : print ( \"Create pack for 0x01020304 in >xl format\" ) b = struct . pack ( \">xl\" , 0x01020304 ) u = struct . unpack ( \">xl\" , b ) print_res ( b ) print ( \"Unpack --> \\n \" , hex ( u [ 0 ])) print ( \"-------------------------------------------------\" ) print ( \"Create pack for a in 10s format\" ) b = struct . pack ( \"10s\" , \"a\" ) u = struct . unpack ( \"10s\" , b ) print_res ( b ) print ( \"Unpack --> \\n \" , u [ 0 ]) print ( \"-------------------------------------------------\" ) print ( \"Create pack for a in 10p format\" ) b = struct . pack ( \"10p\" , \"a\" ) u = struct . unpack ( \"10p\" , b ) print_res ( b ) print ( \"Unpack --> \\n \" , u [ 0 ]) print ( \"-------------------------------------------------\" ) print ( \"Create pack for (1,2,3.0) in blf format\" ) b = struct . pack ( \"blf\" , 1 , 2 , 3.0 ) u = struct . unpack ( \"blf\" , b ) print_res ( b ) print ( \"Unpack --> \\n \" , u ) print ( \"-------------------------------------------------\" ) print ( \"Create pack for (-1,9,1.2) in =hlf format\" ) b = struct . pack ( \"=hlf\" , - 1 , 9 , 1.2 ) u = struct . unpack ( \"=hlf\" , b ) print_res ( b ) print ( \"Unpack --> \\n \" , u ) print ( \"-------------------------------------------------\" ) print ( \"Create pack for (127,10,5.5) in =blf format\" ) b = struct . pack ( \"=blf\" , 127 , 10 , 5.5 ) u = struct . unpack ( \"=blf\" , b ) print_res ( b ) print ( \"Unpack --> \\n \" , u ) except Exception as e : print ( e ) while True : print ( \".\" ) sleep ( 1000 ) Flash Internal \u00b6 Writing and reading internal flash files. main.py ################################################################################ # iflash # # Created: 2016-03-22 15:54:21.232663 # ################################################################################ import streams import json import flash ## Warning! This example works on the Particle Photon only! # You need to change the flash address to use another board # --> For Sam3X based boards you can safely use 0xe0000 streams . serial () print ( \"create flash file\" ) # open a 512 bytes FlashFileStream at address 0x80E0000 ff = flash . FlashFileStream ( 0x80E0000 , 512 ) print ( \"reading flash file\" ) for i in range ( 30 ): print ( i , \"->\" , str ( ff [ i ])) print ( \"writing flash file\" ) sleep ( 1000 ) hh = { \"type\" : \"thing\" , \"data\" : 23.5 } ds = json . dumps ( hh ) # save length and json to flash ff . write ( len ( ds )) ff . write ( ds ) ff . flush () ff . seek ( 0 , streams . SEEK_SET ) print ( \"reading flash file\" ) n = ff . read_int () for i in range ( n + 4 ): print ( i , \"->\" , str ( ff [ i ])) Spi Flash \u00b6 An example of how to use the spiflash library to read Spi Flash chips. main.py ################################################################################ # SpiFlash Example # # Created: 2016-04-21 19:16:44.440555 # ################################################################################ import spiflash import streams streams . serial () my_flash = spiflash . SpiFlash ( SPI0 , D25 ) my_flash . erase_sector ( 0x30122 ) to_w = [ 235 , 166 , 128 , 124 , 65 , 66 ] # write data through bracket notation my_flash [ 0x30122 ] = to_w print ( \"---\" ) # read 8 bytes starting from 0x30122 address for x in my_flash . read_data ( 0x30122 , 8 ): print ( x ) print ( \"---\" ) # read the same 8 bytes through bracket notation for x in my_flash [ 0x30123 : 0x30123 + 8 ]: print ( x ) print ( \"---\" ) QSpi Flash \u00b6 An example of how to use the qspiflash library to read QSpi Flash chips. main.py ################################################################################ # QSpiFlash Example # ################################################################################ import qspiflash import streams streams . serial () my_flash = qspiflash . QSpiFlash () my_flash . erase_block ( 0 ) to_w = b ' \\x77\\x76\\x75\\x74\\x73\\x72 ' # write data through bracket notation my_flash [ 0 ] = to_w print ( \"---\" ) # read 8 bytes starting from 0 address for x in my_flash . read_data ( 0 , 8 ): print ( ' %02x ' % x ) print ( \"---\" ) # read the same 8 bytes through bracket notation for x in my_flash [ 1 : 1 + 8 ]: print ( ' %02x ' % x ) print ( \"---\" ) Spi SD \u00b6 An example of how to use spisd libray to read SD cards block by block. main.py ################################################################################ # SpiSD Example # # Created: 2016-04-29 12:37:53.316436 # ################################################################################ import spisd import streams streams . serial () my_sd = spisd . SpiSD ( SPI0 , D25 ) data = bytearray ( 512 * 2 ) for i in range ( 512 * 2 ): data [ i ] = 166 # write 512 bytes of data starting from 3rd block my_sd . write_data ( 3 , data ) # read 512*3 bytes of data starting from 3rd block for i , x in enumerate ( my_sd . read_data ( 3 , 3 )): print ( hex ( 0x200 * 3 + i ), \": \" , x ) Filesystem \u00b6 A simple example to show the filesystem support in Zerynth (FATFS on SD with SPI) main.py import streams import fatfs # import driver module import os # import file/directory management module streams . serial () # mount my SD card as volume 0 through SPI protocol fatfs . mount ( '0:' , { \"drv\" : SPI0 , \"cs\" : D25 , \"clock\" : 1000000 } ) # mount my SD card as volume 0 trough SD mode # (be careful in choosing frequency (kHz) and bits supported by your board) # fatfs.mount('0:', {\"drv\": SD1, \"freq_khz\": 20000, \"bits\": 1}) # create \"zerynth.txt\" file and open it for read/write operations ww = os . open ( '0:zerynth.txt' , 'w+' ) # write a string on it, flushing data immediately (not waiting for file to be closed) ww . write ( \"Zerynth allows me to easily manage files, cool.\" , sync = True ) # ops, I forgot what I wrote... # not a real problem problem using Zerynth # back to the start ww . seek ( 0 ) print ( \"I wrote: \" , ww . read ()) ww . close () # files and directories in root folder? print ( os . listdir ( '.' )) # a folder for zerynth stuff is needed if not os . exists ( \"0:zerynth_stuff\" ): os . mkdir ( \"0:zerynth_stuff\" ) # copy my cool file os . copyfile ( \"zerynth.txt\" , \"zerynth_stuff/zerynth_cool.txt\" ) os . chdir ( \"0:zerynth_stuff\" ) # check if anything went wrong print ( \"in \" , os . getcwd ()) print ( os . listdir ( '.' )) print ( \"SUCCESS!\" ) MCU Reset \u00b6 A simple example showing how to soft reset the microcontroller from Python. main.py ############################################################################### # MCU Reset # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ############################################################################### # import the mcu module import mcu import streams # open the default serial port, the output will be visible in the serial console streams . serial () resetting = False # define a simple function to be called on interrupt def reset (): global resetting resetting = True # on button pressed, call reset # >>>> if the board hasn't a button, change BTN0 to a digital pin # and use a jumper wire to simulate a falling edge <<<< onPinFall ( BTN0 , reset ) # loop forever while True : print ( \"Hello Zerynth!\" ) sleep ( 1000 ) # check for the need to reset if resetting : print ( \"Resetting in 3 seconds!!\" ) sleep ( 3000 ) mcu . reset () # bye! C Interface \u00b6 This advanced example shows how to call C functions from Python. main.py ################################################################################ # C Interface # # Created: 2016-01-17 10:06:10.333915 # ################################################################################ import streams streams . serial () # define a Python function decorated with c_native. # This function has no body and will instead call # the C function specified in the decorator. # The source file(s) where to find the C function must be given (cdiv.c) @c_native ( \"_my_c_function\" ,[ \"cdiv.c\" ],[]) def c_division ( a , b ): pass while True : a = random ( 0 , 100 ) b = random ( 0 , 10 ) try : # call the c_division function with random values c = c_division ( a , b ) print ( a , \"/\" , b , \"=\" , c ) except Exception as e : print ( e ) sleep ( 1000 ) Secure Hash Functions \u00b6 A simple example to introduce Secure Hashes of the crypto module main.py ################################################################################ # Secure Hash # # Created by Zerynth Team 2017 CC # Authors: G.Baldi ################################################################################ import streams # import all supported hash functions from crypto.hash import md5 as md5 from crypto.hash import sha1 as sha1 from crypto.hash import sha2 as sha2 from crypto.hash import sha3 as sha3 from crypto.hash import keccak as keccak # also import HMAC from crypto.hash import hmac as hmac # open stdout streams . serial () message = \"Zerynth\" while True : try : ss = md5 . MD5 () ss . update ( message ) print ( \"MD5: \" , ss . hexdigest ()) ss = sha1 . SHA1 () ss . update ( message ) print ( \"SHA1:\" , ss . hexdigest ()) ss = sha2 . SHA2 ( sha2 . SHA512 ) ss . update ( message ) print ( \"SHA2:\" , ss . hexdigest ()) ss = sha3 . SHA3 () ss . update ( message ) print ( \"SHA3:\" , ss . hexdigest ()) ss = keccak . Keccak () ss . update ( message ) print ( \"KECCAK:\" , ss . hexdigest ()) # generate a hmac with key=\"Python\" and sha1 hash hh = hmac . HMAC ( \"Python\" , sha1 . SHA1 ()) hh . update ( message ) print ( \"HMAC:\" , hh . hexdigest ()) except Exception as e : print ( e ) sleep ( 2000 ) Elliptic Curve Cryptography \u00b6 A simple example to introduce ECDSA primitives. main.py ################################################################################ # Elliptic Curve Cryptography # # Created by Zerynth Team 2017 CC # Authors: G. Baldi ################################################################################ import streams # import ecc and sha1 modules from crypto.ecc import ecc as ec from crypto.hash import sha1 as sha1 streams . serial () message = \"Zerynth\" # import a Public Key for SECP256R1 pb = ec . hex_to_bin ( \"7A181C7D3AD54EC3817CBAF86EA4E003AD492D8569102392A6EFE0C27E471A65553918EA1BAC86A68C78A30E9FE725EA499E14BEA96C3FE85E2267B74385E56B\" ) # import a Private Key for SECP256R1 pv = ec . hex_to_bin ( \"6D5BE10E67D479FF99421A8DE030E2B4C5323EE477DA4C17420936CAC49C261E\" ) while True : # calculate hash of message ss = sha1 . SHA1 () ss . update ( message ) digest = ss . digest () # Calculate non deterministic signature of digest # for SECP256R1 and pv signature = ec . sign ( ec . SECP256R1 , digest , pv ) # Calculate the deterministic signature of digest using SHA1 deterministic_signature = ec . sign ( ec . SECP256R1 , digest , pv , deterministic = sha1 . SHA1 ()) print ( \"PVKEY:\" , ec . bin_to_hex ( pv )) print ( \"PBKEY:\" , ec . bin_to_hex ( pb )) # this changes each loop because of random number generator print ( \"SIGNED:\" , ec . bin_to_hex ( signature )) # this is always the same print ( \"SIGNED (det)\" , ec . bin_to_hex ( deterministic_signature )) print ( \"VERIFY SIGNATURE:\" , ec . verify ( ec . SECP256R1 , digest , signature , pb )) print ( \"VERIFY SIGNATURE (det):\" , ec . verify ( ec . SECP256R1 , digest , deterministic_signature , pb )) # tampered digests are detected print ( \"VERIFY TAMPERED:\" , ec . verify ( ec . SECP256R1 , digest + b ' \\x00 ' , signature , pb )) print ( \"-\" * 20 ) sleep ( 2000 ) Powersaving \u00b6 This example shows the most important features of Powersaving enabled VMs: The ability to choose which low power mode to enter and how to exit The ability to save status on a special purpose memory guaranteed to be preserved after exiting the low power mode main.py ################################################################################ # Powersaving # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ ## ## This example only works on a Powersaving enabled Virtual Machine! ## import streams # import the Power Management module # Check documentation here: https://docs.zerynth.com/latest/official/core.zerynth.stdlib/docs/official_core.zerynth.stdlib_pwr.html import pwr streams . serial () # wake up reasons dictionary reasons = { pwr . PWR_RESET : \"System Reset\" , pwr . PWR_INTERRUPT : \"Event on WAKEUP pin\" , pwr . PWR_TIMEOUT : \"Timeout\" } # modes and descriptions modes = [ ( pwr . PWR_SLEEP , \"Sleep mode\" ), ( pwr . PWR_STOP , \"Stop mode\" ), ( pwr . PWR_STANDBY , \"Standby mode\" ) ] # some status variables slept = 0 wokeup = 0 sleep_counter = 0 # callback for Wake Up events on pins def wakeup (): print ( \"Hello!\" ) # function to prepare for and enter low power mode def sleepfn ( delay , mode ): global slept , wokeup print ( \"Going to sleep for\" , delay , \"milliseconds in\" , modes [ mode ][ 1 ]) sleep ( 100 ) # call go_to_sleep and get the amount of time spent sleeping # !! the VM is suspended here !! slept = pwr . go_to_sleep ( delay , modes [ mode ][ 0 ]) # if we reach this point, something caused a Wake Up from a low power mode # if we don't reach here, the device exited from a standby mode with a system reset # retrieve the Wake Up reason wokeup = pwr . wakeup_reason () print ( \"SLEPT FOR\" , slept ) print ( \"My wake up reason:\" , reasons . get ( wokeup , \"Unknown\" )) try : # retrieve the Wake Up reason wokeup = pwr . wakeup_reason () # retrieve sleep_counter from special purpose memory if supported try : sleep_counter = pwr . get_status_byte ( 0 ) print ( \"Special purpose memory supported!\" ) except Exception as e : print ( \"Special purpose memory not supported :(\" ) # print status at VM startup print ( \"Wake up reason at startup:\" , reasons . get ( wokeup , \"Unknown\" )) print ( \"Tried to sleep\" , sleep_counter , \"times\" ) # configure button to do something # depending on the platform this is enough to configure a Wake Up event # on some platforms only specific pins have the Wake Up property # (If the device has no button, configure another pin! [Try D6 on MKR1000 and D8 on Hexiwear]) pinMode ( BTN0 , INPUT_PULLUP ) onPinFall ( BTN0 , wakeup , debounce = 1000 ) cnt = 5 mode = 0 print ( \"Countdown!\" ) while True : # print the countdown print ( cnt ) sleep ( 1000 ) cnt -= 1 if cnt == 0 : cnt = 5 try : # save number of sleeps in special purpose memory sleep_counter = ( sleep_counter + 1 ) % 256 try : pwr . set_status_byte ( 0 , sleep_counter ) except : # ignore if special purpose memory not supported pass # enter a low power mode for 5 seconds or less # (press the button while sleeping to check if Wake Up is available in this mode) sleepfn ( 5000 , mode ) except Exception as e : print ( modes [ mode ][ 1 ], \"not supported!\" ) print ( e ) mode = ( mode + 1 ) % len ( modes ) print ( \"Countdown!\" ) except Exception as e : print ( e ) # Expected results by architecture and mode for Wake Up on pin event # # MODE | SLEEP STOP STANDBY # MCU | # ------------------------------------------------------------------- # | # STM32F | OK OK Only on pin PA0 # | # ------------------------------------------------------------------- # | # SAMD21 | OK No Mode not supported # | # -------------------------------------------------------------------- # | # NXP K64 | OK OK Only on WakeUp pins # | # -------------------------------------------------------------------- # | # ESP8266 | Unsupported Unsupported Only works for Gpio 16 # | # -------------------------------------------------------------------- Watchdogs \u00b6 A basic example showing the watchdog functionalities in a Secure Fimrware enabled VM. main.py ################################################################################ # Watchdogs # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ ## ## This example only works on a Secure Firmware enabled Virtual Machine! ## import streams # import the Secure Firmware module # Check documentation here: https://docs.zerynth.com/latest/official/core.zerynth.stdlib/docs/official_core.zerynth.stdlib_sfw.html import sfw streams . serial () sleep ( 2000 ) # Check for reset reason try : print ( \"Watchdog triggered:\" , sfw . watchdog_triggered ()) except Exception as e : print ( \"Watchdog not suppported by this Virtual Machine!\" ) while True : sleep ( 1000 ) # Do something without fearing a reset for x in range ( 10 ): sleep ( 1000 ) print ( \"Printing something for a while, no watchdog can reset me! 8\u2011D\" ) # Configure watchdog in normal mode with a 5 seconds timeout print ( \"Configuring watchdog to a 5 seconds timeout...\" ) sfw . watchdog ( 0 , 5000 ) sleep ( 100 ) # Kick the watchdog every second for x in range ( 10 ): sleep ( 1000 ) sfw . kick () print ( \"Kick!\" ) # Stop kicking and wait for reset while True : print ( \"Printing something for a while waiting for the watchdog! D-8\" ) sleep ( 1000 ) VM Exceptions \u00b6 This example explains how to set VM Options to handle uncaught exceptions main.py ################################################################################ # Zerynth VM Options # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams import vm streams . serial () #let's set some VM options: uncomment the test you want to try, comment the others #test 1: reset on uncaught exception and print trace (Default) vm . set_option ( vm . VM_OPT_RESET_ON_EXCEPTION , 1 ) vm . set_option ( vm . VM_OPT_TRACE_ON_EXCEPTION , 1 ) #test 2: don't reset on uncaught exception but print trace (Default) # vm.set_option(vm.VM_OPT_RESET_ON_EXCEPTION,0) # vm.set_option(vm.VM_OPT_TRACE_ON_EXCEPTION,1) #test 3: don't reset on uncaught exception and don't print trace (Default) # vm.set_option(vm.VM_OPT_RESET_ON_EXCEPTION,0) # vm.set_option(vm.VM_OPT_TRACE_ON_EXCEPTION,0) #test 3: reset on uncaught exception but don't print trace (Default) # vm.set_option(vm.VM_OPT_RESET_ON_EXCEPTION,1) # vm.set_option(vm.VM_OPT_TRACE_ON_EXCEPTION,0) def thread_fn_exc (): for i in range ( 5 ): print ( \"TH working\" , i ) sleep ( 1000 ) x = 1 / 0 # launch thread thread ( thread_fn_exc ) while True : sleep ( 2000 ) #let's print some VM info nfo = vm . info () print ( \"--------------\" ) print ( \"VM uid \" , nfo [ 0 ]) print ( \"Target \" , nfo [ 1 ]) print ( \"Version\" , nfo [ 2 ]) print ( \"--------------\" ) VM Hard Fault \u00b6 This example explains how to set VM Options to manage Hard Faults main.py ################################################################################ # Zerynth VM Options # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams import vm streams . serial () #let's set some VM options: uncomment the test you want to try, comment the others #test 1: reset on hard fault and print trace (Default) vm . set_option ( vm . VM_OPT_RESET_ON_HARDFAULT , 1 ) vm . set_option ( vm . VM_OPT_TRACE_ON_HARDFAULT , 1 ) #test 2: don't reset on hard fault but print trace (Default) # vm.set_option(vm.VM_OPT_RESET_ON_HARDFAULT,0) # vm.set_option(vm.VM_OPT_TRACE_ON_HARDFAULT,1) #test 3: don't reset on hard fault and don't print trace (Default) # vm.set_option(vm.VM_OPT_RESET_ON_HARDFAULT,0) # vm.set_option(vm.VM_OPT_TRACE_ON_HARDFAULT,0) #test 3: reset on hard faultbut don't print trace (Default) # vm.set_option(vm.VM_OPT_RESET_ON_HARDFAULT,1) # vm.set_option(vm.VM_OPT_TRACE_ON_HARDFAULT,0) # here is a function that causes a hard fault by writing to NULL (in c) @c_native ( \"_hf_function\" ,[ \"hf.c\" ],[]) def armageddon (): pass while True : print ( \"Releasing the Armageddon in 2 sec...:-@\" ) sleep ( 2000 ) armageddon ()","title":"Examples"},{"location":"reference/core/stdlib/docs/examples/#examples","text":"The following are a list of examples for core.zerynth.stdlib","title":"Examples"},{"location":"reference/core/stdlib/docs/examples/#hello-world","text":"The simplest example to be tried for starting with embedded development tags: [First Steps, Serial] groups:[First Steps] main.py ############################################################################### # Hello Zerynth # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ############################################################################### # import the streams module, it is needed to send data around import streams # open the default serial port, the output will be visible in the serial console streams . serial () # loop forever while True : print ( \"Hello Zerynth!\" ) # print automatically knows where to print! sleep ( 1000 )","title":"Hello World"},{"location":"reference/core/stdlib/docs/examples/#basic-led-blink","text":"The \"Hello World\" of embedded devices Just configure a digital pin as output driving it ON and OFF every sec to blink the attached LED. tags: [Digital I/O, First Steps] groups:[First Steps] main.py ############################################################################### # Led Blink # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ############################################################################### # D0 to D127 represent the names of digital pins # On most Arduino-like boards Pin D13 has an on-board LED connected. # However Zerynth abstracts the board layout allowing to use LED0, LED1, etc as led names. # In this example LED0 is used. pinMode ( LED0 , OUTPUT ) # loop forever while True : digitalWrite ( LED0 , HIGH ) # turn the LED ON by setting the voltage HIGH sleep ( 1000 ) # wait for a second digitalWrite ( LED0 , LOW ) # turn the LED OFF by setting the voltage LOW sleep ( 1000 ) # wait for a second","title":"Basic LED Blink"},{"location":"reference/core/stdlib/docs/examples/#digital-read-basics","text":"The basic definition of digitalRead() in ZERYNTH has the same behaviour of Arduino digitalRead(). In this example simple digitalRead use is reported tags: [First Steps,Digital Read ADC] groups:[First Steps] main.py ################################################################################ # Digital Read Basics # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams # create a serial port stream with default parameters streams . serial () # configure pin D5 in input mode pinMode ( D5 , INPUT_PULLUP ) # loop forever, printing the value of D5 while True : print ( digitalRead ( D5 )) sleep ( 500 )","title":"Digital Read Basics"},{"location":"reference/core/stdlib/docs/examples/#adc-analog-to-digital-acquisition-basics","text":"The function for Analog to Digital convertion in ZERYNTH is adc.read() The complete definition is adc.read(pin, samples=1) In this example simple ADC single pin acquisition and advanced multi sample ADC acquisition are reported. In ZERYNTH ADC is also available as builtin analogRead() with the same signature of adc.read(). analogRead() is available only for compatibility with the Arduino world and will be deprecated in future versions of ZERYNTH. tags: [First Steps,Analog Read ADC] groups:[First Steps] main.py ################################################################################ # Analog Read # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams # import the streams module import adc # import the adc driver # create a stream linked to the default serial port streams . serial () while True : # Basic usage of ADC for acquiring the analog signal from a pin value = adc . read ( A0 ) print ( \"One sample:\" , value ) # The complete definition of adc.read() is adc.read(pin, samples=1) # For an advanced usage of adc.read refer to the official Zerynth documentation #acquire 10 samples with default sampling period value2 = adc . read ( A0 , 10 ) print ( \"10 samples: \\n \" , value2 ) #acquire 3 samples from the first 4 analog pins of the board with default sampling period value3 = adc . read ([ A0 , A1 , A2 , A3 ], 3 ) print ( \"3 samples from A0, A1, A2 and A3: \\n \" , value3 ) print () sleep ( 300 )","title":"ADC Analog to Digital Acquisition Basics"},{"location":"reference/core/stdlib/docs/examples/#adc-analog-to-digital-acquisition-with-voltage-conversion","text":"This basic examples shows how to read an analog voltage from pin 0, converts it to the corresponding voltage, and prints the result to the serial monitor. To test it user can attach the center pin of a potentiometer to pin A0, and the other pins respectively to to +3.3V and GND. tags: [Analog Read ADC, Sensors, First Steps] groups:[First Steps] main.py ################################################################################ # Analog Read to Voltage # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams import adc # import the adc module #create a serial port stream with default parameters streams . serial () while True : #read the input on analog pin 0 sensor_value = adc . read ( A0 ) #convert the analog reading (which goes from 0 - 4095.0) to a voltage (0 - 3.3V): voltage = sensor_value * ( 3.3 / 4095.0 ) #print out the raw and converted values: print ( \"sensor raw value:\" , sensor_value , \"Voltage:\" , voltage ) sleep ( 300 )","title":"ADC Analog to Digital Acquisition with Voltage Conversion"},{"location":"reference/core/stdlib/docs/examples/#zerynth-oscilloscope","text":"Simple usage of the analog acquisition and of the Python smart print functions. The example shows how to print to the serial console the values read on an analog pin in a \"scope\" like graphicspretty way. tags: [First Steps, Analog Read ADC, Serial] groups:[First Steps] main.py ############################################################################### # Zerynth oscilloscope # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ############################################################################### import streams import adc streams . serial () while True : value = adc . read ( A4 ) conv = value * 80 // 4095 print ( \"|\" , \"#\" * conv , \" \" * ( 80 - conv ), \"|\" ) sleep ( 200 )","title":"ZERYNTH Oscilloscope"},{"location":"reference/core/stdlib/docs/examples/#serial-port-readwrite-basics","text":"Basic examples of read and write data through a serial port. In this example a serial port instance is created allowing use of various methods. tags:[Serial, First Steps] groups:[First Steps] main.py ################################################################################ # Serial Port Basics # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams # creates a serial port and name it \"s\" s = streams . serial () while True : print ( \"Write some chars on the serial port and terminate with \\\\ n (new line)\" ) line = s . readline () # read and return any single character available on the serial port until a \\n is found print ( \"You wrote:\" , line ) print () sleep ( 300 )","title":"Serial Port Read/Write Basics"},{"location":"reference/core/stdlib/docs/examples/#sensor-driven-multi-blink","text":"This examples shows how to drive various behaviours taking as input an analog signal acquired through ADC fro driving three loop implemented as separated threads. In particular, the implemented scripts drives three LEDs at three different frequencies calculated on the basis of the acquired analog signal. The example is implemented using 4 threads that run in parallel. One thread is used for acquiring the analog signal and convert the acquired raw value in blinking frequencies usable by the LED driving threads. The other three threads are used to instantiate a generic blinking function that drive a PIN where a LED is connected. tags:[Multi-Thread, First Steps, Analog Read ADC] groups:[First Steps] main.py ################################################################################ # Sensor Driven Multi-Blink # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ # This example requires an analog sensor and three LEDs import streams import adc # create a serial port stream with default parameters streams . serial () # set the A1 pin as analog input and D8, D9, D10 as outputs to drive the LEDs. pinMode ( A1 , INPUT_ANALOG ) pinMode ( D10 , OUTPUT ) pinMode ( D9 , OUTPUT ) pinMode ( D8 , OUTPUT ) # creates two arrays for storing global variables to be used in the blinking threads freq = [ 1 , 1 , 1 ] pin = [ D8 , D9 , D10 ] # define the generic blinking function to be used for driving the LEDs # this function takes as input the index identifying the LED, then uses the global freq and pin arrays to dynamically drive the LEDs def blink ( Npin ): while True : digitalWrite ( pin [ Npin ], HIGH ) sleep ( freq [ Npin ]) digitalWrite ( pin [ Npin ], LOW ) sleep ( freq [ Npin ]) # define an analog sensor sampling function that acquires the raw data and converts it to the three LED frequencies def sampling (): global freq while True : value = adc . read ( A1 ) freq [ 0 ] = value // 10 freq [ 1 ] = freq [ 0 ] * 2 freq [ 2 ] = freq [ 0 ] * 4 sleep ( 50 ) # launch the four threads thread ( sampling ) thread ( blink , 0 ) thread ( blink , 1 ) thread ( blink , 2 ) # The main loop is used only for printing out at reasonable speed the calculated frequencies in term of waiting times while True : print ( \"Wait times are\" , freq ) sleep ( 500 )","title":"Sensor driven Multi-Blink"},{"location":"reference/core/stdlib/docs/examples/#multi-thread-basics","text":"This examples shows the basics of ZERYNTH multi-threading In ZERYNTH a thread require a function to be executed as input for the definition the same function can be instanced by various thread giving you the possibility to write very concise and readable code. In this example 4 threads are created as instances of the same function where different parameters are passed to the function when the thread is initialized Note that the while True main loop typical of imperative programming is not present in this code. ZERYNTH allows pure thread driven implementation! tags: [First Steps, Multi-Thread] groups:[First Steps] main.py ################################################################################ # Multi-Thread Basics # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams # create a serial port with default parameters streams . serial () # Define a function to be used in the various threads. # Parameters are passed to the function when the thread is created and then used in the thread loop. # To be continuously executed by a thread a function requires an infinite loop, # otherwise when the function terminates the thread is closed def threadfn ( number , delay ): while True : print ( \"I am the thread\" , number ) print ( \"I run every:\" , delay , \"msec\" ) print () # just add an empty line for console output readability sleep ( delay ) # create the various threads using the same function but passing different parameters thread ( threadfn , 1 , 500 ) thread ( threadfn , 2 , 1000 ) thread ( threadfn , 3 , 1300 ) thread ( threadfn , 4 , 800 )","title":"Multi-Thread Basics"},{"location":"reference/core/stdlib/docs/examples/#multi-leds-blink-with-threads","text":"This examples shows how to use ZERYNTH threads for driving three LEDs with asymmetric and different blinking rates. Each Thread in ZERYNTH is a sort of separated and parallel process that runs autonomously on your board. With threads you can design your algorithm architecture assuming parallelism that is typical of high level programming languages. In this code a function is defined and then instanced by three threads creating a pool of parallel processes where three LEDs are driven at different frequencies. Moreover, thanks to Python argument passing, default values can be defined for function inputs. This way you can launch threads without specifying all the inputs required by the function, default values will fill the holes. In this case all the parameters following 'blink' are passed to the functions as arguments. thread(blink,pin,delayON,delayOFF) is equivalent to thread(blink(pin,delayON,delayOFF)). tags: [Multi-Thread, First Steps, Digital I/O] groups:[First Steps] main.py ################################################################################ # Multi-Blink # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ # Initialize the digital pins where the LEDs are connected as output pinMode ( D2 , OUTPUT ) pinMode ( D8 , OUTPUT ) pinMode ( D5 , OUTPUT ) # Define the 'blink' function to be used by the threads def blink ( pin , timeON = 100 , timeOFF = 100 ): # delayON and delayOFF are optional parameters, used as default # if not specified when you call the function while True : digitalWrite ( pin , HIGH ) # turn the LED ON by making the voltage HIGH sleep ( timeON ) # wait for timeON digitalWrite ( pin , LOW ) # turn the LED OFF by making the voltage LOW sleep ( timeOFF ) # wait for timeOFF # Create three threads that execute instances of the 'blink' function. thread ( blink , D2 ) # D2 is ON for 100 ms and OFF for 100 ms, the default values of delayON an delayOFF thread ( blink , D8 , 200 ) # D8 is ON for 200 ms and OFF for 100 ms, the default value of delayOFF thread ( blink , D5 , 500 , 200 ) # D5 is ON for 500 ms and OFF for 200 ms","title":"Multi LEDs Blink with threads"},{"location":"reference/core/stdlib/docs/examples/#serial-port-advanced","text":"Advanced example of using a serial port for writing and sending data The examples shows how to read the entire serial port buffer or how to read a defined number of chars from the buffer. Moreover is also shown how to read a buffer until a \\n newline terminator is found. tags:[Serial, First Steps] groups:[First Steps] main.py ################################################################################ # Serial Advanced # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams s = streams . serial () # Testing various serial port reading methods while True : print ( \"write some chars and send it to the board\" ) char = s . read () # read and return any single character available on the serial port one by one print ( \"This is the first char you wrote:\" , char ) print () # add a line space for improving the serial console ouput readability sleep ( 500 ) # waiting for the serial buffer to fill length = s . available () # check if data are available on the port and count them chars = s . read ( length ) # read all the bytes available in the buffer an return the bytearray print ( \"This are the other\" , length , \"chars you wrote:\" , chars ) print () # add a line space for improving the serial console view print ( \"write a line ending it with return or enter\" ) line = s . readline () # read until a line terminator \\n is found, then return a bytearray print ( \"This is the line you wrote:\" , line )","title":"Serial Port Advanced"},{"location":"reference/core/stdlib/docs/examples/#input-capture-unit-as-pwm-analyzer","text":"This examples shows how to use the Input Capture Unit of the board MCU for analysing a PWM signal The PWM is generated on PIN13 in order to have a feedbakc on the board embedded LED PIN13 is also connected through a wire with PIN2 on which the ICU capture is activated An interrupt is also attached on a PIN where a button is connected for changing the PWM duty. Very Important: ICU and PWM are both timer powered embedded feature, it is impossible to run an ICU and a PWM on two pin controlled by the same timer channel. Please refer to the board pinout in order to select the proper pins for your board e.i: on a ST Nucleo this example use PWM2/1 for PIN13 and PWM\u2153 for PIN2 so we are using two diferent embedded timers (first number on the PEM pin descrition) Board setup: PIN13-----PIN2 (shortcut the pins) BTNPin----GND (connect a button between a pin and GND) tags: [First Steps, Input Capture Unit ICU, Interrupts, Analog Write PWM] groups:[First Steps] main.py ################################################################################ # Input Capture Unit as PWM Analyzer # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import pwm import icu import streams # create the serial port using default parameters streams . serial () # define a pin where a button is connected, you can use the Nucleo button pin as input or change it with any other digital pin available # this is the pin the button is connected to; for the various supported boards, Zerynth automatically translates it # to the board button. On Arduino DUE the user button isn't installed, so this line rises a compilation error. # On Arduino DUE, change it to the pin your button is connected to or comment this line (see below) buttonPin = BTN0 # define the ICU pin. D5 works with Arduino footprint boards while with Particle boards D0 can be used captPin = D5 . ICU # On Arduino like boards #captPin=D0.ICU # On Particle boards # define the PWM pin. D13 works with Arduino footprint boards (and is also connected to a LED) while with Particle boards A4 can be used pwmPin = D13 . PWM # On Arduino like boards #pwmPin=A4.PWM # On Particle boards # set the pin as input with PullUp, the button will be connected to ground pinMode ( buttonPin , INPUT_PULLUP ) # define a function for printing capture results on the serial port def print_results ( y ): print ( \"Time ON is:\" , y [ 0 ], \"micros\" ) print ( \"Time OFF is:\" , y [ 1 ], \"micros\" ) print ( \"Period is:\" , y [ 0 ] + y [ 1 ], \"micros\" ) print () # define a global variable for PWM duty cycle and turn on the PWM duty = 10 pwm . write ( pwmPin , 100 , duty , MICROS ) #pwm.write needs (pn, period, duty, time_unit) # define the function to be called for changing the PWM duty when the button is pressed def pwm_control (): global duty duty = duty + 10 if duty >= 100 : duty = 0 pwm . write ( pwmPin , 100 , duty , MICROS ) print ( \"Duty:\" , duty , \"millis\" ) # Attach an interrupt on the button pin waiting for signal going from high to low when the button is pressed. # pwm_control will be called when the interrupt is fired. # If you are on Arduino DUE and you haven't connected any button comment the following line # you will not change the PWM duty but you can still test the ICU capture onPinFall ( buttonPin , pwm_control ) while True : # start an icu capture to be triggered when the pin rise. # this routine acquires 10 steps (HIGH or LOW states) or terminates after 50000 micros # this is a blocking function x = icu . capture ( captPin , LOW_TO_HIGH , 10 , 50000 , MICROS ) print ( \"captured\" ) # x is a list of step durations in microseconds, pass it to the printing function and check the serial console print_results ( x ) sleep ( 1000 )","title":"Input Capture Unit as PWM Analyzer"},{"location":"reference/core/stdlib/docs/examples/#timers-basics","text":"Basic example of use of the timer module for monitoring the time during the program execution. Timers can be used as alternative to the Arduino Millis(). tags=[First Steps, Timers] groups:[First Steps] main.py ################################################################################ # Timers Basics # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import timers import streams # create a serial port with default parameters streams . serial () # create a new timer t = timers . timer () # start the timer t . start () minutes = 0 while True : if t . get () >= 60000 : #check if 60 seconds are passed t . reset () #timer can be reset minutes += 1 seconds = t . get () // 1000 print ( \"time is:\" , minutes , \":\" , seconds ) #just print the current value since timer start or last reset print ( \"System time is:\" , timers . now (), \"(millis)\" ) #timers.now() gives the system time in milliseconds since program start print () sleep ( 500 ) #run every 500 millisec","title":"Timers Basics"},{"location":"reference/core/stdlib/docs/examples/#string-formatting","text":"Some example of Python string formatting with the modulo operator. main.py ################################################################################ # strformat # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams streams . serial () print ( \"Starting!\" ) sleep ( 1000 ) # a data tuple tt = ( \"string\" , - 21 , 15.23 , 32 ) # a data dictionary dd = { \"thing\" : \"string\" , \"number\" : 1 , \"float\" : 1.0 , \"hex\" : 32 } # let's format :) while True : try : # basic formatting print ( \" %% this is a %s , this is a %d , this is a %f , this is a %x , this is a %% \" % tt ) # named keys formatting print ( \" %% this is a %(thing)s , this is a %(number)d , this is a %(float)f , this is a %(hex)x , this is a %% \" % dd ) # width & precision print ( \" %s %8d %f %d \" % tt ) print ( \" %s %08.7d %f %d \" % tt ) # width & precision & left alignment & sign print ( \" %s %-010.9d %f %d \" % tt ) print ( \" %s %-010.9d %2.0f %d \" % tt ) print ( \" %s %-010.9d %2.5f %d \" % tt ) print ( \" %s %-010.9d %12.5f %d \" % tt ) print ( \" %s %-010.9d %-12.5f %d \" % tt ) print ( \" %s %-010.9d %012.15f %d \" % tt ) print ( \" %s %+010.9d %012.15f %d \" % tt ) print ( \" %s % 010.9d %012.15f %d \" % tt ) # width & precision for strings print ( \" %15.3s % 010.9d %012.15f %d \" % tt ) # variable width & precision print ( \" %x %3.*d \" % ( 123456 , 5 , 6 )) except Exception as e : print ( e ) sleep ( 5000 )","title":"String Formatting"},{"location":"reference/core/stdlib/docs/examples/#serial-port-readwrite-basics_1","text":"Basic examples of read and write data through a serial port. In this example a serial port instance is created allowing use of various methods. tags:[Serial, First Steps] groups:[First Steps] main.py ################################################################################ # Serial Port Basics # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams # creates a serial port and name it \"s\" s = streams . serial () while True : print ( \"Write some chars on the serial port and terminate with \\\\ n (new line)\" ) line = s . readline () # read and return any single character available on the serial port until a \\n is found print ( \"You wrote:\" , line ) print () sleep ( 300 )","title":"Serial Port Read/Write Basics"},{"location":"reference/core/stdlib/docs/examples/#serial-port-advanced_1","text":"Advanced example of using a serial port for writing and sending data The examples shows how to read the entire serial port buffer or how to read a defined number of chars from the buffer. Moreover is also shown how to read a buffer until a \\n newline terminator is found. tags:[Serial, First Steps] groups:[First Steps] main.py ################################################################################ # Serial Advanced # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams s = streams . serial () # Testing various serial port reading methods while True : print ( \"write some chars and send it to the board\" ) char = s . read () # read and return any single character available on the serial port one by one print ( \"This is the first char you wrote:\" , char ) print () # add a line space for improving the serial console ouput readability sleep ( 500 ) # waiting for the serial buffer to fill length = s . available () # check if data are available on the port and count them chars = s . read ( length ) # read all the bytes available in the buffer an return the bytearray print ( \"This are the other\" , length , \"chars you wrote:\" , chars ) print () # add a line space for improving the serial console view print ( \"write a line ending it with return or enter\" ) line = s . readline () # read until a line terminator \\n is found, then return a bytearray print ( \"This is the line you wrote:\" , line )","title":"Serial Port Advanced"},{"location":"reference/core/stdlib/docs/examples/#digital-read-basics_1","text":"The basic definition of digitalRead() in ZERYNTH has the same behaviour of Arduino digitalRead(). In this example simple digitalRead use is reported tags: [First Steps,Digital Read ADC] groups:[First Steps] main.py ################################################################################ # Digital Read Basics # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams # create a serial port stream with default parameters streams . serial () # configure pin D5 in input mode pinMode ( D5 , INPUT_PULLUP ) # loop forever, printing the value of D5 while True : print ( digitalRead ( D5 )) sleep ( 500 )","title":"Digital Read Basics"},{"location":"reference/core/stdlib/docs/examples/#basic-led-blink_1","text":"The \"Hello World\" of embedded devices Just configure a digital pin as output driving it ON and OFF every sec to blink the attached LED. tags: [Digital I/O, First Steps] groups:[First Steps] main.py ############################################################################### # Led Blink # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ############################################################################### # D0 to D127 represent the names of digital pins # On most Arduino-like boards Pin D13 has an on-board LED connected. # However Zerynth abstracts the board layout allowing to use LED0, LED1, etc as led names. # In this example LED0 is used. pinMode ( LED0 , OUTPUT ) # loop forever while True : digitalWrite ( LED0 , HIGH ) # turn the LED ON by setting the voltage HIGH sleep ( 1000 ) # wait for a second digitalWrite ( LED0 , LOW ) # turn the LED OFF by setting the voltage LOW sleep ( 1000 ) # wait for a second","title":"Basic LED Blink"},{"location":"reference/core/stdlib/docs/examples/#adc-analog-to-digital-acquisition-basics_1","text":"The function for Analog to Digital convertion in ZERYNTH is adc.read() The complete definition is adc.read(pin, samples=1) In this example simple ADC single pin acquisition and advanced multi sample ADC acquisition are reported. In ZERYNTH ADC is also available as builtin analogRead() with the same signature of adc.read(). analogRead() is available only for compatibility with the Arduino world and will be deprecated in future versions of ZERYNTH. tags: [First Steps,Analog Read ADC] groups:[First Steps] main.py ################################################################################ # Analog Read # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams # import the streams module import adc # import the adc driver # create a stream linked to the default serial port streams . serial () while True : # Basic usage of ADC for acquiring the analog signal from a pin value = adc . read ( A0 ) print ( \"One sample:\" , value ) # The complete definition of adc.read() is adc.read(pin, samples=1) # For an advanced usage of adc.read refer to the official Zerynth documentation #acquire 10 samples with default sampling period value2 = adc . read ( A0 , 10 ) print ( \"10 samples: \\n \" , value2 ) #acquire 3 samples from the first 4 analog pins of the board with default sampling period value3 = adc . read ([ A0 , A1 , A2 , A3 ], 3 ) print ( \"3 samples from A0, A1, A2 and A3: \\n \" , value3 ) print () sleep ( 300 )","title":"ADC Analog to Digital Acquisition Basics"},{"location":"reference/core/stdlib/docs/examples/#adc-analog-to-digital-acquisition-with-voltage-conversion_1","text":"This basic examples shows how to read an analog voltage from pin 0, converts it to the corresponding voltage, and prints the result to the serial monitor. To test it user can attach the center pin of a potentiometer to pin A0, and the other pins respectively to to +3.3V and GND. tags: [Analog Read ADC, Sensors, First Steps] groups:[First Steps] main.py ################################################################################ # Analog Read to Voltage # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams import adc # import the adc module #create a serial port stream with default parameters streams . serial () while True : #read the input on analog pin 0 sensor_value = adc . read ( A0 ) #convert the analog reading (which goes from 0 - 4095.0) to a voltage (0 - 3.3V): voltage = sensor_value * ( 3.3 / 4095.0 ) #print out the raw and converted values: print ( \"sensor raw value:\" , sensor_value , \"Voltage:\" , voltage ) sleep ( 300 )","title":"ADC Analog to Digital Acquisition with Voltage Conversion"},{"location":"reference/core/stdlib/docs/examples/#zerynth-oscilloscope_1","text":"Simple usage of the analog acquisition and of the Python smart print functions. The example shows how to print to the serial console the values read on an analog pin in a \"scope\" like graphicspretty way. tags: [First Steps, Analog Read ADC, Serial] groups:[First Steps] main.py ############################################################################### # Zerynth oscilloscope # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ############################################################################### import streams import adc streams . serial () while True : value = adc . read ( A4 ) conv = value * 80 // 4095 print ( \"|\" , \"#\" * conv , \" \" * ( 80 - conv ), \"|\" ) sleep ( 200 )","title":"ZERYNTH Oscilloscope"},{"location":"reference/core/stdlib/docs/examples/#sensor-driven-multi-blink_1","text":"This examples shows how to drive various behaviours taking as input an analog signal acquired through ADC fro driving three loop implemented as separated threads. In particular, the implemented scripts drives three LEDs at three different frequencies calculated on the basis of the acquired analog signal. The example is implemented using 4 threads that run in parallel. One thread is used for acquiring the analog signal and convert the acquired raw value in blinking frequencies usable by the LED driving threads. The other three threads are used to instantiate a generic blinking function that drive a PIN where a LED is connected. tags:[Multi-Thread, First Steps, Analog Read ADC] groups:[First Steps] main.py ################################################################################ # Sensor Driven Multi-Blink # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ # This example requires an analog sensor and three LEDs import streams import adc # create a serial port stream with default parameters streams . serial () # set the A1 pin as analog input and D8, D9, D10 as outputs to drive the LEDs. pinMode ( A1 , INPUT_ANALOG ) pinMode ( D10 , OUTPUT ) pinMode ( D9 , OUTPUT ) pinMode ( D8 , OUTPUT ) # creates two arrays for storing global variables to be used in the blinking threads freq = [ 1 , 1 , 1 ] pin = [ D8 , D9 , D10 ] # define the generic blinking function to be used for driving the LEDs # this function takes as input the index identifying the LED, then uses the global freq and pin arrays to dynamically drive the LEDs def blink ( Npin ): while True : digitalWrite ( pin [ Npin ], HIGH ) sleep ( freq [ Npin ]) digitalWrite ( pin [ Npin ], LOW ) sleep ( freq [ Npin ]) # define an analog sensor sampling function that acquires the raw data and converts it to the three LED frequencies def sampling (): global freq while True : value = adc . read ( A1 ) freq [ 0 ] = value // 10 freq [ 1 ] = freq [ 0 ] * 2 freq [ 2 ] = freq [ 0 ] * 4 sleep ( 50 ) # launch the four threads thread ( sampling ) thread ( blink , 0 ) thread ( blink , 1 ) thread ( blink , 2 ) # The main loop is used only for printing out at reasonable speed the calculated frequencies in term of waiting times while True : print ( \"Wait times are\" , freq ) sleep ( 500 )","title":"Sensor driven Multi-Blink"},{"location":"reference/core/stdlib/docs/examples/#can-auto-baudrate","text":"This example shows how to use the CAN interface library and how to detect baudrate. main.py # CAN Auto-baudrate # Created at 2020-02-10 16:39:24.048614 from fortebit.polaris import polaris import can polaris . init () print ( \"CAN Bus Auto-Baudrate Example\" ) # Initialize CAN transceiver pinMode ( polaris . internal . PIN_CAN_STANDBY , OUTPUT ) digitalWrite ( polaris . internal . PIN_CAN_STANDBY , LOW ) sleep ( 100 ) def can_auto_baudrate (): print ( \"Start auto baudrate...\" ) for bps in ( 1000000 , 800000 , 500000 , 250000 , 125000 , 100000 , 50000 , 10000 ): print ( \"Try\" , bps , \"bps\" ) try : canbus = can . Can ( CAN0 , bps , options = can . OPTION_LISTEN_ONLY ) except Exception as e : print ( e ) continue try : canbus . add_filter ( 0 , 0 ) canbus . receive ( timeout = 500 ) print ( \"Found baudrate:\" , bps ) canbus . done () return bps except TimeoutError : pass except Exception as e : print ( e ) print ( \"Errors\" , canbus . get_errors ()) canbus . done () print ( \"Auto baudrate failed!\" ) return None bps = None while bps is None : bps = can_auto_baudrate () sleep ( 1000 ) print ( \"Start active listening at\" , bps , \"bps\" ) canbus = can . Can ( CAN0 , bps ) canbus . add_filter ( 0 , 0 ) while True : try : msg = canbus . receive () print ( \"ID\" , hex ( msg [ 0 ] & can . FRAME_EXT_MASK ), \"IDE\" ,( msg [ 0 ] & can . FRAME_EXT_FLAG ) != 0 , \"RTR\" ,( msg [ 0 ] & can . FRAME_RTR_FLAG ) != 0 , \"DLC\" , msg [ 1 ], \"DATA\" ,[ hex ( b ) for b in msg [ 2 ]]) except Exception as e : print ( e )","title":"CAN Auto-baudrate"},{"location":"reference/core/stdlib/docs/examples/#can-bus-example","text":"This example shows how to use the CAN interface library. main.py # Can Bus Example # Created at 2019-12-17 16:21:55.938660 from fortebit.polaris import polaris import can polaris . init () print ( \"CAN Bus Auto-Baudrate Example\" ) # Initialize CAN transceiver pinMode ( polaris . internal . PIN_CAN_STANDBY , OUTPUT ) digitalWrite ( polaris . internal . PIN_CAN_STANDBY , LOW ) sleep ( 100 ) canbus = can . Can ( CAN0 , 500000 ) def can_rx ( timeout =- 1 ): print ( \"rx, listening...\" ) msg = canbus . receive ( timeout = timeout ) print ( \"ID\" , hex ( msg [ 0 ] & can . FRAME_EXT_MASK ), \"IDE\" ,( msg [ 0 ] & can . FRAME_EXT_FLAG ) != 0 , \"RTR\" ,( msg [ 0 ] & can . FRAME_RTR_FLAG ) != 0 , \"DLC\" , msg [ 1 ], \"DATA\" ,[ hex ( b ) for b in msg [ 2 ]]) def abort_rx (): sleep ( 1000 ) print ( \"abort rx\" ) canbus . abort_receive () sleep ( 500 ) print ( \"resume rx\" ) canbus . resume_receive () def abort_tx (): sleep ( 1000 ) print ( \"abort tx\" ) canbus . abort_transmit () sleep ( 500 ) print ( \"resume tx\" ) canbus . resume_transmit () f0 = canbus . add_filter ( 0 , 0 ) f1 = canbus . add_filter ( 0x123 | can . FRAME_EXT_FLAG , can . FRAME_EXT_MASK | can . FRAME_EXT_FLAG ) print ( \"Filters\" , f0 , f1 ) canbus . del_filter ( f0 ) f2 = canbus . add_filter ( 0x456 , can . FRAME_STD_MASK ) f3 = canbus . add_filter ( 0x88 | can . FRAME_RTR_FLAG , can . FRAME_STD_MASK | can . FRAME_RTR_FLAG ) print ( \"Filters\" , f1 , f2 , f3 ) print ( \"tx std data\" ) canbus . transmit ( 0x456 , 8 , b 'abcdefgh' ) print ( \"tx ext remote\" ) canbus . transmit ( 0x123 | can . FRAME_EXT_FLAG | can . FRAME_RTR_FLAG , 8 ) print ( \"Errors\" , canbus . get_errors ()) thread ( abort_rx ) try : can_rx () except Exception as e : print ( e ) sleep ( 1000 ) can_rx () canbus . done () # test standby/wakeup digitalWrite ( polaris . internal . PIN_CAN_STANDBY , HIGH ) sleep ( 100 ) sleeping = True def wakeup (): global sleeping if sleeping : sleeping = False onPinFall ( CANRX0 , None ) print ( \"CAN wakeup\" ) pinMode ( CANRX0 , INPUT_PULLUP ) onPinFall ( CANRX0 , wakeup ) print ( \"Going to sleep...\" ) while sleeping : sleep ( 10 ) digitalWrite ( polaris . internal . PIN_CAN_STANDBY , LOW ) canbus = can . Can ( CAN0 , 500000 ) f0 = canbus . add_filter ( 0 , 0 ) print ( \"Timeout rx 3s...\" ) try : can_rx ( timeout = 3000 ) except Exception as e : print ( e ) thread ( abort_tx ) id = 0 while id <= can . FRAME_STD_MASK : try : canbus . transmit (( id << 18 ) | can . FRAME_EXT_FLAG | can . FRAME_RTR_FLAG , id & 7 ) canbus . transmit ( id + 6 ,( id & 7 ) + 1 , b 'abcdefgh' ) except Exception as e : print ( e ) sleep ( 100 ) #sleep(50) id += 15 print ( \"Errors\" , canbus . get_errors ()) while True : can_rx () print ( \"Errors\" , canbus . get_errors ()) canbus . done ()","title":"Can Bus Example"},{"location":"reference/core/stdlib/docs/examples/#dac-basic","text":"A simple example to introduce Dac features. main.py ################################################################################ # Dac Basic # # Created by Zerynth Team 2015 CC # Authors: L. Rizzello ################################################################################ import streams import adc # for analogRead import dac def readInput (): while True : print ( \"reading A1: \" , analogRead ( A1 )) sleep ( 500 ) streams . serial () pinMode ( A1 , INPUT ) # read input in a separate thread thread ( readInput ) my_dac = dac . DAC ( D8 . DAC ) my_dac . start () # circular mode: continuously repeat the input buffer my_dac . write ([ 100 , 200 , 900 , 800 ], 1000 , MILLIS , circular = True )","title":"DAC Basic"},{"location":"reference/core/stdlib/docs/examples/#buzzer-driven-through-pwm","text":"This example shows how to drive a buzzer using PWM. In the example a frequency ramp going from 100 Hz to 5 KHz is generated as drive. The frequency is converted in period to be used as input of the pwm.rite function that require period and pulse to be expressed in milli or micro seconds (measure unit can be selected as extra parameter of the pwm.write function). The PWM duty cycle is set to 50% driving the buzzer with a symmetric square wave. tags:[First Steps, Input Capture Unit ICU, Sound] groups:[First Steps] main.py ################################################################################ # Buzzer with PWM # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams import pwm #create a serial port stream with default parameters streams . serial () # the pin where the buzzer is attached to buzzerpin = D8 . PWM pinMode ( buzzerpin , OUTPUT ) #set buzzerpin to output mode frequency = 100 #define a variable to hold the played tone frequency while True : period = 1000000 // frequency #we are using MICROS so every sec is 1000000 of micros. // is the int division, pwm.write period doesn't accept floats print ( \"frequency is\" , frequency , \"Hz\" ) #set the period of the buzzer and the duty to 50% of the period pwm . write ( buzzerpin , period , period // 2 , MICROS ) # increment the frequency every loop frequency = frequency + 20 # reset period if frequency >= 5000 : frequency = 100 sleep ( 100 )","title":"Buzzer Driven through PWM"},{"location":"reference/core/stdlib/docs/examples/#led-fade","text":"This example shows hot to use PWM for fading a LED by changing the duty cycle in a for loop. main.py ################################################################################ # LED Fade # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ############################################################################### import pwm duty = 0 pinMode ( LED0 , OUTPUT ) # set the LED pin as output: while True : for i in range ( - 100 , 100 , 1 ): # create a loop for ranging the duty cycle from 0 to 100 MICROS duty = 100 - abs ( i ) pwm . write ( LED0 . PWM , 100 , duty , MICROS ) # set the pwm at the calculated duty with a fixed period of 100 MICROS sleep ( 10 ) # update the PWM every 10 millis","title":"LED Fade"},{"location":"reference/core/stdlib/docs/examples/#input-capture-unit-as-pwm-analyzer_1","text":"This examples shows how to use the Input Capture Unit of the board MCU for analysing a PWM signal The PWM is generated on PIN13 in order to have a feedbakc on the board embedded LED PIN13 is also connected through a wire with PIN2 on which the ICU capture is activated An interrupt is also attached on a PIN where a button is connected for changing the PWM duty. Very Important: ICU and PWM are both timer powered embedded feature, it is impossible to run an ICU and a PWM on two pin controlled by the same timer channel. Please refer to the board pinout in order to select the proper pins for your board e.i: on a ST Nucleo this example use PWM2/1 for PIN13 and PWM\u2153 for PIN2 so we are using two diferent embedded timers (first number on the PEM pin descrition) Board setup: PIN13-----PIN2 (shortcut the pins) BTNPin----GND (connect a button between a pin and GND) tags: [First Steps, Input Capture Unit ICU, Interrupts, Analog Write PWM] groups:[First Steps] main.py ################################################################################ # Input Capture Unit as PWM Analyzer # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import pwm import icu import streams # create the serial port using default parameters streams . serial () # define a pin where a button is connected, you can use the Nucleo button pin as input or change it with any other digital pin available # this is the pin the button is connected to; for the various supported boards, Zerynth automatically translates it # to the board button. On Arduino DUE the user button isn't installed, so this line rises a compilation error. # On Arduino DUE, change it to the pin your button is connected to or comment this line (see below) buttonPin = BTN0 # define the ICU pin. D5 works with Arduino footprint boards while with Particle boards D0 can be used captPin = D5 . ICU # On Arduino like boards #captPin=D0.ICU # On Particle boards # define the PWM pin. D13 works with Arduino footprint boards (and is also connected to a LED) while with Particle boards A4 can be used pwmPin = D13 . PWM # On Arduino like boards #pwmPin=A4.PWM # On Particle boards # set the pin as input with PullUp, the button will be connected to ground pinMode ( buttonPin , INPUT_PULLUP ) # define a function for printing capture results on the serial port def print_results ( y ): print ( \"Time ON is:\" , y [ 0 ], \"micros\" ) print ( \"Time OFF is:\" , y [ 1 ], \"micros\" ) print ( \"Period is:\" , y [ 0 ] + y [ 1 ], \"micros\" ) print () # define a global variable for PWM duty cycle and turn on the PWM duty = 10 pwm . write ( pwmPin , 100 , duty , MICROS ) #pwm.write needs (pn, period, duty, time_unit) # define the function to be called for changing the PWM duty when the button is pressed def pwm_control (): global duty duty = duty + 10 if duty >= 100 : duty = 0 pwm . write ( pwmPin , 100 , duty , MICROS ) print ( \"Duty:\" , duty , \"millis\" ) # Attach an interrupt on the button pin waiting for signal going from high to low when the button is pressed. # pwm_control will be called when the interrupt is fired. # If you are on Arduino DUE and you haven't connected any button comment the following line # you will not change the PWM duty but you can still test the ICU capture onPinFall ( buttonPin , pwm_control ) while True : # start an icu capture to be triggered when the pin rise. # this routine acquires 10 steps (HIGH or LOW states) or terminates after 50000 micros # this is a blocking function x = icu . capture ( captPin , LOW_TO_HIGH , 10 , 50000 , MICROS ) print ( \"captured\" ) # x is a list of step durations in microseconds, pass it to the printing function and check the serial console print_results ( x ) sleep ( 1000 )","title":"Input Capture Unit as PWM Analyzer"},{"location":"reference/core/stdlib/docs/examples/#icu-capture-ir-packets","text":"Basic example of use of the ICU feature for capturing IR signals acquired through an IR demodulator. main.py ################################################################################ # ICU Capture IR Packets # # Created by Zerynth Team 2015 CC # Authors: L. Rizzello, G. Baldi, D. Mazzei ################################################################################ import icu import streams import pwm streams . serial () # Set the pin the IR receiver is connected to. # In this example D2 is used: if you happen to have a TOI Shield on an Arduino compatible board # you are good to go. ir_pin = D2 . ICU # when you want to use a particular pin function, just use the dot notation def IR_capture (): while True : print ( \"Capturing...\" ) # Starts capturing from the icu configured pin. # The capture starts from a selected trigger (in this case capture will start when the pin first goes from # HIGH to LOW). # The max number of samples to be collected and a maximum time window are specified. # Play with max number and time window to fit your remote protocol. # The following values are for the NEC IR (used by LG) protocol x = icu . capture ( ir_pin , LOW , 67 , 68 , pull = HIGH ) print ( x , \" \\n captured n samples:\" , len ( x )) # captures in a different thread thread ( IR_capture ) while True : print ( \"alive!\" ) sleep ( 1000 )","title":"ICU Capture IR Packets"},{"location":"reference/core/stdlib/docs/examples/#timers-basics_1","text":"Basic example of use of the timer module for monitoring the time during the program execution. Timers can be used as alternative to the Arduino Millis(). tags=[First Steps, Timers] groups:[First Steps] main.py ################################################################################ # Timers Basics # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import timers import streams # create a serial port with default parameters streams . serial () # create a new timer t = timers . timer () # start the timer t . start () minutes = 0 while True : if t . get () >= 60000 : #check if 60 seconds are passed t . reset () #timer can be reset minutes += 1 seconds = t . get () // 1000 print ( \"time is:\" , minutes , \":\" , seconds ) #just print the current value since timer start or last reset print ( \"System time is:\" , timers . now (), \"(millis)\" ) #timers.now() gives the system time in milliseconds since program start print () sleep ( 500 ) #run every 500 millisec","title":"Timers Basics"},{"location":"reference/core/stdlib/docs/examples/#timers-advanced-use","text":"This example shows how ZERYNTH soft timers can be used to schedule functions execution. ZERYNTH timers can be used as program time counter through the timer.start attribute or as recursive callers through the timer.interval method that takes as input the elapsing interval and the function to be called. Moreover, it is also possible to activate a timer in one shot mode. In this case the function si called after the requested interval and then the timer stops tags: [Timers, First Steps] groups:[First Steps] main.py ################################################################################ # Timers Advanced Use # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import timers import streams # create a serial port with default parameters streams . serial () # create new timers tsec = timers . timer () tminute = timers . timer () tshoot = timers . timer () seconds = 0 minutes = 0 # define a function to call when the timer for seconds elapses def secondpassed (): global seconds seconds += 1 print ( seconds , \" seconds\" ) if seconds == 60 : seconds = 0 # define a function to call when the timer for minutes elapses def minutepassed (): global minutes minutes += 1 print ( minutes , \" minutes\" ) # define a function to call when the one shot timer elapses def shootpassed (): print ( \"1 second ago was 1:30\" ) # start the timers for minutes and seconds tsec . interval ( 1000 , secondpassed ) tminute . interval ( 60000 , minutepassed ) tsec . start () tminute . start () while True : if seconds == 30 and minutes == 1 : # do a check on passed time to trigger a oneshot timer tshoot . one_shot ( 1000 , shootpassed ) # this is a oneshot timer, it executes only one time print ( \"timer minutes runs since:\" , tminute . get (), \"timer seconds runs since:\" , tsec . get (), \"millisec\" ) #just print the current value since start or last reset sleep ( 2500 ) #run every 2500 millisec","title":"Timers Advanced Use"},{"location":"reference/core/stdlib/docs/examples/#multi-thread-basics_1","text":"This examples shows the basics of ZERYNTH multi-threading In ZERYNTH a thread require a function to be executed as input for the definition the same function can be instanced by various thread giving you the possibility to write very concise and readable code. In this example 4 threads are created as instances of the same function where different parameters are passed to the function when the thread is initialized Note that the while True main loop typical of imperative programming is not present in this code. ZERYNTH allows pure thread driven implementation! tags: [First Steps, Multi-Thread] groups:[First Steps] main.py ################################################################################ # Multi-Thread Basics # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams # create a serial port with default parameters streams . serial () # Define a function to be used in the various threads. # Parameters are passed to the function when the thread is created and then used in the thread loop. # To be continuously executed by a thread a function requires an infinite loop, # otherwise when the function terminates the thread is closed def threadfn ( number , delay ): while True : print ( \"I am the thread\" , number ) print ( \"I run every:\" , delay , \"msec\" ) print () # just add an empty line for console output readability sleep ( delay ) # create the various threads using the same function but passing different parameters thread ( threadfn , 1 , 500 ) thread ( threadfn , 2 , 1000 ) thread ( threadfn , 3 , 1300 ) thread ( threadfn , 4 , 800 )","title":"Multi-Thread Basics"},{"location":"reference/core/stdlib/docs/examples/#multi-leds-blink-with-threads_1","text":"This examples shows how to use ZERYNTH threads for driving three LEDs with asymmetric and different blinking rates. Each Thread in ZERYNTH is a sort of separated and parallel process that runs autonomously on your board. With threads you can design your algorithm architecture assuming parallelism that is typical of high level programming languages. In this code a function is defined and then instanced by three threads creating a pool of parallel processes where three LEDs are driven at different frequencies. Moreover, thanks to Python argument passing, default values can be defined for function inputs. This way you can launch threads without specifying all the inputs required by the function, default values will fill the holes. In this case all the parameters following 'blink' are passed to the functions as arguments. thread(blink,pin,delayON,delayOFF) is equivalent to thread(blink(pin,delayON,delayOFF)). tags: [Multi-Thread, First Steps, Digital I/O] groups:[First Steps] main.py ################################################################################ # Multi-Blink # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ # Initialize the digital pins where the LEDs are connected as output pinMode ( D2 , OUTPUT ) pinMode ( D8 , OUTPUT ) pinMode ( D5 , OUTPUT ) # Define the 'blink' function to be used by the threads def blink ( pin , timeON = 100 , timeOFF = 100 ): # delayON and delayOFF are optional parameters, used as default # if not specified when you call the function while True : digitalWrite ( pin , HIGH ) # turn the LED ON by making the voltage HIGH sleep ( timeON ) # wait for timeON digitalWrite ( pin , LOW ) # turn the LED OFF by making the voltage LOW sleep ( timeOFF ) # wait for timeOFF # Create three threads that execute instances of the 'blink' function. thread ( blink , D2 ) # D2 is ON for 100 ms and OFF for 100 ms, the default values of delayON an delayOFF thread ( blink , D8 , 200 ) # D8 is ON for 200 ms and OFF for 100 ms, the default value of delayOFF thread ( blink , D5 , 500 , 200 ) # D5 is ON for 500 ms and OFF for 200 ms","title":"Multi LEDs Blink with threads"},{"location":"reference/core/stdlib/docs/examples/#sensor-driven-multi-blink_2","text":"This examples shows how to drive various behaviours taking as input an analog signal acquired through ADC fro driving three loop implemented as separated threads. In particular, the implemented scripts drives three LEDs at three different frequencies calculated on the basis of the acquired analog signal. The example is implemented using 4 threads that run in parallel. One thread is used for acquiring the analog signal and convert the acquired raw value in blinking frequencies usable by the LED driving threads. The other three threads are used to instantiate a generic blinking function that drive a PIN where a LED is connected. tags:[Multi-Thread, First Steps, Analog Read ADC] groups:[First Steps] main.py ################################################################################ # Sensor Driven Multi-Blink # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ # This example requires an analog sensor and three LEDs import streams import adc # create a serial port stream with default parameters streams . serial () # set the A1 pin as analog input and D8, D9, D10 as outputs to drive the LEDs. pinMode ( A1 , INPUT_ANALOG ) pinMode ( D10 , OUTPUT ) pinMode ( D9 , OUTPUT ) pinMode ( D8 , OUTPUT ) # creates two arrays for storing global variables to be used in the blinking threads freq = [ 1 , 1 , 1 ] pin = [ D8 , D9 , D10 ] # define the generic blinking function to be used for driving the LEDs # this function takes as input the index identifying the LED, then uses the global freq and pin arrays to dynamically drive the LEDs def blink ( Npin ): while True : digitalWrite ( pin [ Npin ], HIGH ) sleep ( freq [ Npin ]) digitalWrite ( pin [ Npin ], LOW ) sleep ( freq [ Npin ]) # define an analog sensor sampling function that acquires the raw data and converts it to the three LED frequencies def sampling (): global freq while True : value = adc . read ( A1 ) freq [ 0 ] = value // 10 freq [ 1 ] = freq [ 0 ] * 2 freq [ 2 ] = freq [ 0 ] * 4 sleep ( 50 ) # launch the four threads thread ( sampling ) thread ( blink , 0 ) thread ( blink , 1 ) thread ( blink , 2 ) # The main loop is used only for printing out at reasonable speed the calculated frequencies in term of waiting times while True : print ( \"Wait times are\" , freq ) sleep ( 500 )","title":"Sensor driven Multi-Blink"},{"location":"reference/core/stdlib/docs/examples/#queues","text":"Simple producer/consumer example based on thread safe queues. main.py ################################################################################ # Queues # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import threading import streams import queue streams . serial () # create a bounded queue q = queue . Queue ( maxsize = 20 ) # keep producing an element every 100 millis def producer ( id ): while True : try : x = random ( 0 , 100 ) print ( \"producer\" , id , \"->\" , x ) q . put ( x ) except Exception as e : print ( e ) sleep ( 100 ) # keep consuming an element every 1 second def consumer ( id ): while True : try : print ( \"consumer\" , id , \"<-\" , q . get ()) except Exception as e : print ( e ) sleep ( 1000 ) # start everyone thread ( producer , 0 ) thread ( consumer , 1 ) thread ( consumer , 2 ) while True : isfull = q . full () print ( \"Queue is full?\" , isfull ) if isfull : # clear queue if full print ( \"Clearing queue\" ) q . clear () sleep ( 5000 )","title":"Queues"},{"location":"reference/core/stdlib/docs/examples/#interrupt-basics","text":"This example shows how to use interrupts for monitoring pin state changes. A button is used to connect a pin to ground when pressed. The pin is set as INPUT_PULLUP putting HIGH voltage on it while activated as digital input. It is possible to use onboard embedded button like in the case of ST Nucleo. Otherwise an external button can be connected to any digital pin available on the board and then to GND. In this case the pin number have to be changed with the pin used for connecting the button Note that the main loop (while True) is not present in this example. With ZERYNTH it is possible to write pure event driven code! tags: [First Steps, Interrupts, Digital I/O] groups:[First Steps] main.py ################################################################################ # Interrupt Basics # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams # create a serial port stream with default parameters streams . serial () # define where the button and the LED are connected # in this case BTN0 will be automatically configured according to the selected board button # change this definition to connect external buttons on any other digital pin buttonPin = BTN0 ledPin = LED0 # LED0 will be configured to the selected board led # configure the pin behaviour to drive the LED and to read from the button pinMode ( buttonPin , INPUT_PULLUP ) pinMode ( ledPin , OUTPUT ) # define the function to be called when the button is pressed def pressed (): print ( \"touched!\" ) digitalWrite ( ledPin , HIGH ) # just blink the LED for 100 millisec when the button is pressed sleep ( 100 ) digitalWrite ( ledPin , LOW ) # attach an interrupt on the button pin and call the pressed function when it falls # being BTN0 configured as pullup, when the button is pressed the signal goes to from HIGH to LOW. # opposite behaviour can be obtained with the equivalent \"rise\" interrupt function: onPinRise(pin,fun) # hint: onPinFall and onPinRise can be used together on the same pin, even with different functions onPinFall ( buttonPin , pressed )","title":"Interrupt Basics"},{"location":"reference/core/stdlib/docs/examples/#interrupt-advanced","text":"This example uses pwm to show the advanced feature of interrupt debouncing. PWM triggers fall and rise events at different speeds, but interrupts are triggered only if the debounce time (i.e. the stable time after and event) is in the correct range. main.py ################################################################################ # Interrupt Debounce # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ # import streams import streams # import pwm for testing import pwm # CONNECT pin D3 to PIN D2 for this example to work! streams . serial () def on_touch_up (): print ( \"touched UP\" ) def on_touch_dn (): print ( \"touched DN\" ) try : # D2 will call touch_up on rise and touch_dn on fall with different debounce times onPinRise ( D2 , on_touch_up , debounce = 500 ) onPinFall ( D2 , on_touch_dn , debounce = 300 ) except Exception as e : print ( e ) while True : for x in [ 100 , 200 , 300 , 400 , 500 , 600 , 700 , 800 , 900 ]: print ( \"--->\" , x , 1000 - x ) # start pwm on D3 with the current period pwm . write ( D3 . PWM , 1000 , x ) # now wait and check if debounce is working sleep ( 5000 )","title":"Interrupt Advanced"},{"location":"reference/core/stdlib/docs/examples/#exceptions-debugger-basic","text":"Basic example of how to use the ZERYNTH Exceptions class to monitor and analyze programs behavior without crashing the execution. The examples shows how a \"division by zero\" is identified in the code without causing any crash. In ZERYNTH exceptions reported on the IDE serial console can be opened and analyzed through the integrated debugger window. tags:[First Steps, Exceptions] groups:[First Steps] main.py ################################################################################ # Exception-Debugger Basics # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ############################################################################### import streams streams . serial () while True : for x in range ( - 10 , 10 , 1 ): # create a loop ranging on the integers between -10 and 10 try : # open the Exception monitoring scope value = 100 // x # when x=0 this will results in a DivisionByZero! print ( value ) except Exception as e : # capture any raised exception as e print ( e ) # print the content of e to monitor where the program is faulting # click on the console X icon to open the Zerynth debugger window sleep ( 1000 )","title":"Exceptions-Debugger Basic"},{"location":"reference/core/stdlib/docs/examples/#math-module","text":"Some fun with math functions main.py ############################################################################### # Math module # # Created by Zerynth Team 2017 CC # Authors: G. Baldi ############################################################################### import streams import math streams . serial () while True : # loop over angles in degrees print ( \"---> TRIGONOMETRY!\" ) for angle in range ( 0 , 360 * 3 , 10 ): # convert to radians r = math . radians ( angle ) # take the sin s = math . sin ( r ) # calculate offset... sl = int ( 40 * s ) # ...and print! if sl >= 0 : print ( \" \" * 40 , \"#\" * sl ) else : print ( \" \" * ( 40 + sl ), \"#\" * ( - sl )) sleep ( 50 ) sleep ( 1000 ) # loop from -5 to 0 in 0.05 increments print ( \"---> EXPONENTIALS\" ) x = - 5 incr = 0.05 while x < 0 : # take the exp... y = math . exp ( x ) # ...and print! print ( \"#\" * int ( y * 80 )) # do not forget to increment x x = x + incr sleep ( 50 ) sleep ( 1000 ) print ( \"---> ROOTS and POWERS\" ) # loop from 1 to 100 print ( \" a | b | c | math.sqrt(a*a*+b*b)\" ) print ( \"----------------------------------------\" ) for i in range ( 0 , 100 ): # let's generate and test Pythagorean Triples! # select n and m m = 1 n = 0 while m >= n : n = random ( 1 , 30 ) m = random ( 1 , 30 ) a = math . pow ( n , 2 ) - math . pow ( m , 2 ) b = 2 * m * n c = math . pow ( n , 2 ) + math . pow ( m , 2 ) a2 = math . pow ( a , 2 ) b2 = math . pow ( b , 2 ) p = math . sqrt ( a2 + b2 ) print ( \" %4.0f | %4.0f | %4.0f | %4.0f \" % ( a , b , c , p )) sleep ( 100 ) sleep ( 1000 )","title":"Math Module"},{"location":"reference/core/stdlib/docs/examples/#mini-web-server","text":"This example implements a very minimal web server by opening a TCP socket in listening mode, reading HTTP headers and sending out some HTML. It prints the IP to connect to in the serial console. Type it in your browser and test your mini web server! It uses the CC3000 wireless driver, however any network driver can be used changing only a few lines of code. main.py ############################################################################### # Mini Web Server # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ############################################################################### # import streams & socket import streams import socket # import the wifi interface from wireless import wifi # the wifi module needs a networking driver to be loaded # in order to control the board hardware. # FOR THIS EXAMPLE TO WORK, A NETWORK DRIVER MUST BE SELECTED BELOW # uncomment the following line to use the CC3000 driver (Particle Core or CC3000 Wifi shields) # from texas.cc3000 import cc3000 as wifi_driver # uncomment the following line to use the BCM43362 driver (Particle Photon) # from broadcom.bcm43362 import bcm43362 as wifi_driver streams . serial () # init the wifi driver! # The driver automatically registers itself to the wifi interface # with the correct configuration for the selected board wifi_driver . auto_init () # use the wifi interface to link to the Access Point # change network name, security and password as needed print ( \"Establishing Link...\" ) try : # FOR THIS EXAMPLE TO WORK, \"Network-Name\" AND \"Wifi-Password\" MUST BE SET # TO MATCH YOUR ACTUAL NETWORK CONFIGURATION wifi . link ( \"Network-Name\" , wifi . WIFI_WPA2 , \"Wifi-Password\" ) except Exception as e : print ( \"ooops, something wrong while linking :(\" , e ) while True : sleep ( 1000 ) # Yes! we are connected print ( \"Linked!\" ) # Let's print our ip, it will be needed soon info = wifi . link_info () print ( \"My IP is:\" , info [ 0 ]) # Now let's create a socket and listen for incoming connections on port 80 sock = socket . socket () sock . bind ( 80 ) sock . listen () while True : try : # Type in your browser the board ip! print ( \"Waiting for connection...\" ) # here we wait for a connection clientsock , addr = sock . accept () print ( \"Incoming connection from\" , addr ) # yes! a connection is ready to use # first let's create a SocketStream # it's like a serial stream, but with a socket underneath. # This way we can read and print to the socket client = streams . SocketStream ( clientsock ) # let's read all the HTTP headers from the browser # stop when a blank line is received line = client . readline () while line != \" \\n \" and line != \" \\r\\n \" : line = client . readline () print ( \"HTTP request received!\" ) # let's now send our headers (very minimal) # hint: \\n is added by print print ( \"HTTP/1.1 200 OK \\r \" , stream = client ) print ( \"Content-Type: text/html \\r \" , stream = client ) print ( \"Connection: close \\r\\n\\r \" , stream = client ) # see? as easy as print! print ( \"<html><body>Hello Zerynth!\" , random ( 0 , 100 ), \"</body></html>\" , stream = client ) # close connection and go waiting for another one client . close () except Exception as e : print ( \"ooops, something wrong:\" , e )","title":"Mini Web Server"},{"location":"reference/core/stdlib/docs/examples/#zerynth-udp-pinger","text":"This example demonstrates the use of UDP sockets. A writer thread sends UDP broadcast packets while a reader threads catches them. Uplink this script on more than one board for some pinger fun! main.py ################################################################################ # Zerynth UDP pinger # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ # import streams & socket import streams import socket # import the wifi interface from wireless import wifi # the wifi module needs a networking driver to be loaded # in order to control the board hardware. # FOR THIS EXAMPLE TO WORK, A NETWORK DRIVER MUST BE SELECTED BELOW # uncomment the following line to use the CC3000 driver (Particle Core or CC3000 Wifi shields) # from texas.cc3000 import cc3000 as wifi_driver # uncomment the following line to use the BCM43362 driver (Particle Photon) # from broadcom.bcm43362 import bcm43362 as wifi_driver streams . serial () # init the wifi driver! # The driver automatically registers itself to the wifi interface # with the correct configuration for the selected board wifi_driver . auto_init () # use the wifi interface to link to the Access Point # change network name, security and password as needed print ( \"Establishing Link...\" ) try : # FOR THIS EXAMPLE TO WORK, \"Network-Name\" AND \"Wifi-Password\" MUST BE SET # TO MATCH YOUR ACTUAL NETWORK CONFIGURATION wifi . link ( \"Network-Name\" , wifi . WIFI_WPA2 , \"Wifi-Password\" ) # get our ip myip = wifi . link_info ()[ 0 ] # convert myip to a tuple with the socket.ip_to_tuple function # \"x.y.z.w\" becomes (x,y,z,w) ip_tuple = socket . ip_to_tuple ( myip ) # generate a broadcast address to port 9999 # (it's ok and easier to generate it as a 5 number tuple) broadcast = ( ip_tuple [ 0 ], ip_tuple [ 1 ], ip_tuple [ 2 ], 255 , 9999 ) print ( myip , ip_tuple , broadcast ) # create an UDP socket and bind it to port 9999 sock = socket . socket ( type = socket . SOCK_DGRAM ) sock . bind ( 9999 ) except Exception as e : print ( \"ooops, something wrong while linking :(\" , e ) while True : sleep ( 1000 ) # this function will be used as a thread # sending every 2 seconds a message to all # the udp sockets listening on port 9999 def ping (): while True : print ( \"Sending\" ) sock . sendto ( \"Hello Zerynth!\" , broadcast ) sleep ( 2000 ) # launch it! thread ( ping ) # in the main thread we listen for incoming udp packets while True : print ( \"Receiving pings\" ) try : # recvfrom returns both the packet data and the address of the sender data , address = sock . recvfrom ( 32 ) # since we bind to 9999 we also receive the packets we sent # check for it by comparing just the ip address (without the port) if address [ 0 ] != myip : print ( \"Received ping from\" , address , \"=>\" , str ( data )) else : print ( \"Received ping from myself!\" ) except Exception as e : print ( e ) # uplink this script to more than one board and check","title":"ZERYNTH UDP pinger"},{"location":"reference/core/stdlib/docs/examples/#udp-ntp-time","text":"This example uses UDP socket to make client requests to an NTP server. The received timestamp is printed on the serial console in a human-readable form. main.py # UDP NTP Time # Created at 2019-02-19 08:07:55.144570 import streams import socket # import the wifi interface from wireless import wifi # the wifi module needs a networking driver to be loaded # in order to control the board hardware. # This example can be used as is with ESP32 based devices from espressif.esp32net import esp32wifi as wifi_driver def ntc_ts_to_datetime ( t ): # convert NTP timestamp (seconds since January 1st 1900) to datetime formatted string # YYYY-mm-dd HH:MM:SS ts = t - 2208988800 s = ts % 60 ts //= 60 m = ts % 60 ts //= 60 h = ts % 24 ts //= 24 a = ( 4 * ts + 102032 ) // 146097 + 15 b = ( ts + 2442113 + a - ( a // 4 )) c = ( 20 * b - 2442 ) // 7305 d = b - 365 * c - ( c // 4 ) e = d * 1000 // 30601 f = d - e * 30 - e * 601 // 1000 if e <= 13 : c -= 4716 e -= 1 else : c -= 4715 e -= 13 Y = c M = e D = f return \" %d - %02d - %02d %02d : %02d : %02d \" % ( Y , M , D , h , m , s ) try : streams . serial () # init the wifi driver! # The driver automatically registers itself to the wifi interface # with the correct configuration for the selected board wifi_driver . auto_init () # use the wifi interface to link to the Access Point # change network name, security and password as needed print ( \"Establishing WiFi Link...\" ) for retry in range ( 5 ): try : # FOR THIS EXAMPLE TO WORK, \"Network-Name\" AND \"Wifi-Password\" MUST BE SET # TO MATCH YOUR ACTUAL NETWORK CONFIGURATION wifi . link ( \"Network-Name\" , wifi . WIFI_WPA2 , \"Wifi-Password\" ) print ( \"...done!\" ) break except Exception as e : pass else : print ( \":( can't connect to wifi\" ) raise IOError # create an UDP socket and set a timeout of 1 second sock = socket . socket ( type = socket . SOCK_DGRAM ) sock . settimeout ( 1000 ) # create an NTP request packet pkt = bytearray ([ 0 ] * 48 ) pkt [ 0 ] = 0x1B while True : try : # resolve the NTP server hostname to get its IP address ip_string = wifi . gethostbyname ( \"0.pool.ntp.org\" ) ip = socket . ip_to_tuple ( ip_string ) # create a tuple containing NTP server ip address and port addr = ( ip [ 0 ], ip [ 1 ], ip [ 2 ], ip [ 3 ], 123 ) print ( \"Sending NTP request to %s : %d \" % ( ip_string , 123 )) # send the NTP request packet to the NTP server sock . sendto ( pkt , addr ) # read the response from the server res = sock . recv ( 48 ) # extract the \"transmit timestamp\" field from the received packet ts = ( res [ 40 ] << 24 ) | ( res [ 41 ] << 16 ) | ( res [ 42 ] << 8 ) | res [ 43 ] # convert NTP timestamp to human readable datetime print ( \" >\" , ntc_ts_to_datetime ( ts )) print ( \" \" ) except Exception as e : print ( \" >\" , e ) sleep ( 10000 ) except Exception as e : print ( e )","title":"UDP NTP Time"},{"location":"reference/core/stdlib/docs/examples/#zerynth-wifi-scan","text":"This example explains how to scan for wifi networks. main.py ################################################################################ # Zerynth wifi scan # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ # import streams & socket import streams import socket # import the wifi interface from wireless import wifi # the wifi module needs a networking driver to be loaded # in order to control the board hardware. # FOR THIS EXAMPLE TO WORK, A NETWORK DRIVER MUST BE SELECTED BELOW # uncomment the following line to use the CC3000 driver (Particle Core or CC3000 Wifi shields) # from texas.cc3000 import cc3000 as wifi_driver # uncomment the following line to use the BCM43362 driver (Particle Photon) # from broadcom.bcm43362 import bcm43362 as wifi_driver streams . serial () # init the wifi driver! # The driver automatically registers itself to the wifi interface # with the correct configuration for the selected board wifi_driver . auto_init () # a list of security strings wifi_sec = [ \"Open\" , \"WEP\" , \"WPA\" , \"WPA2\" ] try : print ( \"Scanning for 15 seconds...\" ) # start scanning for 15000 milliseconds res = wifi . scan ( 15000 ) # if everything goes well, res is a sequence of tuples # each tuple contains: # -ssid: the name of the network # -sec: the security type of the network, from 0 to 3 # -rssi: the strength of the signal, from 0 to 127 # -bssid: the mac address of the access point for ssid , sec , rssi , bssid in res : print ( ssid , \"::\" , wifi_sec [ sec ], \":: strength \" , rssi * 100 / 127 ) except Exception as e : print ( e )","title":"ZERYNTH wifi scan"},{"location":"reference/core/stdlib/docs/examples/#zerynth-time-api","text":"This example connects via HTTP to timeapi.org to get the current UTC time main.py ################################################################################ # Zerynth Time API # # Created: 2015-08-17 16:44:58.640097 # ################################################################################ # import streams import streams import json # import the wifi interface from wireless import wifi # import the http module import requests # the wifi module needs a networking driver to be loaded # in order to control the board hardware. # THIS EXAMPLE IS SET TO WORK WITH BCM43362 WIFI DRIVER # uncomment the following line to use the espressif esp8266 wifi driver (NodeMcu v2, Adafruit Feather Huzzah, Wemos d1 Mini, ...) # from espressif.esp8266wifi import esp8266wifi as wifi_driver # uncomment the following line to use the BCM43362 driver (Particle Photon) from broadcom.bcm43362 import bcm43362 as wifi_driver # uncomment the following line to use the ESP32 driver (Sparkfun Esp32 Thing, Olimex Esp32, ...) # from espressif.esp32net import esp32wifi as wifi_driver streams . serial () # init the wifi driver! # The driver automatically registers itself to the wifi interface # with the correct configuration for the selected board wifi_driver . auto_init () # use the wifi interface to link to the Access Point # change network name, security and password as needed print ( \"Establishing Link...\" ) try : # FOR THIS EXAMPLE TO WORK, \"Network-Name\" AND \"Wifi-Password\" MUST BE SET # TO MATCH YOUR ACTUAL NETWORK CONFIGURATION wifi . link ( \"Network-Name\" , wifi . WIFI_WPA2 , \"Wifi-Password\" ) except Exception as e : print ( \"ooops, something wrong while linking :(\" , e ) while True : sleep ( 1000 ) ## let's try to connect to timeapi.org to get the current UTC time for i in range ( 3 ): try : print ( \"Trying to connect...\" ) # go get that time! # url resolution and http protocol handling are hidden inside the requests module response = requests . get ( \"http://now.zerynth.com/\" ) # let's check the http response status: if different than 200, something went wrong print ( \"Http Status:\" , response . status ) # if we get here, there has been no exception, exit the loop break except Exception as e : print ( e ) try : # check status and print the result #if response.status==200: print ( \"Success!!\" ) print ( \"-------------\" ) print ( \"And the result is:\" , response . content ) print ( \"-------------\" ) js = json . loads ( response . content ) print ( \"Date:\" , js [ \"now\" ][ \"rfc2822\" ][: 16 ]) print ( \"Time:\" , js [ \"now\" ][ \"rfc2822\" ][ 17 :]) except Exception as e : print ( \"ooops, something very wrong! :(\" , e )","title":"ZERYNTH Time API"},{"location":"reference/core/stdlib/docs/examples/#zerynth-weather","text":"This example connects to openweathermap.org, queries for weather conditions and prints the result. main.py ################################################################################ # Zerynth Weather # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ # import streams & socket import streams import socket # import json parser, will be needed later import json # import the wifi interface from wireless import wifi # import the http module import requests # the wifi module needs a networking driver to be loaded # in order to control the board hardware. # THIS EXAMPLE IS SET TO WORK WITH ESP8266 WIFI DRIVER # uncomment the following line to use the espressif esp8266 wifi driver (NodeMcu v2, Adafruit Feather Huzzah, Wemos d1 Mini, ...) from espressif.esp8266wifi import esp8266wifi as wifi_driver # uncomment the following line to use the BCM43362 driver (Particle Photon) # from broadcom.bcm43362 import bcm43362 as wifi_driver # uncomment the following line to use the ESP32 driver (Sparkfun Esp32 Thing, Olimex Esp32, ...) # from espressif.esp32net import esp32wifi as wifi_driver streams . serial () # init the wifi driver! # The driver automatically registers itself to the wifi interface # with the correct configuration for the selected board wifi_driver . auto_init () # use the wifi interface to link to the Access Point # change network name, security and password as needed print ( \"Establishing Link...\" ) try : # FOR THIS EXAMPLE TO WORK, \"Network-Name\" AND \"Wifi-Password\" MUST BE SET # TO MATCH YOUR ACTUAL NETWORK CONFIGURATION wifi . link ( \"Network-Name\" , wifi . WIFI_WPA2 , \"Wifi-Password\" ) except Exception as e : print ( \"ooops, something wrong while linking :(\" , e ) while True : sleep ( 1000 ) # let's try to connect to openweathermap.org to get some weather info # for this example to work you need a openweathermap API key # if you don't have one, you can get one for free here: http://openweathermap.org/price # type here your API key! # or you can use ours...however, if our calls quota is exceded # the example won't work :( api_key = \"bd4ba90e2b397e24a925e436a9d8fed9\" for i in range ( 3 ): try : print ( \"Trying to connect...\" ) # to get weather info you need to specify a correct api url # there are a lot of different urls with different functions # they are all documented here http://openweathermap.org/api # let's put the http query parameters in a dict params = { \"APPID\" : api_key , \"q\" : \"Pisa\" # <----- here it goes your city } # the following url gets weather information in json based on the name of the city url = \"http://api.openweathermap.org/data/2.5/weather\" # url resolution and http protocol handling are hidden inside the requests module response = requests . get ( url , params = params ) # if we get here, there has been no exception, exit the loop break except Exception as e : print ( e ) try : # check status and print the result if response . status == 200 : print ( \"Success!!\" ) print ( \"-------------\" ) # it's time to parse the json response js = json . loads ( response . content ) # super easy! print ( \"Weather:\" , js [ \"weather\" ][ 0 ][ \"description\" ], js [ \"main\" ][ \"temp\" ] - 273 , \"degrees\" ) print ( \"-------------\" ) except Exception as e : print ( \"ooops, something very wrong! :(\" , e )","title":"ZERYNTH Weather"},{"location":"reference/core/stdlib/docs/examples/#http-methods","text":"This example connects via HTTP to httpbin.org and tests each Zerynth supported HTTP method main.py ################################################################################ # Zerynth HTTP Methods # # Created: 2017-09-19 12:35:25.155721 # Authors: M. Cipriani ################################################################################ # import streams import streams import json # import the wifi interface from wireless import wifi # import the http module import requests # the wifi module needs a networking driver to be loaded # in order to control the board hardware. # THIS EXAMPLE IS SET TO WORK WITH ESP32 WIFI DRIVER # uncomment the following line to use the espressif esp8266 wifi driver (NodeMcu v2, Adafruit Feather Huzzah, Wemos d1 Mini, ...) # from espressif.esp8266wifi import esp8266wifi as wifi_driver # uncomment the following line to use the BCM43362 driver (Particle Photon) # from broadcom.bcm43362 import bcm43362 as wifi_driver # uncomment the following line to use the ESP32 driver (Sparkfun Esp32 Thing, Olimex Esp32, ...) from espressif.esp32net import esp32wifi as wifi_driver streams . serial () # init the wifi driver! # The driver automatically registers itself to the wifi interface # with the correct configuration for the selected board wifi_driver . auto_init () # use the wifi interface to link to the Access Point # change network name, security and password as needed print ( \"Establishing Link...\" ) try : # FOR THIS EXAMPLE TO WORK, \"Network-Name\" AND \"Wifi-Password\" MUST BE SET # TO MATCH YOUR ACTUAL NETWORK CONFIGURATION wifi . link ( \"Zerynth\" , wifi . WIFI_WPA2 , \"zerynthwifi\" ) except Exception as e : print ( \"ooops, something wrong while linking :(\" , e ) while True : sleep ( 1000 ) url = \"http://httpbin.org/\" tests = [ { \"title\" : \"Testing GET Method...\" , \"method\" : requests . get , \"url\" : url + \"get\" , \"params\" : { \"test\" : \"query_string\" } }, { \"title\" : \"Testing POST Method...\" , \"method\" : requests . post , \"url\" : url + \"post\" , \"json\" : { \"test\" : \"json_data\" } }, { \"title\" : \"Testing PUT Method...\" , \"method\" : requests . put , \"url\" : url + \"put\" , \"data\" : { \"test\" : \"urlencoded_data\" } }, { \"title\" : \"Testing PATCH Method...\" , \"method\" : requests . patch , \"url\" : url + \"patch\" , \"data\" : { \"test\" : \"urlencoded_data\" } }, { \"title\" : \"Testing DELETE Method...\" , \"method\" : requests . delete , \"url\" : url + \"delete\" , }, { \"title\" : \"Testing HEAD Method...\" , \"method\" : requests . head , \"url\" : url + \"get\" , }, { \"title\" : \"Testing OPTIONS Method...\" , \"method\" : requests . options , \"url\" : url + \"get\" , } ] print ( \"---------------------------------\" ) for test in tests : try : print ( test [ \"title\" ]) if \"params\" in test : response = test [ \"method\" ]( test [ \"url\" ], params = test [ \"params\" ]) elif \"json\" in test : response = test [ \"method\" ]( test [ \"url\" ], json = test [ \"json\" ]) elif \"data\" in test : response = test [ \"method\" ]( test [ \"url\" ], data = test [ \"data\" ]) else : response = test [ \"method\" ]( test [ \"url\" ]) print ( \"Http Status:\" , response . status ) print ( \"Http Headers:\" , response . headers ) print ( \"Http Content:\" , response . content ) print ( \"---------------------------------\" ) response = None except Exception as e : print ( e ) sleep ( 2000 )","title":"HTTP Methods"},{"location":"reference/core/stdlib/docs/examples/#secure-http","text":"This example connects to https://howsmyssl.com/a/check and displays info about the SSL/TLS connection main.py ################################################################################ # Zerynth Secure Sockets # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams import json # import the wifi interface from wireless import wifi # import the http module import requests import ssl # the wifi module needs a networking driver to be loaded # in order to control the board hardware. # This example can be used as is with ESP32 based devices from espressif.esp32net import esp32wifi as wifi_driver streams . serial () # init the wifi driver! # The driver automatically registers itself to the wifi interface # with the correct configuration for the selected board wifi_driver . auto_init () # use the wifi interface to link to the Access Point # change network name, security and password as needed print ( \"Establishing Link...\" ) try : # FOR THIS EXAMPLE TO WORK, \"Network-Name\" AND \"Wifi-Password\" MUST BE SET # TO MATCH YOUR ACTUAL NETWORK CONFIGURATION wifi . link ( \"Network-Name\" , wifi . WIFI_WPA2 , \"Wifi-Password\" ) except Exception as e : print ( \"ooops, something wrong while linking :(\" , e ) while True : sleep ( 1000 ) # let's try to connect to https://www.howsmyssl.com/a/check to get some info # on the SSL/TLS connection # retrieve the CA certificate used to sign the howsmyssl.com certificate cacert = __lookup ( SSL_CACERT_DST_ROOT_CA_X3 ) # create a SSL context to require server certificate verification ctx = ssl . create_ssl_context ( cacert = cacert , options = ssl . CERT_REQUIRED | ssl . SERVER_AUTH ) # NOTE: if the underlying SSL driver does not support certificate validation # uncomment the following line! # ctx = None for i in range ( 3 ): try : print ( \"Trying to connect...\" ) url = \"https://www.howsmyssl.com/a/check\" # url resolution and http protocol handling are hidden inside the requests module user_agent = { \"User-Agent\" : \"curl/7.53.1\" , \"Accept\" : \"*/*\" } # pass the ssl context together with the request response = requests . get ( url , headers = user_agent , ctx = ctx ) # if we get here, there has been no exception, exit the loop break except Exception as e : print ( e ) try : # check status and print the result if response . status == 200 : print ( \"Success!!\" ) print ( \"-------------\" ) # it's time to parse the json response js = json . loads ( response . content ) # super easy! for k , v in js . items (): if k == \"given_cipher_suites\" : print ( \"Supported Ciphers\" ) for cipher in v : print ( cipher ) print ( \"-----\" ) else : print ( k , \"::\" , v ) print ( \"-------------\" ) except Exception as e : print ( \"ooops, something very wrong! :(\" , e )","title":"Secure HTTP"},{"location":"reference/core/stdlib/docs/examples/#ntpclient","text":"A simple example showing how to obtain a timestamp from an NTP server and how to convert it to UTC datetime. main.py ################################################################################ # NTPClient using UDP # # Created: 2019-06-16 # Author: L. Marsicano ################################################################################ import streams import ntpclient streams . serial () # import the wifi interface from wireless import wifi # the wifi module needs a networking driver to be loaded # in order to control the board hardware. # This example can be used as is with ESP32 based devices from espressif.esp32net import esp32wifi as wifi_driver def ntc_ts_to_datetime ( t ): ts = t - 2208988800 s = ts % 60 ts //= 60 m = ts % 60 ts //= 60 h = ts % 24 ts //= 24 a = ( 4 * ts + 102032 ) // 146097 + 15 b = ( ts + 2442113 + a - ( a // 4 )) c = ( 20 * b - 2442 ) // 7305 d = b - 365 * c - ( c // 4 ) e = d * 1000 // 30601 f = d - e * 30 - e * 601 // 1000 if e <= 13 : c -= 4716 e -= 1 else : c -= 4715 e -= 13 Y = c M = e D = f return \" %d - %02d - %02d %02d : %02d : %02d \" % ( Y , M , D , h , m , s ) try : wifi_driver . auto_init () for i in range ( 0 , 5 ): try : # Change this line to match your network configuration wifi . link ( \"SSID\" , wifi . WIFI_WPA2 , \"PASSWORD\" ) break except Exception as e : print ( e ) sleep ( 500 ) else : print ( \"Could not link :(\" ) raise IOError client = ntpclient . NTPClient ( wifi_driver ) t = client . get_time () print ( \"Time is\" , t ) print ( \"Converted time is:\" , ntc_ts_to_datetime ( t )) except Exception as e : print ( e )","title":"NTPClient"},{"location":"reference/core/stdlib/docs/examples/#secure-http_1","text":"This example connects to https://howsmyssl.com/a/check and displays info about the SSL/TLS connection main.py ################################################################################ # Zerynth Secure Sockets # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams import json # import the wifi interface from wireless import wifi # import the http module import requests import ssl # the wifi module needs a networking driver to be loaded # in order to control the board hardware. # This example can be used as is with ESP32 based devices from espressif.esp32net import esp32wifi as wifi_driver streams . serial () # init the wifi driver! # The driver automatically registers itself to the wifi interface # with the correct configuration for the selected board wifi_driver . auto_init () # use the wifi interface to link to the Access Point # change network name, security and password as needed print ( \"Establishing Link...\" ) try : # FOR THIS EXAMPLE TO WORK, \"Network-Name\" AND \"Wifi-Password\" MUST BE SET # TO MATCH YOUR ACTUAL NETWORK CONFIGURATION wifi . link ( \"Network-Name\" , wifi . WIFI_WPA2 , \"Wifi-Password\" ) except Exception as e : print ( \"ooops, something wrong while linking :(\" , e ) while True : sleep ( 1000 ) # let's try to connect to https://www.howsmyssl.com/a/check to get some info # on the SSL/TLS connection # retrieve the CA certificate used to sign the howsmyssl.com certificate cacert = __lookup ( SSL_CACERT_DST_ROOT_CA_X3 ) # create a SSL context to require server certificate verification ctx = ssl . create_ssl_context ( cacert = cacert , options = ssl . CERT_REQUIRED | ssl . SERVER_AUTH ) # NOTE: if the underlying SSL driver does not support certificate validation # uncomment the following line! # ctx = None for i in range ( 3 ): try : print ( \"Trying to connect...\" ) url = \"https://www.howsmyssl.com/a/check\" # url resolution and http protocol handling are hidden inside the requests module user_agent = { \"User-Agent\" : \"curl/7.53.1\" , \"Accept\" : \"*/*\" } # pass the ssl context together with the request response = requests . get ( url , headers = user_agent , ctx = ctx ) # if we get here, there has been no exception, exit the loop break except Exception as e : print ( e ) try : # check status and print the result if response . status == 200 : print ( \"Success!!\" ) print ( \"-------------\" ) # it's time to parse the json response js = json . loads ( response . content ) # super easy! for k , v in js . items (): if k == \"given_cipher_suites\" : print ( \"Supported Ciphers\" ) for cipher in v : print ( cipher ) print ( \"-----\" ) else : print ( k , \"::\" , v ) print ( \"-------------\" ) except Exception as e : print ( \"ooops, something very wrong! :(\" , e )","title":"Secure HTTP"},{"location":"reference/core/stdlib/docs/examples/#rtc-keep-time","text":"This example downloads a time reference for the Real-Time Clock from the Internet and retrieves updated time from the RTC itself for subsequent use. main.py ################################################################################ # RTC Keep Time # # Created by Zerynth Team 2018 CC # Authors: G. Baldi, L. Rizzello ################################################################################ import streams import json import requests from wireless import wifi # import a wifi driver to connect and retrieve base timestamp from espressif.esp32net import esp32wifi as wifi_driver # import Real-Time Clock module import rtc def get_epoch (): user_agent = { \"user-agent\" : \"curl/7.56.0\" } return int ( json . loads ( requests . get ( \"http://now.zerynth.com/\" , headers = user_agent ) . content )[ 'now' ][ 'epoch' ]) streams . serial () wifi_driver . auto_init () print ( 'connecting to wifi...' ) try : wifi . link ( \"SSID\" , wifi . WIFI_WPA2 , \"PSW\" ) except Exception as e : print ( \"ooops, something wrong while linking :(\" , e ) while True : sleep ( 1000 ) timestamp = get_epoch () rtc . set_utc ( timestamp ) while True : tm = rtc . get_utc () print ( tm . tv_seconds ) print ( tm . tm_year , '/' , tm . tm_month , '/' , tm . tm_mday , sep = '' ) print ( tm . tm_hour , ':' , tm . tm_min , ':' , tm . tm_sec , sep = '' ) sleep ( 1000 )","title":"RTC Keep Time"},{"location":"reference/core/stdlib/docs/examples/#zerynth-resources","text":"This example explains the use of flash resources. main.py ################################################################################ # Zerynth Resources # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams streams . serial () # new_resource is a builtin that includes the file specified # in the generated bytecode # remember: the file used as a resource must be added to the project! new_resource ( \"mytxt.txt\" ) # to open resources saved by new_resource # a specific url must be passed to open # once opened, methods like read, readline and seek can be used! ff = open ( \"resource://mytxt.txt\" ) print ( \"Opening resource...\" ) while True : # let's read line by line and print line = ff . readline () # if line is empty, we are at the end of file if not line : break print ( \"Line:\" , line ) # easy! print ( \"Done!\" )","title":"ZERYNTH Resources"},{"location":"reference/core/stdlib/docs/examples/#struct-example","text":"Test pack and unpack methods with different formats main.py ################################################################################ # struct # # Created by Zerynth Team 2017 CC # Authors: G. Baldi, M. Cipriani ################################################################################ import streams import struct streams . serial () def print_res ( b ): print ( \"Pack --> \\n \" , end = \"\" ) for x in b : print ( hex ( x , prefix = \"\" ), end = \"\" ) print ( \"\" ) try : print ( \"Create pack for 0x01020304 in >xl format\" ) b = struct . pack ( \">xl\" , 0x01020304 ) u = struct . unpack ( \">xl\" , b ) print_res ( b ) print ( \"Unpack --> \\n \" , hex ( u [ 0 ])) print ( \"-------------------------------------------------\" ) print ( \"Create pack for a in 10s format\" ) b = struct . pack ( \"10s\" , \"a\" ) u = struct . unpack ( \"10s\" , b ) print_res ( b ) print ( \"Unpack --> \\n \" , u [ 0 ]) print ( \"-------------------------------------------------\" ) print ( \"Create pack for a in 10p format\" ) b = struct . pack ( \"10p\" , \"a\" ) u = struct . unpack ( \"10p\" , b ) print_res ( b ) print ( \"Unpack --> \\n \" , u [ 0 ]) print ( \"-------------------------------------------------\" ) print ( \"Create pack for (1,2,3.0) in blf format\" ) b = struct . pack ( \"blf\" , 1 , 2 , 3.0 ) u = struct . unpack ( \"blf\" , b ) print_res ( b ) print ( \"Unpack --> \\n \" , u ) print ( \"-------------------------------------------------\" ) print ( \"Create pack for (-1,9,1.2) in =hlf format\" ) b = struct . pack ( \"=hlf\" , - 1 , 9 , 1.2 ) u = struct . unpack ( \"=hlf\" , b ) print_res ( b ) print ( \"Unpack --> \\n \" , u ) print ( \"-------------------------------------------------\" ) print ( \"Create pack for (127,10,5.5) in =blf format\" ) b = struct . pack ( \"=blf\" , 127 , 10 , 5.5 ) u = struct . unpack ( \"=blf\" , b ) print_res ( b ) print ( \"Unpack --> \\n \" , u ) except Exception as e : print ( e ) while True : print ( \".\" ) sleep ( 1000 )","title":"Struct Example"},{"location":"reference/core/stdlib/docs/examples/#flash-internal","text":"Writing and reading internal flash files. main.py ################################################################################ # iflash # # Created: 2016-03-22 15:54:21.232663 # ################################################################################ import streams import json import flash ## Warning! This example works on the Particle Photon only! # You need to change the flash address to use another board # --> For Sam3X based boards you can safely use 0xe0000 streams . serial () print ( \"create flash file\" ) # open a 512 bytes FlashFileStream at address 0x80E0000 ff = flash . FlashFileStream ( 0x80E0000 , 512 ) print ( \"reading flash file\" ) for i in range ( 30 ): print ( i , \"->\" , str ( ff [ i ])) print ( \"writing flash file\" ) sleep ( 1000 ) hh = { \"type\" : \"thing\" , \"data\" : 23.5 } ds = json . dumps ( hh ) # save length and json to flash ff . write ( len ( ds )) ff . write ( ds ) ff . flush () ff . seek ( 0 , streams . SEEK_SET ) print ( \"reading flash file\" ) n = ff . read_int () for i in range ( n + 4 ): print ( i , \"->\" , str ( ff [ i ]))","title":"Flash Internal"},{"location":"reference/core/stdlib/docs/examples/#spi-flash","text":"An example of how to use the spiflash library to read Spi Flash chips. main.py ################################################################################ # SpiFlash Example # # Created: 2016-04-21 19:16:44.440555 # ################################################################################ import spiflash import streams streams . serial () my_flash = spiflash . SpiFlash ( SPI0 , D25 ) my_flash . erase_sector ( 0x30122 ) to_w = [ 235 , 166 , 128 , 124 , 65 , 66 ] # write data through bracket notation my_flash [ 0x30122 ] = to_w print ( \"---\" ) # read 8 bytes starting from 0x30122 address for x in my_flash . read_data ( 0x30122 , 8 ): print ( x ) print ( \"---\" ) # read the same 8 bytes through bracket notation for x in my_flash [ 0x30123 : 0x30123 + 8 ]: print ( x ) print ( \"---\" )","title":"Spi Flash"},{"location":"reference/core/stdlib/docs/examples/#qspi-flash","text":"An example of how to use the qspiflash library to read QSpi Flash chips. main.py ################################################################################ # QSpiFlash Example # ################################################################################ import qspiflash import streams streams . serial () my_flash = qspiflash . QSpiFlash () my_flash . erase_block ( 0 ) to_w = b ' \\x77\\x76\\x75\\x74\\x73\\x72 ' # write data through bracket notation my_flash [ 0 ] = to_w print ( \"---\" ) # read 8 bytes starting from 0 address for x in my_flash . read_data ( 0 , 8 ): print ( ' %02x ' % x ) print ( \"---\" ) # read the same 8 bytes through bracket notation for x in my_flash [ 1 : 1 + 8 ]: print ( ' %02x ' % x ) print ( \"---\" )","title":"QSpi Flash"},{"location":"reference/core/stdlib/docs/examples/#spi-sd","text":"An example of how to use spisd libray to read SD cards block by block. main.py ################################################################################ # SpiSD Example # # Created: 2016-04-29 12:37:53.316436 # ################################################################################ import spisd import streams streams . serial () my_sd = spisd . SpiSD ( SPI0 , D25 ) data = bytearray ( 512 * 2 ) for i in range ( 512 * 2 ): data [ i ] = 166 # write 512 bytes of data starting from 3rd block my_sd . write_data ( 3 , data ) # read 512*3 bytes of data starting from 3rd block for i , x in enumerate ( my_sd . read_data ( 3 , 3 )): print ( hex ( 0x200 * 3 + i ), \": \" , x )","title":"Spi SD"},{"location":"reference/core/stdlib/docs/examples/#filesystem","text":"A simple example to show the filesystem support in Zerynth (FATFS on SD with SPI) main.py import streams import fatfs # import driver module import os # import file/directory management module streams . serial () # mount my SD card as volume 0 through SPI protocol fatfs . mount ( '0:' , { \"drv\" : SPI0 , \"cs\" : D25 , \"clock\" : 1000000 } ) # mount my SD card as volume 0 trough SD mode # (be careful in choosing frequency (kHz) and bits supported by your board) # fatfs.mount('0:', {\"drv\": SD1, \"freq_khz\": 20000, \"bits\": 1}) # create \"zerynth.txt\" file and open it for read/write operations ww = os . open ( '0:zerynth.txt' , 'w+' ) # write a string on it, flushing data immediately (not waiting for file to be closed) ww . write ( \"Zerynth allows me to easily manage files, cool.\" , sync = True ) # ops, I forgot what I wrote... # not a real problem problem using Zerynth # back to the start ww . seek ( 0 ) print ( \"I wrote: \" , ww . read ()) ww . close () # files and directories in root folder? print ( os . listdir ( '.' )) # a folder for zerynth stuff is needed if not os . exists ( \"0:zerynth_stuff\" ): os . mkdir ( \"0:zerynth_stuff\" ) # copy my cool file os . copyfile ( \"zerynth.txt\" , \"zerynth_stuff/zerynth_cool.txt\" ) os . chdir ( \"0:zerynth_stuff\" ) # check if anything went wrong print ( \"in \" , os . getcwd ()) print ( os . listdir ( '.' )) print ( \"SUCCESS!\" )","title":"Filesystem"},{"location":"reference/core/stdlib/docs/examples/#mcu-reset","text":"A simple example showing how to soft reset the microcontroller from Python. main.py ############################################################################### # MCU Reset # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ############################################################################### # import the mcu module import mcu import streams # open the default serial port, the output will be visible in the serial console streams . serial () resetting = False # define a simple function to be called on interrupt def reset (): global resetting resetting = True # on button pressed, call reset # >>>> if the board hasn't a button, change BTN0 to a digital pin # and use a jumper wire to simulate a falling edge <<<< onPinFall ( BTN0 , reset ) # loop forever while True : print ( \"Hello Zerynth!\" ) sleep ( 1000 ) # check for the need to reset if resetting : print ( \"Resetting in 3 seconds!!\" ) sleep ( 3000 ) mcu . reset () # bye!","title":"MCU Reset"},{"location":"reference/core/stdlib/docs/examples/#c-interface","text":"This advanced example shows how to call C functions from Python. main.py ################################################################################ # C Interface # # Created: 2016-01-17 10:06:10.333915 # ################################################################################ import streams streams . serial () # define a Python function decorated with c_native. # This function has no body and will instead call # the C function specified in the decorator. # The source file(s) where to find the C function must be given (cdiv.c) @c_native ( \"_my_c_function\" ,[ \"cdiv.c\" ],[]) def c_division ( a , b ): pass while True : a = random ( 0 , 100 ) b = random ( 0 , 10 ) try : # call the c_division function with random values c = c_division ( a , b ) print ( a , \"/\" , b , \"=\" , c ) except Exception as e : print ( e ) sleep ( 1000 )","title":"C Interface"},{"location":"reference/core/stdlib/docs/examples/#secure-hash-functions","text":"A simple example to introduce Secure Hashes of the crypto module main.py ################################################################################ # Secure Hash # # Created by Zerynth Team 2017 CC # Authors: G.Baldi ################################################################################ import streams # import all supported hash functions from crypto.hash import md5 as md5 from crypto.hash import sha1 as sha1 from crypto.hash import sha2 as sha2 from crypto.hash import sha3 as sha3 from crypto.hash import keccak as keccak # also import HMAC from crypto.hash import hmac as hmac # open stdout streams . serial () message = \"Zerynth\" while True : try : ss = md5 . MD5 () ss . update ( message ) print ( \"MD5: \" , ss . hexdigest ()) ss = sha1 . SHA1 () ss . update ( message ) print ( \"SHA1:\" , ss . hexdigest ()) ss = sha2 . SHA2 ( sha2 . SHA512 ) ss . update ( message ) print ( \"SHA2:\" , ss . hexdigest ()) ss = sha3 . SHA3 () ss . update ( message ) print ( \"SHA3:\" , ss . hexdigest ()) ss = keccak . Keccak () ss . update ( message ) print ( \"KECCAK:\" , ss . hexdigest ()) # generate a hmac with key=\"Python\" and sha1 hash hh = hmac . HMAC ( \"Python\" , sha1 . SHA1 ()) hh . update ( message ) print ( \"HMAC:\" , hh . hexdigest ()) except Exception as e : print ( e ) sleep ( 2000 )","title":"Secure Hash Functions"},{"location":"reference/core/stdlib/docs/examples/#elliptic-curve-cryptography","text":"A simple example to introduce ECDSA primitives. main.py ################################################################################ # Elliptic Curve Cryptography # # Created by Zerynth Team 2017 CC # Authors: G. Baldi ################################################################################ import streams # import ecc and sha1 modules from crypto.ecc import ecc as ec from crypto.hash import sha1 as sha1 streams . serial () message = \"Zerynth\" # import a Public Key for SECP256R1 pb = ec . hex_to_bin ( \"7A181C7D3AD54EC3817CBAF86EA4E003AD492D8569102392A6EFE0C27E471A65553918EA1BAC86A68C78A30E9FE725EA499E14BEA96C3FE85E2267B74385E56B\" ) # import a Private Key for SECP256R1 pv = ec . hex_to_bin ( \"6D5BE10E67D479FF99421A8DE030E2B4C5323EE477DA4C17420936CAC49C261E\" ) while True : # calculate hash of message ss = sha1 . SHA1 () ss . update ( message ) digest = ss . digest () # Calculate non deterministic signature of digest # for SECP256R1 and pv signature = ec . sign ( ec . SECP256R1 , digest , pv ) # Calculate the deterministic signature of digest using SHA1 deterministic_signature = ec . sign ( ec . SECP256R1 , digest , pv , deterministic = sha1 . SHA1 ()) print ( \"PVKEY:\" , ec . bin_to_hex ( pv )) print ( \"PBKEY:\" , ec . bin_to_hex ( pb )) # this changes each loop because of random number generator print ( \"SIGNED:\" , ec . bin_to_hex ( signature )) # this is always the same print ( \"SIGNED (det)\" , ec . bin_to_hex ( deterministic_signature )) print ( \"VERIFY SIGNATURE:\" , ec . verify ( ec . SECP256R1 , digest , signature , pb )) print ( \"VERIFY SIGNATURE (det):\" , ec . verify ( ec . SECP256R1 , digest , deterministic_signature , pb )) # tampered digests are detected print ( \"VERIFY TAMPERED:\" , ec . verify ( ec . SECP256R1 , digest + b ' \\x00 ' , signature , pb )) print ( \"-\" * 20 ) sleep ( 2000 )","title":"Elliptic Curve Cryptography"},{"location":"reference/core/stdlib/docs/examples/#powersaving","text":"This example shows the most important features of Powersaving enabled VMs: The ability to choose which low power mode to enter and how to exit The ability to save status on a special purpose memory guaranteed to be preserved after exiting the low power mode main.py ################################################################################ # Powersaving # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ ## ## This example only works on a Powersaving enabled Virtual Machine! ## import streams # import the Power Management module # Check documentation here: https://docs.zerynth.com/latest/official/core.zerynth.stdlib/docs/official_core.zerynth.stdlib_pwr.html import pwr streams . serial () # wake up reasons dictionary reasons = { pwr . PWR_RESET : \"System Reset\" , pwr . PWR_INTERRUPT : \"Event on WAKEUP pin\" , pwr . PWR_TIMEOUT : \"Timeout\" } # modes and descriptions modes = [ ( pwr . PWR_SLEEP , \"Sleep mode\" ), ( pwr . PWR_STOP , \"Stop mode\" ), ( pwr . PWR_STANDBY , \"Standby mode\" ) ] # some status variables slept = 0 wokeup = 0 sleep_counter = 0 # callback for Wake Up events on pins def wakeup (): print ( \"Hello!\" ) # function to prepare for and enter low power mode def sleepfn ( delay , mode ): global slept , wokeup print ( \"Going to sleep for\" , delay , \"milliseconds in\" , modes [ mode ][ 1 ]) sleep ( 100 ) # call go_to_sleep and get the amount of time spent sleeping # !! the VM is suspended here !! slept = pwr . go_to_sleep ( delay , modes [ mode ][ 0 ]) # if we reach this point, something caused a Wake Up from a low power mode # if we don't reach here, the device exited from a standby mode with a system reset # retrieve the Wake Up reason wokeup = pwr . wakeup_reason () print ( \"SLEPT FOR\" , slept ) print ( \"My wake up reason:\" , reasons . get ( wokeup , \"Unknown\" )) try : # retrieve the Wake Up reason wokeup = pwr . wakeup_reason () # retrieve sleep_counter from special purpose memory if supported try : sleep_counter = pwr . get_status_byte ( 0 ) print ( \"Special purpose memory supported!\" ) except Exception as e : print ( \"Special purpose memory not supported :(\" ) # print status at VM startup print ( \"Wake up reason at startup:\" , reasons . get ( wokeup , \"Unknown\" )) print ( \"Tried to sleep\" , sleep_counter , \"times\" ) # configure button to do something # depending on the platform this is enough to configure a Wake Up event # on some platforms only specific pins have the Wake Up property # (If the device has no button, configure another pin! [Try D6 on MKR1000 and D8 on Hexiwear]) pinMode ( BTN0 , INPUT_PULLUP ) onPinFall ( BTN0 , wakeup , debounce = 1000 ) cnt = 5 mode = 0 print ( \"Countdown!\" ) while True : # print the countdown print ( cnt ) sleep ( 1000 ) cnt -= 1 if cnt == 0 : cnt = 5 try : # save number of sleeps in special purpose memory sleep_counter = ( sleep_counter + 1 ) % 256 try : pwr . set_status_byte ( 0 , sleep_counter ) except : # ignore if special purpose memory not supported pass # enter a low power mode for 5 seconds or less # (press the button while sleeping to check if Wake Up is available in this mode) sleepfn ( 5000 , mode ) except Exception as e : print ( modes [ mode ][ 1 ], \"not supported!\" ) print ( e ) mode = ( mode + 1 ) % len ( modes ) print ( \"Countdown!\" ) except Exception as e : print ( e ) # Expected results by architecture and mode for Wake Up on pin event # # MODE | SLEEP STOP STANDBY # MCU | # ------------------------------------------------------------------- # | # STM32F | OK OK Only on pin PA0 # | # ------------------------------------------------------------------- # | # SAMD21 | OK No Mode not supported # | # -------------------------------------------------------------------- # | # NXP K64 | OK OK Only on WakeUp pins # | # -------------------------------------------------------------------- # | # ESP8266 | Unsupported Unsupported Only works for Gpio 16 # | # --------------------------------------------------------------------","title":"Powersaving"},{"location":"reference/core/stdlib/docs/examples/#watchdogs","text":"A basic example showing the watchdog functionalities in a Secure Fimrware enabled VM. main.py ################################################################################ # Watchdogs # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ ## ## This example only works on a Secure Firmware enabled Virtual Machine! ## import streams # import the Secure Firmware module # Check documentation here: https://docs.zerynth.com/latest/official/core.zerynth.stdlib/docs/official_core.zerynth.stdlib_sfw.html import sfw streams . serial () sleep ( 2000 ) # Check for reset reason try : print ( \"Watchdog triggered:\" , sfw . watchdog_triggered ()) except Exception as e : print ( \"Watchdog not suppported by this Virtual Machine!\" ) while True : sleep ( 1000 ) # Do something without fearing a reset for x in range ( 10 ): sleep ( 1000 ) print ( \"Printing something for a while, no watchdog can reset me! 8\u2011D\" ) # Configure watchdog in normal mode with a 5 seconds timeout print ( \"Configuring watchdog to a 5 seconds timeout...\" ) sfw . watchdog ( 0 , 5000 ) sleep ( 100 ) # Kick the watchdog every second for x in range ( 10 ): sleep ( 1000 ) sfw . kick () print ( \"Kick!\" ) # Stop kicking and wait for reset while True : print ( \"Printing something for a while waiting for the watchdog! D-8\" ) sleep ( 1000 )","title":"Watchdogs"},{"location":"reference/core/stdlib/docs/examples/#vm-exceptions","text":"This example explains how to set VM Options to handle uncaught exceptions main.py ################################################################################ # Zerynth VM Options # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams import vm streams . serial () #let's set some VM options: uncomment the test you want to try, comment the others #test 1: reset on uncaught exception and print trace (Default) vm . set_option ( vm . VM_OPT_RESET_ON_EXCEPTION , 1 ) vm . set_option ( vm . VM_OPT_TRACE_ON_EXCEPTION , 1 ) #test 2: don't reset on uncaught exception but print trace (Default) # vm.set_option(vm.VM_OPT_RESET_ON_EXCEPTION,0) # vm.set_option(vm.VM_OPT_TRACE_ON_EXCEPTION,1) #test 3: don't reset on uncaught exception and don't print trace (Default) # vm.set_option(vm.VM_OPT_RESET_ON_EXCEPTION,0) # vm.set_option(vm.VM_OPT_TRACE_ON_EXCEPTION,0) #test 3: reset on uncaught exception but don't print trace (Default) # vm.set_option(vm.VM_OPT_RESET_ON_EXCEPTION,1) # vm.set_option(vm.VM_OPT_TRACE_ON_EXCEPTION,0) def thread_fn_exc (): for i in range ( 5 ): print ( \"TH working\" , i ) sleep ( 1000 ) x = 1 / 0 # launch thread thread ( thread_fn_exc ) while True : sleep ( 2000 ) #let's print some VM info nfo = vm . info () print ( \"--------------\" ) print ( \"VM uid \" , nfo [ 0 ]) print ( \"Target \" , nfo [ 1 ]) print ( \"Version\" , nfo [ 2 ]) print ( \"--------------\" )","title":"VM Exceptions"},{"location":"reference/core/stdlib/docs/examples/#vm-hard-fault","text":"This example explains how to set VM Options to manage Hard Faults main.py ################################################################################ # Zerynth VM Options # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams import vm streams . serial () #let's set some VM options: uncomment the test you want to try, comment the others #test 1: reset on hard fault and print trace (Default) vm . set_option ( vm . VM_OPT_RESET_ON_HARDFAULT , 1 ) vm . set_option ( vm . VM_OPT_TRACE_ON_HARDFAULT , 1 ) #test 2: don't reset on hard fault but print trace (Default) # vm.set_option(vm.VM_OPT_RESET_ON_HARDFAULT,0) # vm.set_option(vm.VM_OPT_TRACE_ON_HARDFAULT,1) #test 3: don't reset on hard fault and don't print trace (Default) # vm.set_option(vm.VM_OPT_RESET_ON_HARDFAULT,0) # vm.set_option(vm.VM_OPT_TRACE_ON_HARDFAULT,0) #test 3: reset on hard faultbut don't print trace (Default) # vm.set_option(vm.VM_OPT_RESET_ON_HARDFAULT,1) # vm.set_option(vm.VM_OPT_TRACE_ON_HARDFAULT,0) # here is a function that causes a hard fault by writing to NULL (in c) @c_native ( \"_hf_function\" ,[ \"hf.c\" ],[]) def armageddon (): pass while True : print ( \"Releasing the Armageddon in 2 sec...:-@\" ) sleep ( 2000 ) armageddon ()","title":"VM Hard Fault"},{"location":"reference/core/stdlib/docs/fatfs/","text":"fatFS \u00b6 This module implements Zerynth binding to FatFS C library to handle FAT disks. Driver \u00b6 mount(path, args) Register/unregister a file system object to the fatFs module. There is no activity of the physical drive in this function: physical mount process will be attempted during first file access. Required arguments are: path string, following FatFS path convention: path = \"0:/\" # to mount your drive as volume 0 generic_file_path = \"0:/my/file/path\" args dictionary containing disk initialization parameters: # correct format for SD Card read through SPI protocol args = { \"drv\" : SPI0 , \"cs\" : D25 , \"clock\" : 1000000 } # correct format for SD Card read through SD mode # (be careful in choosing frequency (kHz) and bits supported by your board) args = { \"drv\" : SD1 , \"freq_khz\" : 20000 , \"bits\" : 1 } File/Directory Access/Management \u00b6 File/Directory access/management is handled by os module, which needs a filesystem to be mounted and a list of low-level functions implemented in the filesystem module. File Access * __f_open * __f_close * __f_read * __f_write * __f_seek * __f_size * __f_tell * __f_truncate * __f_eof Directory Access * __f_opendir * __f_closedir * __f_readdir File/Directory Management * __f_copy * __f_unlink * __f_rename * __f_mkdir * __f_chdir * __f_getcwd * __f_exists * __f_isdir Misc * get_available_fd_n * free_fd_n * to_b_mode","title":"fatFS"},{"location":"reference/core/stdlib/docs/fatfs/#fatfs","text":"This module implements Zerynth binding to FatFS C library to handle FAT disks.","title":"fatFS"},{"location":"reference/core/stdlib/docs/fatfs/#driver","text":"mount(path, args) Register/unregister a file system object to the fatFs module. There is no activity of the physical drive in this function: physical mount process will be attempted during first file access. Required arguments are: path string, following FatFS path convention: path = \"0:/\" # to mount your drive as volume 0 generic_file_path = \"0:/my/file/path\" args dictionary containing disk initialization parameters: # correct format for SD Card read through SPI protocol args = { \"drv\" : SPI0 , \"cs\" : D25 , \"clock\" : 1000000 } # correct format for SD Card read through SD mode # (be careful in choosing frequency (kHz) and bits supported by your board) args = { \"drv\" : SD1 , \"freq_khz\" : 20000 , \"bits\" : 1 }","title":"Driver"},{"location":"reference/core/stdlib/docs/fatfs/#filedirectory-accessmanagement","text":"File/Directory access/management is handled by os module, which needs a filesystem to be mounted and a list of low-level functions implemented in the filesystem module. File Access * __f_open * __f_close * __f_read * __f_write * __f_seek * __f_size * __f_tell * __f_truncate * __f_eof Directory Access * __f_opendir * __f_closedir * __f_readdir File/Directory Management * __f_copy * __f_unlink * __f_rename * __f_mkdir * __f_chdir * __f_getcwd * __f_exists * __f_isdir Misc * get_available_fd_n * free_fd_n * to_b_mode","title":"File/Directory Access/Management"},{"location":"reference/core/stdlib/docs/fifo/","text":"Fifo \u00b6 This module implements no thread-safe fifo queues. A fifo queue behaves in such a way that the first element inserted in the queue is also the first element to be removed (first in, first out). Fifo class \u00b6 Fifo(size=16, only_bytes=False) Create a Fifo instance with size \u201cplaces\u201d for items. If only_bytes is True, the Fifo will use a bytearray to store bytes; if False it will use a list. is_full() Return True if the fifo is full is_empty() Return True if the fifo is empty put(obj) Insert obj into the fifo queue. Raise FifoFullError if the fifo is full. get() Get an object out of the fifo queue. Raise FifoEmptyError if the fifo is empty. peek() Return the object at the head of the fifo queu without removing it. Raise FifoEmptyError if the fifo is empty. put_all(objs) Put every item of objs into the fifo queue. elements() Return the number of items in the queue. clear() Clear the fifo by removing all elements","title":"Fifo"},{"location":"reference/core/stdlib/docs/fifo/#fifo","text":"This module implements no thread-safe fifo queues. A fifo queue behaves in such a way that the first element inserted in the queue is also the first element to be removed (first in, first out).","title":"Fifo"},{"location":"reference/core/stdlib/docs/fifo/#fifo-class","text":"Fifo(size=16, only_bytes=False) Create a Fifo instance with size \u201cplaces\u201d for items. If only_bytes is True, the Fifo will use a bytearray to store bytes; if False it will use a list. is_full() Return True if the fifo is full is_empty() Return True if the fifo is empty put(obj) Insert obj into the fifo queue. Raise FifoFullError if the fifo is full. get() Get an object out of the fifo queue. Raise FifoEmptyError if the fifo is empty. peek() Return the object at the head of the fifo queu without removing it. Raise FifoEmptyError if the fifo is empty. put_all(objs) Put every item of objs into the fifo queue. elements() Return the number of items in the queue. clear() Clear the fifo by removing all elements","title":"Fifo class"},{"location":"reference/core/stdlib/docs/flash/","text":"Flash \u00b6 This module contains class definitions to read and write the MCU internal flash The FlashFileStream class \u00b6 FlashFileStream(start_address, size) This class creates an in memory buffer of size size bytes that is filled with the content of the internal flash starting from address start_address Subsequent operations of read and write are performed on the memory buffer. To actually write the memory buffer to the internal flash a call to flush() is needed. The memory buffer can also be accessed via bracket notation. The following is valid syntax: f = flash . FlashFileStream ( 0x0800000 , 512 ) f [ 0 ] = 1 x = f [ 10 : 20 ] write(buf) Writes the content of buf at the current file position, checking for overflow. read_int() Read 4 bytes at the current position and return the corresponding 32 bit integer. flush() Write the memory buffer to flash. It can be VERY slow because the sector(s) of flash interested by the write operation must be erased first. close() Free memory buffer","title":"Flash"},{"location":"reference/core/stdlib/docs/flash/#flash","text":"This module contains class definitions to read and write the MCU internal flash","title":"Flash"},{"location":"reference/core/stdlib/docs/flash/#the-flashfilestream-class","text":"FlashFileStream(start_address, size) This class creates an in memory buffer of size size bytes that is filled with the content of the internal flash starting from address start_address Subsequent operations of read and write are performed on the memory buffer. To actually write the memory buffer to the internal flash a call to flush() is needed. The memory buffer can also be accessed via bracket notation. The following is valid syntax: f = flash . FlashFileStream ( 0x0800000 , 512 ) f [ 0 ] = 1 x = f [ 10 : 20 ] write(buf) Writes the content of buf at the current file position, checking for overflow. read_int() Read 4 bytes at the current position and return the corresponding 32 bit integer. flush() Write the memory buffer to flash. It can be VERY slow because the sector(s) of flash interested by the write operation must be erased first. close() Free memory buffer","title":"The FlashFileStream class"},{"location":"reference/core/stdlib/docs/fota/","text":"Firmware Over the Air update (FOTA) \u00b6 This module enables access to VM functionalities for updating firmware and/or VM at runtime. It can be safely imported in every program, however its functions will raise UnsupportedError if the target VM is not enabled for FOTA features ( a premium VM with the OTA feature enabled is needed ). In Zerynth FOTA can be performed for bytecode only or for bytecode and VM if the target device supports a multiple VM layout. In order to support FOTA updates, the flash memory of the target device is divided in segments that can hold either a VM or bytecode. Moreover a small segment of persistent memory (not necessary flash) must be allocated to store the current and desired state of the firmware (FOTA record). The following layouts show different flash organization for FOTA support: Support for FOTA update of bytecode only |------------------------------------------------------------------------------| | | | | | | VM | Bytecode Slot 0 | Bytecode Slot 1 | | <-- FOTA Record | | | | | |------------------------------------------------------------------------------| Support for FOTA update of bytecode and VM |------------------------------------------------------------------------------| | | | | | | | VM 0 | Bytecode Slot 0 | VM 1 | Bytecode Slot 1 | | <-- FOTA Record | | | | | | |------------------------------------------------------------------------------| FOTA process for bytecode only \u00b6 The FOTA process consists of the following steps: check the FOTA record structure to ensure that the current VM+Bytecode slot configuration is functioning correctly ( get_record() ) identify the available slot for the new bytecode ( find_bytecode_slot() ) erase the bytecode slot to make room for new bytecode ( erase_slot() ) write the binary representation of the new bytecode to the slot ( write_slot() ) optionally check that the new bytecode has been written correctly ( checksum_slot() ) modify the FOTA record with the new desired configuration ( attempt() ) restart the VM in the new configuration ( restart() ) the new bytecode should check that everything is ok and confirm the configuration ( accept() ). In case the new bytecode is faulty, a simple restart will bring the system back in the previously working configuration. FOTA process for bytecode and VM \u00b6 For some target devices it is possible to change both the bytecode and the VM in a single FOTA process. The FOTA process in this case consists of the following steps: check the FOTA record structure to ensure that the current VM+Bytecode slot configuration is functioning correctly ( get_record() ) identify the available slot for the new bytecode ( find_bytecode_slot() ) and for the new VM ( find_vm_slot() ) erase the bytecode slot and vm slot to make room for new firmware ( erase_slot() ) write the binary representation of the new bytecode and vm to the slots ( write_slot() ) optionally check that the new bytecode and vm have been written correctly ( checksum_slot() ) modify the FOTA record with the new desired configuration ( attempt() ) restart the VM in the new configuration ( restart() ) the previous VM will start and behave as a bootloader passing control to the new VM the new bytecode should check that everything is ok and confirm the configuration ( accept() ). In case the new bytecode is faulty, a simple restart will bring the system back in the previously working configuration. FOTA functions \u00b6 get_record() Return the FOTA record (fota) as a tuple of integers following this scheme: fota[0] is 0 if the FOTA record is not valid fota[1] is the index of the FOTA VM fota[2] is the slot of the current VM (as an index starting from 0) fota[3] is the slot of the last working VM (as an index starting from 0) fota[4] is the slot of the current bytecode (as an index starting from 0) fota[5] is the slot of the last working bytecode (as an index starting from 0) fota[6] is the flash address of the current bytecode fota[7] is the flash address of the current VM fota[8] is the OTA chunk set_record(newfota) Set the FOTA record (fota) to the values in newfota according to this scheme: fota[2] = newfota[0], sets the current VM for next restart fota[3] = newfota[1], sets the last working VM fota[4] = newfota[2], set the current bytecode for the next restart fota[5] = newfota[3], set the last working bytecode All other fota elements are managed by the VM and cannot be changed find_bytecode_slot() Return the address of next available bytecode slot. find_vm_slot() Return the address of the next available vm slot. If the result of the function is equal to fota[7], the current VM does not support VM updates. erase_slot(addr, size) Erase the slot (either bytecode or VM) starting at addr for at least size bytes. Since flash memories are often organized in sectors, the erased size can be larger than the requested size. write_slot(addr, block) Write block (bytes, bytearray or string) at addr where addr is an address contained in a bytecode or VM slot. This function does not keep count of the written blocks, it is up to the programmer to update the address correctly. close_slot(addr) This function must be called once at the end of the operations (write, erase, \u2026) on a specific addr where addr is an address contained in a bytecode or VM slot. checksum_slot(addr, size) Return the MD5 checksum (as a bytes object) of the slot starting at addr and extending for size bytes. restart() Reset the microcontroller and restart the system accept() Modify the FOTA record to make the current configuration the last working configuration. Must be called by the new bytecode in order to end the FOTA process correctly. attempt(bcslot, vmslot) Modify the FOTA record to make bcslot and vmslot (expressed as indexes starting from 0), the test configuration to be tried on restart.","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/core/stdlib/docs/fota/#firmware-over-the-air-update-fota","text":"This module enables access to VM functionalities for updating firmware and/or VM at runtime. It can be safely imported in every program, however its functions will raise UnsupportedError if the target VM is not enabled for FOTA features ( a premium VM with the OTA feature enabled is needed ). In Zerynth FOTA can be performed for bytecode only or for bytecode and VM if the target device supports a multiple VM layout. In order to support FOTA updates, the flash memory of the target device is divided in segments that can hold either a VM or bytecode. Moreover a small segment of persistent memory (not necessary flash) must be allocated to store the current and desired state of the firmware (FOTA record). The following layouts show different flash organization for FOTA support: Support for FOTA update of bytecode only |------------------------------------------------------------------------------| | | | | | | VM | Bytecode Slot 0 | Bytecode Slot 1 | | <-- FOTA Record | | | | | |------------------------------------------------------------------------------| Support for FOTA update of bytecode and VM |------------------------------------------------------------------------------| | | | | | | | VM 0 | Bytecode Slot 0 | VM 1 | Bytecode Slot 1 | | <-- FOTA Record | | | | | | |------------------------------------------------------------------------------|","title":"Firmware Over the Air update (FOTA)"},{"location":"reference/core/stdlib/docs/fota/#fota-process-for-bytecode-only","text":"The FOTA process consists of the following steps: check the FOTA record structure to ensure that the current VM+Bytecode slot configuration is functioning correctly ( get_record() ) identify the available slot for the new bytecode ( find_bytecode_slot() ) erase the bytecode slot to make room for new bytecode ( erase_slot() ) write the binary representation of the new bytecode to the slot ( write_slot() ) optionally check that the new bytecode has been written correctly ( checksum_slot() ) modify the FOTA record with the new desired configuration ( attempt() ) restart the VM in the new configuration ( restart() ) the new bytecode should check that everything is ok and confirm the configuration ( accept() ). In case the new bytecode is faulty, a simple restart will bring the system back in the previously working configuration.","title":"FOTA process for bytecode only"},{"location":"reference/core/stdlib/docs/fota/#fota-process-for-bytecode-and-vm","text":"For some target devices it is possible to change both the bytecode and the VM in a single FOTA process. The FOTA process in this case consists of the following steps: check the FOTA record structure to ensure that the current VM+Bytecode slot configuration is functioning correctly ( get_record() ) identify the available slot for the new bytecode ( find_bytecode_slot() ) and for the new VM ( find_vm_slot() ) erase the bytecode slot and vm slot to make room for new firmware ( erase_slot() ) write the binary representation of the new bytecode and vm to the slots ( write_slot() ) optionally check that the new bytecode and vm have been written correctly ( checksum_slot() ) modify the FOTA record with the new desired configuration ( attempt() ) restart the VM in the new configuration ( restart() ) the previous VM will start and behave as a bootloader passing control to the new VM the new bytecode should check that everything is ok and confirm the configuration ( accept() ). In case the new bytecode is faulty, a simple restart will bring the system back in the previously working configuration.","title":"FOTA process for bytecode and VM"},{"location":"reference/core/stdlib/docs/fota/#fota-functions","text":"get_record() Return the FOTA record (fota) as a tuple of integers following this scheme: fota[0] is 0 if the FOTA record is not valid fota[1] is the index of the FOTA VM fota[2] is the slot of the current VM (as an index starting from 0) fota[3] is the slot of the last working VM (as an index starting from 0) fota[4] is the slot of the current bytecode (as an index starting from 0) fota[5] is the slot of the last working bytecode (as an index starting from 0) fota[6] is the flash address of the current bytecode fota[7] is the flash address of the current VM fota[8] is the OTA chunk set_record(newfota) Set the FOTA record (fota) to the values in newfota according to this scheme: fota[2] = newfota[0], sets the current VM for next restart fota[3] = newfota[1], sets the last working VM fota[4] = newfota[2], set the current bytecode for the next restart fota[5] = newfota[3], set the last working bytecode All other fota elements are managed by the VM and cannot be changed find_bytecode_slot() Return the address of next available bytecode slot. find_vm_slot() Return the address of the next available vm slot. If the result of the function is equal to fota[7], the current VM does not support VM updates. erase_slot(addr, size) Erase the slot (either bytecode or VM) starting at addr for at least size bytes. Since flash memories are often organized in sectors, the erased size can be larger than the requested size. write_slot(addr, block) Write block (bytes, bytearray or string) at addr where addr is an address contained in a bytecode or VM slot. This function does not keep count of the written blocks, it is up to the programmer to update the address correctly. close_slot(addr) This function must be called once at the end of the operations (write, erase, \u2026) on a specific addr where addr is an address contained in a bytecode or VM slot. checksum_slot(addr, size) Return the MD5 checksum (as a bytes object) of the slot starting at addr and extending for size bytes. restart() Reset the microcontroller and restart the system accept() Modify the FOTA record to make the current configuration the last working configuration. Must be called by the new bytecode in order to end the FOTA process correctly. attempt(bcslot, vmslot) Modify the FOTA record to make bcslot and vmslot (expressed as indexes starting from 0), the test configuration to be tried on restart.","title":"FOTA functions"},{"location":"reference/core/stdlib/docs/gc/","text":"Garbage Collector \u00b6 This module allows the interaction with the garbage collector from Zerynth programs. info() Returns a tuple of integers: Total memory in bytes Free memory in bytes Memory fragmentation percentage Number of allocated blocks Number of free blocks GC Period: milliseconds between forced collections Milliseconds since last collection collect() Starts a collection enable(period=500) Activates the garbage collector with a GC Period of period milliseconds disable() Disable garbage collector","title":"Garbage Collector"},{"location":"reference/core/stdlib/docs/gc/#garbage-collector","text":"This module allows the interaction with the garbage collector from Zerynth programs. info() Returns a tuple of integers: Total memory in bytes Free memory in bytes Memory fragmentation percentage Number of allocated blocks Number of free blocks GC Period: milliseconds between forced collections Milliseconds since last collection collect() Starts a collection enable(period=500) Activates the garbage collector with a GC Period of period milliseconds disable() Disable garbage collector","title":"Garbage Collector"},{"location":"reference/core/stdlib/docs/gpio/","text":"GPIO \u00b6 Generic GPIO module for transparently handling physical pins and pins controlled by port expanders. The module can be used without configuration like this: import gpio gpio . mode ( D10 , OUTPUT ) # Set mode for D10 gpio . mode ( D11 , OUTPUT ) # Set mode for D11 gpio . high ( D10 ) # Set D10 high gpio . low ( D11 ) # Set D11 low More advanced configurations allow the use of port expanders: import gpio from semtech.sx1503 import sx1503 # a port expander driver for sx1503 # initialize port expander driver pdriver = sx1503.SX1503(I2C0) # sx1503 is connected on I2C0 pinmap = { # now add pins definition for the expander 100: 7, # pin \"100\" maps to pin 7 on sx1503 101: 14, # pin \"101\" maps to pin 14 on sx1503 102: 15 # pin \"102\" maps to pin 15 on sx1503 } gpio.add_expander(1,pdriver,pinmap) # add expander to gpio module # with id = 1, using pdriver # and mapping the pins in pinmap # from here on, every library using gpio can access the port expander # without knowing about its existence! Like this: mypin1 = D10 mypin2 = 100 gpio.mode(mypin1,OUTPUT) # configure D10 as output gpio.mode(mypin2,OUTPUT) # configure pin \"100\" as output on sx1503 gpio.high(mypin1) # set pin D10 to high gpio.low(mypin2) # set pin \"100\" to low ** high(pin) ** Set the value of pin to HIGH . If the module is configured with one or more port expanders, the value of pin is set by calling into the port expander driver. ** low(pin) ** Set the value of pin to LOW . If the module is configured with one or more port expanders, the value of pin is set by calling into the port expander driver. ** set(pin, value) ** Set the value of pin to value . If the module is configured with one or more port expanders, the value of pin is set by calling into the port expander driver. ** get(pin) ** Return the value of pin. If the module is configured with one or more port expanders, the value of pin is returned by calling into the port expander driver. ** mode(pin, pinmode) ** Set the mode of pin to pinmode . If the module is configured with one or more port expanders, the mode of pin is set by calling into the port expander driver. For available modes please check here. ** add_expander(id, pdriver, pinmap) ** Add pdriver and pinmap as expander id to the list of available expanders. pdriver must be a port expander driver, pinmap must be a dictionary mapping pin names to the port expander internal representation.","title":"Gpio"},{"location":"reference/core/stdlib/docs/gpio/#gpio","text":"Generic GPIO module for transparently handling physical pins and pins controlled by port expanders. The module can be used without configuration like this: import gpio gpio . mode ( D10 , OUTPUT ) # Set mode for D10 gpio . mode ( D11 , OUTPUT ) # Set mode for D11 gpio . high ( D10 ) # Set D10 high gpio . low ( D11 ) # Set D11 low More advanced configurations allow the use of port expanders: import gpio from semtech.sx1503 import sx1503 # a port expander driver for sx1503 # initialize port expander driver pdriver = sx1503.SX1503(I2C0) # sx1503 is connected on I2C0 pinmap = { # now add pins definition for the expander 100: 7, # pin \"100\" maps to pin 7 on sx1503 101: 14, # pin \"101\" maps to pin 14 on sx1503 102: 15 # pin \"102\" maps to pin 15 on sx1503 } gpio.add_expander(1,pdriver,pinmap) # add expander to gpio module # with id = 1, using pdriver # and mapping the pins in pinmap # from here on, every library using gpio can access the port expander # without knowing about its existence! Like this: mypin1 = D10 mypin2 = 100 gpio.mode(mypin1,OUTPUT) # configure D10 as output gpio.mode(mypin2,OUTPUT) # configure pin \"100\" as output on sx1503 gpio.high(mypin1) # set pin D10 to high gpio.low(mypin2) # set pin \"100\" to low ** high(pin) ** Set the value of pin to HIGH . If the module is configured with one or more port expanders, the value of pin is set by calling into the port expander driver. ** low(pin) ** Set the value of pin to LOW . If the module is configured with one or more port expanders, the value of pin is set by calling into the port expander driver. ** set(pin, value) ** Set the value of pin to value . If the module is configured with one or more port expanders, the value of pin is set by calling into the port expander driver. ** get(pin) ** Return the value of pin. If the module is configured with one or more port expanders, the value of pin is returned by calling into the port expander driver. ** mode(pin, pinmode) ** Set the mode of pin to pinmode . If the module is configured with one or more port expanders, the mode of pin is set by calling into the port expander driver. For available modes please check here. ** add_expander(id, pdriver, pinmap) ** Add pdriver and pinmap as expander id to the list of available expanders. pdriver must be a port expander driver, pinmap must be a dictionary mapping pin names to the port expander internal representation.","title":"GPIO"},{"location":"reference/core/stdlib/docs/hwtimers/","text":"Hardware Timers \u00b6 This module implements the interface to the hardware timers of the board, allowing a greater precision in time measuring or time constrained tasks. Currently, only the sleep_micros function is implemented sleep_micros(n) Suspend the current thread for n microseconds by using the functionalities of an high precision hardware timer. Currently, sleep_micros is not thread safe, and can\u2019t be called simultaneously by more than one thread. The actual amount of microseconds between the call and return of sleep_micros is usually greater than n due to the overhead of calling, returning and thread switching.","title":"Hardware Timers"},{"location":"reference/core/stdlib/docs/hwtimers/#hardware-timers","text":"This module implements the interface to the hardware timers of the board, allowing a greater precision in time measuring or time constrained tasks. Currently, only the sleep_micros function is implemented sleep_micros(n) Suspend the current thread for n microseconds by using the functionalities of an high precision hardware timer. Currently, sleep_micros is not thread safe, and can\u2019t be called simultaneously by more than one thread. The actual amount of microseconds between the call and return of sleep_micros is usually greater than n due to the overhead of calling, returning and thread switching.","title":"Hardware Timers"},{"location":"reference/core/stdlib/docs/i2c/","text":"I2C \u00b6 This module loads the I2C interface. The I2C protocol is a multimaster and multislave serial communication protocol that allows sending and receiving data between the microcontroller (MCU) and low-speed peripheral. I2C needs only two wires, one called SCL functioning as a clock and one called SDA where the actual message bits are transferred. I2C is a master-slave protocol, therefore a single master takes control of the bus and interacts with peripherals by sending on the bus the address of the peripheral the master wants to communicate with. It is also possible to have more than one master on the same bus by using an arbitration policy; however, at the moment Zerynth VM supports only a single master protocol version where the microcontroller is the master. Different versions of the I2C protocol use different clock speed: Low-speed: up to 100kHz with 7 bits of peripheral address Fast-mode: up to 400kHz, up to 10 bits of peripheral address High-speed: up to 3.4 MHz Fast-mode plus: up to 1 MHz Ultra Fast-mode: up to 5 MHz Zerynth VM generally supports low-speed and fast-mode if the microcontroller implements those versions. I2C peripherals are usually implemented as a serial memory, meaning that they expose a list of registers that can be read and/or written. Therefore, for the master to correctly interact with a peripheral, some data must be known: peripheral address: 7-bit or 10-bit address, hardwired in the peripheral and reported in the datasheet register address: the peripheral memory location to be accessed The master can perform three actions on the bus: read: to access the value of a peripheral register. First, the master gets control of the bus, then the peripheral address is sent. The peripheral sends back the content of a predetermined register. The master releases the bus. write: to change the value of a peripheral register. First, the master gets control of the bus, the peripheral address is sent, followed by the register address and the data to be written. The master releases the bus. write-read: to exchange data with the peripherals in an atomic call. First, the master gets control of the bus, then the peripheral address is sent, followed by the data to be written (usually the address of a peripheral register). The bus is not released until the peripheral finishes to send its answer. The I2C protocol provides mechanisms to detect bus errors. Zerynth VM catches bus errors and raises exceptions. The I2C class \u00b6 I2C(drvname, addr, clock=100000) Creates an I2C instance using the MCU I2C circuitry drvname (one of I2C0, I2C1, \u2026 check pinmap for details). The created instance is configured to communicate with the slave peripheral identified by addr . clock is configured by default in slow mode. set_addr(addr) Changes the peripheral address to communicate with. start() I2C is started. It is necessary to start the driver before any communication can commence to transfer the I2C configuration parameter to the low level driver. If the I2C bus is already configured with different settings by another active istance of the I2C class, an exception is raised. write_bytes(\\*args, timeout=-1) args is converted to bytes and sent. write(data, timeout=-1) data is written. read(n, timeout=-1) Returns a sequence of n bytes. write_read(data, n, timeout=-1) Writes data and then reads n bytes in a single call. stop() i2c is stopped and low level configuration disabled. lock() Locks the driver. It is useful when the same i2c object is used by multiple threads to avoid interferences. unlock() Unlocks the driver. It is useful when the same i2c object is used by multiple threads to avoid interferences.","title":"I2C"},{"location":"reference/core/stdlib/docs/i2c/#i2c","text":"This module loads the I2C interface. The I2C protocol is a multimaster and multislave serial communication protocol that allows sending and receiving data between the microcontroller (MCU) and low-speed peripheral. I2C needs only two wires, one called SCL functioning as a clock and one called SDA where the actual message bits are transferred. I2C is a master-slave protocol, therefore a single master takes control of the bus and interacts with peripherals by sending on the bus the address of the peripheral the master wants to communicate with. It is also possible to have more than one master on the same bus by using an arbitration policy; however, at the moment Zerynth VM supports only a single master protocol version where the microcontroller is the master. Different versions of the I2C protocol use different clock speed: Low-speed: up to 100kHz with 7 bits of peripheral address Fast-mode: up to 400kHz, up to 10 bits of peripheral address High-speed: up to 3.4 MHz Fast-mode plus: up to 1 MHz Ultra Fast-mode: up to 5 MHz Zerynth VM generally supports low-speed and fast-mode if the microcontroller implements those versions. I2C peripherals are usually implemented as a serial memory, meaning that they expose a list of registers that can be read and/or written. Therefore, for the master to correctly interact with a peripheral, some data must be known: peripheral address: 7-bit or 10-bit address, hardwired in the peripheral and reported in the datasheet register address: the peripheral memory location to be accessed The master can perform three actions on the bus: read: to access the value of a peripheral register. First, the master gets control of the bus, then the peripheral address is sent. The peripheral sends back the content of a predetermined register. The master releases the bus. write: to change the value of a peripheral register. First, the master gets control of the bus, the peripheral address is sent, followed by the register address and the data to be written. The master releases the bus. write-read: to exchange data with the peripherals in an atomic call. First, the master gets control of the bus, then the peripheral address is sent, followed by the data to be written (usually the address of a peripheral register). The bus is not released until the peripheral finishes to send its answer. The I2C protocol provides mechanisms to detect bus errors. Zerynth VM catches bus errors and raises exceptions.","title":"I2C"},{"location":"reference/core/stdlib/docs/i2c/#the-i2c-class","text":"I2C(drvname, addr, clock=100000) Creates an I2C instance using the MCU I2C circuitry drvname (one of I2C0, I2C1, \u2026 check pinmap for details). The created instance is configured to communicate with the slave peripheral identified by addr . clock is configured by default in slow mode. set_addr(addr) Changes the peripheral address to communicate with. start() I2C is started. It is necessary to start the driver before any communication can commence to transfer the I2C configuration parameter to the low level driver. If the I2C bus is already configured with different settings by another active istance of the I2C class, an exception is raised. write_bytes(\\*args, timeout=-1) args is converted to bytes and sent. write(data, timeout=-1) data is written. read(n, timeout=-1) Returns a sequence of n bytes. write_read(data, n, timeout=-1) Writes data and then reads n bytes in a single call. stop() i2c is stopped and low level configuration disabled. lock() Locks the driver. It is useful when the same i2c object is used by multiple threads to avoid interferences. unlock() Unlocks the driver. It is useful when the same i2c object is used by multiple threads to avoid interferences.","title":"The I2C class"},{"location":"reference/core/stdlib/docs/icu/","text":"Input Capture Unit \u00b6 This module loads the Input Capture (icu) driver of the embedded device. An Input Capture unit is a mcu peripheral that is able to read a digital signal on a pin and measure times between HIGH and LOW transition. Imagine to have this signal on a digital pin: HIGH _______ ________________ _________ | | | | | | | | | | | | _____| |__________| |___| |____ LOW <------><----------><---------------><-><---------> T0 T1 T2 T3 T4 Often it is very useful to know T0,T1, etc.. with a very good precision (such as in IR decoder). Writing a program that listens for transitions from HIGH to LOW or viceversa and saves the time passed in between can surely be done, but a modern mcu is usually equipped with a piece of hardware (being it a timer or a dedicated input capture unit) that can obtain the same result with almost no code and a staggering precision (in the order of sub-microseconds). The icu module is a general interface with such mcu hardware. init(drvname) Loads the icu driver identified by drvname Returns the previous driver without disabling it. capture(pin, trigger, max_samples, time_window=1000, time_unit=MILLIS, pull=LOW, bits=-1) Activates the Input Capture Unit on pin and starts capturing the signal with the following constraints: waits until the signal on pin is equal to trigger . If trigger is LOW the capture starts when a transition HIGH to LOW is detected. Otherwise the capture starts when a transition LOW to HIGH is detected. Synonyms for LOW transition are HIGH_TO_LOW or FALLING_EDGE . Synonyms for HIGH are LOW_TO_HIGH or RISING_EDGE . It is possible to select a trigger on any edge with BOTH_EDGES . once the capture is started, the input capture units starts saving times at each transition. the capture ends if max_samples are captured or if time_window expires, whichever condition verifies first. pin is set to INPUT_PULLDOWN if pull is LOW else is set to INPUT_PULLUP This function is blocking and returns a tuple of times expressed in microseconds as soon as the capture ends. The type of the returned value can be changed by setting bits to a non negative value. If bits is 0, a tuple is returned, the first item being the times, the second item being the digital value of pin during the first captured time. If bits is 1, the result is a tuple, the first item being the times, the second item being a tuple of zeros and ones representing the digital value of pin during each captured time. Non negative values for bits other than 0 and 1 are reserved and will be used in future enhancements of the function. Imagine to have this signal on pin : HIGH _______ ________________ _________ | | | | | | | | | | | | _______| |__________| |___| |____ LOW (forever) ^ ^ ^ ^ ^ ^ edges 0 1 2 3 4 5 <------><----------><---------------><-><---------> ms 7 10 16 3 9 Here are some examples: import icu # Case 1: x = icu . capture ( D3 . ICU , HIGH , 10 , 50 ) # trigger is set to HIGH, so capture starts at edge 0 # x is (7000,10000,16000,3000,9000) --> result in microseconds # Case 2: x = icu . capture ( D3 . ICU , HIGH_TO_LOW , 10 , 50 ) # trigger is set to HIGH_TO_LOW, so capture starts at edge 1 # x is (10000,16000,3000,9000) --> result in microseconds # Case 3: x = icu . capture ( D3 . ICU , RISING_EDGE , 10 , 18 ) # trigger is set to RISING_EDGE, so capture starts at edge 0 # x is (7000,10000) --> time_window is 18 so after the first 18 ms, # the capture ends # Case 4: x , y = icu . capture ( D3 . ICU , BOTH_EDGES , 10 , 18 , bits = 1 ) # trigger is set to BOTH_EDGES, so capture starts at first available edge, edge 0 # x is (7000,10000) --> time_window is 18 so after the first 18 ms, # the capture ends # y is (1,0) --> first captured time (7000) was HIGH, second captured time (10000) was LOW Some boards have restrictions on how icu pins can be used, refer to the single board documentation for details.","title":"Input Capture Unit"},{"location":"reference/core/stdlib/docs/icu/#input-capture-unit","text":"This module loads the Input Capture (icu) driver of the embedded device. An Input Capture unit is a mcu peripheral that is able to read a digital signal on a pin and measure times between HIGH and LOW transition. Imagine to have this signal on a digital pin: HIGH _______ ________________ _________ | | | | | | | | | | | | _____| |__________| |___| |____ LOW <------><----------><---------------><-><---------> T0 T1 T2 T3 T4 Often it is very useful to know T0,T1, etc.. with a very good precision (such as in IR decoder). Writing a program that listens for transitions from HIGH to LOW or viceversa and saves the time passed in between can surely be done, but a modern mcu is usually equipped with a piece of hardware (being it a timer or a dedicated input capture unit) that can obtain the same result with almost no code and a staggering precision (in the order of sub-microseconds). The icu module is a general interface with such mcu hardware. init(drvname) Loads the icu driver identified by drvname Returns the previous driver without disabling it. capture(pin, trigger, max_samples, time_window=1000, time_unit=MILLIS, pull=LOW, bits=-1) Activates the Input Capture Unit on pin and starts capturing the signal with the following constraints: waits until the signal on pin is equal to trigger . If trigger is LOW the capture starts when a transition HIGH to LOW is detected. Otherwise the capture starts when a transition LOW to HIGH is detected. Synonyms for LOW transition are HIGH_TO_LOW or FALLING_EDGE . Synonyms for HIGH are LOW_TO_HIGH or RISING_EDGE . It is possible to select a trigger on any edge with BOTH_EDGES . once the capture is started, the input capture units starts saving times at each transition. the capture ends if max_samples are captured or if time_window expires, whichever condition verifies first. pin is set to INPUT_PULLDOWN if pull is LOW else is set to INPUT_PULLUP This function is blocking and returns a tuple of times expressed in microseconds as soon as the capture ends. The type of the returned value can be changed by setting bits to a non negative value. If bits is 0, a tuple is returned, the first item being the times, the second item being the digital value of pin during the first captured time. If bits is 1, the result is a tuple, the first item being the times, the second item being a tuple of zeros and ones representing the digital value of pin during each captured time. Non negative values for bits other than 0 and 1 are reserved and will be used in future enhancements of the function. Imagine to have this signal on pin : HIGH _______ ________________ _________ | | | | | | | | | | | | _______| |__________| |___| |____ LOW (forever) ^ ^ ^ ^ ^ ^ edges 0 1 2 3 4 5 <------><----------><---------------><-><---------> ms 7 10 16 3 9 Here are some examples: import icu # Case 1: x = icu . capture ( D3 . ICU , HIGH , 10 , 50 ) # trigger is set to HIGH, so capture starts at edge 0 # x is (7000,10000,16000,3000,9000) --> result in microseconds # Case 2: x = icu . capture ( D3 . ICU , HIGH_TO_LOW , 10 , 50 ) # trigger is set to HIGH_TO_LOW, so capture starts at edge 1 # x is (10000,16000,3000,9000) --> result in microseconds # Case 3: x = icu . capture ( D3 . ICU , RISING_EDGE , 10 , 18 ) # trigger is set to RISING_EDGE, so capture starts at edge 0 # x is (7000,10000) --> time_window is 18 so after the first 18 ms, # the capture ends # Case 4: x , y = icu . capture ( D3 . ICU , BOTH_EDGES , 10 , 18 , bits = 1 ) # trigger is set to BOTH_EDGES, so capture starts at first available edge, edge 0 # x is (7000,10000) --> time_window is 18 so after the first 18 ms, # the capture ends # y is (1,0) --> first captured time (7000) was HIGH, second captured time (10000) was LOW Some boards have restrictions on how icu pins can be used, refer to the single board documentation for details.","title":"Input Capture Unit"},{"location":"reference/core/stdlib/docs/json/","text":"JSON \u00b6 This module define functions to serialize and deserialize objects to and from JSON format. The deserialization of objects is performed using a wrapped version of the awesome and lighting fast JSMN library dumps(obj) Returns a bytearray containing the JSON representation of obj . Raises JSONError when obj contains non serializable objects. loads(data) Returns the object represented in JSON format inside the byte sequence data . Raises JSONError when data contains bad JSON.","title":"JSON"},{"location":"reference/core/stdlib/docs/json/#json","text":"This module define functions to serialize and deserialize objects to and from JSON format. The deserialization of objects is performed using a wrapped version of the awesome and lighting fast JSMN library dumps(obj) Returns a bytearray containing the JSON representation of obj . Raises JSONError when obj contains non serializable objects. loads(data) Returns the object represented in JSON format inside the byte sequence data . Raises JSONError when data contains bad JSON.","title":"JSON"},{"location":"reference/core/stdlib/docs/jwt/","text":"JSON Web Tokens \u00b6 This module allows handling JSON Web Tokens from Zerynth programs. encode(payload, key) \u00b6 Encode a JWT for target payload signed with key . Currently only ES256 encoding algorithm using prime256v1 curve is supported. key must be an ECDSA private key in hex format. If a private key is, for example, stored as a pem file, the needed hex string can be extracted from the OCTET STRING field associated value obtained from openssl asn1parse - in my_private . pem command (since pem is a base64 encoded, plus header, DER ).","title":"JSON Web Tokens"},{"location":"reference/core/stdlib/docs/jwt/#json-web-tokens","text":"This module allows handling JSON Web Tokens from Zerynth programs.","title":"JSON Web Tokens"},{"location":"reference/core/stdlib/docs/jwt/#encodepayload-key","text":"Encode a JWT for target payload signed with key . Currently only ES256 encoding algorithm using prime256v1 curve is supported. key must be an ECDSA private key in hex format. If a private key is, for example, stored as a pem file, the needed hex string can be extracted from the OCTET STRING field associated value obtained from openssl asn1parse - in my_private . pem command (since pem is a base64 encoded, plus header, DER ).","title":"encode(payload, key)"},{"location":"reference/core/stdlib/docs/math/","text":"Math \u00b6 This module implements various mathematical functions. Except when explicitly noted otherwise, all return values are floats. The underlying implementations works on double precision floats that are converted back to single precision if the VM does not support double precision. No exceptions are raised: in case of error, the return value can be infinite or NaN. Such cases can be checked with the provided functions. The following constants are defined: pi 3.14159265 e 2.71828182 tan(x) Return the tangent of x radians. cos(x) Return the cosine of x radians. sin(x) Return the sine of x radians. atan2(y, x) Return atan(y / x) , in radians. The result is between -pi and pi . The vector in the plane from the origin to point (x, y) makes this angle with the positive X axis. The point of atan2() is that the signs of both inputs are known to it, so it can compute the correct quadrant for the angle. For example, atan(1) and atan2(1, 1) are both pi/4 , but atan2(-1, -1) is -3\\*pi/4 . atan(x) Return the arc tangent of x , in radians. acos(x) Return the arc cosine of x , in radians. asin(x) Return the arc sine of x , in radians. degress(rad) Converts rad from radians to degrees. radians(degree) Converts degree from degrees to radians. exp(x) Return e\\*\\*x . log(x, ) With one argument or with base non positive, return the natural logarithm of x (to base e ). With two arguments, return the logarithm of x to the given base , calculated as log(x)/log(base) . pow(x, y) Return x raised to the power y . Unlike the built-in \\*\\* operator, math.pow() converts both its arguments to type float() . Use \\*\\* or the built-in pow() function for computing exact integer powers. sqrt(x) Return the square root of x . isnan(x) Return True if x is a NaN (not a number), and False otherwise. isinf(x) Return True if x is a positive or negative infinity, and False otherwise. floor(x) Return the floor of x , the largest integer less than or equal to x . ceil(x) Return the ceiling of x , the smallest integer greater than or equal to x .","title":"Math"},{"location":"reference/core/stdlib/docs/math/#math","text":"This module implements various mathematical functions. Except when explicitly noted otherwise, all return values are floats. The underlying implementations works on double precision floats that are converted back to single precision if the VM does not support double precision. No exceptions are raised: in case of error, the return value can be infinite or NaN. Such cases can be checked with the provided functions. The following constants are defined: pi 3.14159265 e 2.71828182 tan(x) Return the tangent of x radians. cos(x) Return the cosine of x radians. sin(x) Return the sine of x radians. atan2(y, x) Return atan(y / x) , in radians. The result is between -pi and pi . The vector in the plane from the origin to point (x, y) makes this angle with the positive X axis. The point of atan2() is that the signs of both inputs are known to it, so it can compute the correct quadrant for the angle. For example, atan(1) and atan2(1, 1) are both pi/4 , but atan2(-1, -1) is -3\\*pi/4 . atan(x) Return the arc tangent of x , in radians. acos(x) Return the arc cosine of x , in radians. asin(x) Return the arc sine of x , in radians. degress(rad) Converts rad from radians to degrees. radians(degree) Converts degree from degrees to radians. exp(x) Return e\\*\\*x . log(x, ) With one argument or with base non positive, return the natural logarithm of x (to base e ). With two arguments, return the logarithm of x to the given base , calculated as log(x)/log(base) . pow(x, y) Return x raised to the power y . Unlike the built-in \\*\\* operator, math.pow() converts both its arguments to type float() . Use \\*\\* or the built-in pow() function for computing exact integer powers. sqrt(x) Return the square root of x . isnan(x) Return True if x is a NaN (not a number), and False otherwise. isinf(x) Return True if x is a positive or negative infinity, and False otherwise. floor(x) Return the floor of x , the largest integer less than or equal to x . ceil(x) Return the ceiling of x , the smallest integer greater than or equal to x .","title":"Math"},{"location":"reference/core/stdlib/docs/mcu/","text":"MCU \u00b6 This module enables the access to low level microcontroller functionalities like: unique identifiers soft reset reset() Restart the microcontroller. uid() Return a bytes object containing the unique id of the mcu","title":"MCU"},{"location":"reference/core/stdlib/docs/mcu/#mcu","text":"This module enables the access to low level microcontroller functionalities like: unique identifiers soft reset reset() Restart the microcontroller. uid() Return a bytes object containing the unique id of the mcu","title":"MCU"},{"location":"reference/core/stdlib/docs/msgpack/","text":"MsgPack \u00b6 This module define functions to serialize and unserialize objects to and from msgpack format. Objects serialized with msgpack are usually smaller than their equivalent json representation. The supported formats are shown in the table below. Format name First byte (in binary) First byte (in hex) positive fixint 0xxxxxxx 0x00 - 0x7f fixmap 1000xxxx 0x80 - 0x8f fixarray 1001xxxx 0x90 - 0x9f fixstr 101xxxxx 0xa0 - 0xbf nil 11000000 0xc0 false 11000010 0xc2 true 11000011 0xc3 bin 8 11000100 0xc4 bin 16 11000101 0xc5 float 32 11001010 0xca uint 8 11001100 0xcc uint 16 11001101 0xcd uint 32 11001110 0xce int 8 11010000 0xd0 int 16 11010001 0xd1 int 32 11010010 0xd2 str 8 11011001 0xd9 str 16 11011010 0xda array 16 11011100 0xdc map 16 11011110 0xde negative fixint 111xxxxx 0xe0 - 0xff pack(obj) Returns a bytearray containing the msgpack representation of obj . Raises MsgPackError when obj contains non serializable objects. unpack(data, offs=0) Returns an object represented in msgpack format inside the byte sequence data starting from offset offs . Not every valid msgpack representation can be converted to python objects by unpack . For example, 64-bit msgpack integers and msgpack ext types. In that case, MsgUnpackError is raised.","title":"MsgPack"},{"location":"reference/core/stdlib/docs/msgpack/#msgpack","text":"This module define functions to serialize and unserialize objects to and from msgpack format. Objects serialized with msgpack are usually smaller than their equivalent json representation. The supported formats are shown in the table below. Format name First byte (in binary) First byte (in hex) positive fixint 0xxxxxxx 0x00 - 0x7f fixmap 1000xxxx 0x80 - 0x8f fixarray 1001xxxx 0x90 - 0x9f fixstr 101xxxxx 0xa0 - 0xbf nil 11000000 0xc0 false 11000010 0xc2 true 11000011 0xc3 bin 8 11000100 0xc4 bin 16 11000101 0xc5 float 32 11001010 0xca uint 8 11001100 0xcc uint 16 11001101 0xcd uint 32 11001110 0xce int 8 11010000 0xd0 int 16 11010001 0xd1 int 32 11010010 0xd2 str 8 11011001 0xd9 str 16 11011010 0xda array 16 11011100 0xdc map 16 11011110 0xde negative fixint 111xxxxx 0xe0 - 0xff pack(obj) Returns a bytearray containing the msgpack representation of obj . Raises MsgPackError when obj contains non serializable objects. unpack(data, offs=0) Returns an object represented in msgpack format inside the byte sequence data starting from offset offs . Not every valid msgpack representation can be converted to python objects by unpack . For example, 64-bit msgpack integers and msgpack ext types. In that case, MsgUnpackError is raised.","title":"MsgPack"},{"location":"reference/core/stdlib/docs/ntpclient/","text":"NTPClient Library \u00b6 This library retrieve the current time from an NTP server. A method to convert the timestamp from ntc to a human readable format is available in the examples. NTPClient class \u00b6 NTPClient(conn_ifc, ) Create an instance of the NTPClient class which allow communication with the NTPServer. If no server is provided, a default one will be used. Arguments conn_ifc \u2013 a connection interface that must be initialized by the user. server \u2013 the server to be used. get_time() Retrieve the amount of second passed since January 1 st 1900 from the NTP Server. Returns: The amount of second passed since January 1st 1900.","title":"NTPClient Library"},{"location":"reference/core/stdlib/docs/ntpclient/#ntpclient-library","text":"This library retrieve the current time from an NTP server. A method to convert the timestamp from ntc to a human readable format is available in the examples.","title":"NTPClient Library"},{"location":"reference/core/stdlib/docs/ntpclient/#ntpclient-class","text":"NTPClient(conn_ifc, ) Create an instance of the NTPClient class which allow communication with the NTPServer. If no server is provided, a default one will be used. Arguments conn_ifc \u2013 a connection interface that must be initialized by the user. server \u2013 the server to be used. get_time() Retrieve the amount of second passed since January 1 st 1900 from the NTP Server. Returns: The amount of second passed since January 1st 1900.","title":"NTPClient class"},{"location":"reference/core/stdlib/docs/os/","text":"Operating System \u00b6 This module implements a generic os interface. To function correctly it needs a filesystem to be mounted, so that the module can use the driver to access the underlying hardware. Note Every path needed as argument for an os function must follow chosen driver path convention. File/Directory access error due to low-level failure will raise an OSError. exists(path) Return True if path refers to an existing path, False otherwise. isdir(path) Return True if path is an existing directory, False otherwise. remove(path) Remove (delete) the file path. If path is a directory, OSError is raised; see rmdir() below to remove a directory. rmdir(path) Remove (delete) the directory path. Only works when the directory is empty, otherwise, OSError is raised. rename(src_path, dst_path) Rename the file or directory src_path to dst_path. If dst_path is a directory, OSError will be raised. mkdir(path) Create a directory named path. chdir(path) Change the current working directory to path. getcwd() Return a string representing the current working directory. Since C filesystem drivers need a limit on returned string length: os . cwd_max_length attribute is set to 128 by default but can be adjusted, if needed, before calling getcwd() . listdir(path) Return a list containing the names of the entries in the directory given by path. The list is in arbitrary order. It does not include the special entries \u2018.\u2019 and \u2018..\u2019 even if they are present in the directory. copyfile(src, dst) Copy the contents of the file named src to a file named dst. The FileIO class \u00b6 FileIO(path, mode = 'r') Main class to handle files. path is a string (following chosen low-level filesystem driver format) mode is a string: * \u2018 r \u2019 open for reading ( default ) * \u2018 w \u2019 open for writing , truncating the file first * \u2018 a \u2019 open for writing , appending to the end of the file if it exists * \u2018 b \u2019 binary mode * \u2018 + \u2019 open a disk file for updating ( reading and writing ) read(n_bytes = -1) Read up to size bytes from the object and return them. As a convenience, if size is unspecified or -1, the whole file is read. Return type can be string or bytes depending on chosen mode. An empty string or an empty bytes object indicate end of file. write(to_w, sync = False) Write to_w object (string or bytes) to the stream and return the number of characters written. sync parameter allows to write changes to disk immediately, without waiting close() call. close() Close file stream. size() Return file size. tell() Return the current stream position. seek(offset, whence=0) Move the current position to offset bytes with respect to whence . whence can be: 0: start of file 1: current position 2: end of file truncate() Resize the stream to the given size in bytes (or the current position if size is not specified). The current stream position isn\u2019t changed. readline() Read until newline or EOF and return a single str. If the stream is already at EOF, an empty string is returned.","title":"Operating System"},{"location":"reference/core/stdlib/docs/os/#operating-system","text":"This module implements a generic os interface. To function correctly it needs a filesystem to be mounted, so that the module can use the driver to access the underlying hardware. Note Every path needed as argument for an os function must follow chosen driver path convention. File/Directory access error due to low-level failure will raise an OSError. exists(path) Return True if path refers to an existing path, False otherwise. isdir(path) Return True if path is an existing directory, False otherwise. remove(path) Remove (delete) the file path. If path is a directory, OSError is raised; see rmdir() below to remove a directory. rmdir(path) Remove (delete) the directory path. Only works when the directory is empty, otherwise, OSError is raised. rename(src_path, dst_path) Rename the file or directory src_path to dst_path. If dst_path is a directory, OSError will be raised. mkdir(path) Create a directory named path. chdir(path) Change the current working directory to path. getcwd() Return a string representing the current working directory. Since C filesystem drivers need a limit on returned string length: os . cwd_max_length attribute is set to 128 by default but can be adjusted, if needed, before calling getcwd() . listdir(path) Return a list containing the names of the entries in the directory given by path. The list is in arbitrary order. It does not include the special entries \u2018.\u2019 and \u2018..\u2019 even if they are present in the directory. copyfile(src, dst) Copy the contents of the file named src to a file named dst.","title":"Operating System"},{"location":"reference/core/stdlib/docs/os/#the-fileio-class","text":"FileIO(path, mode = 'r') Main class to handle files. path is a string (following chosen low-level filesystem driver format) mode is a string: * \u2018 r \u2019 open for reading ( default ) * \u2018 w \u2019 open for writing , truncating the file first * \u2018 a \u2019 open for writing , appending to the end of the file if it exists * \u2018 b \u2019 binary mode * \u2018 + \u2019 open a disk file for updating ( reading and writing ) read(n_bytes = -1) Read up to size bytes from the object and return them. As a convenience, if size is unspecified or -1, the whole file is read. Return type can be string or bytes depending on chosen mode. An empty string or an empty bytes object indicate end of file. write(to_w, sync = False) Write to_w object (string or bytes) to the stream and return the number of characters written. sync parameter allows to write changes to disk immediately, without waiting close() call. close() Close file stream. size() Return file size. tell() Return the current stream position. seek(offset, whence=0) Move the current position to offset bytes with respect to whence . whence can be: 0: start of file 1: current position 2: end of file truncate() Resize the stream to the given size in bytes (or the current position if size is not specified). The current stream position isn\u2019t changed. readline() Read until newline or EOF and return a single str. If the stream is already at EOF, an empty string is returned.","title":"The FileIO class"},{"location":"reference/core/stdlib/docs/pwm/","text":"Pulse Width Modulation \u00b6 This module loads the Pulse Width Modulation (pwm) driver of the embedded device. When imported, automatically sets the system pwm driver to the default one. init(drvname) Loads the pwm driver identified by drvname Returns the previous driver without disabling it. write(pin, period, pulse, time_unit=MILLIS, npulses=0) Activate PWM (Pulse Width Modulation) on pin pin (must be one of the PWMx pins, expressed as Dx.PWM). The state of pin is periodically switched between LOW and HIGH according to parameters: period is the duration of a pwm square wave pulse is the time the pwm square wave stays in the HIGH state time_unit is the unit of time period and pulse are expressed in A PWM wave can be depicted as a train of elements made like this: HIGH _________________ _________________ | | | | | | | | _____| |________| |____ LOW <-----PULSE------> <-----PERIOD--------------> Here are some examples: #Remember to import the pwm module import pwm # A 1000 milliseconds wave that stays HIGH for 100 milliseconds and LOW for 900 pwm . write ( D5 . PWM , 1000 , 100 ) # A 500 microseconds wave that stays HIGH for 10 microseconds and LOW for 490 pwm . write ( D5 . PWM , 500 , 10 , MICROS ) # Disable pwm pwm . write ( D5 . PWM , 0 , 0 ) Some boards have restrictions on how pwm pins can be used, refer to the single board documentation for details. The parameter npulses is used to specify a limited train of pulses. When npulses is zero or less, PWM is activated on the pin and the function returns. When npulses is more than zero, pwm.write becomes blocking and returns only after a number of pulses equal to npulses has been generated on the pin; PWM is disabled on return. For very small pulses in the range of a few ten microseconds, the actual number of pulses produced may be greater than npulses by one or two units. An example: #Remember to import the pwm module import pwm # A 1000 milliseconds wave that stays HIGH for 100 milliseconds and LOW for 900 # pwm.write returns after 5 pulses (i.e. after 4100 milliseconds) pwm . write ( D5 . PWM , 1000 , 100 , npulses = 5 ) Available time units are: NANOS, MICROS, MILLIS, SECONDS. The precision, or even the correcteness, of a pwm period/pulse configuration when expressed in nanoseconds may greatly vary between microcontrollers. Indeed it depends on the clock of the peripheral implementing the pwm signal. For example, an MCU running at 100 MHz can, in teory, generate a pwm signal as precise as 10 ns.","title":"Pulse Width Modulation"},{"location":"reference/core/stdlib/docs/pwm/#pulse-width-modulation","text":"This module loads the Pulse Width Modulation (pwm) driver of the embedded device. When imported, automatically sets the system pwm driver to the default one. init(drvname) Loads the pwm driver identified by drvname Returns the previous driver without disabling it. write(pin, period, pulse, time_unit=MILLIS, npulses=0) Activate PWM (Pulse Width Modulation) on pin pin (must be one of the PWMx pins, expressed as Dx.PWM). The state of pin is periodically switched between LOW and HIGH according to parameters: period is the duration of a pwm square wave pulse is the time the pwm square wave stays in the HIGH state time_unit is the unit of time period and pulse are expressed in A PWM wave can be depicted as a train of elements made like this: HIGH _________________ _________________ | | | | | | | | _____| |________| |____ LOW <-----PULSE------> <-----PERIOD--------------> Here are some examples: #Remember to import the pwm module import pwm # A 1000 milliseconds wave that stays HIGH for 100 milliseconds and LOW for 900 pwm . write ( D5 . PWM , 1000 , 100 ) # A 500 microseconds wave that stays HIGH for 10 microseconds and LOW for 490 pwm . write ( D5 . PWM , 500 , 10 , MICROS ) # Disable pwm pwm . write ( D5 . PWM , 0 , 0 ) Some boards have restrictions on how pwm pins can be used, refer to the single board documentation for details. The parameter npulses is used to specify a limited train of pulses. When npulses is zero or less, PWM is activated on the pin and the function returns. When npulses is more than zero, pwm.write becomes blocking and returns only after a number of pulses equal to npulses has been generated on the pin; PWM is disabled on return. For very small pulses in the range of a few ten microseconds, the actual number of pulses produced may be greater than npulses by one or two units. An example: #Remember to import the pwm module import pwm # A 1000 milliseconds wave that stays HIGH for 100 milliseconds and LOW for 900 # pwm.write returns after 5 pulses (i.e. after 4100 milliseconds) pwm . write ( D5 . PWM , 1000 , 100 , npulses = 5 ) Available time units are: NANOS, MICROS, MILLIS, SECONDS. The precision, or even the correcteness, of a pwm period/pulse configuration when expressed in nanoseconds may greatly vary between microcontrollers. Indeed it depends on the clock of the peripheral implementing the pwm signal. For example, an MCU running at 100 MHz can, in teory, generate a pwm signal as precise as 10 ns.","title":"Pulse Width Modulation"},{"location":"reference/core/stdlib/docs/pwr/","text":"Power Management \u00b6 This module enables access to power management functionalities specific to the target microcontroller. It can be safely imported in every program, however its functions will raise UnsupportedError if the target VM is not enabled for power management features ( a premium VM with the OTA feature enabled is needed ). There exists two methods of reducing power consumption: optimizing runtime behaviour of the VM task scheduler writing programs that put the microcontroller in low consumption states The first method is implemented internally by the VM using, when possibile, a tickless version of the underlying RTOS. The second method rests on the programmer. Note During a low power mode the VM stops taking into account the passing of time! Semaphores, locks, suspended threads and software timers will behave as if low power mode was never entered. Power management is a very platform specific feature of each microcontroller, therefore each function of this module is subject to the mcu limitations. For reference: STM32F families NXP K64 families Microchip SAMD21 ESP8266 Power management model \u00b6 Zerynth tries to abstract the many different power management features of different microcontrollers with the following model: There exist three low power modes: SLEEP, STOP and STANDBY mode The programmer can enter a low power mode by calling the function go_to_sleep() To exit a low power mode the programmer can setup either a timer or an external event (or both) Once exited from a low power mode the programmer can query the VM with the function wakeup_reason() to retrieve the cause of exit The programmer can, before entering a low power mode, save some data that is guaranteed to be preserved during low power mode The following constants are defined: PWR_STANDBY , for STANDBY mode. It is the mode with the lowest consumption because it removes power to RAM and Flash. Therefore, when exiting from STANDBY the VM restarts and executes the program from the beginning. PWR_STOP , for STOP mode. It is the mode with low consumption that keeps RAM powered. On exit the VM restart the program from where it was suspended. PWR_SLEEP , for SLEEP mode. It keeps RAM and most peripherals powered therefore obtaining PWR_RESET , to indicate power reset as the exit reason from a low power mode PWR_INTERRUPT , to indicate an asynchronous interrupt as the exit reason from a low power mode PWR_TIMEOUT , to indicate a reached timeout as the exit reason from a low power mode PWR_WATCHDOG , to indicate watchdog triggered reset as the exit reason from a low power mode go_to_sleep(timeout, mode) Enter a low power mode specified by mode (one of PWR_STANDBY , PWR_STOP or PWR_SLEEP ). timeout (in milliseconds) is used to exit the low power mode after the specified timeout. If zero or negative, no timeout is enabled and the only way to exit low power mode is to configure an asynchronous interrupt. The time to enter (and exit) a low power mode is platform dependent and can be significative. Return the time in milliseconds spent in low power mode. wakeup_reason() Return the reason of exit from low power mode. It is useful to change the program behaviour based on low power mode exit reason. get_status_size() Return the size in bytes of the space available to safely store data before entering a very low power mode (STANDBY). If zero is returned, the target microcontroller doesn\u2019t have a special purpose memory for saving the program state between low power modes. set_status_byte(pos, val) Save val to the position pos in the special purpose memory. If pos is out of the memory boundaries, an exception is raised. get_status_byte(pos) Retrieve the byte at position pos in the special purpose memory. If pos is out of the memory boundaries, an exception is raised. Power management for STM32Fxx families \u00b6 For this set of microcontrollers the following modes are enabled: STANDBY mode is equivalent to the microcontroller standby mode (RAM is not preserved). It can be exited by a rising edge on the MCU WakeUp pin or by a timeout STOP mode is equivalent to the microcontroller stop mode. It can be exited by a rising edge on the MCU WakeUp pin or by any configured GPIO for interrupts (with OnPinRise() or OnPinFall() ) or by a timeout SLEEP mode is equivalent to the microcontroller sleep mode. It can be exited by any interrupt or timeout. For low power modes timeouts: * the Real Time Clock ( RTC ) of the microcontroller is started and configured at VM startup * It is driven by the internal 32 kHz oscillator with a prescaler of 16 ; therefore the maximum timeout for a low power mode is 16 seconds . * The time spent in low power is returned by ` go_to_sleep () ` with a precision of 1 millisecond The special purpose memory for low power mode status is the RTC backup domain (80 bytes). Power management for NXP K64 families \u00b6 For this set of microcontrollers the following modes are enabled: STANDBY mode is equivalent to the microcontroller VLLS1 mode (RAM is not preserved). It can be exited by a configured interrupt (with OnPinRise() or OnPinFall() ) on any of the WakeUp pins or by a timeout. STOP mode is equivalent to the microcontroller stop mode. It can be exited by any configured GPIO for interrupts (with OnPinRise() or OnPinFall() ) or by a timeout SLEEP mode is equivalent to the microcontroller sleep mode. It can be exited by any interrupt or timeout. For low power modes timeouts: * the Low Power Timer ( LPTMR ) of the microcontroller is started and configured at VM startup * It is driven by the internal 1 kHz oscillator with a prescaler of 256 ; therefore the maximum timeout for a low power mode is 16776 milliseconds . * The time spent in low power is returned by ` go_to_sleep () ` with a precision of ~ 250 milliseconds The special purpose memory for low power mode status is the VBAT register file (32 bytes). Power management for Microchip SAMD21 \u00b6 For this set of microcontrollers the following modes are enabled: STANDBY mode is not supported. STOP mode is equivalent to the microcontroller standby mode (RAM is preserved). It can be exited by a timeout only SLEEP mode is equivalent to the microcontroller IDLE2 mode. It can be exited by any interrupt or timeout. For low power modes timeouts: * the RTC of the microcontroller is started and configured at VM startup * It is driven by the internal 1 kHz oscillator ; therefore the maximum timeout for a low power mode is ~ 74 hours . * The time spent in low power is returned by ` go_to_sleep () ` with a precision of 1 millisecond . No special purpose memory for low power mode status is present. Power management for Esp8266 \u00b6 For Esp8266 based devices, the only available mode is STANDBY (equivalent to deep sleep). RAM is not preserved. It can be exited by a timeout or by a signal on the WakeUp pin (GPIO 16). For Esp8266 based boards that have a led attached to GPIO 16, the led is disabled during VM startup since it may cause a system reset. For low power modes timeouts: * RTC is used . * The maximum timeout is 1073 seconds * The time spent in STANDBY mode is not returned by ` go_to_sleep () ` ( always return 0 ) The special purpose memory for low power mode status is the RTC memory (400 bytes available).","title":"Power Management"},{"location":"reference/core/stdlib/docs/pwr/#power-management","text":"This module enables access to power management functionalities specific to the target microcontroller. It can be safely imported in every program, however its functions will raise UnsupportedError if the target VM is not enabled for power management features ( a premium VM with the OTA feature enabled is needed ). There exists two methods of reducing power consumption: optimizing runtime behaviour of the VM task scheduler writing programs that put the microcontroller in low consumption states The first method is implemented internally by the VM using, when possibile, a tickless version of the underlying RTOS. The second method rests on the programmer. Note During a low power mode the VM stops taking into account the passing of time! Semaphores, locks, suspended threads and software timers will behave as if low power mode was never entered. Power management is a very platform specific feature of each microcontroller, therefore each function of this module is subject to the mcu limitations. For reference: STM32F families NXP K64 families Microchip SAMD21 ESP8266","title":"Power Management"},{"location":"reference/core/stdlib/docs/pwr/#power-management-model","text":"Zerynth tries to abstract the many different power management features of different microcontrollers with the following model: There exist three low power modes: SLEEP, STOP and STANDBY mode The programmer can enter a low power mode by calling the function go_to_sleep() To exit a low power mode the programmer can setup either a timer or an external event (or both) Once exited from a low power mode the programmer can query the VM with the function wakeup_reason() to retrieve the cause of exit The programmer can, before entering a low power mode, save some data that is guaranteed to be preserved during low power mode The following constants are defined: PWR_STANDBY , for STANDBY mode. It is the mode with the lowest consumption because it removes power to RAM and Flash. Therefore, when exiting from STANDBY the VM restarts and executes the program from the beginning. PWR_STOP , for STOP mode. It is the mode with low consumption that keeps RAM powered. On exit the VM restart the program from where it was suspended. PWR_SLEEP , for SLEEP mode. It keeps RAM and most peripherals powered therefore obtaining PWR_RESET , to indicate power reset as the exit reason from a low power mode PWR_INTERRUPT , to indicate an asynchronous interrupt as the exit reason from a low power mode PWR_TIMEOUT , to indicate a reached timeout as the exit reason from a low power mode PWR_WATCHDOG , to indicate watchdog triggered reset as the exit reason from a low power mode go_to_sleep(timeout, mode) Enter a low power mode specified by mode (one of PWR_STANDBY , PWR_STOP or PWR_SLEEP ). timeout (in milliseconds) is used to exit the low power mode after the specified timeout. If zero or negative, no timeout is enabled and the only way to exit low power mode is to configure an asynchronous interrupt. The time to enter (and exit) a low power mode is platform dependent and can be significative. Return the time in milliseconds spent in low power mode. wakeup_reason() Return the reason of exit from low power mode. It is useful to change the program behaviour based on low power mode exit reason. get_status_size() Return the size in bytes of the space available to safely store data before entering a very low power mode (STANDBY). If zero is returned, the target microcontroller doesn\u2019t have a special purpose memory for saving the program state between low power modes. set_status_byte(pos, val) Save val to the position pos in the special purpose memory. If pos is out of the memory boundaries, an exception is raised. get_status_byte(pos) Retrieve the byte at position pos in the special purpose memory. If pos is out of the memory boundaries, an exception is raised.","title":"Power management model"},{"location":"reference/core/stdlib/docs/pwr/#power-management-for-stm32fxx-families","text":"For this set of microcontrollers the following modes are enabled: STANDBY mode is equivalent to the microcontroller standby mode (RAM is not preserved). It can be exited by a rising edge on the MCU WakeUp pin or by a timeout STOP mode is equivalent to the microcontroller stop mode. It can be exited by a rising edge on the MCU WakeUp pin or by any configured GPIO for interrupts (with OnPinRise() or OnPinFall() ) or by a timeout SLEEP mode is equivalent to the microcontroller sleep mode. It can be exited by any interrupt or timeout. For low power modes timeouts: * the Real Time Clock ( RTC ) of the microcontroller is started and configured at VM startup * It is driven by the internal 32 kHz oscillator with a prescaler of 16 ; therefore the maximum timeout for a low power mode is 16 seconds . * The time spent in low power is returned by ` go_to_sleep () ` with a precision of 1 millisecond The special purpose memory for low power mode status is the RTC backup domain (80 bytes).","title":"Power management for STM32Fxx families"},{"location":"reference/core/stdlib/docs/pwr/#power-management-for-nxp-k64-families","text":"For this set of microcontrollers the following modes are enabled: STANDBY mode is equivalent to the microcontroller VLLS1 mode (RAM is not preserved). It can be exited by a configured interrupt (with OnPinRise() or OnPinFall() ) on any of the WakeUp pins or by a timeout. STOP mode is equivalent to the microcontroller stop mode. It can be exited by any configured GPIO for interrupts (with OnPinRise() or OnPinFall() ) or by a timeout SLEEP mode is equivalent to the microcontroller sleep mode. It can be exited by any interrupt or timeout. For low power modes timeouts: * the Low Power Timer ( LPTMR ) of the microcontroller is started and configured at VM startup * It is driven by the internal 1 kHz oscillator with a prescaler of 256 ; therefore the maximum timeout for a low power mode is 16776 milliseconds . * The time spent in low power is returned by ` go_to_sleep () ` with a precision of ~ 250 milliseconds The special purpose memory for low power mode status is the VBAT register file (32 bytes).","title":"Power management for NXP K64 families"},{"location":"reference/core/stdlib/docs/pwr/#power-management-for-microchip-samd21","text":"For this set of microcontrollers the following modes are enabled: STANDBY mode is not supported. STOP mode is equivalent to the microcontroller standby mode (RAM is preserved). It can be exited by a timeout only SLEEP mode is equivalent to the microcontroller IDLE2 mode. It can be exited by any interrupt or timeout. For low power modes timeouts: * the RTC of the microcontroller is started and configured at VM startup * It is driven by the internal 1 kHz oscillator ; therefore the maximum timeout for a low power mode is ~ 74 hours . * The time spent in low power is returned by ` go_to_sleep () ` with a precision of 1 millisecond . No special purpose memory for low power mode status is present.","title":"Power management for Microchip SAMD21"},{"location":"reference/core/stdlib/docs/pwr/#power-management-for-esp8266","text":"For Esp8266 based devices, the only available mode is STANDBY (equivalent to deep sleep). RAM is not preserved. It can be exited by a timeout or by a signal on the WakeUp pin (GPIO 16). For Esp8266 based boards that have a led attached to GPIO 16, the led is disabled during VM startup since it may cause a system reset. For low power modes timeouts: * RTC is used . * The maximum timeout is 1073 seconds * The time spent in STANDBY mode is not returned by ` go_to_sleep () ` ( always return 0 ) The special purpose memory for low power mode status is the RTC memory (400 bytes available).","title":"Power management for Esp8266"},{"location":"reference/core/stdlib/docs/qspiflash/","text":"QSpiFlash class \u00b6 class QSpiFlash() \u00b6 Initialize a a QspiFlash peripheral (external flash memory handled by qspi). This peripheral is available only for stm32l4 family chip and for Polaris device the auto_init is implemented (pins and memory data already configured). To initialize a custom external memory qspi flash several params must be passed to the init method: Arguments d0 \u2013 D0 pin of the Qspi peripheral d1 \u2013 D1 pin of the Qspi peripheral d2 \u2013 D2 pin of the Qspi peripheral d3 \u2013 D3 pin of the Qspi peripheral clk \u2013 CLK pin of the Qspi peripheral cs \u2013 CS pin of the Qspi peripheral flash_size \u2013 Flash size of the qspi flash block_size \u2013 Block size of the qspi flash subblock_size \u2013 Sub-block size of the qspi flash sector_size \u2013 Sector size of the qspi flash page_size \u2013 Page size of the qspi flash dummy_cycles_read \u2013 Dummy cycles simple read dummy_cycles_read_dual \u2013 Dummy cycles Dual flash read dummy_cycles_read_quad \u2013 Dummy cicles Quad Flash read dummy_cycles_2read \u2013 Dummy cycles 2read dummy_cycles_4read \u2013 Dummy Cycles 4read alt_bytes_pe_mode \u2013 Alternate Bytes for PE mode alt_bytes_no_pe_mode \u2013 Alternate Bytes for NO PE mode sr_wip \u2013 Write in progress of the flash mamory status register sr_wel \u2013 Write enable latch of the flash mamory status register sr_bp \u2013 Block protect of the flash mamory status register sr_srwd \u2013 Write disable of the flash mamory status register sr1_qe \u2013 Quad enable of the flash mamory status register1 sr1_sus \u2013 Suspend status of the flash mamory status register1 get_geometry() Return a tuple holding flash geometry: flash_size , Flash size of the qspi flash block_size , Block size of the qspi flash subblock_size , Sub-block size of the qspi flash sector_size , Sector size of the qspi flash page_size , Page size of the qspi flash write_data(addr, data) Write data data starting from address addr . data can be a bytearray or a list of integers less than 256. erase_sector() MUST be called before writing data in a sector. Writing is also allowed via bracket notation. The following is valid syntax: my_flash [ addr ] = data erase_sector(addr) Erase a whole sector passing the addr address of any byte contained in it. All sector bytes set to 0xff. erase_block(addr) Erase a memory block passing the addr address of any byte contained in it. All block bytes set to 0xff. read_data(addr, n=1) Read n bytes of data starting from address addr . Reading is also allowed via bracket notation. The following is valid syntax: my_data = my_flash[addr:addr+n] ** chip_erase() ** Erase the whole memory. All memory bytes set to 0xff. done() Close the QspiFlash peripheral. wakeup() Wake Up the QspiFlash peripheral from sleep mode. sleep() Put the QspiFlash peripheral in sleep mode.","title":"QSpiFlash class"},{"location":"reference/core/stdlib/docs/qspiflash/#qspiflash-class","text":"","title":"QSpiFlash class"},{"location":"reference/core/stdlib/docs/qspiflash/#class-qspiflash","text":"Initialize a a QspiFlash peripheral (external flash memory handled by qspi). This peripheral is available only for stm32l4 family chip and for Polaris device the auto_init is implemented (pins and memory data already configured). To initialize a custom external memory qspi flash several params must be passed to the init method: Arguments d0 \u2013 D0 pin of the Qspi peripheral d1 \u2013 D1 pin of the Qspi peripheral d2 \u2013 D2 pin of the Qspi peripheral d3 \u2013 D3 pin of the Qspi peripheral clk \u2013 CLK pin of the Qspi peripheral cs \u2013 CS pin of the Qspi peripheral flash_size \u2013 Flash size of the qspi flash block_size \u2013 Block size of the qspi flash subblock_size \u2013 Sub-block size of the qspi flash sector_size \u2013 Sector size of the qspi flash page_size \u2013 Page size of the qspi flash dummy_cycles_read \u2013 Dummy cycles simple read dummy_cycles_read_dual \u2013 Dummy cycles Dual flash read dummy_cycles_read_quad \u2013 Dummy cicles Quad Flash read dummy_cycles_2read \u2013 Dummy cycles 2read dummy_cycles_4read \u2013 Dummy Cycles 4read alt_bytes_pe_mode \u2013 Alternate Bytes for PE mode alt_bytes_no_pe_mode \u2013 Alternate Bytes for NO PE mode sr_wip \u2013 Write in progress of the flash mamory status register sr_wel \u2013 Write enable latch of the flash mamory status register sr_bp \u2013 Block protect of the flash mamory status register sr_srwd \u2013 Write disable of the flash mamory status register sr1_qe \u2013 Quad enable of the flash mamory status register1 sr1_sus \u2013 Suspend status of the flash mamory status register1 get_geometry() Return a tuple holding flash geometry: flash_size , Flash size of the qspi flash block_size , Block size of the qspi flash subblock_size , Sub-block size of the qspi flash sector_size , Sector size of the qspi flash page_size , Page size of the qspi flash write_data(addr, data) Write data data starting from address addr . data can be a bytearray or a list of integers less than 256. erase_sector() MUST be called before writing data in a sector. Writing is also allowed via bracket notation. The following is valid syntax: my_flash [ addr ] = data erase_sector(addr) Erase a whole sector passing the addr address of any byte contained in it. All sector bytes set to 0xff. erase_block(addr) Erase a memory block passing the addr address of any byte contained in it. All block bytes set to 0xff. read_data(addr, n=1) Read n bytes of data starting from address addr . Reading is also allowed via bracket notation. The following is valid syntax: my_data = my_flash[addr:addr+n] ** chip_erase() ** Erase the whole memory. All memory bytes set to 0xff. done() Close the QspiFlash peripheral. wakeup() Wake Up the QspiFlash peripheral from sleep mode. sleep() Put the QspiFlash peripheral in sleep mode.","title":"class QSpiFlash()"},{"location":"reference/core/stdlib/docs/queue/","text":"Queue \u00b6 The queue module implements multi-producer, multi-consumer queues. It is especially useful in threaded programming when information must be exchanged safely between multiple threads. The Queue class in this module implements all the required locking semantics. Queue class \u00b6 Queue(maxsize=0) Constructor for a FIFO queue. maxsize is an integer that sets the upperbound limit on the number of items that can be placed in the queue. Insertion will block once this size has been reached, until queue items are consumed. If maxsize is less than or equal to zero, the queue size is infinite. qsize() Return the approximate size of the queue. Note, qsize() > 0 doesn\u2019t guarantee that a subsequent get() will not block, nor will qsize() < maxsize guarantee that put() will not block. full() Return True if the queue is full, False otherwise. If full() returns True it doesn\u2019t guarantee that a subsequent call to get() will not block. Similarly, if full() returns False it doesn\u2019t guarantee that a subsequent call to put() will not block. empty() Return True if the queue is empty, False otherwise. If empty() returns True it doesn\u2019t guarantee that a subsequent call to put() will not block. Similarly, if empty() returns False it doesn\u2019t guarantee that a subsequent call to get() will not block. put(obj, block=True, timeout=-1) Insert obj into the queue. If the queue is full, and block is True, block until a free slot becomes available. If block is False, raise QueueFull. If timeout is greater than zero, waits for the specified amount of milliseconds before raising QueueFull exception. get() Remove and return an object out of the queue. If the queue is empty, block until an item is available. peek() Return the object at the head of the queue without removing it. If the queue is empty, wait until an item is available. clear() Clear the queue by removing all elements.","title":"Queue"},{"location":"reference/core/stdlib/docs/queue/#queue","text":"The queue module implements multi-producer, multi-consumer queues. It is especially useful in threaded programming when information must be exchanged safely between multiple threads. The Queue class in this module implements all the required locking semantics.","title":"Queue"},{"location":"reference/core/stdlib/docs/queue/#queue-class","text":"Queue(maxsize=0) Constructor for a FIFO queue. maxsize is an integer that sets the upperbound limit on the number of items that can be placed in the queue. Insertion will block once this size has been reached, until queue items are consumed. If maxsize is less than or equal to zero, the queue size is infinite. qsize() Return the approximate size of the queue. Note, qsize() > 0 doesn\u2019t guarantee that a subsequent get() will not block, nor will qsize() < maxsize guarantee that put() will not block. full() Return True if the queue is full, False otherwise. If full() returns True it doesn\u2019t guarantee that a subsequent call to get() will not block. Similarly, if full() returns False it doesn\u2019t guarantee that a subsequent call to put() will not block. empty() Return True if the queue is empty, False otherwise. If empty() returns True it doesn\u2019t guarantee that a subsequent call to put() will not block. Similarly, if empty() returns False it doesn\u2019t guarantee that a subsequent call to get() will not block. put(obj, block=True, timeout=-1) Insert obj into the queue. If the queue is full, and block is True, block until a free slot becomes available. If block is False, raise QueueFull. If timeout is greater than zero, waits for the specified amount of milliseconds before raising QueueFull exception. get() Remove and return an object out of the queue. If the queue is empty, block until an item is available. peek() Return the object at the head of the queue without removing it. If the queue is empty, wait until an item is available. clear() Clear the queue by removing all elements.","title":"Queue class"},{"location":"reference/core/stdlib/docs/requests/","text":"Requests \u00b6 This module implements functions to easily handle the intricacies of the HTTP protocol. The name and the API are inspired by the wonderful Python module Requests . To use requests a net driver must have been properly configured and started. get(url, params=None, headers=None, connection=None, stream_callback=None, stream_chunk=512) Implements the GET method of the HTTP protocol. A tcp connection is made to the host:port given in the url using the default net driver. If params is given as a dictionary, each pair (key, value) is appended to the requested url, properly encoded and sent. If headers is given as a dictionary, each pair (key, value) is appropriately sent as a HTTP request header. Mandatory headers are transparently handled: \u201cHost:\u201d is always derived by parsing url ; other headers are set to defaults if not given: for example \u201cConnection: close\u201d is sent if no value for \u201cConnection\u201d is specified in headers . To request a permanent connection, headers must contain the pair {\u201cConnection\u201d:\u201dKeep-Alive\u201d}. If connection is given, the initial connection step is skipped and connection is used for communication. This feature allows the reuse of a connection to a HTTP server opened with a \u201cKeep-Alive\u201d header. get returns a Response() instance. Exceptions can be raised: HTTPConnectionError when the HTTP server can\u2019t be contacted; IOError when the source of error lies at the socket level (i.e. closed sockets, invalid sockets, etc..) If the parameter stream_callback is given, the HTTP body data will be retrieved in chunk s of stream_chunk size and passed as arguments to stream_callback one by one. If stream_callback is used, the content of Response() instance is the last chunk. post(url, data=None, json=None, headers=None, ctx=None) Implements the POST method of the HTTP protocol. A tcp connection is made to the host:port given in the url using the default net driver. If headers is given as a dictionary, each pair (key, value) is appropriately sent as a HTTP request header. Mandatory headers are transparently handled: \u201cHost:\u201d is always derived by parsing url ; other headers are set to defaults if not given: for example \u201cConnection: close\u201d is sent if no value for \u201cConnection\u201d is specified in headers . To request a permanent connection, headers must contain the pair {\u201cConnection\u201d:\u201dKeep-Alive\u201d}. If data is provided (always as dictionary), each pair (key, value) will be form-encoded and send in the body of the request with {\u201ccontent-type\u201d:\u201dapplication/x-www-form-urlencoded\u201d} appended in the headers. If json is provided (always as dictionary), json data will send in the body of the request with {\u201ccontent-type\u201d:\u201dapplication/json\u201d} appended in the headers. NOTE : if both ( data and json ) dict are provided, json data are ignored and post request is performed with urlencoded data. post returns a Response() instance. Exceptions can be raised: HTTPConnectionError when the HTTP server can\u2019t be contacted; IOError when the source of error lies at the socket level (i.e. closed sockets, invalid sockets, etc..) put(url, data=None, json=None, headers=None, ctx=None) Implements the PUT method of the HTTP protocol. A tcp connection is made to the host:port given in the url using the default net driver. If headers is given as a dictionary, each pair (key, value) is appropriately sent as a HTTP request header. Mandatory headers are transparently handled: \u201cHost:\u201d is always derived by parsing url ; other headers are set to defaults if not given: for example \u201cConnection: close\u201d is sent if no value for \u201cConnection\u201d is specified in headers . To request a permanent connection, headers must contain the pair {\u201cConnection\u201d:\u201dKeep-Alive\u201d}. If data is provided (always as dictionary), each pair (key, value) will be form-encoded and send in the body of the request with {\u201ccontent-type\u201d:\u201dapplication/x-www-form-urlencoded\u201d} appended in the headers. If json is provided (always as dictionary), json data will send in the body of the request with {\u201ccontent-type\u201d:\u201dapplication/json\u201d} appended in the headers. Note if both ( data and json ) dict are provided, json data are ignored and post request is performed with urlencoded data. put returns a Response() instance. Exceptions can be raised: HTTPConnectionError when the HTTP server can\u2019t be contacted; IOError when the source of error lies at the socket level (i.e. closed sockets, invalid sockets, etc..) patch(url, data=None, headers=None, ctx=None) Implements the PATCH method of the HTTP protocol. A tcp connection is made to the host:port given in the url using the default net driver. If headers is given as a dictionary, each pair (key, value) is appropriately sent as a HTTP request header. Mandatory headers are transparently handled: \u201cHost:\u201d is always derived by parsing url ; other headers are set to defaults if not given: for example \u201cConnection: close\u201d is sent if no value for \u201cConnection\u201d is specified in headers . To request a permanent connection, headers must contain the pair {\u201cConnection\u201d:\u201dKeep-Alive\u201d}. If data is provided (always as dictionary), each pair (key, value) will be form-encoded and send in the body of the request with {\u201ccontent-type\u201d:\u201dapplication/x-www-form-urlencoded\u201d} appended in the headers. If json is provided (always as dictionary), json data will send in the body of the request with {\u201ccontent-type\u201d:\u201dapplication/json\u201d} appended in the headers. Note if both ( data and json ) dict are provided, json data are ignored and post request is performed with urlencoded data. patch returns a Response() instance. Exceptions can be raised: HTTPConnectionError when the HTTP server can\u2019t be contacted; IOError when the source of error lies at the socket level (i.e. closed sockets, invalid sockets, etc..) delete(url, headers=None, ctx=None) Implements the DELETE method of the HTTP protocol. A tcp connection is made to the host:port given in the url using the default net driver. If headers is given as a dictionary, each pair (key, value) is appropriately sent as a HTTP request header. Mandatory headers are transparently handled: \u201cHost:\u201d is always derived by parsing url ; other headers are set to defaults if not given: for example \u201cConnection: close\u201d is sent if no value for \u201cConnection\u201d is specified in headers . To request a permanent connection, headers must contain the pair {\u201cConnection\u201d:\u201dKeep-Alive\u201d}. delete returns a Response() instance. Exceptions can be raised: HTTPConnectionError when the HTTP server can\u2019t be contacted; IOError when the source of error lies at the socket level (i.e. closed sockets, invalid sockets, etc..) head(url, headers=None, ctx=None) Implements the HEAD method of the HTTP protocol. A tcp connection is made to the host:port given in the url using the default net driver. If headers is given as a dictionary, each pair (key, value) is appropriately sent as a HTTP request header. Mandatory headers are transparently handled: \u201cHost:\u201d is always derived by parsing url ; other headers are set to defaults if not given: for example \u201cConnection: close\u201d is sent if no value for \u201cConnection\u201d is specified in headers . To request a permanent connection, headers must contain the pair {\u201cConnection\u201d:\u201dKeep-Alive\u201d}. head returns a Response() instance. Exceptions can be raised: HTTPConnectionError when the HTTP server can\u2019t be contacted; IOError when the source of error lies at the socket level (i.e. closed sockets, invalid sockets, etc..) options(url, headers=None, ctx=None) Implements the OPTIONS method of the HTTP protocol. A tcp connection is made to the host:port given in the url using the default net driver. If headers is given as a dictionary, each pair (key, value) is appropriately sent as a HTTP request header. Mandatory headers are transparently handled: \u201cHost:\u201d is always derived by parsing url ; other headers are set to defaults if not given: for example \u201cConnection: close\u201d is sent if no value for \u201cConnection\u201d is specified in headers . To request a permanent connection, headers must contain the pair {\u201cConnection\u201d:\u201dKeep-Alive\u201d}. options returns a Response() instance. Exceptions can be raised: HTTPConnectionError when the HTTP server can\u2019t be contacted; IOError when the source of error lies at the socket level (i.e. closed sockets, invalid sockets, etc..) upload(url, fd, ctx=None, mime_type=\"application/octet-stream\", method=\"POST\") Upload a file identified by fd to url . fd must provide methods read and size. A tcp connection is made to the host:port given in the url using the default net driver. The type of the file contents and the HTTP method (POST pr PUT) can be customized. upload returns a Response() instance. Exceptions can be raised: HTTPConnectionError when the HTTP server can\u2019t be contacted; IOError when the source of error lies at the socket level (i.e. closed sockets, invalid sockets, file, etc..) Response() This class represent the result of a HTTP request. It contains the following members: status() Contains the HTTP response code content() It is the bytearray containing the byte version of the content section of a HTTP response headers() A dictionary with all the response headers connection() the connection used to communicate with the server, or None if it has been closed. text() Returns a string representing the content section of the HTTP response","title":"Requests"},{"location":"reference/core/stdlib/docs/requests/#requests","text":"This module implements functions to easily handle the intricacies of the HTTP protocol. The name and the API are inspired by the wonderful Python module Requests . To use requests a net driver must have been properly configured and started. get(url, params=None, headers=None, connection=None, stream_callback=None, stream_chunk=512) Implements the GET method of the HTTP protocol. A tcp connection is made to the host:port given in the url using the default net driver. If params is given as a dictionary, each pair (key, value) is appended to the requested url, properly encoded and sent. If headers is given as a dictionary, each pair (key, value) is appropriately sent as a HTTP request header. Mandatory headers are transparently handled: \u201cHost:\u201d is always derived by parsing url ; other headers are set to defaults if not given: for example \u201cConnection: close\u201d is sent if no value for \u201cConnection\u201d is specified in headers . To request a permanent connection, headers must contain the pair {\u201cConnection\u201d:\u201dKeep-Alive\u201d}. If connection is given, the initial connection step is skipped and connection is used for communication. This feature allows the reuse of a connection to a HTTP server opened with a \u201cKeep-Alive\u201d header. get returns a Response() instance. Exceptions can be raised: HTTPConnectionError when the HTTP server can\u2019t be contacted; IOError when the source of error lies at the socket level (i.e. closed sockets, invalid sockets, etc..) If the parameter stream_callback is given, the HTTP body data will be retrieved in chunk s of stream_chunk size and passed as arguments to stream_callback one by one. If stream_callback is used, the content of Response() instance is the last chunk. post(url, data=None, json=None, headers=None, ctx=None) Implements the POST method of the HTTP protocol. A tcp connection is made to the host:port given in the url using the default net driver. If headers is given as a dictionary, each pair (key, value) is appropriately sent as a HTTP request header. Mandatory headers are transparently handled: \u201cHost:\u201d is always derived by parsing url ; other headers are set to defaults if not given: for example \u201cConnection: close\u201d is sent if no value for \u201cConnection\u201d is specified in headers . To request a permanent connection, headers must contain the pair {\u201cConnection\u201d:\u201dKeep-Alive\u201d}. If data is provided (always as dictionary), each pair (key, value) will be form-encoded and send in the body of the request with {\u201ccontent-type\u201d:\u201dapplication/x-www-form-urlencoded\u201d} appended in the headers. If json is provided (always as dictionary), json data will send in the body of the request with {\u201ccontent-type\u201d:\u201dapplication/json\u201d} appended in the headers. NOTE : if both ( data and json ) dict are provided, json data are ignored and post request is performed with urlencoded data. post returns a Response() instance. Exceptions can be raised: HTTPConnectionError when the HTTP server can\u2019t be contacted; IOError when the source of error lies at the socket level (i.e. closed sockets, invalid sockets, etc..) put(url, data=None, json=None, headers=None, ctx=None) Implements the PUT method of the HTTP protocol. A tcp connection is made to the host:port given in the url using the default net driver. If headers is given as a dictionary, each pair (key, value) is appropriately sent as a HTTP request header. Mandatory headers are transparently handled: \u201cHost:\u201d is always derived by parsing url ; other headers are set to defaults if not given: for example \u201cConnection: close\u201d is sent if no value for \u201cConnection\u201d is specified in headers . To request a permanent connection, headers must contain the pair {\u201cConnection\u201d:\u201dKeep-Alive\u201d}. If data is provided (always as dictionary), each pair (key, value) will be form-encoded and send in the body of the request with {\u201ccontent-type\u201d:\u201dapplication/x-www-form-urlencoded\u201d} appended in the headers. If json is provided (always as dictionary), json data will send in the body of the request with {\u201ccontent-type\u201d:\u201dapplication/json\u201d} appended in the headers. Note if both ( data and json ) dict are provided, json data are ignored and post request is performed with urlencoded data. put returns a Response() instance. Exceptions can be raised: HTTPConnectionError when the HTTP server can\u2019t be contacted; IOError when the source of error lies at the socket level (i.e. closed sockets, invalid sockets, etc..) patch(url, data=None, headers=None, ctx=None) Implements the PATCH method of the HTTP protocol. A tcp connection is made to the host:port given in the url using the default net driver. If headers is given as a dictionary, each pair (key, value) is appropriately sent as a HTTP request header. Mandatory headers are transparently handled: \u201cHost:\u201d is always derived by parsing url ; other headers are set to defaults if not given: for example \u201cConnection: close\u201d is sent if no value for \u201cConnection\u201d is specified in headers . To request a permanent connection, headers must contain the pair {\u201cConnection\u201d:\u201dKeep-Alive\u201d}. If data is provided (always as dictionary), each pair (key, value) will be form-encoded and send in the body of the request with {\u201ccontent-type\u201d:\u201dapplication/x-www-form-urlencoded\u201d} appended in the headers. If json is provided (always as dictionary), json data will send in the body of the request with {\u201ccontent-type\u201d:\u201dapplication/json\u201d} appended in the headers. Note if both ( data and json ) dict are provided, json data are ignored and post request is performed with urlencoded data. patch returns a Response() instance. Exceptions can be raised: HTTPConnectionError when the HTTP server can\u2019t be contacted; IOError when the source of error lies at the socket level (i.e. closed sockets, invalid sockets, etc..) delete(url, headers=None, ctx=None) Implements the DELETE method of the HTTP protocol. A tcp connection is made to the host:port given in the url using the default net driver. If headers is given as a dictionary, each pair (key, value) is appropriately sent as a HTTP request header. Mandatory headers are transparently handled: \u201cHost:\u201d is always derived by parsing url ; other headers are set to defaults if not given: for example \u201cConnection: close\u201d is sent if no value for \u201cConnection\u201d is specified in headers . To request a permanent connection, headers must contain the pair {\u201cConnection\u201d:\u201dKeep-Alive\u201d}. delete returns a Response() instance. Exceptions can be raised: HTTPConnectionError when the HTTP server can\u2019t be contacted; IOError when the source of error lies at the socket level (i.e. closed sockets, invalid sockets, etc..) head(url, headers=None, ctx=None) Implements the HEAD method of the HTTP protocol. A tcp connection is made to the host:port given in the url using the default net driver. If headers is given as a dictionary, each pair (key, value) is appropriately sent as a HTTP request header. Mandatory headers are transparently handled: \u201cHost:\u201d is always derived by parsing url ; other headers are set to defaults if not given: for example \u201cConnection: close\u201d is sent if no value for \u201cConnection\u201d is specified in headers . To request a permanent connection, headers must contain the pair {\u201cConnection\u201d:\u201dKeep-Alive\u201d}. head returns a Response() instance. Exceptions can be raised: HTTPConnectionError when the HTTP server can\u2019t be contacted; IOError when the source of error lies at the socket level (i.e. closed sockets, invalid sockets, etc..) options(url, headers=None, ctx=None) Implements the OPTIONS method of the HTTP protocol. A tcp connection is made to the host:port given in the url using the default net driver. If headers is given as a dictionary, each pair (key, value) is appropriately sent as a HTTP request header. Mandatory headers are transparently handled: \u201cHost:\u201d is always derived by parsing url ; other headers are set to defaults if not given: for example \u201cConnection: close\u201d is sent if no value for \u201cConnection\u201d is specified in headers . To request a permanent connection, headers must contain the pair {\u201cConnection\u201d:\u201dKeep-Alive\u201d}. options returns a Response() instance. Exceptions can be raised: HTTPConnectionError when the HTTP server can\u2019t be contacted; IOError when the source of error lies at the socket level (i.e. closed sockets, invalid sockets, etc..) upload(url, fd, ctx=None, mime_type=\"application/octet-stream\", method=\"POST\") Upload a file identified by fd to url . fd must provide methods read and size. A tcp connection is made to the host:port given in the url using the default net driver. The type of the file contents and the HTTP method (POST pr PUT) can be customized. upload returns a Response() instance. Exceptions can be raised: HTTPConnectionError when the HTTP server can\u2019t be contacted; IOError when the source of error lies at the socket level (i.e. closed sockets, invalid sockets, file, etc..) Response() This class represent the result of a HTTP request. It contains the following members: status() Contains the HTTP response code content() It is the bytearray containing the byte version of the content section of a HTTP response headers() A dictionary with all the response headers connection() the connection used to communicate with the server, or None if it has been closed. text() Returns a string representing the content section of the HTTP response","title":"Requests"},{"location":"reference/core/stdlib/docs/rtc/","text":"Real-Time Clock \u00b6 This module loads the Real-Time Clock (rtc) driver of the embedded device when available (the chip family should be equipped with a rtc and a driver should have been developed, look at the bottom of this page for info about supported chip families). When imported, automatically sets the system rtc driver to the default one. init(drvname) Loads the rtc driver identified by drvname Returns the previous driver without disabling it. set_utc(seconds, microseconds=0) Arguments seconds \u2013 integer Unix timestamp containing the total number of seconds from the 1 st of January 1970 at UTC microseconds \u2013 integer number representing the microseconds part of the timestamp to reach sub-second precision Sets a Coordinated Universal Time (UTC) reference for the rtc. TimeInfo() Class containing useful time information to be filled by the get_utc() function. List of attributes: Timeinfo.tv_seconds : Unix timestamp containing the total number of seconds from the 1 st of January 1970 at UTC; Timeinfo.tv_microseconds : number of microseconds to complete the timestamp with sub-second precision; Timeinfo.tm_year : current year Timeinfo.tm_month : months since January (0-11) Timeinfo.tm_mday : day of the month (1-31) Timeinfo.tm_hour : hours since midnight (0-23) Timeinfo.tm_min : minutes after the hour (0-59) Timeinfo.tm_sec : seconds after the minute (0-59) Timeinfo.tm_wday : days since Sunday (0-6) Timeinfo.tm_yday : days since January 1 (0-365) get_utc(verbosity=2) When called with verbosity parameter set to 2 , returns a TimeInfo() object filled with info derived from the rtc. Only Timeinfo.tv_seconds and Timeinfo.tv_microseconds are guaranteed to be filled correctly. The availability of the other fields depend on the underlying driver implementation. When called with verbosity parameter set to 1 , returns a tuple containing timestamp seconds and microseconds. When called with verbosity parameter set to 0 , returns a single integer representing the Unix timestamp. Real-Time Clock for ESP32 devices \u00b6 When synchronized, ESP32 will perform timekeeping using built-in timers: RTC clock is used to maintain accurate time when chip is in deep sleep mode FRC1 timer is used to provide time at microsecond accuracy when ESP32 is running.","title":"Real-Time Clock"},{"location":"reference/core/stdlib/docs/rtc/#real-time-clock","text":"This module loads the Real-Time Clock (rtc) driver of the embedded device when available (the chip family should be equipped with a rtc and a driver should have been developed, look at the bottom of this page for info about supported chip families). When imported, automatically sets the system rtc driver to the default one. init(drvname) Loads the rtc driver identified by drvname Returns the previous driver without disabling it. set_utc(seconds, microseconds=0) Arguments seconds \u2013 integer Unix timestamp containing the total number of seconds from the 1 st of January 1970 at UTC microseconds \u2013 integer number representing the microseconds part of the timestamp to reach sub-second precision Sets a Coordinated Universal Time (UTC) reference for the rtc. TimeInfo() Class containing useful time information to be filled by the get_utc() function. List of attributes: Timeinfo.tv_seconds : Unix timestamp containing the total number of seconds from the 1 st of January 1970 at UTC; Timeinfo.tv_microseconds : number of microseconds to complete the timestamp with sub-second precision; Timeinfo.tm_year : current year Timeinfo.tm_month : months since January (0-11) Timeinfo.tm_mday : day of the month (1-31) Timeinfo.tm_hour : hours since midnight (0-23) Timeinfo.tm_min : minutes after the hour (0-59) Timeinfo.tm_sec : seconds after the minute (0-59) Timeinfo.tm_wday : days since Sunday (0-6) Timeinfo.tm_yday : days since January 1 (0-365) get_utc(verbosity=2) When called with verbosity parameter set to 2 , returns a TimeInfo() object filled with info derived from the rtc. Only Timeinfo.tv_seconds and Timeinfo.tv_microseconds are guaranteed to be filled correctly. The availability of the other fields depend on the underlying driver implementation. When called with verbosity parameter set to 1 , returns a tuple containing timestamp seconds and microseconds. When called with verbosity parameter set to 0 , returns a single integer representing the Unix timestamp.","title":"Real-Time Clock"},{"location":"reference/core/stdlib/docs/rtc/#real-time-clock-for-esp32-devices","text":"When synchronized, ESP32 will perform timekeeping using built-in timers: RTC clock is used to maintain accurate time when chip is in deep sleep mode FRC1 timer is used to provide time at microsecond accuracy when ESP32 is running.","title":"Real-Time Clock for ESP32 devices"},{"location":"reference/core/stdlib/docs/sfw/","text":"Secure Firmware \u00b6 This module enables access to secure firmware functionalities specific to the target microcontroller. It can be safely imported in every program, however its functions will raise UnsupportedError if the target VM is not enabled for secure firmware features ( a premium VM with the OTA feature enabled is needed ). There are many ways of securing the firmware running on a microcontroller: disable access to the flash memory wher the firmware resides with external means (e.g. JTAG probes) reserve some memory areas to critical parts of the system (e.g. VM running in mcu Trust Zones) detect device tampering and take action accordingly (e.g. erase firmware) detect and recover from firmware malfunctions (e.g. watchdogs) Of the above features, only watchdogs are implemented in all architectures; the rest of features are strongly platform dependent. This module allow access to the microcontroller watchdogs and will enable access to anti-tampering features soon. Bytecode integrity check \u00b6 All secure firmware VMs execute an integrity check of the loaded bytecode and fail if one of the following two conditions is met: The calculated hash of the bytecode is not equal to the bytecode fingerprint The VM version is not the one the bytecode was compiled for Watchdogs \u00b6 A Watchdog is usually implemented as a countdown timer that resets the microcontroller if it is not refreshed by firmware in a specified timeout period. The action of refreshing the watchdog timer is often called \u201ckicking\u201d or \u201cfeeding\u201d the watchdog. A windowed watchdog is a specially configured watchdog that resets the microcontroller both on a normal timeout or on a kick that happens before a specified time from last refresh. Visually: Normal Watchdog time window |----------------------------------------------| --> a reset happens! 0 timeout A kick here restarts the watchdog Windowed Watchodog |............|---------------------------------| --> a reset happens! 0 t1 timeout A kick here A kick here reset the mcu! restarts the watchdog Each microcontroller family has its own watchdog peculiarities, described in the following sections: STM32F families NXP K64 families Microchip SAMD21 Espressif ESP32 This module provides the following functions for watchdog usage: watchdog(time0, timeout) Enable the watchdog. If time0 is zero, the watchdog is configured in normal mode; if it is greater than zero, the watchdog is configured in windowed mode (if supported) in such a way that a kick in the first time0 milliseconds resets the device. timeout configures the number of milliseconds the whole watchdog window lasts. Once started, the watchdog CAN\u2019T be stopped! kick() Refresh the watchdog, resetting its time window. watchdog_triggered() Return True if the microcontroller has been reset by the watchdog, False otherwise. Watchdogs for STM32Fxx families \u00b6 For STM32 microcontrollers the watchdog is implemented using the IWDG. The maximum timeout is 32768 milliseconds and there is no support for windowed mode (an exception is raised if time0 is greater than zero in watchdog() ). The watchdog is disabled in low power modes. Watchdogs for NXP K64 families \u00b6 For K64 microcontrollers the watchdog is implemented using WDOG. The WDOG is clocked by the low power oscillator with a frequency of 1kHz.T The maximum timeout is around 74 hours and windowed mode is supported. The watchdog is disabled in low power modes. Watchdogs for Microchip SAMD21 \u00b6 For SAMD21 microcontrollers the watchdog is implemented using WDT. The WDT is clocked by the ultra low power oscillator with a frequency of 1kHz. In normal mode the maximum timeout is 16 seconds. In windowed mode timeout can reach 32 seconds and time0 16 seconds; this is because windowed mode works with two timers, the first for time0 and the second for timeout . The timeout granularity of WDT is quite coarse, allowing only 12 different timeout values, expressed in WDT clock cycles: 8 cycles, 8 milliseconds 16 cycles, 16 milliseconds \u2026 16384 cycles, 16384 milliseconds The watchdog() function will select the nearest allowed time rounding up with respect to the specified time. Watchdogs for ESP32 devices \u00b6 Starting from version r2.2.0, the watchdog for ESP32 devices is implemented using the RTC watchdog. The maximum timeout is 2^31 milliseconds and there is no support for windowed mode (an exception is raised if time0 is greater than zero in watchdog()). The RTC watchod is enabled by the bootloader and set to 30 seconds by default. This allows to recover from a faulty firmware that does not have time to configure the watchdog at startup. However, when using a secure firmware VM it is mandatory to configure the watchdog in the first 30 seconds of execution.","title":"Secure Firmware"},{"location":"reference/core/stdlib/docs/sfw/#secure-firmware","text":"This module enables access to secure firmware functionalities specific to the target microcontroller. It can be safely imported in every program, however its functions will raise UnsupportedError if the target VM is not enabled for secure firmware features ( a premium VM with the OTA feature enabled is needed ). There are many ways of securing the firmware running on a microcontroller: disable access to the flash memory wher the firmware resides with external means (e.g. JTAG probes) reserve some memory areas to critical parts of the system (e.g. VM running in mcu Trust Zones) detect device tampering and take action accordingly (e.g. erase firmware) detect and recover from firmware malfunctions (e.g. watchdogs) Of the above features, only watchdogs are implemented in all architectures; the rest of features are strongly platform dependent. This module allow access to the microcontroller watchdogs and will enable access to anti-tampering features soon.","title":"Secure Firmware"},{"location":"reference/core/stdlib/docs/sfw/#bytecode-integrity-check","text":"All secure firmware VMs execute an integrity check of the loaded bytecode and fail if one of the following two conditions is met: The calculated hash of the bytecode is not equal to the bytecode fingerprint The VM version is not the one the bytecode was compiled for","title":"Bytecode integrity check"},{"location":"reference/core/stdlib/docs/sfw/#watchdogs","text":"A Watchdog is usually implemented as a countdown timer that resets the microcontroller if it is not refreshed by firmware in a specified timeout period. The action of refreshing the watchdog timer is often called \u201ckicking\u201d or \u201cfeeding\u201d the watchdog. A windowed watchdog is a specially configured watchdog that resets the microcontroller both on a normal timeout or on a kick that happens before a specified time from last refresh. Visually: Normal Watchdog time window |----------------------------------------------| --> a reset happens! 0 timeout A kick here restarts the watchdog Windowed Watchodog |............|---------------------------------| --> a reset happens! 0 t1 timeout A kick here A kick here reset the mcu! restarts the watchdog Each microcontroller family has its own watchdog peculiarities, described in the following sections: STM32F families NXP K64 families Microchip SAMD21 Espressif ESP32 This module provides the following functions for watchdog usage: watchdog(time0, timeout) Enable the watchdog. If time0 is zero, the watchdog is configured in normal mode; if it is greater than zero, the watchdog is configured in windowed mode (if supported) in such a way that a kick in the first time0 milliseconds resets the device. timeout configures the number of milliseconds the whole watchdog window lasts. Once started, the watchdog CAN\u2019T be stopped! kick() Refresh the watchdog, resetting its time window. watchdog_triggered() Return True if the microcontroller has been reset by the watchdog, False otherwise.","title":"Watchdogs"},{"location":"reference/core/stdlib/docs/sfw/#watchdogs-for-stm32fxx-families","text":"For STM32 microcontrollers the watchdog is implemented using the IWDG. The maximum timeout is 32768 milliseconds and there is no support for windowed mode (an exception is raised if time0 is greater than zero in watchdog() ). The watchdog is disabled in low power modes.","title":"Watchdogs for STM32Fxx families"},{"location":"reference/core/stdlib/docs/sfw/#watchdogs-for-nxp-k64-families","text":"For K64 microcontrollers the watchdog is implemented using WDOG. The WDOG is clocked by the low power oscillator with a frequency of 1kHz.T The maximum timeout is around 74 hours and windowed mode is supported. The watchdog is disabled in low power modes.","title":"Watchdogs for NXP K64 families"},{"location":"reference/core/stdlib/docs/sfw/#watchdogs-for-microchip-samd21","text":"For SAMD21 microcontrollers the watchdog is implemented using WDT. The WDT is clocked by the ultra low power oscillator with a frequency of 1kHz. In normal mode the maximum timeout is 16 seconds. In windowed mode timeout can reach 32 seconds and time0 16 seconds; this is because windowed mode works with two timers, the first for time0 and the second for timeout . The timeout granularity of WDT is quite coarse, allowing only 12 different timeout values, expressed in WDT clock cycles: 8 cycles, 8 milliseconds 16 cycles, 16 milliseconds \u2026 16384 cycles, 16384 milliseconds The watchdog() function will select the nearest allowed time rounding up with respect to the specified time.","title":"Watchdogs for Microchip SAMD21"},{"location":"reference/core/stdlib/docs/sfw/#watchdogs-for-esp32-devices","text":"Starting from version r2.2.0, the watchdog for ESP32 devices is implemented using the RTC watchdog. The maximum timeout is 2^31 milliseconds and there is no support for windowed mode (an exception is raised if time0 is greater than zero in watchdog()). The RTC watchod is enabled by the bootloader and set to 30 seconds by default. This allows to recover from a faulty firmware that does not have time to configure the watchdog at startup. However, when using a secure firmware VM it is mandatory to configure the watchdog in the first 30 seconds of execution.","title":"Watchdogs for ESP32 devices"},{"location":"reference/core/stdlib/docs/socket/","text":"Sockets \u00b6 This module provides access to an almost complete BSD socket interface. However, some behaviour may be dependent on the underlying network driver. The following constants are defined: For socket families: AF_INET, AF_INET6, AF_CAN For socket types: SOCK_STREAM, SOCK_DGRAM, SOCK_RAW For socket options: SOL_SOCKET, SO_RCVTIMEO, SO_REUSEADDR IPv4 addresses can be passed to functions and methods in the following forms: string, e.g. \u201c192.168.1.10\u201d tuple, e.g. (192,168,1,10) tuple of ip and port, e.g. (\u201c192.168.1.10\u201d,8080) tuple of ip and port, e.g. (192,168,1,10,8080) if a port is required but not given, it is set to zero. ip_to_tuple() Return a tuple of four integers from a ip address of the form \u201cx.y.z.w\u201d. The socket class \u00b6 socket(family=AF_INET, type=SOCK_STREAM, proto=IPPROTO_TCP, fileno=None) This class represents a BSD socket. Raise __builtins__.IOError exceptions if socket creation goes wrong. Sockets can be used like this: # import the socket module import socket # import a module to access a net driver (wifi, eth,...) from wireless import wifi # import the actual net driver from driver.wifi.your_preferred_net_driver import your_preferred_net_driver # init the driver your_preferred_net_driver . init () # link the wifi to an AP wifi . link ( \"Your Wifi SSID\" , WIFI_WPA2 , \"Your Wifi Password\" ) # create a tcp socket sock = socket . socket ( type = SOCK_STREAM ) # connect the socket to net address 192.168.1.10 on port 5555 sock . connect (( \"192.168.1.10\" , 5555 )) # send something on the socket! sock . sendall ( \"Hello World!\" ) fileno() Return an integer identifying the underlying socket number. connect(address) Tries to connect the underlying socket (tcp or udp) to address . A tcp socket must be connected to be used successfully. Udp sockets are connectionless and everytime a datagram is sent, the receiver address must be specified ( sendto() ). However if an udp socket is connected to an address, it can be used with methods like recv() and send() without specifying a receiver address. When an udp socket is connected to address , datagram packets coming from addresses different from address are ignored. close() Closes the underlying socket. No more input/output operations are possible. recv(bufsize, flags=0) Reads at most bufsize bytes from the underlying socket. It blocks until bufsize bytes are received or an error occurs. Returns a bytearray containing the received bytes. recv_into(buffer, bufsize=-1, flags=0) Reads at most bufsize bytes from the underlying socket into buffer . It blocks until bufsize bytes are received or an error occurs. Returns the number of received bytes. recvfrom(bufsize, flags=0) Reads at most bufsize bytes from the underlying udp socket. It blocks until a datagram is received. Returns a tuple ( data , address ) where data is a bytearray containing the received bytes and address is the net address of the sender. recvfrom_into(buffer, bufsize=-1, flags=0) Reads at most bufsize bytes from the underlying udp socket into buffer . It blocks until a datagram is received. If bufsize is not given or is less than 0, bufsize is set to len(buffer). Returns a tuple ( rd , address ) where rd is the number of bytes received and address is the net address of the sender. send(buffer, flags=0) Send data to the socket. The socket must be connected to a remote socket. Returns the number of bytes sent. Applications are responsible for checking that all data has been sent; if only some of the data was transmitted, the application needs to attempt delivery of the remaining data. sendall(buffer, flags=0) Send all data to the socket. The socket must be connected to a remote socket. Unlike send(), this method continues to send data from bytes until either all data has been sent or an error occurs. None is returned on success. On error, an exception is raised, and there is no way to determine how much data, if any, was successfully sent. sendto(buffer, address, flags=0) Send data to the socket. The socket should not be connected to a remote socket, since the destination socket is specified by address. Return the number of bytes sent settimeout(timeout) Set a timeout on blocking socket operations. The timeout argument can be a nonnegative integer number expressing milliseconds, or None . If a non-zero value is given, subsequent socket operations will raise a timeout exception if the timeout period value has elapsed before the operation has completed. If zero is given, the socket is put in non-blocking mode. If None is given, the socket is put in blocking mode. bind(address) Binds the socket to address . address can be: an integer representing a port number. In this case ip is set to the local one an ip address with a port A tcp socket needs binding when it is used to accept incoming connection (e.g. a http server socket). A udp socket needs to be bound before any input/output operation. After binding, the udp socket will receive every packet incoming to address . listen(maxlog=2) Enables listening on the underlying tcp socket. A tcp socket in listening state can be used as a server socket to accept incoming connection. maxlog specifies the maximum number of waiting connections. accept() Blocks until an incoming connection is made on the underlying tcp socket. Returns a tuple ( sock , address ) where sock is a socket stream that can be used to communicate with the client and address is the client address. Here is an example of tcp server socket: # import the socket module import socket # import a module to access a net driver (wifi, eth,...) from wireless import wifi # import the actual net driver from driver.wifi.your_preferred_net_driver import your_preferred_net_driver # init the driver your_preferred_net_driver . init () # link the wifi to an AP wifi . link ( \"Your Wifi SSID\" , WIFI_WPA2 , \"Your Wifi Password\" ) # create a tcp socket sock = socket . socket ( type = SOCK_STREAM ) # bind the socket to port 80 sock . bind ( 80 ) # set the socket in listening mode sock . listen () while True : # accept incoming connections from clients client , addr = sock . accept () # send something to the client and close client . sendall ( \"Hello!\" ) client . close ()","title":"Sockets"},{"location":"reference/core/stdlib/docs/socket/#sockets","text":"This module provides access to an almost complete BSD socket interface. However, some behaviour may be dependent on the underlying network driver. The following constants are defined: For socket families: AF_INET, AF_INET6, AF_CAN For socket types: SOCK_STREAM, SOCK_DGRAM, SOCK_RAW For socket options: SOL_SOCKET, SO_RCVTIMEO, SO_REUSEADDR IPv4 addresses can be passed to functions and methods in the following forms: string, e.g. \u201c192.168.1.10\u201d tuple, e.g. (192,168,1,10) tuple of ip and port, e.g. (\u201c192.168.1.10\u201d,8080) tuple of ip and port, e.g. (192,168,1,10,8080) if a port is required but not given, it is set to zero. ip_to_tuple() Return a tuple of four integers from a ip address of the form \u201cx.y.z.w\u201d.","title":"Sockets"},{"location":"reference/core/stdlib/docs/socket/#the-socket-class","text":"socket(family=AF_INET, type=SOCK_STREAM, proto=IPPROTO_TCP, fileno=None) This class represents a BSD socket. Raise __builtins__.IOError exceptions if socket creation goes wrong. Sockets can be used like this: # import the socket module import socket # import a module to access a net driver (wifi, eth,...) from wireless import wifi # import the actual net driver from driver.wifi.your_preferred_net_driver import your_preferred_net_driver # init the driver your_preferred_net_driver . init () # link the wifi to an AP wifi . link ( \"Your Wifi SSID\" , WIFI_WPA2 , \"Your Wifi Password\" ) # create a tcp socket sock = socket . socket ( type = SOCK_STREAM ) # connect the socket to net address 192.168.1.10 on port 5555 sock . connect (( \"192.168.1.10\" , 5555 )) # send something on the socket! sock . sendall ( \"Hello World!\" ) fileno() Return an integer identifying the underlying socket number. connect(address) Tries to connect the underlying socket (tcp or udp) to address . A tcp socket must be connected to be used successfully. Udp sockets are connectionless and everytime a datagram is sent, the receiver address must be specified ( sendto() ). However if an udp socket is connected to an address, it can be used with methods like recv() and send() without specifying a receiver address. When an udp socket is connected to address , datagram packets coming from addresses different from address are ignored. close() Closes the underlying socket. No more input/output operations are possible. recv(bufsize, flags=0) Reads at most bufsize bytes from the underlying socket. It blocks until bufsize bytes are received or an error occurs. Returns a bytearray containing the received bytes. recv_into(buffer, bufsize=-1, flags=0) Reads at most bufsize bytes from the underlying socket into buffer . It blocks until bufsize bytes are received or an error occurs. Returns the number of received bytes. recvfrom(bufsize, flags=0) Reads at most bufsize bytes from the underlying udp socket. It blocks until a datagram is received. Returns a tuple ( data , address ) where data is a bytearray containing the received bytes and address is the net address of the sender. recvfrom_into(buffer, bufsize=-1, flags=0) Reads at most bufsize bytes from the underlying udp socket into buffer . It blocks until a datagram is received. If bufsize is not given or is less than 0, bufsize is set to len(buffer). Returns a tuple ( rd , address ) where rd is the number of bytes received and address is the net address of the sender. send(buffer, flags=0) Send data to the socket. The socket must be connected to a remote socket. Returns the number of bytes sent. Applications are responsible for checking that all data has been sent; if only some of the data was transmitted, the application needs to attempt delivery of the remaining data. sendall(buffer, flags=0) Send all data to the socket. The socket must be connected to a remote socket. Unlike send(), this method continues to send data from bytes until either all data has been sent or an error occurs. None is returned on success. On error, an exception is raised, and there is no way to determine how much data, if any, was successfully sent. sendto(buffer, address, flags=0) Send data to the socket. The socket should not be connected to a remote socket, since the destination socket is specified by address. Return the number of bytes sent settimeout(timeout) Set a timeout on blocking socket operations. The timeout argument can be a nonnegative integer number expressing milliseconds, or None . If a non-zero value is given, subsequent socket operations will raise a timeout exception if the timeout period value has elapsed before the operation has completed. If zero is given, the socket is put in non-blocking mode. If None is given, the socket is put in blocking mode. bind(address) Binds the socket to address . address can be: an integer representing a port number. In this case ip is set to the local one an ip address with a port A tcp socket needs binding when it is used to accept incoming connection (e.g. a http server socket). A udp socket needs to be bound before any input/output operation. After binding, the udp socket will receive every packet incoming to address . listen(maxlog=2) Enables listening on the underlying tcp socket. A tcp socket in listening state can be used as a server socket to accept incoming connection. maxlog specifies the maximum number of waiting connections. accept() Blocks until an incoming connection is made on the underlying tcp socket. Returns a tuple ( sock , address ) where sock is a socket stream that can be used to communicate with the client and address is the client address. Here is an example of tcp server socket: # import the socket module import socket # import a module to access a net driver (wifi, eth,...) from wireless import wifi # import the actual net driver from driver.wifi.your_preferred_net_driver import your_preferred_net_driver # init the driver your_preferred_net_driver . init () # link the wifi to an AP wifi . link ( \"Your Wifi SSID\" , WIFI_WPA2 , \"Your Wifi Password\" ) # create a tcp socket sock = socket . socket ( type = SOCK_STREAM ) # bind the socket to port 80 sock . bind ( 80 ) # set the socket in listening mode sock . listen () while True : # accept incoming connections from clients client , addr = sock . accept () # send something to the client and close client . sendall ( \"Hello!\" ) client . close ()","title":"The socket class"},{"location":"reference/core/stdlib/docs/spi/","text":"SPI \u00b6 This module loads the Serial Peripheral Interface (spi). The connection between a spi peripheral (sensor, actuator, etc..) and the microcontroller is made via four wires with different functions as in the following schema: MCU Peripheral _____________ ________ | | | | | |______________________________| | | | SCLK | | | |______________________________| | | | MOSI | | | |______________________________| | | | MISO | | | |______________________________| | |_____________| CS |________| One of the connected components is in charge of deciding the parameters of the connection and is the one starting and stopping data transfers. Such component is aptly called Master whereas all the other connected components (the spi interface is engineered to connect a master to more tha one slave) are called Slaves . The master decides the speed of the connection by sending a clock signal on the SCLK wire, transmits data to the slave by encoding bits on the MOSI wire (Master Out Slave In), and receives data by reading bits on the MISO wire (Master In Slave Out). Since many slaves can be connected to a single master, the wire CS (Chip Select, but also called SS, Slave Select) is used to signal a particular slave that the connection is going to start and the transmitted data is addressed at it. One CS wire is needed for ever connected slave. The master also decides some low level details of the communication, namely the bit width and the polarity/phase. The bit width is simply the number of bits to be sent per frame. The polarity and phase of the clock are somewhat more difficult to understand also because the naming of the polarity and phase setting often differs between chip producers. Refer to the following clock schema: _________ _________ _________ | | | | | | LOW | | | | | | SCLK0 ________| |__________| |__________| |___ ________ __________ __________ ___ | | | | | | HIGH | | | | | | SCLK1 |_________| |_________| |_________| 1 2 1 2 1 2 MISO0 <--------------------><-------------------><-------------------> MISO1 <--------------------><-------------------><-------------------> The master needs to set the SCLK polarity, namely the idle status of the SCLK line. If polarity is low, it means the SCLK signal starts LOW (SCLK0 in the schema), whereas if polarity is high the SCLK signal starts HIGH (SCLK1 in the schema). Often the polarity of a peripheral is reported as CPOL in the data sheets, with CPOL=0 low polarity and CPOL=1 high polarity. Once the polarity is decided, signals in the MISO and MOSI lines can be transmitted in two different ways: with bits starting at the first transition of SCLK (such as MISO0) or at the second transition of SCLK (such as MISO1). This setting is called phase, and it is often reported as CPHA in the datasheet, with CPHA=0 meaning first transition and CPHA=1 meaning second transiton. Finally, MISO and MOSI lines are synchronous, i.e. data is transmitted in a full duplex manner: the slave can send data to the master while it is receiving data from the master. Therefore, spi operations can be divided in: write: the master sends data over MOSI and ignores what the slave sends over MISO read: the master reads data from MISO and writes nothing on MOSI skip: the master activates SCLK but neither reads or writes exchange: the master sends data over MOSI and at the same time receives data from MISO The Spi class \u00b6 Spi(nss, drvname=SPI0, clock=12000000, bits=SPI_8_BITS, mode=SPI_MODE_LOW_FIRST) This is the base class implementing spi master functionalities. Spi slave is not yet supported. Spi is initialized by passing the driver name drvname , in the form of SPI0, SPI1, etc\u2026 depending on the board capabilities. Refer to the board pinout to locate the actual pins belonging to the driver. clock in Hz is also needed, together with the bit width (can be SPI_8_BITS or SPI_16_BITS), and the polarity/phase mode. Combining polarity and phase yields four possible modes: SPI_MODE_LOW_FIRST: polarity low, phase on the first transition (CPOL=0,CPHA=0) SPI_MODE_LOW_SECOND: polarity low, phase on second transition (CPOL=0,CPHA=1) SPI_MODE_HIGH_FIRST: polarity high, phase on the first transition (CPOL=1,CPHA=0) SPI_MODE_HIGH_SECOND: polarity high, phase on second transition (CPOL=1,CPHA=1) The nss argument is the pin name used as CS. Different Spi instances for the same drvname coordinates themselves in selecting and unselecting slaves, as long as a correct usage pattern is enforced: import spi s0 = spi . Spi ( D0 ) s1 = spi . Spi ( D1 , clock = 8000000 ) s0 . select () # starts the spi bus, unselect the slave at D1, select the slave at D0 # do all s0 communications s0 . unselect () # unselect all the slaves s1 . select () # stop the spi bus,starts the spi bus with s1 configuration, unselect the slave at D0, select the slave at D1 # do all s1 communications s1 . unselect () # unselect all the slaves # done must be called manually when the instance is no more needed s0 . done () s1 . done () write(data) data is written to MOSI, bits on MISO are ignored. read(n) Returns a sequence of n bytes read from MISO. MOSI is ignored. skip(n) Ignores the next n bytes transmitted over MISO. exchange(data) data is written to MOSI, and a sequence of bytes read from MISO is returned. select() The slave is selected, all the other slaves are unselected. A slave must be selected before starting a transmission. If necessary the spi bus is configured and started. unselect() All slaves are unselected. lock() Locks the driver. It is useful when the same spi bus is used by multiple Spi instances and/or multiple threads to avoid interferences. unlock() Unlocks the driver. It is useful when the same spi bus is used by multiple Spi instances and/or multiple threads to avoid interferences. done() Stops the spi driver","title":"SPI"},{"location":"reference/core/stdlib/docs/spi/#spi","text":"This module loads the Serial Peripheral Interface (spi). The connection between a spi peripheral (sensor, actuator, etc..) and the microcontroller is made via four wires with different functions as in the following schema: MCU Peripheral _____________ ________ | | | | | |______________________________| | | | SCLK | | | |______________________________| | | | MOSI | | | |______________________________| | | | MISO | | | |______________________________| | |_____________| CS |________| One of the connected components is in charge of deciding the parameters of the connection and is the one starting and stopping data transfers. Such component is aptly called Master whereas all the other connected components (the spi interface is engineered to connect a master to more tha one slave) are called Slaves . The master decides the speed of the connection by sending a clock signal on the SCLK wire, transmits data to the slave by encoding bits on the MOSI wire (Master Out Slave In), and receives data by reading bits on the MISO wire (Master In Slave Out). Since many slaves can be connected to a single master, the wire CS (Chip Select, but also called SS, Slave Select) is used to signal a particular slave that the connection is going to start and the transmitted data is addressed at it. One CS wire is needed for ever connected slave. The master also decides some low level details of the communication, namely the bit width and the polarity/phase. The bit width is simply the number of bits to be sent per frame. The polarity and phase of the clock are somewhat more difficult to understand also because the naming of the polarity and phase setting often differs between chip producers. Refer to the following clock schema: _________ _________ _________ | | | | | | LOW | | | | | | SCLK0 ________| |__________| |__________| |___ ________ __________ __________ ___ | | | | | | HIGH | | | | | | SCLK1 |_________| |_________| |_________| 1 2 1 2 1 2 MISO0 <--------------------><-------------------><-------------------> MISO1 <--------------------><-------------------><-------------------> The master needs to set the SCLK polarity, namely the idle status of the SCLK line. If polarity is low, it means the SCLK signal starts LOW (SCLK0 in the schema), whereas if polarity is high the SCLK signal starts HIGH (SCLK1 in the schema). Often the polarity of a peripheral is reported as CPOL in the data sheets, with CPOL=0 low polarity and CPOL=1 high polarity. Once the polarity is decided, signals in the MISO and MOSI lines can be transmitted in two different ways: with bits starting at the first transition of SCLK (such as MISO0) or at the second transition of SCLK (such as MISO1). This setting is called phase, and it is often reported as CPHA in the datasheet, with CPHA=0 meaning first transition and CPHA=1 meaning second transiton. Finally, MISO and MOSI lines are synchronous, i.e. data is transmitted in a full duplex manner: the slave can send data to the master while it is receiving data from the master. Therefore, spi operations can be divided in: write: the master sends data over MOSI and ignores what the slave sends over MISO read: the master reads data from MISO and writes nothing on MOSI skip: the master activates SCLK but neither reads or writes exchange: the master sends data over MOSI and at the same time receives data from MISO","title":"SPI"},{"location":"reference/core/stdlib/docs/spi/#the-spi-class","text":"Spi(nss, drvname=SPI0, clock=12000000, bits=SPI_8_BITS, mode=SPI_MODE_LOW_FIRST) This is the base class implementing spi master functionalities. Spi slave is not yet supported. Spi is initialized by passing the driver name drvname , in the form of SPI0, SPI1, etc\u2026 depending on the board capabilities. Refer to the board pinout to locate the actual pins belonging to the driver. clock in Hz is also needed, together with the bit width (can be SPI_8_BITS or SPI_16_BITS), and the polarity/phase mode. Combining polarity and phase yields four possible modes: SPI_MODE_LOW_FIRST: polarity low, phase on the first transition (CPOL=0,CPHA=0) SPI_MODE_LOW_SECOND: polarity low, phase on second transition (CPOL=0,CPHA=1) SPI_MODE_HIGH_FIRST: polarity high, phase on the first transition (CPOL=1,CPHA=0) SPI_MODE_HIGH_SECOND: polarity high, phase on second transition (CPOL=1,CPHA=1) The nss argument is the pin name used as CS. Different Spi instances for the same drvname coordinates themselves in selecting and unselecting slaves, as long as a correct usage pattern is enforced: import spi s0 = spi . Spi ( D0 ) s1 = spi . Spi ( D1 , clock = 8000000 ) s0 . select () # starts the spi bus, unselect the slave at D1, select the slave at D0 # do all s0 communications s0 . unselect () # unselect all the slaves s1 . select () # stop the spi bus,starts the spi bus with s1 configuration, unselect the slave at D0, select the slave at D1 # do all s1 communications s1 . unselect () # unselect all the slaves # done must be called manually when the instance is no more needed s0 . done () s1 . done () write(data) data is written to MOSI, bits on MISO are ignored. read(n) Returns a sequence of n bytes read from MISO. MOSI is ignored. skip(n) Ignores the next n bytes transmitted over MISO. exchange(data) data is written to MOSI, and a sequence of bytes read from MISO is returned. select() The slave is selected, all the other slaves are unselected. A slave must be selected before starting a transmission. If necessary the spi bus is configured and started. unselect() All slaves are unselected. lock() Locks the driver. It is useful when the same spi bus is used by multiple Spi instances and/or multiple threads to avoid interferences. unlock() Unlocks the driver. It is useful when the same spi bus is used by multiple Spi instances and/or multiple threads to avoid interferences. done() Stops the spi driver","title":"The Spi class"},{"location":"reference/core/stdlib/docs/spiflash/","text":"SpiFlash \u00b6 This modules handles operations on a generic Spi Flash Memory. The following operations are allowed: read/write data; check if flash is busy; enable write operations; erase sector; erase chip. SpiFlash class \u00b6 SpiFlash(drvname, cs, clock=1000000) Initialize an external Flash memory specifying its: MCU SPI circuitry drvname (one of SPI0, SPI1, \u2026 check pinmap for details); chip select pin cs ; clock clock , default at 1MHz. write_enable() Enable write operations. Automatically called by write_data() , erase_sector() , chip_erase() methods. is_write_busy() Returns 1 or 0 depending on whether the Flash is busy or not. write_data(addr, data) Write data data starting from address addr . data can be a bytearray or a list of integers less than 256. erase_sector() MUST be called before writing data in a sector. Writing is also allowed via bracket notation. The following is valid syntax: my_flash [ addr ] = data erase_sector(addr) Erase a whole sector passing the addr address of any byte contained in it. All sector bytes set to 0xff. read_data(addr, n=1) Read n bytes of data starting from address addr . Reading is also allowed via bracket notation. The following is valid syntax: my_data = my_flash[addr:addr+n] chip_erase() Erase the whole memory. All memory bytes set to 0xff. chip_id(n) Returns the bytes representation of the flash chip unique identifier. The length in bytes of the chip id must be passed as argument n .","title":"SpiFlash"},{"location":"reference/core/stdlib/docs/spiflash/#spiflash","text":"This modules handles operations on a generic Spi Flash Memory. The following operations are allowed: read/write data; check if flash is busy; enable write operations; erase sector; erase chip.","title":"SpiFlash"},{"location":"reference/core/stdlib/docs/spiflash/#spiflash-class","text":"SpiFlash(drvname, cs, clock=1000000) Initialize an external Flash memory specifying its: MCU SPI circuitry drvname (one of SPI0, SPI1, \u2026 check pinmap for details); chip select pin cs ; clock clock , default at 1MHz. write_enable() Enable write operations. Automatically called by write_data() , erase_sector() , chip_erase() methods. is_write_busy() Returns 1 or 0 depending on whether the Flash is busy or not. write_data(addr, data) Write data data starting from address addr . data can be a bytearray or a list of integers less than 256. erase_sector() MUST be called before writing data in a sector. Writing is also allowed via bracket notation. The following is valid syntax: my_flash [ addr ] = data erase_sector(addr) Erase a whole sector passing the addr address of any byte contained in it. All sector bytes set to 0xff. read_data(addr, n=1) Read n bytes of data starting from address addr . Reading is also allowed via bracket notation. The following is valid syntax: my_data = my_flash[addr:addr+n] chip_erase() Erase the whole memory. All memory bytes set to 0xff. chip_id(n) Returns the bytes representation of the flash chip unique identifier. The length in bytes of the chip id must be passed as argument n .","title":"SpiFlash class"},{"location":"reference/core/stdlib/docs/spisd/","text":"SpiSD \u00b6 This module handles operations on Standard Capacity and High Capacity SD Cards (SDSC, SDHC) through Spi protocol. The following operations are allowed: read/write single block, with block address specified through SDSC or SDHC convention; read/write multiple blocks, with block address specified through SDSC or SDHC convention; generic read/write data, with block address specified through SDHC convention for both SDCS and SDHC cards; read cid register. Block size is set by default to 512 bytes. Address conventions: SDSC convention allows to select a block through its first byte location in byte address (example: for a block size of 512 bytes, second block will be addressed 0x200); SDHC convention allows to select a block through its block address (example: 2 nd block address (starting from 0 th block) is simply 0x2) SpiSD class \u00b6 SpiSD(drvname, cs, clock=1000000) Initialize an SD card specifying its: MCU SPI circuitry drvname (one of SPI0, SPI1, \u2026 check pinmap for details); chip select pin cs ; clock clock , default at 1MHz The instance attribute hc is set to 1 if the card is recognized as an SDHC, to 0 otherwise. single_block_read(addr) Read a single block at address addr , following SDSC or SDHC address convention depending on used card. multiple_blocks_read(addr, n) Read n blocks starting from address addr , following SDSC or SDHC address convention depending on used card. read_data(addr, n) Read n blocks starting from address addr , SDHC address convention is used. single_block_write(addr, data) Write a single block at address addr , following SDSC or SDHC address convention depending on used card. data must be a 512-byte long bytearray. multiple_blocks_write(addr, data) Write data starting from address addr , following SDSC or SDHC address convention depending on used card. Two formats allowed for data : bytearray with a len multiple of 512 bytes. list of 512-byte long bytearrays, where each bytearray inside data list contains data for a single block: block_1 = bytearray ( 0x200 ) block_2 = bytearray ( 0x200 ) ... [ block_1 , block_2 , ... ] write_data(addr, data) Write data starting from address addr , SDHC address convention is used. data format is defined as in multiple_blocks_write() . read_cid() Read 16-byte long cid register value.","title":"SpiSD"},{"location":"reference/core/stdlib/docs/spisd/#spisd","text":"This module handles operations on Standard Capacity and High Capacity SD Cards (SDSC, SDHC) through Spi protocol. The following operations are allowed: read/write single block, with block address specified through SDSC or SDHC convention; read/write multiple blocks, with block address specified through SDSC or SDHC convention; generic read/write data, with block address specified through SDHC convention for both SDCS and SDHC cards; read cid register. Block size is set by default to 512 bytes. Address conventions: SDSC convention allows to select a block through its first byte location in byte address (example: for a block size of 512 bytes, second block will be addressed 0x200); SDHC convention allows to select a block through its block address (example: 2 nd block address (starting from 0 th block) is simply 0x2)","title":"SpiSD"},{"location":"reference/core/stdlib/docs/spisd/#spisd-class","text":"SpiSD(drvname, cs, clock=1000000) Initialize an SD card specifying its: MCU SPI circuitry drvname (one of SPI0, SPI1, \u2026 check pinmap for details); chip select pin cs ; clock clock , default at 1MHz The instance attribute hc is set to 1 if the card is recognized as an SDHC, to 0 otherwise. single_block_read(addr) Read a single block at address addr , following SDSC or SDHC address convention depending on used card. multiple_blocks_read(addr, n) Read n blocks starting from address addr , following SDSC or SDHC address convention depending on used card. read_data(addr, n) Read n blocks starting from address addr , SDHC address convention is used. single_block_write(addr, data) Write a single block at address addr , following SDSC or SDHC address convention depending on used card. data must be a 512-byte long bytearray. multiple_blocks_write(addr, data) Write data starting from address addr , following SDSC or SDHC address convention depending on used card. Two formats allowed for data : bytearray with a len multiple of 512 bytes. list of 512-byte long bytearrays, where each bytearray inside data list contains data for a single block: block_1 = bytearray ( 0x200 ) block_2 = bytearray ( 0x200 ) ... [ block_1 , block_2 , ... ] write_data(addr, data) Write data starting from address addr , SDHC address convention is used. data format is defined as in multiple_blocks_write() . read_cid() Read 16-byte long cid register value.","title":"SpiSD class"},{"location":"reference/core/stdlib/docs/ssl/","text":"Secure Socket Layer \u00b6 This module provides access to an almost complete Secure Socket Layer interface. However, some behaviour may be dependent on the underlying network driver. SSL/TLS (TLS from now on) provides encryption and peer authentication facilities for network sockets, both client-side and server-side. The properties enforced by TLS on data transmission are: confidentiality : it means the transmitted data is readable only to the two end points of the TLS, it is unreadable garbage for everyon else intercepting the such data during transmission integrity : it means each end point receives exactly what has been sent by the other end point, no data tampering is possible authentication : it means each end point can have guarantees on the identity of the other end point In order to achieve such capabilities, TLS exploits the properties of different cryptographic primitives. Confidentiality is obtained by exchanging a symmetric key (a secret known only by he two end points for the duration of the connection) by means of asymmetric key cryptography (usually Diffie-Hellman or RSA key exchange). Such symmetric key will be used to encrypt every transmitted message. Integrity is guaranteed by appending to transmitted messages a signed digest (called HMAC) that can be generated only by someone knowing the symmetric key. Authentication is more complex and configurable. Indeed authentication in TLS can be: skipped: the two end points are not interested in the authentication property, therefore they do not require the other end to authenticate at the beginning of the connection one-way: the client can require the server to show some credentials (called certificate) that guarantees its identity. The client can close the connection if the verification of the server certificate fails. two-way: both server and client ask each other a proof of identity by exchanging and verifying certificates. A certificate consists of a public key together with some more data (such as the server domain, the expiration date, etc\u2026) and to guarantee the certificate is not tampered, it is signed with the private key of a certification authority (CA). The CA public key must be known and it is contained in a set of CA certificates common to both end points. The mechanism of certificate verification consists of an exchange of asymmetrically crypted messages that proves the identity of the server (and of the client if requested). No TLS connection is secure without athentication! Therefore, at least a CA certificate must be given to the client in order to authenticate the server and certificate verification must be enabled (it is disabled by default). Since there are many certification authorities, shipping all CA certificates inside a microcontroller is not feasible. Zerynth provides the useful __lookup macro that can be used to retrieve a single CA certificate and store it directly in the firmware: cacert0 = __lookup ( SSL_CACERT_COMODO_TRUSTED_SERVICES_ROOT ) cacert1 = __lookup ( SSL_CACERT_DIGICERT_TRUSTED_ROOT_G4 ) # cacert0 will be set to \"Comodo Trusted Services\" CA certificate # cacert1 will be set to \"DigiCert Trusted Root G4\" CA certificate To check the TLS feature available in a particular network driver, refer to the following example (based on ESP32): import json # import the wifi interface from wireless import wifi # import the http module import requests # import ssl module import ssl # the wifi module needs a networking driver to be loaded # in order to control the board hardware. from espressif.esp32net import esp32wifi as wifi_driver streams . serial () # init the wifi driver! # The driver automatically registers itself to the wifi interface # with the correct configuration for the selected board wifi_driver . auto_init () # use the wifi interface to link to the Access Point # change network name, security and password as needed print ( \"Establishing Link...\" ) try : # FOR THIS EXAMPLE TO WORK, \"Network-Name\" AND \"Wifi-Password\" MUST BE SET # TO MATCH YOUR ACTUAL NETWORK CONFIGURATION wifi . link ( \"Network-Name\" , wifi . WIFI_WPA2 , \"Wifi-Password\" ) except Exception as e : print ( \"ooops, something wrong while linking :(\" , e ) while True : sleep ( 1000 ) # let's try to connect to https://www.howsmyssl.com/a/check to get some info # on the SSL/TLS connection # retrieve the CA certificate used to sign the howsmyssl.com certificate cacert = __lookup ( SSL_CACERT_DST_ROOT_CA_X3 ) # create a SSL context to require server certificate verification ctx = ssl . create_ssl_context ( cacert = cacert , options = ssl . CERT_REQUIRED | ssl . SERVER_AUTH ) for i in range ( 3 ): try : print ( \"Trying to connect...\" ) url = \"https://www.howsmyssl.com/a/check\" # url resolution and http protocol handling are hidden inside the requests module user_agent = { \"User-Agent\" : \"curl/7.53.1\" , \"Accept\" : \"*/*\" } # pass the ssl context together with the request response = requests . get ( url , headers = user_agent , ctx = ctx ) # if we get here, there has been no exception, exit the loop break except Exception as e : print ( e ) try : # check status and print the result if response . status == 200 : print ( \"Success!!\" ) print ( \"-------------\" ) # it's time to parse the json response js = json . loads ( response . content ) # super easy! for k , v in js . items (): if k == \"given_cipher_suites\" : print ( \"Supported Ciphers\" ) for cipher in v : print ( cipher ) print ( \"-----\" ) else : print ( k , \"::\" , v ) print ( \"-------------\" ) except Exception as e : print ( \"ooops, something very wrong! :(\" , e ) The following CA certificates are available with the __lookup primitive: GlobalSign Root CA : SSL_CACERT_GLOBALSIGN_ROOT_CA GlobalSign Root CA - R2 : SSL_CACERT_GLOBALSIGN_ROOT_CA___R2 Verisign Class 3 Public Primary Certification Authority - G3 : SSL_CACERT_VERISIGN_CLASS_3_PUBLIC_PRIMARY_CERTIFICATION_AUTHORITY___G3 Entrust.net Premium 2048 Secure Server CA : SSL_CACERT_ENTRUST.NET_PREMIUM_2048_SECURE_SERVER_CA Baltimore CyberTrust Root : SSL_CACERT_BALTIMORE_CYBERTRUST_ROOT AddTrust Low-Value Services Root : SSL_CACERT_ADDTRUST_LOW_VALUE_SERVICES_ROOT AddTrust External Root : SSL_CACERT_ADDTRUST_EXTERNAL_ROOT AddTrust Public Services Root : SSL_CACERT_ADDTRUST_PUBLIC_SERVICES_ROOT AddTrust Qualified Certificates Root : SSL_CACERT_ADDTRUST_QUALIFIED_CERTIFICATES_ROOT Entrust Root Certification Authority : SSL_CACERT_ENTRUST_ROOT_CERTIFICATION_AUTHORITY RSA Security 2048 v3 : SSL_CACERT_RSA_SECURITY_2048_V3 GeoTrust Global CA : SSL_CACERT_GEOTRUST_GLOBAL_CA GeoTrust Global CA 2 : SSL_CACERT_GEOTRUST_GLOBAL_CA_2 GeoTrust Universal CA : SSL_CACERT_GEOTRUST_UNIVERSAL_CA GeoTrust Universal CA 2 : SSL_CACERT_GEOTRUST_UNIVERSAL_CA_2 Visa eCommerce Root : SSL_CACERT_VISA_ECOMMERCE_ROOT Certum Root CA : SSL_CACERT_CERTUM_ROOT_CA Comodo AAA Services root : SSL_CACERT_COMODO_AAA_SERVICES_ROOT Comodo Secure Services root : SSL_CACERT_COMODO_SECURE_SERVICES_ROOT Comodo Trusted Services root : SSL_CACERT_COMODO_TRUSTED_SERVICES_ROOT QuoVadis Root CA : SSL_CACERT_QUOVADIS_ROOT_CA QuoVadis Root CA 2 : SSL_CACERT_QUOVADIS_ROOT_CA_2 QuoVadis Root CA 3 : SSL_CACERT_QUOVADIS_ROOT_CA_3 Security Communication Root CA : SSL_CACERT_SECURITY_COMMUNICATION_ROOT_CA Sonera Class 2 Root CA : SSL_CACERT_SONERA_CLASS_2_ROOT_CA UTN USERFirst Hardware Root CA : SSL_CACERT_UTN_USERFIRST_HARDWARE_ROOT_CA Camerfirma Chambers of Commerce Root : SSL_CACERT_CAMERFIRMA_CHAMBERS_OF_COMMERCE_ROOT Camerfirma Global Chambersign Root : SSL_CACERT_CAMERFIRMA_GLOBAL_CHAMBERSIGN_ROOT XRamp Global CA Root : SSL_CACERT_XRAMP_GLOBAL_CA_ROOT Go Daddy Class 2 CA : SSL_CACERT_GO_DADDY_CLASS_2_CA Starfield Class 2 CA : SSL_CACERT_STARFIELD_CLASS_2_CA StartCom Certification Authority : SSL_CACERT_STARTCOM_CERTIFICATION_AUTHORITY Taiwan GRCA : SSL_CACERT_TAIWAN_GRCA Swisscom Root CA 1 : SSL_CACERT_SWISSCOM_ROOT_CA_1 DigiCert Assured ID Root CA : SSL_CACERT_DIGICERT_ASSURED_ID_ROOT_CA DigiCert Global Root CA : SSL_CACERT_DIGICERT_GLOBAL_ROOT_CA DigiCert High Assurance EV Root CA : SSL_CACERT_DIGICERT_HIGH_ASSURANCE_EV_ROOT_CA Certplus Class 2 Primary CA : SSL_CACERT_CERTPLUS_CLASS_2_PRIMARY_CA DST Root CA X3 : SSL_CACERT_DST_ROOT_CA_X3 DST ACES CA X6 : SSL_CACERT_DST_ACES_CA_X6 SwissSign Gold CA - G2 : SSL_CACERT_SWISSSIGN_GOLD_CA___G2 SwissSign Silver CA - G2 : SSL_CACERT_SWISSSIGN_SILVER_CA___G2 GeoTrust Primary Certification Authority : SSL_CACERT_GEOTRUST_PRIMARY_CERTIFICATION_AUTHORITY thawte Primary Root CA : SSL_CACERT_THAWTE_PRIMARY_ROOT_CA VeriSign Class 3 Public Primary Certification Authority - G5 : SSL_CACERT_VERISIGN_CLASS_3_PUBLIC_PRIMARY_CERTIFICATION_AUTHORITY___G5 SecureTrust CA : SSL_CACERT_SECURETRUST_CA Secure Global CA : SSL_CACERT_SECURE_GLOBAL_CA COMODO Certification Authority : SSL_CACERT_COMODO_CERTIFICATION_AUTHORITY Network Solutions Certificate Authority : SSL_CACERT_NETWORK_SOLUTIONS_CERTIFICATE_AUTHORITY WellsSecure Public Root Certificate Authority : SSL_CACERT_WELLSSECURE_PUBLIC_ROOT_CERTIFICATE_AUTHORITY COMODO ECC Certification Authority : SSL_CACERT_COMODO_ECC_CERTIFICATION_AUTHORITY Security Communication EV RootCA1 : SSL_CACERT_SECURITY_COMMUNICATION_EV_ROOTCA1 OISTE WISeKey Global Root GA CA : SSL_CACERT_OISTE_WISEKEY_GLOBAL_ROOT_GA_CA Microsec e-Szigno Root CA : SSL_CACERT_MICROSEC_E_SZIGNO_ROOT_CA Certigna : SSL_CACERT_CERTIGNA Deutsche Telekom Root CA 2 : SSL_CACERT_DEUTSCHE_TELEKOM_ROOT_CA_2 Cybertrust Global Root : SSL_CACERT_CYBERTRUST_GLOBAL_ROOT ePKI Root Certification Authority : SSL_CACERT_EPKI_ROOT_CERTIFICATION_AUTHORITY Buypass Class 2 CA 1 : SSL_CACERT_BUYPASS_CLASS_2_CA_1 certSIGN ROOT CA : SSL_CACERT_CERTSIGN_ROOT_CA CNNIC ROOT : SSL_CACERT_CNNIC_ROOT ApplicationCA - Japanese Government : SSL_CACERT_APPLICATIONCA___JAPANESE_GOVERNMENT GeoTrust Primary Certification Authority - G3 : SSL_CACERT_GEOTRUST_PRIMARY_CERTIFICATION_AUTHORITY___G3 thawte Primary Root CA - G2 : SSL_CACERT_THAWTE_PRIMARY_ROOT_CA___G2 thawte Primary Root CA - G3 : SSL_CACERT_THAWTE_PRIMARY_ROOT_CA___G3 GeoTrust Primary Certification Authority - G2 : SSL_CACERT_GEOTRUST_PRIMARY_CERTIFICATION_AUTHORITY___G2 VeriSign Universal Root Certification Authority : SSL_CACERT_VERISIGN_UNIVERSAL_ROOT_CERTIFICATION_AUTHORITY VeriSign Class 3 Public Primary Certification Authority - G4 : SSL_CACERT_VERISIGN_CLASS_3_PUBLIC_PRIMARY_CERTIFICATION_AUTHORITY___G4 NetLock Arany (Class Gold) F\u0151tan\u00fas\u00edtv\u00e1ny : SSL_CACERT_NETLOCK_ARANY_(CLASS_GOLD)_F\u0150TAN\u00daS\u00cdTV\u00c1NY Staat der Nederlanden Root CA - G2 : SSL_CACERT_STAAT_DER_NEDERLANDEN_ROOT_CA___G2 Hongkong Post Root CA 1 : SSL_CACERT_HONGKONG_POST_ROOT_CA_1 SecureSign RootCA11 : SSL_CACERT_SECURESIGN_ROOTCA11 ACEDICOM Root : SSL_CACERT_ACEDICOM_ROOT Microsec e-Szigno Root CA 2009 : SSL_CACERT_MICROSEC_E_SZIGNO_ROOT_CA_2009 GlobalSign Root CA - R3 : SSL_CACERT_GLOBALSIGN_ROOT_CA___R3 Autoridad de Certificacion Firmaprofesional CIF A62634068 : SSL_CACERT_AUTORIDAD_DE_CERTIFICACION_FIRMAPROFESIONAL_CIF_A62634068 Izenpe.com : SSL_CACERT_IZENPE.COM Chambers of Commerce Root - 2008 : SSL_CACERT_CHAMBERS_OF_COMMERCE_ROOT___2008 Global Chambersign Root - 2008 : SSL_CACERT_GLOBAL_CHAMBERSIGN_ROOT___2008 Go Daddy Root Certificate Authority - G2 : SSL_CACERT_GO_DADDY_ROOT_CERTIFICATE_AUTHORITY___G2 Starfield Root Certificate Authority - G2 : SSL_CACERT_STARFIELD_ROOT_CERTIFICATE_AUTHORITY___G2 Starfield Services Root Certificate Authority - G2 : SSL_CACERT_STARFIELD_SERVICES_ROOT_CERTIFICATE_AUTHORITY___G2 AffirmTrust Commercial : SSL_CACERT_AFFIRMTRUST_COMMERCIAL AffirmTrust Networking : SSL_CACERT_AFFIRMTRUST_NETWORKING AffirmTrust Premium : SSL_CACERT_AFFIRMTRUST_PREMIUM AffirmTrust Premium ECC : SSL_CACERT_AFFIRMTRUST_PREMIUM_ECC Certum Trusted Network CA : SSL_CACERT_CERTUM_TRUSTED_NETWORK_CA Certinomis - Autorit\u00e9 Racine : SSL_CACERT_CERTINOMIS___AUTORIT\u00c9_RACINE Root CA Generalitat Valenciana : SSL_CACERT_ROOT_CA_GENERALITAT_VALENCIANA TWCA Root Certification Authority : SSL_CACERT_TWCA_ROOT_CERTIFICATION_AUTHORITY Security Communication RootCA2 : SSL_CACERT_SECURITY_COMMUNICATION_ROOTCA2 Hellenic Academic and Research Institutions RootCA 2011 : SSL_CACERT_HELLENIC_ACADEMIC_AND_RESEARCH_INSTITUTIONS_ROOTCA_2011 Actalis Authentication Root CA : SSL_CACERT_ACTALIS_AUTHENTICATION_ROOT_CA Trustis FPS Root CA : SSL_CACERT_TRUSTIS_FPS_ROOT_CA StartCom Certification Authority : SSL_CACERT_STARTCOM_CERTIFICATION_AUTHORITY StartCom Certification Authority G2 : SSL_CACERT_STARTCOM_CERTIFICATION_AUTHORITY_G2 Buypass Class 2 Root CA : SSL_CACERT_BUYPASS_CLASS_2_ROOT_CA Buypass Class 3 Root CA : SSL_CACERT_BUYPASS_CLASS_3_ROOT_CA T-TeleSec GlobalRoot Class 3 : SSL_CACERT_T_TELESEC_GLOBALROOT_CLASS_3 EE Certification Centre Root CA : SSL_CACERT_EE_CERTIFICATION_CENTRE_ROOT_CA TURKTRUST Certificate Services Provider Root 2007 : SSL_CACERT_TURKTRUST_CERTIFICATE_SERVICES_PROVIDER_ROOT_2007 D-TRUST Root Class 3 CA 2 2009 : SSL_CACERT_D_TRUST_ROOT_CLASS_3_CA_2_2009 D-TRUST Root Class 3 CA 2 EV 2009 : SSL_CACERT_D_TRUST_ROOT_CLASS_3_CA_2_EV_2009 PSCProcert : SSL_CACERT_PSCPROCERT China Internet Network Information Center EV Certificates Root : SSL_CACERT_CHINA_INTERNET_NETWORK_INFORMATION_CENTER_EV_CERTIFICATES_ROOT Swisscom Root CA 2 : SSL_CACERT_SWISSCOM_ROOT_CA_2 Swisscom Root EV CA 2 : SSL_CACERT_SWISSCOM_ROOT_EV_CA_2 CA Disig Root R1 : SSL_CACERT_CA_DISIG_ROOT_R1 CA Disig Root R2 : SSL_CACERT_CA_DISIG_ROOT_R2 ACCVRAIZ1 : SSL_CACERT_ACCVRAIZ1 TWCA Global Root CA : SSL_CACERT_TWCA_GLOBAL_ROOT_CA TeliaSonera Root CA v1 : SSL_CACERT_TELIASONERA_ROOT_CA_V1 E-Tugra Certification Authority : SSL_CACERT_E_TUGRA_CERTIFICATION_AUTHORITY T-TeleSec GlobalRoot Class 2 : SSL_CACERT_T_TELESEC_GLOBALROOT_CLASS_2 Atos TrustedRoot 2011 : SSL_CACERT_ATOS_TRUSTEDROOT_2011 QuoVadis Root CA 1 G3 : SSL_CACERT_QUOVADIS_ROOT_CA_1_G3 QuoVadis Root CA 2 G3 : SSL_CACERT_QUOVADIS_ROOT_CA_2_G3 QuoVadis Root CA 3 G3 : SSL_CACERT_QUOVADIS_ROOT_CA_3_G3 DigiCert Assured ID Root G2 : SSL_CACERT_DIGICERT_ASSURED_ID_ROOT_G2 DigiCert Assured ID Root G3 : SSL_CACERT_DIGICERT_ASSURED_ID_ROOT_G3 DigiCert Global Root G2 : SSL_CACERT_DIGICERT_GLOBAL_ROOT_G2 DigiCert Global Root G3 : SSL_CACERT_DIGICERT_GLOBAL_ROOT_G3 DigiCert Trusted Root G4 : SSL_CACERT_DIGICERT_TRUSTED_ROOT_G4 WoSign : SSL_CACERT_WOSIGN WoSign China : SSL_CACERT_WOSIGN_CHINA COMODO RSA Certification Authority : SSL_CACERT_COMODO_RSA_CERTIFICATION_AUTHORITY USERTrust RSA Certification Authority : SSL_CACERT_USERTRUST_RSA_CERTIFICATION_AUTHORITY USERTrust ECC Certification Authority : SSL_CACERT_USERTRUST_ECC_CERTIFICATION_AUTHORITY GlobalSign ECC Root CA - R4 : SSL_CACERT_GLOBALSIGN_ECC_ROOT_CA___R4 GlobalSign ECC Root CA - R5 : SSL_CACERT_GLOBALSIGN_ECC_ROOT_CA___R5 Staat der Nederlanden Root CA - G3 : SSL_CACERT_STAAT_DER_NEDERLANDEN_ROOT_CA___G3 Staat der Nederlanden EV Root CA : SSL_CACERT_STAAT_DER_NEDERLANDEN_EV_ROOT_CA IdenTrust Commercial Root CA 1 : SSL_CACERT_IDENTRUST_COMMERCIAL_ROOT_CA_1 IdenTrust Public Sector Root CA 1 : SSL_CACERT_IDENTRUST_PUBLIC_SECTOR_ROOT_CA_1 Entrust Root Certification Authority - G2 : SSL_CACERT_ENTRUST_ROOT_CERTIFICATION_AUTHORITY___G2 Entrust Root Certification Authority - EC1 : SSL_CACERT_ENTRUST_ROOT_CERTIFICATION_AUTHORITY___EC1 CFCA EV ROOT : SSL_CACERT_CFCA_EV_ROOT T\u00dcRKTRUST Elektronik Sertifika Hizmet Sa\u011flay\u0131c\u0131s\u0131 H5 : SSL_CACERT_T\u00dcRKTRUST_ELEKTRONIK_SERTIFIKA_HIZMET_SA\u011eLAYICISI_H5 T\u00dcRKTRUST Elektronik Sertifika Hizmet Sa\u011flay\u0131c\u0131s\u0131 H6 : SSL_CACERT_T\u00dcRKTRUST_ELEKTRONIK_SERTIFIKA_HIZMET_SA\u011eLAYICISI_H6 Certinomis - Root CA : SSL_CACERT_CERTINOMIS___ROOT_CA OISTE WISeKey Global Root GB CA : SSL_CACERT_OISTE_WISEKEY_GLOBAL_ROOT_GB_CA Certification Authority of WoSign G2 : SSL_CACERT_CERTIFICATION_AUTHORITY_OF_WOSIGN_G2 CA WoSign ECC Root : SSL_CACERT_CA_WOSIGN_ECC_ROOT SZAFIR ROOT CA2 : SSL_CACERT_SZAFIR_ROOT_CA2 Certum Trusted Network CA 2 : SSL_CACERT_CERTUM_TRUSTED_NETWORK_CA_2 Hellenic Academic and Research Institutions RootCA 2015 : SSL_CACERT_HELLENIC_ACADEMIC_AND_RESEARCH_INSTITUTIONS_ROOTCA_2015 Hellenic Academic and Research Institutions ECC RootCA 2015 : SSL_CACERT_HELLENIC_ACADEMIC_AND_RESEARCH_INSTITUTIONS_ECC_ROOTCA_2015 Certplus Root CA G1 : SSL_CACERT_CERTPLUS_ROOT_CA_G1 Certplus Root CA G2 : SSL_CACERT_CERTPLUS_ROOT_CA_G2 OpenTrust Root CA G1 : SSL_CACERT_OPENTRUST_ROOT_CA_G1 OpenTrust Root CA G2 : SSL_CACERT_OPENTRUST_ROOT_CA_G2 OpenTrust Root CA G3 : SSL_CACERT_OPENTRUST_ROOT_CA_G3 The sslsocket class \u00b6 sslsocket(family=AF_INET, type=SOCK_STREAM, proto=IPPROTO_TCP, ctx=()) This class represents a secure socket based on SSL/TLS protocol. It inherits from socket.socket Raise IOError exceptions if socket creation goes wrong. The parameter ctx is the SSL context to use for the socket. See create_ssl_context for details. Sockets can be used like this: # import the ssl module import ssl # import a module to access a net driver (wifi, eth,...) from wireless import wifi # import the actual net driver from driver.wifi.your_preferred_net_driver import your_preferred_net_driver # init the driver your_preferred_net_driver . init () # link the wifi to an AP wifi . link ( \"Your Wifi SSID\" , WIFI_WPA2 , \"Your Wifi Password\" ) # create a tcp socket sock = ssl . sslsocket ( type = SOCK_STREAM ) # connect the socket to net address 192.168.1.10 on port 443 sock . connect (( \"192.168.1.10\" , 443 )) # send something on the socket! sock . sendall ( \"Hello World!\" ) create_ssl_context(cacert=\"\", clicert=\"\", pkey=\"\", hostname=\"\", options=ssl.CERT_NONE|ssl.SERVER_AUTH) This function generates an SSL context with the following data: cacert is the CA certificate that will be used to authenticate the other end of the TLS connection clicert is the certificate that the server expects to receive from the client in a two-way TLS authentication pkey is the private key matching clicert . It can be an empty string to use a hardware stored private key. To enable the use of hardware keys a hardware cryptographic interface must be started. For example, with an ATECC508A (ATECCx08A interface): from microchip.ateccx08a import ateccx08a # ... ateccx08a . hwcrypto_init ( I2C0 , 0 ) # select private key stored in slot 0 (in this case ZERYNTH_HWCRYPTO_ATECCx08A must be also set to true in project.yml ) hostname is the hostname expected to match the certificate sent by the server. If not given, the hostname check is skipped options is an integer obtained by or\u2019ing together one or more of the following options: * `ssl.CERT_NONE` : no certificate verification is performed ( default ) * `ssl.CERT_OPTIONAL` : certificate verification is performed only if the other end of the connection sends one , otherwise the certificate is not requested and verification skipped * `ssl.CERT_REQUIRED` : certificate verification is mandatory . If verification fails , `ConnectionAborted` is raised during TLS handshake . * `ssl.SERVER_AUTH` : indicates that the context may be used to authenticate servers therefore , it will be used to create client - side sockets ( default ). * `ssl.CLIENT_AUTH` : indicates that the context may be used to authenticate clients therefore , it will be used to create server - side sockets . Returns a tuple to be passed as parameter during secure socket creation. Note cacert , clicert and pkey can be bytes, bytearray, strings or instances of classes that have a size and read method, allowing to pass as parameters open files or resources. Note cacert , clicert and pkey must be in PEM format and null-terminated (they must end with a 0 byte).","title":"Secure Socket Layer"},{"location":"reference/core/stdlib/docs/ssl/#secure-socket-layer","text":"This module provides access to an almost complete Secure Socket Layer interface. However, some behaviour may be dependent on the underlying network driver. SSL/TLS (TLS from now on) provides encryption and peer authentication facilities for network sockets, both client-side and server-side. The properties enforced by TLS on data transmission are: confidentiality : it means the transmitted data is readable only to the two end points of the TLS, it is unreadable garbage for everyon else intercepting the such data during transmission integrity : it means each end point receives exactly what has been sent by the other end point, no data tampering is possible authentication : it means each end point can have guarantees on the identity of the other end point In order to achieve such capabilities, TLS exploits the properties of different cryptographic primitives. Confidentiality is obtained by exchanging a symmetric key (a secret known only by he two end points for the duration of the connection) by means of asymmetric key cryptography (usually Diffie-Hellman or RSA key exchange). Such symmetric key will be used to encrypt every transmitted message. Integrity is guaranteed by appending to transmitted messages a signed digest (called HMAC) that can be generated only by someone knowing the symmetric key. Authentication is more complex and configurable. Indeed authentication in TLS can be: skipped: the two end points are not interested in the authentication property, therefore they do not require the other end to authenticate at the beginning of the connection one-way: the client can require the server to show some credentials (called certificate) that guarantees its identity. The client can close the connection if the verification of the server certificate fails. two-way: both server and client ask each other a proof of identity by exchanging and verifying certificates. A certificate consists of a public key together with some more data (such as the server domain, the expiration date, etc\u2026) and to guarantee the certificate is not tampered, it is signed with the private key of a certification authority (CA). The CA public key must be known and it is contained in a set of CA certificates common to both end points. The mechanism of certificate verification consists of an exchange of asymmetrically crypted messages that proves the identity of the server (and of the client if requested). No TLS connection is secure without athentication! Therefore, at least a CA certificate must be given to the client in order to authenticate the server and certificate verification must be enabled (it is disabled by default). Since there are many certification authorities, shipping all CA certificates inside a microcontroller is not feasible. Zerynth provides the useful __lookup macro that can be used to retrieve a single CA certificate and store it directly in the firmware: cacert0 = __lookup ( SSL_CACERT_COMODO_TRUSTED_SERVICES_ROOT ) cacert1 = __lookup ( SSL_CACERT_DIGICERT_TRUSTED_ROOT_G4 ) # cacert0 will be set to \"Comodo Trusted Services\" CA certificate # cacert1 will be set to \"DigiCert Trusted Root G4\" CA certificate To check the TLS feature available in a particular network driver, refer to the following example (based on ESP32): import json # import the wifi interface from wireless import wifi # import the http module import requests # import ssl module import ssl # the wifi module needs a networking driver to be loaded # in order to control the board hardware. from espressif.esp32net import esp32wifi as wifi_driver streams . serial () # init the wifi driver! # The driver automatically registers itself to the wifi interface # with the correct configuration for the selected board wifi_driver . auto_init () # use the wifi interface to link to the Access Point # change network name, security and password as needed print ( \"Establishing Link...\" ) try : # FOR THIS EXAMPLE TO WORK, \"Network-Name\" AND \"Wifi-Password\" MUST BE SET # TO MATCH YOUR ACTUAL NETWORK CONFIGURATION wifi . link ( \"Network-Name\" , wifi . WIFI_WPA2 , \"Wifi-Password\" ) except Exception as e : print ( \"ooops, something wrong while linking :(\" , e ) while True : sleep ( 1000 ) # let's try to connect to https://www.howsmyssl.com/a/check to get some info # on the SSL/TLS connection # retrieve the CA certificate used to sign the howsmyssl.com certificate cacert = __lookup ( SSL_CACERT_DST_ROOT_CA_X3 ) # create a SSL context to require server certificate verification ctx = ssl . create_ssl_context ( cacert = cacert , options = ssl . CERT_REQUIRED | ssl . SERVER_AUTH ) for i in range ( 3 ): try : print ( \"Trying to connect...\" ) url = \"https://www.howsmyssl.com/a/check\" # url resolution and http protocol handling are hidden inside the requests module user_agent = { \"User-Agent\" : \"curl/7.53.1\" , \"Accept\" : \"*/*\" } # pass the ssl context together with the request response = requests . get ( url , headers = user_agent , ctx = ctx ) # if we get here, there has been no exception, exit the loop break except Exception as e : print ( e ) try : # check status and print the result if response . status == 200 : print ( \"Success!!\" ) print ( \"-------------\" ) # it's time to parse the json response js = json . loads ( response . content ) # super easy! for k , v in js . items (): if k == \"given_cipher_suites\" : print ( \"Supported Ciphers\" ) for cipher in v : print ( cipher ) print ( \"-----\" ) else : print ( k , \"::\" , v ) print ( \"-------------\" ) except Exception as e : print ( \"ooops, something very wrong! :(\" , e ) The following CA certificates are available with the __lookup primitive: GlobalSign Root CA : SSL_CACERT_GLOBALSIGN_ROOT_CA GlobalSign Root CA - R2 : SSL_CACERT_GLOBALSIGN_ROOT_CA___R2 Verisign Class 3 Public Primary Certification Authority - G3 : SSL_CACERT_VERISIGN_CLASS_3_PUBLIC_PRIMARY_CERTIFICATION_AUTHORITY___G3 Entrust.net Premium 2048 Secure Server CA : SSL_CACERT_ENTRUST.NET_PREMIUM_2048_SECURE_SERVER_CA Baltimore CyberTrust Root : SSL_CACERT_BALTIMORE_CYBERTRUST_ROOT AddTrust Low-Value Services Root : SSL_CACERT_ADDTRUST_LOW_VALUE_SERVICES_ROOT AddTrust External Root : SSL_CACERT_ADDTRUST_EXTERNAL_ROOT AddTrust Public Services Root : SSL_CACERT_ADDTRUST_PUBLIC_SERVICES_ROOT AddTrust Qualified Certificates Root : SSL_CACERT_ADDTRUST_QUALIFIED_CERTIFICATES_ROOT Entrust Root Certification Authority : SSL_CACERT_ENTRUST_ROOT_CERTIFICATION_AUTHORITY RSA Security 2048 v3 : SSL_CACERT_RSA_SECURITY_2048_V3 GeoTrust Global CA : SSL_CACERT_GEOTRUST_GLOBAL_CA GeoTrust Global CA 2 : SSL_CACERT_GEOTRUST_GLOBAL_CA_2 GeoTrust Universal CA : SSL_CACERT_GEOTRUST_UNIVERSAL_CA GeoTrust Universal CA 2 : SSL_CACERT_GEOTRUST_UNIVERSAL_CA_2 Visa eCommerce Root : SSL_CACERT_VISA_ECOMMERCE_ROOT Certum Root CA : SSL_CACERT_CERTUM_ROOT_CA Comodo AAA Services root : SSL_CACERT_COMODO_AAA_SERVICES_ROOT Comodo Secure Services root : SSL_CACERT_COMODO_SECURE_SERVICES_ROOT Comodo Trusted Services root : SSL_CACERT_COMODO_TRUSTED_SERVICES_ROOT QuoVadis Root CA : SSL_CACERT_QUOVADIS_ROOT_CA QuoVadis Root CA 2 : SSL_CACERT_QUOVADIS_ROOT_CA_2 QuoVadis Root CA 3 : SSL_CACERT_QUOVADIS_ROOT_CA_3 Security Communication Root CA : SSL_CACERT_SECURITY_COMMUNICATION_ROOT_CA Sonera Class 2 Root CA : SSL_CACERT_SONERA_CLASS_2_ROOT_CA UTN USERFirst Hardware Root CA : SSL_CACERT_UTN_USERFIRST_HARDWARE_ROOT_CA Camerfirma Chambers of Commerce Root : SSL_CACERT_CAMERFIRMA_CHAMBERS_OF_COMMERCE_ROOT Camerfirma Global Chambersign Root : SSL_CACERT_CAMERFIRMA_GLOBAL_CHAMBERSIGN_ROOT XRamp Global CA Root : SSL_CACERT_XRAMP_GLOBAL_CA_ROOT Go Daddy Class 2 CA : SSL_CACERT_GO_DADDY_CLASS_2_CA Starfield Class 2 CA : SSL_CACERT_STARFIELD_CLASS_2_CA StartCom Certification Authority : SSL_CACERT_STARTCOM_CERTIFICATION_AUTHORITY Taiwan GRCA : SSL_CACERT_TAIWAN_GRCA Swisscom Root CA 1 : SSL_CACERT_SWISSCOM_ROOT_CA_1 DigiCert Assured ID Root CA : SSL_CACERT_DIGICERT_ASSURED_ID_ROOT_CA DigiCert Global Root CA : SSL_CACERT_DIGICERT_GLOBAL_ROOT_CA DigiCert High Assurance EV Root CA : SSL_CACERT_DIGICERT_HIGH_ASSURANCE_EV_ROOT_CA Certplus Class 2 Primary CA : SSL_CACERT_CERTPLUS_CLASS_2_PRIMARY_CA DST Root CA X3 : SSL_CACERT_DST_ROOT_CA_X3 DST ACES CA X6 : SSL_CACERT_DST_ACES_CA_X6 SwissSign Gold CA - G2 : SSL_CACERT_SWISSSIGN_GOLD_CA___G2 SwissSign Silver CA - G2 : SSL_CACERT_SWISSSIGN_SILVER_CA___G2 GeoTrust Primary Certification Authority : SSL_CACERT_GEOTRUST_PRIMARY_CERTIFICATION_AUTHORITY thawte Primary Root CA : SSL_CACERT_THAWTE_PRIMARY_ROOT_CA VeriSign Class 3 Public Primary Certification Authority - G5 : SSL_CACERT_VERISIGN_CLASS_3_PUBLIC_PRIMARY_CERTIFICATION_AUTHORITY___G5 SecureTrust CA : SSL_CACERT_SECURETRUST_CA Secure Global CA : SSL_CACERT_SECURE_GLOBAL_CA COMODO Certification Authority : SSL_CACERT_COMODO_CERTIFICATION_AUTHORITY Network Solutions Certificate Authority : SSL_CACERT_NETWORK_SOLUTIONS_CERTIFICATE_AUTHORITY WellsSecure Public Root Certificate Authority : SSL_CACERT_WELLSSECURE_PUBLIC_ROOT_CERTIFICATE_AUTHORITY COMODO ECC Certification Authority : SSL_CACERT_COMODO_ECC_CERTIFICATION_AUTHORITY Security Communication EV RootCA1 : SSL_CACERT_SECURITY_COMMUNICATION_EV_ROOTCA1 OISTE WISeKey Global Root GA CA : SSL_CACERT_OISTE_WISEKEY_GLOBAL_ROOT_GA_CA Microsec e-Szigno Root CA : SSL_CACERT_MICROSEC_E_SZIGNO_ROOT_CA Certigna : SSL_CACERT_CERTIGNA Deutsche Telekom Root CA 2 : SSL_CACERT_DEUTSCHE_TELEKOM_ROOT_CA_2 Cybertrust Global Root : SSL_CACERT_CYBERTRUST_GLOBAL_ROOT ePKI Root Certification Authority : SSL_CACERT_EPKI_ROOT_CERTIFICATION_AUTHORITY Buypass Class 2 CA 1 : SSL_CACERT_BUYPASS_CLASS_2_CA_1 certSIGN ROOT CA : SSL_CACERT_CERTSIGN_ROOT_CA CNNIC ROOT : SSL_CACERT_CNNIC_ROOT ApplicationCA - Japanese Government : SSL_CACERT_APPLICATIONCA___JAPANESE_GOVERNMENT GeoTrust Primary Certification Authority - G3 : SSL_CACERT_GEOTRUST_PRIMARY_CERTIFICATION_AUTHORITY___G3 thawte Primary Root CA - G2 : SSL_CACERT_THAWTE_PRIMARY_ROOT_CA___G2 thawte Primary Root CA - G3 : SSL_CACERT_THAWTE_PRIMARY_ROOT_CA___G3 GeoTrust Primary Certification Authority - G2 : SSL_CACERT_GEOTRUST_PRIMARY_CERTIFICATION_AUTHORITY___G2 VeriSign Universal Root Certification Authority : SSL_CACERT_VERISIGN_UNIVERSAL_ROOT_CERTIFICATION_AUTHORITY VeriSign Class 3 Public Primary Certification Authority - G4 : SSL_CACERT_VERISIGN_CLASS_3_PUBLIC_PRIMARY_CERTIFICATION_AUTHORITY___G4 NetLock Arany (Class Gold) F\u0151tan\u00fas\u00edtv\u00e1ny : SSL_CACERT_NETLOCK_ARANY_(CLASS_GOLD)_F\u0150TAN\u00daS\u00cdTV\u00c1NY Staat der Nederlanden Root CA - G2 : SSL_CACERT_STAAT_DER_NEDERLANDEN_ROOT_CA___G2 Hongkong Post Root CA 1 : SSL_CACERT_HONGKONG_POST_ROOT_CA_1 SecureSign RootCA11 : SSL_CACERT_SECURESIGN_ROOTCA11 ACEDICOM Root : SSL_CACERT_ACEDICOM_ROOT Microsec e-Szigno Root CA 2009 : SSL_CACERT_MICROSEC_E_SZIGNO_ROOT_CA_2009 GlobalSign Root CA - R3 : SSL_CACERT_GLOBALSIGN_ROOT_CA___R3 Autoridad de Certificacion Firmaprofesional CIF A62634068 : SSL_CACERT_AUTORIDAD_DE_CERTIFICACION_FIRMAPROFESIONAL_CIF_A62634068 Izenpe.com : SSL_CACERT_IZENPE.COM Chambers of Commerce Root - 2008 : SSL_CACERT_CHAMBERS_OF_COMMERCE_ROOT___2008 Global Chambersign Root - 2008 : SSL_CACERT_GLOBAL_CHAMBERSIGN_ROOT___2008 Go Daddy Root Certificate Authority - G2 : SSL_CACERT_GO_DADDY_ROOT_CERTIFICATE_AUTHORITY___G2 Starfield Root Certificate Authority - G2 : SSL_CACERT_STARFIELD_ROOT_CERTIFICATE_AUTHORITY___G2 Starfield Services Root Certificate Authority - G2 : SSL_CACERT_STARFIELD_SERVICES_ROOT_CERTIFICATE_AUTHORITY___G2 AffirmTrust Commercial : SSL_CACERT_AFFIRMTRUST_COMMERCIAL AffirmTrust Networking : SSL_CACERT_AFFIRMTRUST_NETWORKING AffirmTrust Premium : SSL_CACERT_AFFIRMTRUST_PREMIUM AffirmTrust Premium ECC : SSL_CACERT_AFFIRMTRUST_PREMIUM_ECC Certum Trusted Network CA : SSL_CACERT_CERTUM_TRUSTED_NETWORK_CA Certinomis - Autorit\u00e9 Racine : SSL_CACERT_CERTINOMIS___AUTORIT\u00c9_RACINE Root CA Generalitat Valenciana : SSL_CACERT_ROOT_CA_GENERALITAT_VALENCIANA TWCA Root Certification Authority : SSL_CACERT_TWCA_ROOT_CERTIFICATION_AUTHORITY Security Communication RootCA2 : SSL_CACERT_SECURITY_COMMUNICATION_ROOTCA2 Hellenic Academic and Research Institutions RootCA 2011 : SSL_CACERT_HELLENIC_ACADEMIC_AND_RESEARCH_INSTITUTIONS_ROOTCA_2011 Actalis Authentication Root CA : SSL_CACERT_ACTALIS_AUTHENTICATION_ROOT_CA Trustis FPS Root CA : SSL_CACERT_TRUSTIS_FPS_ROOT_CA StartCom Certification Authority : SSL_CACERT_STARTCOM_CERTIFICATION_AUTHORITY StartCom Certification Authority G2 : SSL_CACERT_STARTCOM_CERTIFICATION_AUTHORITY_G2 Buypass Class 2 Root CA : SSL_CACERT_BUYPASS_CLASS_2_ROOT_CA Buypass Class 3 Root CA : SSL_CACERT_BUYPASS_CLASS_3_ROOT_CA T-TeleSec GlobalRoot Class 3 : SSL_CACERT_T_TELESEC_GLOBALROOT_CLASS_3 EE Certification Centre Root CA : SSL_CACERT_EE_CERTIFICATION_CENTRE_ROOT_CA TURKTRUST Certificate Services Provider Root 2007 : SSL_CACERT_TURKTRUST_CERTIFICATE_SERVICES_PROVIDER_ROOT_2007 D-TRUST Root Class 3 CA 2 2009 : SSL_CACERT_D_TRUST_ROOT_CLASS_3_CA_2_2009 D-TRUST Root Class 3 CA 2 EV 2009 : SSL_CACERT_D_TRUST_ROOT_CLASS_3_CA_2_EV_2009 PSCProcert : SSL_CACERT_PSCPROCERT China Internet Network Information Center EV Certificates Root : SSL_CACERT_CHINA_INTERNET_NETWORK_INFORMATION_CENTER_EV_CERTIFICATES_ROOT Swisscom Root CA 2 : SSL_CACERT_SWISSCOM_ROOT_CA_2 Swisscom Root EV CA 2 : SSL_CACERT_SWISSCOM_ROOT_EV_CA_2 CA Disig Root R1 : SSL_CACERT_CA_DISIG_ROOT_R1 CA Disig Root R2 : SSL_CACERT_CA_DISIG_ROOT_R2 ACCVRAIZ1 : SSL_CACERT_ACCVRAIZ1 TWCA Global Root CA : SSL_CACERT_TWCA_GLOBAL_ROOT_CA TeliaSonera Root CA v1 : SSL_CACERT_TELIASONERA_ROOT_CA_V1 E-Tugra Certification Authority : SSL_CACERT_E_TUGRA_CERTIFICATION_AUTHORITY T-TeleSec GlobalRoot Class 2 : SSL_CACERT_T_TELESEC_GLOBALROOT_CLASS_2 Atos TrustedRoot 2011 : SSL_CACERT_ATOS_TRUSTEDROOT_2011 QuoVadis Root CA 1 G3 : SSL_CACERT_QUOVADIS_ROOT_CA_1_G3 QuoVadis Root CA 2 G3 : SSL_CACERT_QUOVADIS_ROOT_CA_2_G3 QuoVadis Root CA 3 G3 : SSL_CACERT_QUOVADIS_ROOT_CA_3_G3 DigiCert Assured ID Root G2 : SSL_CACERT_DIGICERT_ASSURED_ID_ROOT_G2 DigiCert Assured ID Root G3 : SSL_CACERT_DIGICERT_ASSURED_ID_ROOT_G3 DigiCert Global Root G2 : SSL_CACERT_DIGICERT_GLOBAL_ROOT_G2 DigiCert Global Root G3 : SSL_CACERT_DIGICERT_GLOBAL_ROOT_G3 DigiCert Trusted Root G4 : SSL_CACERT_DIGICERT_TRUSTED_ROOT_G4 WoSign : SSL_CACERT_WOSIGN WoSign China : SSL_CACERT_WOSIGN_CHINA COMODO RSA Certification Authority : SSL_CACERT_COMODO_RSA_CERTIFICATION_AUTHORITY USERTrust RSA Certification Authority : SSL_CACERT_USERTRUST_RSA_CERTIFICATION_AUTHORITY USERTrust ECC Certification Authority : SSL_CACERT_USERTRUST_ECC_CERTIFICATION_AUTHORITY GlobalSign ECC Root CA - R4 : SSL_CACERT_GLOBALSIGN_ECC_ROOT_CA___R4 GlobalSign ECC Root CA - R5 : SSL_CACERT_GLOBALSIGN_ECC_ROOT_CA___R5 Staat der Nederlanden Root CA - G3 : SSL_CACERT_STAAT_DER_NEDERLANDEN_ROOT_CA___G3 Staat der Nederlanden EV Root CA : SSL_CACERT_STAAT_DER_NEDERLANDEN_EV_ROOT_CA IdenTrust Commercial Root CA 1 : SSL_CACERT_IDENTRUST_COMMERCIAL_ROOT_CA_1 IdenTrust Public Sector Root CA 1 : SSL_CACERT_IDENTRUST_PUBLIC_SECTOR_ROOT_CA_1 Entrust Root Certification Authority - G2 : SSL_CACERT_ENTRUST_ROOT_CERTIFICATION_AUTHORITY___G2 Entrust Root Certification Authority - EC1 : SSL_CACERT_ENTRUST_ROOT_CERTIFICATION_AUTHORITY___EC1 CFCA EV ROOT : SSL_CACERT_CFCA_EV_ROOT T\u00dcRKTRUST Elektronik Sertifika Hizmet Sa\u011flay\u0131c\u0131s\u0131 H5 : SSL_CACERT_T\u00dcRKTRUST_ELEKTRONIK_SERTIFIKA_HIZMET_SA\u011eLAYICISI_H5 T\u00dcRKTRUST Elektronik Sertifika Hizmet Sa\u011flay\u0131c\u0131s\u0131 H6 : SSL_CACERT_T\u00dcRKTRUST_ELEKTRONIK_SERTIFIKA_HIZMET_SA\u011eLAYICISI_H6 Certinomis - Root CA : SSL_CACERT_CERTINOMIS___ROOT_CA OISTE WISeKey Global Root GB CA : SSL_CACERT_OISTE_WISEKEY_GLOBAL_ROOT_GB_CA Certification Authority of WoSign G2 : SSL_CACERT_CERTIFICATION_AUTHORITY_OF_WOSIGN_G2 CA WoSign ECC Root : SSL_CACERT_CA_WOSIGN_ECC_ROOT SZAFIR ROOT CA2 : SSL_CACERT_SZAFIR_ROOT_CA2 Certum Trusted Network CA 2 : SSL_CACERT_CERTUM_TRUSTED_NETWORK_CA_2 Hellenic Academic and Research Institutions RootCA 2015 : SSL_CACERT_HELLENIC_ACADEMIC_AND_RESEARCH_INSTITUTIONS_ROOTCA_2015 Hellenic Academic and Research Institutions ECC RootCA 2015 : SSL_CACERT_HELLENIC_ACADEMIC_AND_RESEARCH_INSTITUTIONS_ECC_ROOTCA_2015 Certplus Root CA G1 : SSL_CACERT_CERTPLUS_ROOT_CA_G1 Certplus Root CA G2 : SSL_CACERT_CERTPLUS_ROOT_CA_G2 OpenTrust Root CA G1 : SSL_CACERT_OPENTRUST_ROOT_CA_G1 OpenTrust Root CA G2 : SSL_CACERT_OPENTRUST_ROOT_CA_G2 OpenTrust Root CA G3 : SSL_CACERT_OPENTRUST_ROOT_CA_G3","title":"Secure Socket Layer"},{"location":"reference/core/stdlib/docs/ssl/#the-sslsocket-class","text":"sslsocket(family=AF_INET, type=SOCK_STREAM, proto=IPPROTO_TCP, ctx=()) This class represents a secure socket based on SSL/TLS protocol. It inherits from socket.socket Raise IOError exceptions if socket creation goes wrong. The parameter ctx is the SSL context to use for the socket. See create_ssl_context for details. Sockets can be used like this: # import the ssl module import ssl # import a module to access a net driver (wifi, eth,...) from wireless import wifi # import the actual net driver from driver.wifi.your_preferred_net_driver import your_preferred_net_driver # init the driver your_preferred_net_driver . init () # link the wifi to an AP wifi . link ( \"Your Wifi SSID\" , WIFI_WPA2 , \"Your Wifi Password\" ) # create a tcp socket sock = ssl . sslsocket ( type = SOCK_STREAM ) # connect the socket to net address 192.168.1.10 on port 443 sock . connect (( \"192.168.1.10\" , 443 )) # send something on the socket! sock . sendall ( \"Hello World!\" ) create_ssl_context(cacert=\"\", clicert=\"\", pkey=\"\", hostname=\"\", options=ssl.CERT_NONE|ssl.SERVER_AUTH) This function generates an SSL context with the following data: cacert is the CA certificate that will be used to authenticate the other end of the TLS connection clicert is the certificate that the server expects to receive from the client in a two-way TLS authentication pkey is the private key matching clicert . It can be an empty string to use a hardware stored private key. To enable the use of hardware keys a hardware cryptographic interface must be started. For example, with an ATECC508A (ATECCx08A interface): from microchip.ateccx08a import ateccx08a # ... ateccx08a . hwcrypto_init ( I2C0 , 0 ) # select private key stored in slot 0 (in this case ZERYNTH_HWCRYPTO_ATECCx08A must be also set to true in project.yml ) hostname is the hostname expected to match the certificate sent by the server. If not given, the hostname check is skipped options is an integer obtained by or\u2019ing together one or more of the following options: * `ssl.CERT_NONE` : no certificate verification is performed ( default ) * `ssl.CERT_OPTIONAL` : certificate verification is performed only if the other end of the connection sends one , otherwise the certificate is not requested and verification skipped * `ssl.CERT_REQUIRED` : certificate verification is mandatory . If verification fails , `ConnectionAborted` is raised during TLS handshake . * `ssl.SERVER_AUTH` : indicates that the context may be used to authenticate servers therefore , it will be used to create client - side sockets ( default ). * `ssl.CLIENT_AUTH` : indicates that the context may be used to authenticate clients therefore , it will be used to create server - side sockets . Returns a tuple to be passed as parameter during secure socket creation. Note cacert , clicert and pkey can be bytes, bytearray, strings or instances of classes that have a size and read method, allowing to pass as parameters open files or resources. Note cacert , clicert and pkey must be in PEM format and null-terminated (they must end with a 0 byte).","title":"The sslsocket class"},{"location":"reference/core/stdlib/docs/streams/","text":"Streams \u00b6 This module contains class definitions for streams. A stream is an abstraction representing a channel to write and read sequences of bytes. A stream is connected to something, being it a serial port or a socket or internal memory, from which it receives and to which it sends bytes. Every stream instance implements the following methods: read: removes bytes from the stream write: puts bytes in the stream available: checks the presence of readable bytes in the stream streams implements the following streams: base class streams.stream() streams.serial() streams.SocketStream() streams.FileStream() streams.ResourceStream() The stream class \u00b6 stream() This is the base class for streams and all streams must derive from this class. _readbuf(buffer, size=1, ofs=0) Reads bytes from the stream to buffer . If the stream contains no readable bytes it blocks until some bytes arrives or the underlying connection is lost (e.g. the server closes the socket). It directly access the driver linked to the stream issuing a native read command. In most cases _readbuf() is called internally by other stream methods and should not be called directly. buffer is a byte sequence used to store the bytes just read. size is the number of bytes to be read and ofs is the position of buffer to start writing incoming bytes. Bytes are stored in buffer up to buffer size or less. Returns the number of bytes read or 0 when the underlying connection is lost. write(buffer) Writes the content of buffer to the stream. buffer must be a byte sequence (bytes, bytearray or string). Returns the number of bytes actually written to the stream (can be less than the elements in buffer ) read(size=1) Reads at most size bytes from the stream and returns a bytearray with the actual bytes read. read blocks if no bytes are available in the stream. If read returns an empty bytearray the underlying stream can be considered disconnected. readline(sep=\"\\\\n\", buffer=None, size=0, ofs=0) Reads bytes from the stream until sep is encountered (an end-of-line byte (\u201c\\n\u201d) is default). Returns the line as a bytearray with sep included. If buffer is given (as a bytearray), buffer is used to store the line up to size bytes, starting at offset ofs . If readline returns an empty bytearray the underlying stream can be considered disconnected. The serial class \u00b6 serial(drivername=SERIAL0, baud=115200, stopbits=STOPBIT_1, parity=PARITY_NONE, bitsize=BITSIZE_8, set_default=True, rxsize=0, txsize=0) This class implements a stream that can be used to connect to a serial port. It inhertis all of its methods from stream() . Initialize the serial port driver identified by drivername and starts it up with a baud rate of baud . Also, if set_default is True, sets itself as the default stream used by __builtins__.print() . This means that the serial stream will be the system default one. Additional parameters can be passed such as: * parity : PARITY_NONE or PARITY_ONE * stopbits : STOPBIT_1 , STOPBIT_1_HALF , STOPBIT_2 * bitsize : BITSIZE_8 * rxsize and txsize : the size in bytes of the receive and transmit buffers (0 selects the board default) Not all of the additional parameters are always supported by the underlying device. This is the code needed to print something on the default serial port: # import the streams module import streams # create a serial stream linked to SERIAL0 port streams . serial () # SERIAL0 is automatically selected as the default system stream, # therefore print will output everything to it print ( \"Hello World!\" ) available() Returns the number of characters that can be read without blocking. close() Close the stream linked to the underlying serial port. The SocketStream class \u00b6 SocketStream(sock) This class implements a stream that has a socket as a source of data. It inhertis all of its methods from stream() . write(buffer) Writes the content of buffer to the stream. buffer must be a byte sequence (bytes, bytearray or string). Returns the number of bytes actually written to the stream (can be less than the elements in buffer ) close() Close the underlying socket. The FileStream class \u00b6 FileStream(name, mode=\"rb\") This class implements a stream that has a file as a source of data. It inherits all of its methods from stream() . It is just a stub at the moment. It is used by ResourceStream() only. seek(offset, whence=SEEK_SET) Move the current position to offset bytes with respect to whence . whence can be: SEEK_SET: start of file SEEK_CUR: current position SEEK_END: end of file The ResourceStream class \u00b6 ResourceStream(name) This class implements a stream that has a flash saved resource as a source of data. It inherits all of its methods from FileStream() .","title":"Streams"},{"location":"reference/core/stdlib/docs/streams/#streams","text":"This module contains class definitions for streams. A stream is an abstraction representing a channel to write and read sequences of bytes. A stream is connected to something, being it a serial port or a socket or internal memory, from which it receives and to which it sends bytes. Every stream instance implements the following methods: read: removes bytes from the stream write: puts bytes in the stream available: checks the presence of readable bytes in the stream streams implements the following streams: base class streams.stream() streams.serial() streams.SocketStream() streams.FileStream() streams.ResourceStream()","title":"Streams"},{"location":"reference/core/stdlib/docs/streams/#the-stream-class","text":"stream() This is the base class for streams and all streams must derive from this class. _readbuf(buffer, size=1, ofs=0) Reads bytes from the stream to buffer . If the stream contains no readable bytes it blocks until some bytes arrives or the underlying connection is lost (e.g. the server closes the socket). It directly access the driver linked to the stream issuing a native read command. In most cases _readbuf() is called internally by other stream methods and should not be called directly. buffer is a byte sequence used to store the bytes just read. size is the number of bytes to be read and ofs is the position of buffer to start writing incoming bytes. Bytes are stored in buffer up to buffer size or less. Returns the number of bytes read or 0 when the underlying connection is lost. write(buffer) Writes the content of buffer to the stream. buffer must be a byte sequence (bytes, bytearray or string). Returns the number of bytes actually written to the stream (can be less than the elements in buffer ) read(size=1) Reads at most size bytes from the stream and returns a bytearray with the actual bytes read. read blocks if no bytes are available in the stream. If read returns an empty bytearray the underlying stream can be considered disconnected. readline(sep=\"\\\\n\", buffer=None, size=0, ofs=0) Reads bytes from the stream until sep is encountered (an end-of-line byte (\u201c\\n\u201d) is default). Returns the line as a bytearray with sep included. If buffer is given (as a bytearray), buffer is used to store the line up to size bytes, starting at offset ofs . If readline returns an empty bytearray the underlying stream can be considered disconnected.","title":"The stream class"},{"location":"reference/core/stdlib/docs/streams/#the-serial-class","text":"serial(drivername=SERIAL0, baud=115200, stopbits=STOPBIT_1, parity=PARITY_NONE, bitsize=BITSIZE_8, set_default=True, rxsize=0, txsize=0) This class implements a stream that can be used to connect to a serial port. It inhertis all of its methods from stream() . Initialize the serial port driver identified by drivername and starts it up with a baud rate of baud . Also, if set_default is True, sets itself as the default stream used by __builtins__.print() . This means that the serial stream will be the system default one. Additional parameters can be passed such as: * parity : PARITY_NONE or PARITY_ONE * stopbits : STOPBIT_1 , STOPBIT_1_HALF , STOPBIT_2 * bitsize : BITSIZE_8 * rxsize and txsize : the size in bytes of the receive and transmit buffers (0 selects the board default) Not all of the additional parameters are always supported by the underlying device. This is the code needed to print something on the default serial port: # import the streams module import streams # create a serial stream linked to SERIAL0 port streams . serial () # SERIAL0 is automatically selected as the default system stream, # therefore print will output everything to it print ( \"Hello World!\" ) available() Returns the number of characters that can be read without blocking. close() Close the stream linked to the underlying serial port.","title":"The serial class"},{"location":"reference/core/stdlib/docs/streams/#the-socketstream-class","text":"SocketStream(sock) This class implements a stream that has a socket as a source of data. It inhertis all of its methods from stream() . write(buffer) Writes the content of buffer to the stream. buffer must be a byte sequence (bytes, bytearray or string). Returns the number of bytes actually written to the stream (can be less than the elements in buffer ) close() Close the underlying socket.","title":"The SocketStream class"},{"location":"reference/core/stdlib/docs/streams/#the-filestream-class","text":"FileStream(name, mode=\"rb\") This class implements a stream that has a file as a source of data. It inherits all of its methods from stream() . It is just a stub at the moment. It is used by ResourceStream() only. seek(offset, whence=SEEK_SET) Move the current position to offset bytes with respect to whence . whence can be: SEEK_SET: start of file SEEK_CUR: current position SEEK_END: end of file","title":"The FileStream class"},{"location":"reference/core/stdlib/docs/streams/#the-resourcestream-class","text":"ResourceStream(name) This class implements a stream that has a flash saved resource as a source of data. It inherits all of its methods from FileStream() .","title":"The ResourceStream class"},{"location":"reference/core/stdlib/docs/struct/","text":"Struct \u00b6 This module performs conversions between Python values and C structs represented as Python bytes() objects. This can be used in handling binary data stored in files or from network connections, among other sources. It uses Format Strings as compact descriptions of the layout of the C structs and the intended conversion to/from Python values. Note By default, the result of packing a given C struct includes pad bytes in order to maintain proper alignment for the C types involved; similarly, alignment is taken into account when unpacking. This behavior is chosen so that the bytes of a packed struct correspond exactly to the layout in memory of the corresponding C struct. To handle platform-independent data formats or omit implicit pad bytes, use standard size and alignment instead of native size and alignment: see Byte Order, Size, and Alignment for details. Several struct functions take a buffer argument. This refers to objects of class bytearray. Functions and Exceptions \u00b6 The module defines the following exception and functions: pack(fmt, v1, v2, ...) Return a bytes object containing the values v1 , v2 , \u2026 packed according to the format string fmt . The arguments must match the values required by the format exactly. pack_into(fmt, buffer, offset, v1, v2, ...) Pack the values v1 , v2 , \u2026 according to the format string fmt and write the packed bytes into the writable buffer buffer starting at position offset . Note that offset is a required argument. unpack(fmt, buffer) Unpack from the buffer buffer (presumably packed by pack(fmt, ...) ) according to the format string fmt . The result is a tuple even if it contains exactly one item. The buffer\u2019s size in bytes must match the size required by the format, as reflected by calcsize() . unpack_from(fmt, buffer, offset=0) Unpack from buffer starting at position offset , according to the format string fmt . The result is a tuple even if it contains exactly one item. The buffer\u2019s size in bytes, minus offset , must be at least the size required by the format, as reflected by calcsize() . calcsize(fmt) Return the size of the struct (and hence of the bytes object produced by pack(fmt, ...) ) corresponding to the format string fmt . Format Strings \u00b6 Format strings are the mechanism used to specify the expected layout when packing and unpacking data. They are built up from Format Characters, which specify the type of data being packed/unpacked. In addition, there are special characters for controlling the Byte Order, Size, and Alignment. Byte Order, Size, and Alignment \u00b6 By default, C types are represented in the machine\u2019s native format and byte order, and properly aligned by skipping pad bytes if necessary (according to the rules used by the C compiler). Alternatively, the first character of the format string can be used to indicate the byte order, size and alignment of the packed data, according to the following table: Character Byte order Size Alignment @ native native native = native standard none < little-endian standard none > big-endian standard none ! network (= big-endian) standard none If the first character is not one of these, '@' is assumed. Native byte order is big-endian or little-endian, depending on the host system. Native size and alignment are determined using the C compiler\u2019s sizeof expression. This is always combined with native byte order. Standard size depends only on the format character; see the table in the Format Characters section. Note the difference between '@' and '=' : both use native byte order, but the size and alignment of the latter is standardized. There is no way to indicate non-native byte order (force byte-swapping); use the appropriate choice of '<' or '>' . Notes: Padding is only automatically added between successive structure members. No padding is added at the beginning or the end of the encoded struct. No padding is added when using non-native size and alignment, e.g. with \u2018<\u2019, \u2018>\u2019, \u2018=\u2019, and \u2018!\u2019. To align the end of a structure to the alignment requirement of a particular type, end the format with the code for that type with a repeat count of zero. See Examples. Format Characters \u00b6 Format characters have the following meaning; the conversion between C and Python values should be obvious given their types. The \u2018Standard size\u2019 column refers to the size of the packed value in bytes when using standard size; that is, when the format string starts with one of '<' , '>' , '!' or '=' . When using native size, the size of the packed value is platform-dependent. Format C Type Python type Standard size Notes x pad byte no value c char bytes of length 1 1 b signed char integer 1 (1),(3) B unsigned char integer 1 (3) ? _Bool bool 1 (1) h short integer 2 (3) H unsigned short integer 2 (3) i int integer 4 (3) I unsigned int integer 4 (3) l long integer 4 (3) L unsigned long integer 4 (3) q long long integer 8 (2), (3) Q unsigned long long integer 8 (2), (3) n ssize_t integer (4) N size_t integer (4) e (7) float 2 (5) f float float 4 (5) d double float 8 (5) s char[] bytes p char[] bytes P void * integer (6) Notes: The '?' conversion code corresponds to the _Bool type defined by C99. If this type is not available, it is simulated using a char . In standard mode, it is always represented by one byte. The 'q' and 'Q' conversion codes are not supported! When attempting to pack a non-integer using any of the integer conversion codes, if the non-integer has a __index__() method then that method is called to convert the argument to an integer before packing. Versionchanged: Changed in version 3.2: Use of the __index__() method for non-integers is new in 3.2. The 'n' and 'N' conversion codes are only available for the native size (selected as the default or with the '@' byte order character). For the standard size, you can use whichever of the other integer formats fits your application. For the 'f' , 'd' and 'e' conversion codes, the packed representation uses the IEEE 754 binary32, binary64 or binary16 format (for 'f' , 'd' or 'e' respectively), regardless of the floating-point format used by the platform. The 'e' format is not supported! The 'P' format character is only available for the native byte ordering (selected as the default or with the '@' byte order character). The byte order character '=' chooses to use little- or big-endian ordering based on the host system. The struct module does not interpret this as native ordering, so the 'P' format is not available. The IEEE 754 binary16 \u201chalf precision\u201d type was introduced in the 2008 revision of the IEEE 754 standard . It has a sign bit, a 5-bit exponent and 11-bit precision (with 10 bits explicitly stored), and can represent numbers between approximately 6.1e-05 and 6.5e+04 at full precision. This type is not widely supported by C compilers: on a typical machine, an unsigned short can be used for storage, but not for math operations. See the Wikipedia page on the half-precision floating-point format for more information. A format character may be preceded by an integral repeat count. For example, the format string '4h' means exactly the same as 'hhhh' . Whitespace characters between formats are ignored; a count and its format must not contain whitespace though. For the 's' format character, the count is interpreted as the length of the bytes, not a repeat count like for the other format characters; for example, '10s' means a single 10-byte string, while '10c' means 10 characters. If a count is not given, it defaults to 1. For packing, the string is truncated or padded with null bytes as appropriate to make it fit. For unpacking, the resulting bytes object always has exactly the specified number of bytes. As a special case, '0s' means a single, empty string (while '0c' means 0 characters). When packing a value x using one of the integer formats ( 'b' , 'B' , 'h' , 'H' , 'i' , 'I' , 'l' , 'L' , 'q' , 'Q' ), if x is outside the valid range for that format then struct.error is raised. The 'p' format character encodes a \u201cPascal string\u201d, meaning a short variable-length string stored in a fixed number of bytes , given by the count. The first byte stored is the length of the string, or 255, whichever is smaller. The bytes of the string follow. If the string passed in to pack() is too long (longer than the count minus 1), only the leading count-1 bytes of the string are stored. If the string is shorter than count-1 , it is padded with null bytes so that exactly count bytes in all are used. Note that for unpack() , the 'p' format character consumes count bytes, but that the string returned can never contain more than 255 bytes. For the '?' format character, the return value is either True or False . When packing, the truth value of the argument object is used. Either 0 or 1 in the native or standard bool representation will be packed, and any non-zero value will be True when unpacking. Examples \u00b6 None All examples assume a native byte order, size, and alignment with a big-endian machine. A basic example of packing/unpacking three integers: >>> from struct import * >>> pack ( 'hhl' , 1 , 2 , 3 ) b '' >>> unpack ( 'hhl' , b '' ) ( 1 , 2 , 3 ) >>> calcsize ( 'hhl' ) 8 Unpacked fields can be named by assigning them to variables or by wrapping the result in a named tuple: >>> record = b 'raymond 2\u0012\b\b' >>> name , serialnum , school , gradelevel = unpack ( '<10sHHb' , record ) >>> from collections import namedtuple >>> Student = namedtuple ( 'Student' , 'name serialnum school gradelevel' ) >>> Student . _make ( unpack ( '<10sHHb' , record )) Student ( name = b 'raymond ' , serialnum = 4658 , school = 264 , gradelevel = 8 ) The ordering of format characters may have an impact on size since the padding needed to satisfy alignment requirements is different: >>> pack ( 'ci' , b '*' , 0x12131415 ) b '*\u0012\u0013\u0014\u0015' >>> pack ( 'ic' , 0x12131415 , b '*' ) b '\u0012\u0013\u0014\u0015*' >>> calcsize ( 'ci' ) 8 >>> calcsize ( 'ic' ) 5 The following format 'llh0l' specifies two pad bytes at the end, assuming longs are aligned on 4-byte boundaries: >>> pack ( 'llh0l' , 1 , 2 , 3 ) b '' This only works when native size and alignment are in effect; standard size and alignment does not enforce any alignment.","title":"Struct"},{"location":"reference/core/stdlib/docs/struct/#struct","text":"This module performs conversions between Python values and C structs represented as Python bytes() objects. This can be used in handling binary data stored in files or from network connections, among other sources. It uses Format Strings as compact descriptions of the layout of the C structs and the intended conversion to/from Python values. Note By default, the result of packing a given C struct includes pad bytes in order to maintain proper alignment for the C types involved; similarly, alignment is taken into account when unpacking. This behavior is chosen so that the bytes of a packed struct correspond exactly to the layout in memory of the corresponding C struct. To handle platform-independent data formats or omit implicit pad bytes, use standard size and alignment instead of native size and alignment: see Byte Order, Size, and Alignment for details. Several struct functions take a buffer argument. This refers to objects of class bytearray.","title":"Struct"},{"location":"reference/core/stdlib/docs/struct/#functions-and-exceptions","text":"The module defines the following exception and functions: pack(fmt, v1, v2, ...) Return a bytes object containing the values v1 , v2 , \u2026 packed according to the format string fmt . The arguments must match the values required by the format exactly. pack_into(fmt, buffer, offset, v1, v2, ...) Pack the values v1 , v2 , \u2026 according to the format string fmt and write the packed bytes into the writable buffer buffer starting at position offset . Note that offset is a required argument. unpack(fmt, buffer) Unpack from the buffer buffer (presumably packed by pack(fmt, ...) ) according to the format string fmt . The result is a tuple even if it contains exactly one item. The buffer\u2019s size in bytes must match the size required by the format, as reflected by calcsize() . unpack_from(fmt, buffer, offset=0) Unpack from buffer starting at position offset , according to the format string fmt . The result is a tuple even if it contains exactly one item. The buffer\u2019s size in bytes, minus offset , must be at least the size required by the format, as reflected by calcsize() . calcsize(fmt) Return the size of the struct (and hence of the bytes object produced by pack(fmt, ...) ) corresponding to the format string fmt .","title":"Functions and Exceptions"},{"location":"reference/core/stdlib/docs/struct/#format-strings","text":"Format strings are the mechanism used to specify the expected layout when packing and unpacking data. They are built up from Format Characters, which specify the type of data being packed/unpacked. In addition, there are special characters for controlling the Byte Order, Size, and Alignment.","title":"Format Strings"},{"location":"reference/core/stdlib/docs/struct/#byte-order-size-and-alignment","text":"By default, C types are represented in the machine\u2019s native format and byte order, and properly aligned by skipping pad bytes if necessary (according to the rules used by the C compiler). Alternatively, the first character of the format string can be used to indicate the byte order, size and alignment of the packed data, according to the following table: Character Byte order Size Alignment @ native native native = native standard none < little-endian standard none > big-endian standard none ! network (= big-endian) standard none If the first character is not one of these, '@' is assumed. Native byte order is big-endian or little-endian, depending on the host system. Native size and alignment are determined using the C compiler\u2019s sizeof expression. This is always combined with native byte order. Standard size depends only on the format character; see the table in the Format Characters section. Note the difference between '@' and '=' : both use native byte order, but the size and alignment of the latter is standardized. There is no way to indicate non-native byte order (force byte-swapping); use the appropriate choice of '<' or '>' . Notes: Padding is only automatically added between successive structure members. No padding is added at the beginning or the end of the encoded struct. No padding is added when using non-native size and alignment, e.g. with \u2018<\u2019, \u2018>\u2019, \u2018=\u2019, and \u2018!\u2019. To align the end of a structure to the alignment requirement of a particular type, end the format with the code for that type with a repeat count of zero. See Examples.","title":"Byte Order, Size, and Alignment"},{"location":"reference/core/stdlib/docs/struct/#format-characters","text":"Format characters have the following meaning; the conversion between C and Python values should be obvious given their types. The \u2018Standard size\u2019 column refers to the size of the packed value in bytes when using standard size; that is, when the format string starts with one of '<' , '>' , '!' or '=' . When using native size, the size of the packed value is platform-dependent. Format C Type Python type Standard size Notes x pad byte no value c char bytes of length 1 1 b signed char integer 1 (1),(3) B unsigned char integer 1 (3) ? _Bool bool 1 (1) h short integer 2 (3) H unsigned short integer 2 (3) i int integer 4 (3) I unsigned int integer 4 (3) l long integer 4 (3) L unsigned long integer 4 (3) q long long integer 8 (2), (3) Q unsigned long long integer 8 (2), (3) n ssize_t integer (4) N size_t integer (4) e (7) float 2 (5) f float float 4 (5) d double float 8 (5) s char[] bytes p char[] bytes P void * integer (6) Notes: The '?' conversion code corresponds to the _Bool type defined by C99. If this type is not available, it is simulated using a char . In standard mode, it is always represented by one byte. The 'q' and 'Q' conversion codes are not supported! When attempting to pack a non-integer using any of the integer conversion codes, if the non-integer has a __index__() method then that method is called to convert the argument to an integer before packing. Versionchanged: Changed in version 3.2: Use of the __index__() method for non-integers is new in 3.2. The 'n' and 'N' conversion codes are only available for the native size (selected as the default or with the '@' byte order character). For the standard size, you can use whichever of the other integer formats fits your application. For the 'f' , 'd' and 'e' conversion codes, the packed representation uses the IEEE 754 binary32, binary64 or binary16 format (for 'f' , 'd' or 'e' respectively), regardless of the floating-point format used by the platform. The 'e' format is not supported! The 'P' format character is only available for the native byte ordering (selected as the default or with the '@' byte order character). The byte order character '=' chooses to use little- or big-endian ordering based on the host system. The struct module does not interpret this as native ordering, so the 'P' format is not available. The IEEE 754 binary16 \u201chalf precision\u201d type was introduced in the 2008 revision of the IEEE 754 standard . It has a sign bit, a 5-bit exponent and 11-bit precision (with 10 bits explicitly stored), and can represent numbers between approximately 6.1e-05 and 6.5e+04 at full precision. This type is not widely supported by C compilers: on a typical machine, an unsigned short can be used for storage, but not for math operations. See the Wikipedia page on the half-precision floating-point format for more information. A format character may be preceded by an integral repeat count. For example, the format string '4h' means exactly the same as 'hhhh' . Whitespace characters between formats are ignored; a count and its format must not contain whitespace though. For the 's' format character, the count is interpreted as the length of the bytes, not a repeat count like for the other format characters; for example, '10s' means a single 10-byte string, while '10c' means 10 characters. If a count is not given, it defaults to 1. For packing, the string is truncated or padded with null bytes as appropriate to make it fit. For unpacking, the resulting bytes object always has exactly the specified number of bytes. As a special case, '0s' means a single, empty string (while '0c' means 0 characters). When packing a value x using one of the integer formats ( 'b' , 'B' , 'h' , 'H' , 'i' , 'I' , 'l' , 'L' , 'q' , 'Q' ), if x is outside the valid range for that format then struct.error is raised. The 'p' format character encodes a \u201cPascal string\u201d, meaning a short variable-length string stored in a fixed number of bytes , given by the count. The first byte stored is the length of the string, or 255, whichever is smaller. The bytes of the string follow. If the string passed in to pack() is too long (longer than the count minus 1), only the leading count-1 bytes of the string are stored. If the string is shorter than count-1 , it is padded with null bytes so that exactly count bytes in all are used. Note that for unpack() , the 'p' format character consumes count bytes, but that the string returned can never contain more than 255 bytes. For the '?' format character, the return value is either True or False . When packing, the truth value of the argument object is used. Either 0 or 1 in the native or standard bool representation will be packed, and any non-zero value will be True when unpacking.","title":"Format Characters"},{"location":"reference/core/stdlib/docs/struct/#examples","text":"None All examples assume a native byte order, size, and alignment with a big-endian machine. A basic example of packing/unpacking three integers: >>> from struct import * >>> pack ( 'hhl' , 1 , 2 , 3 ) b '' >>> unpack ( 'hhl' , b '' ) ( 1 , 2 , 3 ) >>> calcsize ( 'hhl' ) 8 Unpacked fields can be named by assigning them to variables or by wrapping the result in a named tuple: >>> record = b 'raymond 2\u0012\b\b' >>> name , serialnum , school , gradelevel = unpack ( '<10sHHb' , record ) >>> from collections import namedtuple >>> Student = namedtuple ( 'Student' , 'name serialnum school gradelevel' ) >>> Student . _make ( unpack ( '<10sHHb' , record )) Student ( name = b 'raymond ' , serialnum = 4658 , school = 264 , gradelevel = 8 ) The ordering of format characters may have an impact on size since the padding needed to satisfy alignment requirements is different: >>> pack ( 'ci' , b '*' , 0x12131415 ) b '*\u0012\u0013\u0014\u0015' >>> pack ( 'ic' , 0x12131415 , b '*' ) b '\u0012\u0013\u0014\u0015*' >>> calcsize ( 'ci' ) 8 >>> calcsize ( 'ic' ) 5 The following format 'llh0l' specifies two pad bytes at the end, assuming longs are aligned on 4-byte boundaries: >>> pack ( 'llh0l' , 1 , 2 , 3 ) b '' This only works when native size and alignment are in effect; standard size and alignment does not enforce any alignment.","title":"Examples"},{"location":"reference/core/stdlib/docs/threading/","text":"Threading \u00b6 This module define classes used in high-level threaded programming. Zerynth VM offers native low-level primitives for multithreaded programming that can be difficult to use. This module abstracts such primitives to make them easy to use: Thread() Lock() Semaphore() Event() Condition() Thread Objects \u00b6 The Thread() class represents an activity that is run in a separate thread of control. There are two ways to specify the activity: by passing a callable object to the constructor, or by overriding the run() method in a subclass. No other methods (except for the constructor) should be overridden in a subclass. In other words, only override the __init__() and run() methods of this class. Once a thread object is created, its activity must be started by calling the thread\u2019s start() method. This invokes the run() method in a separate thread of control. Once the thread\u2019s activity is started, the thread is considered \u2018alive\u2019. It stops being alive when its run() method terminates \u2013 either normally, or by raising an unhandled exception. The is_alive() method tests whether the thread is alive. The attribute exc is the exception generated by the run() method or None . Other threads can call a thread\u2019s join() method. This blocks the calling thread until the thread whose join() method is called is terminated. A thread has a name. The name can be passed to the constructor, and read or changed through the name attribute. A thread has also an id. The id is determined after start() is called and can be accessed through ident . Thread class \u00b6 Thread(target=None, name=None, args=()) This constructor should always be called with keyword arguments. Arguments are: target is the callable object to be invoked by the run() method. Defaults to None , meaning nothing is called. name is the thread name. By default, a unique name is constructed of the form \u201cThread- N \u201d where N is the thread id. args is the argument tuple for the target invocation. Defaults to () . If the subclass overrides the constructor, it must make sure to invoke the base class constructor ( Thread.__init__() ) before doing anything else to the thread. start(prio = PRIO_NORMAL, size=512) Start the thread\u2019s activity. It must be called at most once per thread object. It arranges for the object\u2019s run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. prio and size are used to set the thread priority and the stack size. run() Method representing the thread\u2019s activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object\u2019s constructor as the target argument, if any, with sequential arguments taken from the args argument. join(timeout=-1) Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates \u2013 either normally or through an unhandled exception \u2013, or until the optional timeout occurs. When the timeout argument is present and not less than zero, it should be a integer number specifying a timeout for the operation in milliseconds. As join() always returns None , you must call is_alive() after join() to decide whether a timeout happened \u2013 if the thread is still alive, the join() call timed out. When the timeout argument is not present or less than zero, the operation will block until the thread terminates. A thread can be join() ed many times. is_alive() Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. name() A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor. ident() The \u2018thread identifier\u2019 of this thread or None if the thread has not been started. This is a non negative integer. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited. Lock class \u00b6 Lock() A Lock object can be in two states: locked or unlocked . When a Lock object is created it starts unlocked . A thread can try to lock a Lock object: if the Lock object is already locked the thread will block until the Lock object is unlocked by some other thread. if the Lock object is unlocked , it becomes locked and the thread continues execution. A thread can also try to unlock a Lock object that it had previously locked : if no other threads are waiting for the Lock object to become unlocked , the Lock object becomes unlocked if one or more threads are waiting for the Lock object to become unlocked , one of them is selected and can continue from where it left. All the other waiting threads remain blocked. The Lock object remains locked . Lock object are tipically used to gain exclusive access to a resource: import streams import threading # open a serial port: our resource streams . serial ( \"ser1\" ) # create a lock lock = threading . Lock () # define a function to be launched as a thread def threadfun ( msg ): while True : # if it's unlocked, lock it and continue printing. Else wait. lock . acquire () print ( msg ) # unlock and allow another thread to call the print lock . release () # launch thread 1 thread ( threadfun , \"Hello\" ) # launch thread 2 thread ( threadfun , \"World\" ) Both threads in the example will compete to call print(msg) . The Lock object ensure that while one thread is printing on the serial port, the other one is blocked, waiting for the message to be printed. acquire(blocking=True, timeout=-1) Acquire a lock, blocking or non-blocking. When invoked with the blocking argument set to True (the default), block until the lock is unlocked, then set it to locked and return True . When invoked with the blocking argument set to False , do not block. If a call with blocking set to True would block, return False immediately; otherwise, set the lock to locked and return True . When invoked with the integer timeout argument set to a positive value, block for at most the number of milliseconds specified by timeout and as long as the lock cannot be acquired. A timeout argument of -1 specifies an unbounded wait. It is forbidden to specify a timeout when blocking is false. The return value is True if the lock is acquired successfully, False if not (for example if the timeout expired). release() Release a lock. This can be called from any thread, not only the thread which has acquired the lock. When the lock is locked, reset it to unlocked, and return. If any other threads are blocked waiting for the lock to become unlocked, allow exactly one of them to proceed. Semaphore class \u00b6 Semaphore(value=1) This class implements semaphore objects. A semaphore manages a counter representing the number of release() calls minus the number of acquire() calls, plus an initial value. The acquire() method blocks if necessary until it can return without making the counter negative. If not given, value defaults to 1. The optional argument gives the initial value for the internal counter; it defaults to 1 . If the value given is less than 0, ValueError is raised. acquire(blocking=True, timeout=-1) Acquire a semaphore. When invoked without arguments: if the internal counter is larger than zero on entry, decrement it by one and return immediately. If it is zero on entry, block, waiting until some other thread has called release() to make it larger than zero. This is done with proper interlocking so that if multiple acquire() calls are blocked, release() will wake exactly one of them up. The implementation may pick one at random, so the order in which blocked threads are awakened should not be relied on. Returns true (or blocks indefinitely). When invoked with blocking set to false, do not block. If a call without an argument would block, return false immediately; otherwise, do the same thing as when called without arguments, and return true. When invoked with a timeout other than -1, it will block for at most timeout milliseconds. If acquire does not complete successfully in that interval, return false. Return true otherwise. release() Release a semaphore, incrementing the internal counter by one. When it was zero on entry and another thread is waiting for it to become larger than zero again, wake up that thread. Event class \u00b6 Event() Class implementing event objects. An event manages a flag that can be set to true with the set() method and reset to false with the clear() method. The wait() method blocks until the flag is true. The flag is initially false. set() Set the internal flag to true. All threads waiting for it to become true are awakened. Threads that call wait() once the flag is true will not block at all. is_set() Return true if and only if the internal flag is true. clear() Reset the internal flag to false. Subsequently, threads calling wait() will block until set() is called to set the internal flag to true again. wait(timeout=-1) Block until the internal flag is true. If the internal flag is true on entry, return immediately. Otherwise, block until another thread calls set() to set the flag to true, or until the optional timeout occurs. When the timeout argument is present and >0 , it should be an integer number specifying a timeout for the operation in milliseconds. This method returns true if and only if the internal flag has been set to true, either before the wait call or after the wait starts, so it will always return True except if a timeout is given and the operation times out. Condition Objects \u00b6 A condition variable is always associated with some kind of lock; this can be passed in or one will be created by default. Passing one in is useful when several condition variables must share the same lock. The lock is part of the condition object: you don\u2019t have to track it separately. A condition variable must be locked with acquire() before any other method can be called, and unlocked with release() when done calling methods. The wait() method releases the lock, and then blocks until another thread awakens it by calling notify() or notify_all() . Once awakened, wait() re-acquires the lock and returns. It is also possible to specify a timeout. The notify() method wakes up one of the threads waiting for the condition variable, if any are waiting. The notify_all() method wakes up all threads waiting for the condition variable. Note: the notify() and notify_all() methods don\u2019t release the lock; this means that the thread or threads awakened will not return from their wait() call immediately, but only when the thread that called notify() or notify_all() finally relinquishes ownership of the lock. The typical programming style using condition variables uses the lock to synchronize access to some shared state; threads that are interested in a particular change of state call wait() repeatedly until they see the desired state, while threads that modify the state call notify() or notify_all() when they change the state in such a way that it could possibly be a desired state for one of the waiters. For example, the following code is a generic producer-consumer situation with unlimited buffer capacity: # Consume one item cv . acquire () while not an_item_is_available (): cv . wait () get_an_available_item () cv . release () # Produce one item cv . acquire () make_an_item_available () cv . notify () cv . release () The while loop checking for the application\u2019s condition is necessary because wait() can return after an arbitrary long time, and the condition which prompted the notify() call may no longer hold true. This is inherent to multi-threaded programming. The wait_for() method can be used to automate the condition checking, and eases the computation of timeouts: # Consume an item cv . acquire () cv . wait_for ( an_item_is_available ) get_an_available_item () cv . release () To choose between notify() and notify_all() , consider whether one state change can be interesting for only one or several waiting threads. E.g. in a typical producer-consumer situation, adding one item to the buffer only needs to wake up one consumer thread. The order of awakened threads may correspond to the order of wait in a fifo style, but this is not guaranteed for every VM. Condition class \u00b6 Condition(lock=None) This class implements condition variable objects. A condition variable allows one or more threads to wait until they are notified by another thread. If the lock argument is given and not None , it must be a Lock() object, and it is used as the underlying lock. Otherwise, a new Lock() object is created and used as the underlying lock. acquire(blocking=True, timeout=-1) Acquire the underlying lock. This method calls the corresponding method on the underlying lock; the return value is whatever that method returns. release() Release the underlying lock. This method calls the corresponding method on the underlying lock; there is no return value. wait(timeout=-1) Wait until notified or until a timeout occurs. If the calling thread has not acquired the lock when this method is called, a RuntimeError is raised. This method releases the underlying lock, and then blocks until it is awakened by a notify() or notify_all() call for the same condition variable in another thread, or until the optional timeout occurs. Once awakened or timed out, it re-acquires the lock and returns. When the timeout argument is present and not less than zero, it should be a integer number specifying a timeout for the operation in milliseconds. The return value is True unless a given timeout expired, in which case it is False . wait_for(predicate, timeout=-1) Wait until a condition evaluates to True. predicate should be a callable which result will be interpreted as a boolean value. A timeout may be provided giving the maximum time to wait. This utility method may call wait() repeatedly until the predicate is satisfied, or until a timeout occurs. The return value is the last return value of the predicate and will evaluate to False if the method timed out. Ignoring the timeout feature, calling this method is roughly equivalent to writing: while not predicate (): cv . wait () Therefore, the same rules apply as with wait() : The lock must be held when called and is re-acquired on return. The predicate is evaluated with the lock held. notify(n=1) By default, wake up one thread waiting on this condition, if any. If the calling thread has not acquired the lock when this method is called, a RuntimeError is raised. This method wakes up at most n of the threads waiting for the condition variable; it is a no-op if no threads are waiting. The current implementation wakes up exactly n threads, if at least n threads are waiting. Note an awakened thread does not actually return from its wait() call until it can reacquire the lock. Since notify() does not release the lock, its caller should. notify_all() Wake up all threads waiting on this condition. This method acts like notify() , but wakes up all waiting threads instead of one. If the calling thread has not acquired the lock when this method is called, a RuntimeError is raised.","title":"Threading"},{"location":"reference/core/stdlib/docs/threading/#threading","text":"This module define classes used in high-level threaded programming. Zerynth VM offers native low-level primitives for multithreaded programming that can be difficult to use. This module abstracts such primitives to make them easy to use: Thread() Lock() Semaphore() Event() Condition()","title":"Threading"},{"location":"reference/core/stdlib/docs/threading/#thread-objects","text":"The Thread() class represents an activity that is run in a separate thread of control. There are two ways to specify the activity: by passing a callable object to the constructor, or by overriding the run() method in a subclass. No other methods (except for the constructor) should be overridden in a subclass. In other words, only override the __init__() and run() methods of this class. Once a thread object is created, its activity must be started by calling the thread\u2019s start() method. This invokes the run() method in a separate thread of control. Once the thread\u2019s activity is started, the thread is considered \u2018alive\u2019. It stops being alive when its run() method terminates \u2013 either normally, or by raising an unhandled exception. The is_alive() method tests whether the thread is alive. The attribute exc is the exception generated by the run() method or None . Other threads can call a thread\u2019s join() method. This blocks the calling thread until the thread whose join() method is called is terminated. A thread has a name. The name can be passed to the constructor, and read or changed through the name attribute. A thread has also an id. The id is determined after start() is called and can be accessed through ident .","title":"Thread Objects"},{"location":"reference/core/stdlib/docs/threading/#thread-class","text":"Thread(target=None, name=None, args=()) This constructor should always be called with keyword arguments. Arguments are: target is the callable object to be invoked by the run() method. Defaults to None , meaning nothing is called. name is the thread name. By default, a unique name is constructed of the form \u201cThread- N \u201d where N is the thread id. args is the argument tuple for the target invocation. Defaults to () . If the subclass overrides the constructor, it must make sure to invoke the base class constructor ( Thread.__init__() ) before doing anything else to the thread. start(prio = PRIO_NORMAL, size=512) Start the thread\u2019s activity. It must be called at most once per thread object. It arranges for the object\u2019s run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. prio and size are used to set the thread priority and the stack size. run() Method representing the thread\u2019s activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object\u2019s constructor as the target argument, if any, with sequential arguments taken from the args argument. join(timeout=-1) Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates \u2013 either normally or through an unhandled exception \u2013, or until the optional timeout occurs. When the timeout argument is present and not less than zero, it should be a integer number specifying a timeout for the operation in milliseconds. As join() always returns None , you must call is_alive() after join() to decide whether a timeout happened \u2013 if the thread is still alive, the join() call timed out. When the timeout argument is not present or less than zero, the operation will block until the thread terminates. A thread can be join() ed many times. is_alive() Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. name() A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor. ident() The \u2018thread identifier\u2019 of this thread or None if the thread has not been started. This is a non negative integer. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited.","title":"Thread class"},{"location":"reference/core/stdlib/docs/threading/#lock-class","text":"Lock() A Lock object can be in two states: locked or unlocked . When a Lock object is created it starts unlocked . A thread can try to lock a Lock object: if the Lock object is already locked the thread will block until the Lock object is unlocked by some other thread. if the Lock object is unlocked , it becomes locked and the thread continues execution. A thread can also try to unlock a Lock object that it had previously locked : if no other threads are waiting for the Lock object to become unlocked , the Lock object becomes unlocked if one or more threads are waiting for the Lock object to become unlocked , one of them is selected and can continue from where it left. All the other waiting threads remain blocked. The Lock object remains locked . Lock object are tipically used to gain exclusive access to a resource: import streams import threading # open a serial port: our resource streams . serial ( \"ser1\" ) # create a lock lock = threading . Lock () # define a function to be launched as a thread def threadfun ( msg ): while True : # if it's unlocked, lock it and continue printing. Else wait. lock . acquire () print ( msg ) # unlock and allow another thread to call the print lock . release () # launch thread 1 thread ( threadfun , \"Hello\" ) # launch thread 2 thread ( threadfun , \"World\" ) Both threads in the example will compete to call print(msg) . The Lock object ensure that while one thread is printing on the serial port, the other one is blocked, waiting for the message to be printed. acquire(blocking=True, timeout=-1) Acquire a lock, blocking or non-blocking. When invoked with the blocking argument set to True (the default), block until the lock is unlocked, then set it to locked and return True . When invoked with the blocking argument set to False , do not block. If a call with blocking set to True would block, return False immediately; otherwise, set the lock to locked and return True . When invoked with the integer timeout argument set to a positive value, block for at most the number of milliseconds specified by timeout and as long as the lock cannot be acquired. A timeout argument of -1 specifies an unbounded wait. It is forbidden to specify a timeout when blocking is false. The return value is True if the lock is acquired successfully, False if not (for example if the timeout expired). release() Release a lock. This can be called from any thread, not only the thread which has acquired the lock. When the lock is locked, reset it to unlocked, and return. If any other threads are blocked waiting for the lock to become unlocked, allow exactly one of them to proceed.","title":"Lock class"},{"location":"reference/core/stdlib/docs/threading/#semaphore-class","text":"Semaphore(value=1) This class implements semaphore objects. A semaphore manages a counter representing the number of release() calls minus the number of acquire() calls, plus an initial value. The acquire() method blocks if necessary until it can return without making the counter negative. If not given, value defaults to 1. The optional argument gives the initial value for the internal counter; it defaults to 1 . If the value given is less than 0, ValueError is raised. acquire(blocking=True, timeout=-1) Acquire a semaphore. When invoked without arguments: if the internal counter is larger than zero on entry, decrement it by one and return immediately. If it is zero on entry, block, waiting until some other thread has called release() to make it larger than zero. This is done with proper interlocking so that if multiple acquire() calls are blocked, release() will wake exactly one of them up. The implementation may pick one at random, so the order in which blocked threads are awakened should not be relied on. Returns true (or blocks indefinitely). When invoked with blocking set to false, do not block. If a call without an argument would block, return false immediately; otherwise, do the same thing as when called without arguments, and return true. When invoked with a timeout other than -1, it will block for at most timeout milliseconds. If acquire does not complete successfully in that interval, return false. Return true otherwise. release() Release a semaphore, incrementing the internal counter by one. When it was zero on entry and another thread is waiting for it to become larger than zero again, wake up that thread.","title":"Semaphore class"},{"location":"reference/core/stdlib/docs/threading/#event-class","text":"Event() Class implementing event objects. An event manages a flag that can be set to true with the set() method and reset to false with the clear() method. The wait() method blocks until the flag is true. The flag is initially false. set() Set the internal flag to true. All threads waiting for it to become true are awakened. Threads that call wait() once the flag is true will not block at all. is_set() Return true if and only if the internal flag is true. clear() Reset the internal flag to false. Subsequently, threads calling wait() will block until set() is called to set the internal flag to true again. wait(timeout=-1) Block until the internal flag is true. If the internal flag is true on entry, return immediately. Otherwise, block until another thread calls set() to set the flag to true, or until the optional timeout occurs. When the timeout argument is present and >0 , it should be an integer number specifying a timeout for the operation in milliseconds. This method returns true if and only if the internal flag has been set to true, either before the wait call or after the wait starts, so it will always return True except if a timeout is given and the operation times out.","title":"Event class"},{"location":"reference/core/stdlib/docs/threading/#condition-objects","text":"A condition variable is always associated with some kind of lock; this can be passed in or one will be created by default. Passing one in is useful when several condition variables must share the same lock. The lock is part of the condition object: you don\u2019t have to track it separately. A condition variable must be locked with acquire() before any other method can be called, and unlocked with release() when done calling methods. The wait() method releases the lock, and then blocks until another thread awakens it by calling notify() or notify_all() . Once awakened, wait() re-acquires the lock and returns. It is also possible to specify a timeout. The notify() method wakes up one of the threads waiting for the condition variable, if any are waiting. The notify_all() method wakes up all threads waiting for the condition variable. Note: the notify() and notify_all() methods don\u2019t release the lock; this means that the thread or threads awakened will not return from their wait() call immediately, but only when the thread that called notify() or notify_all() finally relinquishes ownership of the lock. The typical programming style using condition variables uses the lock to synchronize access to some shared state; threads that are interested in a particular change of state call wait() repeatedly until they see the desired state, while threads that modify the state call notify() or notify_all() when they change the state in such a way that it could possibly be a desired state for one of the waiters. For example, the following code is a generic producer-consumer situation with unlimited buffer capacity: # Consume one item cv . acquire () while not an_item_is_available (): cv . wait () get_an_available_item () cv . release () # Produce one item cv . acquire () make_an_item_available () cv . notify () cv . release () The while loop checking for the application\u2019s condition is necessary because wait() can return after an arbitrary long time, and the condition which prompted the notify() call may no longer hold true. This is inherent to multi-threaded programming. The wait_for() method can be used to automate the condition checking, and eases the computation of timeouts: # Consume an item cv . acquire () cv . wait_for ( an_item_is_available ) get_an_available_item () cv . release () To choose between notify() and notify_all() , consider whether one state change can be interesting for only one or several waiting threads. E.g. in a typical producer-consumer situation, adding one item to the buffer only needs to wake up one consumer thread. The order of awakened threads may correspond to the order of wait in a fifo style, but this is not guaranteed for every VM.","title":"Condition Objects"},{"location":"reference/core/stdlib/docs/threading/#condition-class","text":"Condition(lock=None) This class implements condition variable objects. A condition variable allows one or more threads to wait until they are notified by another thread. If the lock argument is given and not None , it must be a Lock() object, and it is used as the underlying lock. Otherwise, a new Lock() object is created and used as the underlying lock. acquire(blocking=True, timeout=-1) Acquire the underlying lock. This method calls the corresponding method on the underlying lock; the return value is whatever that method returns. release() Release the underlying lock. This method calls the corresponding method on the underlying lock; there is no return value. wait(timeout=-1) Wait until notified or until a timeout occurs. If the calling thread has not acquired the lock when this method is called, a RuntimeError is raised. This method releases the underlying lock, and then blocks until it is awakened by a notify() or notify_all() call for the same condition variable in another thread, or until the optional timeout occurs. Once awakened or timed out, it re-acquires the lock and returns. When the timeout argument is present and not less than zero, it should be a integer number specifying a timeout for the operation in milliseconds. The return value is True unless a given timeout expired, in which case it is False . wait_for(predicate, timeout=-1) Wait until a condition evaluates to True. predicate should be a callable which result will be interpreted as a boolean value. A timeout may be provided giving the maximum time to wait. This utility method may call wait() repeatedly until the predicate is satisfied, or until a timeout occurs. The return value is the last return value of the predicate and will evaluate to False if the method timed out. Ignoring the timeout feature, calling this method is roughly equivalent to writing: while not predicate (): cv . wait () Therefore, the same rules apply as with wait() : The lock must be held when called and is re-acquired on return. The predicate is evaluated with the lock held. notify(n=1) By default, wake up one thread waiting on this condition, if any. If the calling thread has not acquired the lock when this method is called, a RuntimeError is raised. This method wakes up at most n of the threads waiting for the condition variable; it is a no-op if no threads are waiting. The current implementation wakes up exactly n threads, if at least n threads are waiting. Note an awakened thread does not actually return from its wait() call until it can reacquire the lock. Since notify() does not release the lock, its caller should. notify_all() Wake up all threads waiting on this condition. This method acts like notify() , but wakes up all waiting threads instead of one. If the calling thread has not acquired the lock when this method is called, a RuntimeError is raised.","title":"Condition class"},{"location":"reference/core/stdlib/docs/timers/","text":"Software Timers \u00b6 This module contain the timer() to handle time and timed events now() Return the number of milliseconds since the start of the program. timer() Creates a new timer. one_shot(delay, fun, arg=None) Activates the timer in one shot mode. Function fun(arg) is executed only once after delay milliseconds. interval(period, fun, arg=None) Activates the timer in interval mode. Function fun(arg) is executed every period milliseconds. clear() Disable the timer. destroy() Disable the timer and kills it. start() Start the timer. A started timer begins counting the number of passing milliseconds. Such number can be read by calling timer.get(). reset() Reset the timer. A reset timer restarts counting the number of passing milliseconds from zero. Returns the number of milliseconds passed since the start or the last reset. get() Return the number of milliseconds passed since the start or the last reset.","title":"Software Timers"},{"location":"reference/core/stdlib/docs/timers/#software-timers","text":"This module contain the timer() to handle time and timed events now() Return the number of milliseconds since the start of the program. timer() Creates a new timer. one_shot(delay, fun, arg=None) Activates the timer in one shot mode. Function fun(arg) is executed only once after delay milliseconds. interval(period, fun, arg=None) Activates the timer in interval mode. Function fun(arg) is executed every period milliseconds. clear() Disable the timer. destroy() Disable the timer and kills it. start() Start the timer. A started timer begins counting the number of passing milliseconds. Such number can be read by calling timer.get(). reset() Reset the timer. A reset timer restarts counting the number of passing milliseconds from zero. Returns the number of milliseconds passed since the start or the last reset. get() Return the number of milliseconds passed since the start or the last reset.","title":"Software Timers"},{"location":"reference/core/stdlib/docs/urlparse/","text":"Urlparse \u00b6 This module defines a standard interface to break Uniform Resource Locator (URL) strings up in components (addressing scheme, network location, path etc.) parse(url) Returns a tuple ( scheme , netloc , path , query , fragment ) derived from url . This corresponds to the general structure of a URL: scheme://netloc/path?query#fragment . Each tuple item is a string, possibly empty. The components are not broken up in smaller parts (for example, the network location is a single string), and % escapes are not expanded. The delimiters as shown above are not part of the result, except for a leading slash in the path component, which is retained if present. For example: import urlparse o = urlparse(\u2018 http://www.cwi.nl:80/%7Eguido/Python.html \u2019) # result is (\u2018http\u2019, \u2018www.cwi.nl:80\u2019, \u2018/%7Eguido/Python.html\u2019, \u2018\u2019, \u2018\u2019) Following the syntax specifications in RFC 1808 , urlparse recognizes a netloc only if it is properly introduced by \u2018//\u2019. Otherwise the input is presumed to be a relative URL and thus to start with a path component. parse_netloc(netloc) Given netloc as parsed by parse() , breaks it in its component returning a tuple ( user , password , host , port ). Each component of the returned tuple is a string. quote(s) Return the urlencoded version of s . Urlencoding transforms unsafe bytes to their %XX representation where XX is the hex value of the byte. Safe bytes are: lowercase letters from \u201ca\u201d to \u201cz\u201d (bytes from 0x61 to 0x7a) uppercase letters from \u201cA\u201d to \u201cZ\u201d (bytes from 0x41 to 0x5a) numbers from \u201c0\u201d to \u201c9\u201d (bytes from 0x30 to 0x39) the following symbols: $-_.+!*\u2019() quote_plus(s) Like quote() , but also escapes + symbol. unquote(s) If s is urlencoded, returns s with every + substituted with a space and every %xx substituted with the corresponding character. parse_qs(qs) Parses a query string qs and returns a dictionary containing the association between keys and values of qs . Values are urldecoded by unquote() . urlencode(data) Tranforms data dictionary in a urlencoded query string and returns the query string. Each pair (key, value) is encoded by quote_via function. By default, quote_plus() is used to quote the values. An alternate function that can be passed as quote_via is quote() .","title":"Urlparse"},{"location":"reference/core/stdlib/docs/urlparse/#urlparse","text":"This module defines a standard interface to break Uniform Resource Locator (URL) strings up in components (addressing scheme, network location, path etc.) parse(url) Returns a tuple ( scheme , netloc , path , query , fragment ) derived from url . This corresponds to the general structure of a URL: scheme://netloc/path?query#fragment . Each tuple item is a string, possibly empty. The components are not broken up in smaller parts (for example, the network location is a single string), and % escapes are not expanded. The delimiters as shown above are not part of the result, except for a leading slash in the path component, which is retained if present. For example: import urlparse o = urlparse(\u2018 http://www.cwi.nl:80/%7Eguido/Python.html \u2019) # result is (\u2018http\u2019, \u2018www.cwi.nl:80\u2019, \u2018/%7Eguido/Python.html\u2019, \u2018\u2019, \u2018\u2019) Following the syntax specifications in RFC 1808 , urlparse recognizes a netloc only if it is properly introduced by \u2018//\u2019. Otherwise the input is presumed to be a relative URL and thus to start with a path component. parse_netloc(netloc) Given netloc as parsed by parse() , breaks it in its component returning a tuple ( user , password , host , port ). Each component of the returned tuple is a string. quote(s) Return the urlencoded version of s . Urlencoding transforms unsafe bytes to their %XX representation where XX is the hex value of the byte. Safe bytes are: lowercase letters from \u201ca\u201d to \u201cz\u201d (bytes from 0x61 to 0x7a) uppercase letters from \u201cA\u201d to \u201cZ\u201d (bytes from 0x41 to 0x5a) numbers from \u201c0\u201d to \u201c9\u201d (bytes from 0x30 to 0x39) the following symbols: $-_.+!*\u2019() quote_plus(s) Like quote() , but also escapes + symbol. unquote(s) If s is urlencoded, returns s with every + substituted with a space and every %xx substituted with the corresponding character. parse_qs(qs) Parses a query string qs and returns a dictionary containing the association between keys and values of qs . Values are urldecoded by unquote() . urlencode(data) Tranforms data dictionary in a urlencoded query string and returns the query string. Each pair (key, value) is encoded by quote_via function. By default, quote_plus() is used to quote the values. An alternate function that can be passed as quote_via is quote() .","title":"Urlparse"},{"location":"reference/core/stdlib/docs/vm/","text":"VM \u00b6 This module enables inspecting the running VM and controlling some runtime options. info() Return info about the running Virtual Machine. The result is a tuple with 9 elements: Virtual Machine unique identifier (string) Target device (string) Virtual Machine version (string) The RAM address where C memory starts The Unix timestamp at which the bytecode was compiled A 32bit integer customizable at compilation time (not yet supported, set at zero) The bytecode version The bytecode options (not yet supported, set at 0) The bytecode size set_option(opt, value) Set the VM Option opt to value . The following constants are avaiable for opt : VM_OPT_RESET_ON_EXCEPTION : if value is 0, uncaught Python exception do not cause a microcontroller reset VM_OPT_TRACE_ON_EXCEPTION : if value is 0, uncaught Python exception are not printed to console VM_OPT_RESET_ON_HARDFAULT : if value is 0, microcontroller Hard Fault do not cause a microcontroller reset VM_OPT_TRACE_ON_HARDFAULT : if value is 0, microcontroller Hard Fault dumps are not printed to console The functionalities for Hard Fault are not consistent across different microcontrollers due to different behaviours/capabilities of the underlying SDK. get_option(opt) Retrieve the value of opt . Refer to set_option() for a description of opt . encrypt(bin, nonce=0) Return an encrypted copy of bin . The encrypted data is secured with a key which is unique per device and can only be decrypted by the same device that performed the encryption. To increase the key space, an integer nonce can be given that must be passed also for decryption. Raise ValueError if len(bin)<8 decrypt(bin, nonce=0) Return a decrypted copy of bin . To increase the key space, an integer nonce can be given that must be the same one given for encryption. Raise ValueError if len(bin)<8","title":"VM"},{"location":"reference/core/stdlib/docs/vm/#vm","text":"This module enables inspecting the running VM and controlling some runtime options. info() Return info about the running Virtual Machine. The result is a tuple with 9 elements: Virtual Machine unique identifier (string) Target device (string) Virtual Machine version (string) The RAM address where C memory starts The Unix timestamp at which the bytecode was compiled A 32bit integer customizable at compilation time (not yet supported, set at zero) The bytecode version The bytecode options (not yet supported, set at 0) The bytecode size set_option(opt, value) Set the VM Option opt to value . The following constants are avaiable for opt : VM_OPT_RESET_ON_EXCEPTION : if value is 0, uncaught Python exception do not cause a microcontroller reset VM_OPT_TRACE_ON_EXCEPTION : if value is 0, uncaught Python exception are not printed to console VM_OPT_RESET_ON_HARDFAULT : if value is 0, microcontroller Hard Fault do not cause a microcontroller reset VM_OPT_TRACE_ON_HARDFAULT : if value is 0, microcontroller Hard Fault dumps are not printed to console The functionalities for Hard Fault are not consistent across different microcontrollers due to different behaviours/capabilities of the underlying SDK. get_option(opt) Retrieve the value of opt . Refer to set_option() for a description of opt . encrypt(bin, nonce=0) Return an encrypted copy of bin . The encrypted data is secured with a key which is unique per device and can only be decrypted by the same device that performed the encryption. To increase the key space, an integer nonce can be given that must be passed also for decryption. Raise ValueError if len(bin)<8 decrypt(bin, nonce=0) Return a decrypted copy of bin . To increase the key space, an integer nonce can be given that must be the same one given for encryption. Raise ValueError if len(bin)<8","title":"VM"},{"location":"reference/core/stdlib/docs/wireless_ble/","text":"BLE \u00b6 This module implements a generic BLE interface for the peripheral role. To function correctly it needs a BLE driver to be loaded, so that the module can use the driver to access the underlying hardware. The link between the BLE module and the BLE driver is established without the programmer intervention by the driver itself. The BLE module requires the programmer to understand the specifications of the BLE protocol ragarding in particular the Generic Access Profile (GAP) and the Generic Attribute Profile (GATT). Official BLE specifications can be found here . A shorter and easier introduction to BLE can be found here . A minimal example follows: import streams # import a BLE driver: in this example we use NRF52 from nordic.nrf52_ble import nrf52_ble as bledrv # then import the BLE modue from wireless import ble streams . serial () # initialize NRF52 driver bledrv . init () # Set GAP name ble . gap ( \"Zerynth\" ) # Create a GATT Service: let's try a Battery Service (uuid is 0x180F) s = ble . Service ( 0x180F ) # Create a GATT Characteristic: (uuid for Battery Level is 0x2A19, and it is an 8-bit number) c = ble . Characteristic ( 0x2A19 , ble . NOTIFY | ble . READ , 1 , \"Battery Level\" , ble . NUMBER ) # Add the GATT Characteristic to the Service s . add_characteristic ( c ) # Add the Service ble . add_service ( s ) # Start the BLE stack ble . start () # Begin advertising ble . start_advertising () while True : print ( \".\" ) sleep ( 1000 ) # Let's update the Characteristic Value c . set_value ( random ( 0 , 100 )) To interact with the example, download a BLE monitor app (for example this one ). Module Functions \u00b6 gap(name, appearance=0, security=(SECURITY_MODE_1, SECURITY_LEVEL_1), connection=(400, 650, 0, 4000)) Set parameters for the the Generic Access Profile: name is a string representing the full name of the BLE device. Depending on the advertising mode and payload, the advertised name can be shorter. appearance is a 16-bit number encoding the BLE appearance security is a tuple of integers. The first element is the security mode, the second is the security level. More info here . Constants SECURITY_MODE_1 and SECURITY_MODE_2 can be used for mode, SECURITY_LEVEL_1 , SECURITY_LEVEL_2 , SECURITY_LEVEL_3 and SECURITY_LEVEL_4 for level. connection is a tuple of integers representing connections parameters. The first element specifies the Minimum Connection Interval in milliseconds; the second element specifies the Maximum Connection Interval in milliseconds; the third element specifies the slave latency and it represents the number of times that the peripheral can avoid answering to a central; the fourth element is the maximum time in milliseconds after which a connection is declared lost if no data has been exchanged. Security features can be not completely supported by the underlying BLE driver. When supported, the security features are selectable as follows: Security Mode 1: this mode enforces security by means of encryption, and contains four levels Level 1 - No Security (No authentication and no encryption) Level 2 - Unauthenticated pairing with encryption Level 3 - Authenticated pairing with encryption Level 4 - Authenticated LE Secure Connections pairing with encryption Security Mode 2: this mode enforces security by means of data signing, and contains two levels Level 1 - Unauthenticated pairing with data signing Level 2 - Authenticated pairing with data signing security(capabilities=CAP_NONE, bonding=AUTH_NO_BOND, scheme=AUTH_SC, key_size=16, initiator=KEY_ENC|KEY_ID, responder=KEY_ENC|KEY_ID, oob=0, passkey=0) Set security parameters: capabilities is one of the following constants descrbing the device capabilities (to determine how to perform secure pairing): CAP_DISPLAY_ONLY : a device with only a display capability CAP_DISPLAY_YES_NO : a device with a display and the possibility of confirming or unconfirming the displayed passkey (i.e. two buttons) CAP_KB_ONLY : a device with only the possibility of accepting some input CAP_KB_DISPLAY : a device with input and display capabilities CAP_NONE : a device with no input or output capabilities bonding is either AUTH_NO_BOND for pairing without bonding or AUTH_BOND for bonding scheme is an or\u2019ing of the following constants: AUTH_MITM for man in the middle protection AUTH_SC for secure connections key_size between 7 and 16 represents the size of the security keys in bytes initiator determines what kind of keys are exchanged by the initiator: KEY_ENC for the encryption key KEY_ID for the identity key KEY_CSR for the signing key responder same value set of the initiator oob not supported yet passkey is an integer representing the passkey to be displayed for CAP_DISPLAY_ONLY devices bonded() Returns the list of addresses of the currently bonded devices. Each address is a bytes sequence of length 6 remove_bonded(addr) Removes the bonding with the device with address addr . confirm_passkey(confirmed) For devices with CAP_DISPLAY_YES_NO the user must confirm the passkey. If confirmed is not zero, the passkey is confirmed and the secure connection performed. Otherwise the secure connection is aborted. add_service(service) Adds service to the service list. service must be an instance of the Service() class. add_callback(evt, callback) Add callback to the callback list. It will be triggered by event evt . The callback must be a function accepting one positional parameter that will be set to a value specific for each event. Only one callback can be linked to a specific event. A callback can be linked to GAP events by passing one of the following constants as evt : EVT_CONNECTED , the callback is triggered when a connection is made. Specific value is the remote device address. EVT_DISCONNECTED , the callback is triggered when a connection is lost. Specific value is the remote device address. EVT_SCAN_STARTED , the callback is triggered at the start of a scan. EVT_SCAN_STOPPED , the callback is triggered at the end of a scan. EVT_SCAN_REPORT , the callback is triggered at the end of a scan. Specific value is a tuple containing 5 elements (SCAN_TYPE, ADDR_TYPE, RSSI, PACKET, ADDR). EVT_SHOW_PASSKEY , the callback is triggered when the user need to access the passkey for CAP_DISPLAY_ONLY devices EVT_MATCH_PASSKEY , the callback is triggered when the user need confirm the passkey provided by the central ( CAP_DISPLAY_YES_NO devices) EVT_AUTH_FAILED the callback is triggered when the authentication phase fails EVT_ADV_STARTED the callback is triggered when advertising starts EVT_ADV_STOPPED the callback is triggered when advertising stops Regarding scan report events, the meaning of the scan tuple is: SCAN_TYPE: an integer assuming values: ADV_CONN_UND for connectable undirected advertising ADV_CONN_DIR for connectable directed advertising ADV_SCAN_UND for scannable undirected advertising ADV_UNCN_UND for non connectable undirected advertising ADV_SCAN_RSP scan response ADDR_TYPE: an integer being 0 for public address, 1 for random address, 2 for public resolvable private address and 3 for random resolvable private address RSSI: the rssi of the scanned device PACKET: a bytes object containing the advertising packet ADDR: a bytes object containing the 48bit device address An example of a callback: from wireless import ble def connected ( addr ): print ( \"Connected to\" , ble . btos ( addr )) ble . add_callback ( ble . EVT_CONNECTED , connected ) advertising(interval, timeout=0, payload=\"\", scan_rsp=\"\", mode=ADV_CONN_UND) Set advertising parameters: interval is the time in milliseconds between advertising packets timeout is the time in milliseconds after which stopping the advertising (if zero, it never times out) payload is a string or bytes containing the payload to add in the manufacturer section of the advertising packet. Ignored if len(payload) is zero. scanrsp is a string or bytes containing the payload to add in a scan response. Ignored if len(scanrsp) is zero. mode is an integer determining the type of advertising: ADV_CONN_UND , ADV_UNCN_UND , ADV_SCAN_UND are supported. start_advertising() Start advertising according to parameters set by advertising() stop_advertising() Stop advertising immediately scanning(interval=10, window=10, duplicates=0, filter=SCAN_FILTER_ALL, addr=SCAN_ADDR_PUBLIC, active=0) Set options for scanning. interval (in milliseconds) is the scanning interval window (in milliseconds) is the duration of a scanning interval duplicates is zero for no duplicate advertisement packets in the report, not zero for duplicates included filter selects which kind of packets to include in the report (not yet implemented) addr selects which kind of device addresses are included in the report (not yet implemented) active selects active scanning if not zero start_scanning(duration=1000) Start scanning for advertising packets for duration milliseconds. Each scanned packet is retrieved int the EVT_SCAN_REPORT GAP event. stop_scanning() Stop scanning for advertising packets start() Initializes and start the BLE stack. Must be called after the configuration of GAP, GATT, advertising, scanning and security btos(addr) Converts a BLE address from a sequence of bytes to a string. It can also be used with longer sequences like entire packets. Service class \u00b6 Service(uuid, base_uuid=None) This class abstracts a GATT Service. Services are defined by providing a uuid . BLE uuids are 128 bit sequences, but a shorter 16 bit version can be used in case of standard BLE services. The list of standard uuids can be found here . For custom uuids it is possible to specify all 128 bits passing a bytes or bytearray object to base_uuid . base_uuid represents the 128 bit uuid as a sequece of 16 bytes in little endian order. 13 th and 14 th bytes are ignored and substituted by uuid . To create a standard service: from wireless import ble s = ble . Service ( 0x180D ) # Heart Rate Service id is 0x180D To create a custom service from wireless import ble s = ble . Service ( 0xA001 , bytes ([ 0x01 , 0x02 , 0x03 , 0x04 , 0x05 , 0x06 , 0x07 , 0x08 , 0x09 , 0x0A , 0x0B , 0x0C , 0x00 , 0x00 , 0x0F , 0x10 ])) # the custom Service uuid becomes: 100FA001-0C0B-0A09-0807-060504030201 # 13th and 14th bytes are substituted with 0xA001 add_characteristic(ch) Add ch to the list of characteristic contained in the service. ch must be an instance of Characteristic() . ch is modified by setting ch.service to the service uuid. Characteristic class \u00b6 Characteristic(uuid, permission, size, descriptor, type=NUMBER) This class abstracts a GATT Characteristic. Characteristics are defined by providing: uuid : a 16 bit uuid, standard uuids can be found here permission : an integer representing permissions available for the characteristic value. It is defined by ORing the following flags: READ for read permission WRITE for write permission NOTIFY for notify permission INDICATE for indication permission size : the length in bytes of the characteristic value descriptor : a string specifying the characteristic descriptor type : can be one of NUMBER , STRING , BYTES and specifies the type of the characteristic value. In BLE specifications, values are sequences of bytes. Using size and type , the BLE module interprets the sequence of bytes transforming it in a Python object. To create a characteristic: from wireless import ble c = ble . Characteristic ( 0x2A19 , ble . NOTIFY | ble . READ , 1 , \"Battery Level\" , ble . NUMBER ) # The characteristic has uuid 0x2A19, can be read and notified, is a number of size 1 byte and has a descriptor Once created, a characteristic must be added to a service to be usable set_value(value) Update the characteristic value to value . value is converted to bytes sequence according to the characteristic size and type. If connected, the NOTIFY permission is given and the central has enabled notifications, the updated value is notified to the central. get_value() Return the value of the characteristic converted to a Python object according to size and type. set_callback(fn) Characteristics with WRITE permission can be changed by the central. A callback can be used to be notified of such change. fn is called on every WRITE event and accepts two positional arguments; the first one is a status flag, the second one is the updated characteristic value. For example: from wireless import ble def led_toggle ( status , value ): if status & ble . WRITE : if value : digitalWrite ( LED0 , 1 ) else : digitalWrite ( LED0 , 0 ) c = ble . Characteristic ( 0x1525 , ble . WRITE | ble . READ , 1 , \"LED\" , ble . NUMBER ) c . set_callback ( led_toggle ) The status argument of the callback is set to a combination of READ , NOTIFY , WRITE events.","title":"BLE"},{"location":"reference/core/stdlib/docs/wireless_ble/#ble","text":"This module implements a generic BLE interface for the peripheral role. To function correctly it needs a BLE driver to be loaded, so that the module can use the driver to access the underlying hardware. The link between the BLE module and the BLE driver is established without the programmer intervention by the driver itself. The BLE module requires the programmer to understand the specifications of the BLE protocol ragarding in particular the Generic Access Profile (GAP) and the Generic Attribute Profile (GATT). Official BLE specifications can be found here . A shorter and easier introduction to BLE can be found here . A minimal example follows: import streams # import a BLE driver: in this example we use NRF52 from nordic.nrf52_ble import nrf52_ble as bledrv # then import the BLE modue from wireless import ble streams . serial () # initialize NRF52 driver bledrv . init () # Set GAP name ble . gap ( \"Zerynth\" ) # Create a GATT Service: let's try a Battery Service (uuid is 0x180F) s = ble . Service ( 0x180F ) # Create a GATT Characteristic: (uuid for Battery Level is 0x2A19, and it is an 8-bit number) c = ble . Characteristic ( 0x2A19 , ble . NOTIFY | ble . READ , 1 , \"Battery Level\" , ble . NUMBER ) # Add the GATT Characteristic to the Service s . add_characteristic ( c ) # Add the Service ble . add_service ( s ) # Start the BLE stack ble . start () # Begin advertising ble . start_advertising () while True : print ( \".\" ) sleep ( 1000 ) # Let's update the Characteristic Value c . set_value ( random ( 0 , 100 )) To interact with the example, download a BLE monitor app (for example this one ).","title":"BLE"},{"location":"reference/core/stdlib/docs/wireless_ble/#module-functions","text":"gap(name, appearance=0, security=(SECURITY_MODE_1, SECURITY_LEVEL_1), connection=(400, 650, 0, 4000)) Set parameters for the the Generic Access Profile: name is a string representing the full name of the BLE device. Depending on the advertising mode and payload, the advertised name can be shorter. appearance is a 16-bit number encoding the BLE appearance security is a tuple of integers. The first element is the security mode, the second is the security level. More info here . Constants SECURITY_MODE_1 and SECURITY_MODE_2 can be used for mode, SECURITY_LEVEL_1 , SECURITY_LEVEL_2 , SECURITY_LEVEL_3 and SECURITY_LEVEL_4 for level. connection is a tuple of integers representing connections parameters. The first element specifies the Minimum Connection Interval in milliseconds; the second element specifies the Maximum Connection Interval in milliseconds; the third element specifies the slave latency and it represents the number of times that the peripheral can avoid answering to a central; the fourth element is the maximum time in milliseconds after which a connection is declared lost if no data has been exchanged. Security features can be not completely supported by the underlying BLE driver. When supported, the security features are selectable as follows: Security Mode 1: this mode enforces security by means of encryption, and contains four levels Level 1 - No Security (No authentication and no encryption) Level 2 - Unauthenticated pairing with encryption Level 3 - Authenticated pairing with encryption Level 4 - Authenticated LE Secure Connections pairing with encryption Security Mode 2: this mode enforces security by means of data signing, and contains two levels Level 1 - Unauthenticated pairing with data signing Level 2 - Authenticated pairing with data signing security(capabilities=CAP_NONE, bonding=AUTH_NO_BOND, scheme=AUTH_SC, key_size=16, initiator=KEY_ENC|KEY_ID, responder=KEY_ENC|KEY_ID, oob=0, passkey=0) Set security parameters: capabilities is one of the following constants descrbing the device capabilities (to determine how to perform secure pairing): CAP_DISPLAY_ONLY : a device with only a display capability CAP_DISPLAY_YES_NO : a device with a display and the possibility of confirming or unconfirming the displayed passkey (i.e. two buttons) CAP_KB_ONLY : a device with only the possibility of accepting some input CAP_KB_DISPLAY : a device with input and display capabilities CAP_NONE : a device with no input or output capabilities bonding is either AUTH_NO_BOND for pairing without bonding or AUTH_BOND for bonding scheme is an or\u2019ing of the following constants: AUTH_MITM for man in the middle protection AUTH_SC for secure connections key_size between 7 and 16 represents the size of the security keys in bytes initiator determines what kind of keys are exchanged by the initiator: KEY_ENC for the encryption key KEY_ID for the identity key KEY_CSR for the signing key responder same value set of the initiator oob not supported yet passkey is an integer representing the passkey to be displayed for CAP_DISPLAY_ONLY devices bonded() Returns the list of addresses of the currently bonded devices. Each address is a bytes sequence of length 6 remove_bonded(addr) Removes the bonding with the device with address addr . confirm_passkey(confirmed) For devices with CAP_DISPLAY_YES_NO the user must confirm the passkey. If confirmed is not zero, the passkey is confirmed and the secure connection performed. Otherwise the secure connection is aborted. add_service(service) Adds service to the service list. service must be an instance of the Service() class. add_callback(evt, callback) Add callback to the callback list. It will be triggered by event evt . The callback must be a function accepting one positional parameter that will be set to a value specific for each event. Only one callback can be linked to a specific event. A callback can be linked to GAP events by passing one of the following constants as evt : EVT_CONNECTED , the callback is triggered when a connection is made. Specific value is the remote device address. EVT_DISCONNECTED , the callback is triggered when a connection is lost. Specific value is the remote device address. EVT_SCAN_STARTED , the callback is triggered at the start of a scan. EVT_SCAN_STOPPED , the callback is triggered at the end of a scan. EVT_SCAN_REPORT , the callback is triggered at the end of a scan. Specific value is a tuple containing 5 elements (SCAN_TYPE, ADDR_TYPE, RSSI, PACKET, ADDR). EVT_SHOW_PASSKEY , the callback is triggered when the user need to access the passkey for CAP_DISPLAY_ONLY devices EVT_MATCH_PASSKEY , the callback is triggered when the user need confirm the passkey provided by the central ( CAP_DISPLAY_YES_NO devices) EVT_AUTH_FAILED the callback is triggered when the authentication phase fails EVT_ADV_STARTED the callback is triggered when advertising starts EVT_ADV_STOPPED the callback is triggered when advertising stops Regarding scan report events, the meaning of the scan tuple is: SCAN_TYPE: an integer assuming values: ADV_CONN_UND for connectable undirected advertising ADV_CONN_DIR for connectable directed advertising ADV_SCAN_UND for scannable undirected advertising ADV_UNCN_UND for non connectable undirected advertising ADV_SCAN_RSP scan response ADDR_TYPE: an integer being 0 for public address, 1 for random address, 2 for public resolvable private address and 3 for random resolvable private address RSSI: the rssi of the scanned device PACKET: a bytes object containing the advertising packet ADDR: a bytes object containing the 48bit device address An example of a callback: from wireless import ble def connected ( addr ): print ( \"Connected to\" , ble . btos ( addr )) ble . add_callback ( ble . EVT_CONNECTED , connected ) advertising(interval, timeout=0, payload=\"\", scan_rsp=\"\", mode=ADV_CONN_UND) Set advertising parameters: interval is the time in milliseconds between advertising packets timeout is the time in milliseconds after which stopping the advertising (if zero, it never times out) payload is a string or bytes containing the payload to add in the manufacturer section of the advertising packet. Ignored if len(payload) is zero. scanrsp is a string or bytes containing the payload to add in a scan response. Ignored if len(scanrsp) is zero. mode is an integer determining the type of advertising: ADV_CONN_UND , ADV_UNCN_UND , ADV_SCAN_UND are supported. start_advertising() Start advertising according to parameters set by advertising() stop_advertising() Stop advertising immediately scanning(interval=10, window=10, duplicates=0, filter=SCAN_FILTER_ALL, addr=SCAN_ADDR_PUBLIC, active=0) Set options for scanning. interval (in milliseconds) is the scanning interval window (in milliseconds) is the duration of a scanning interval duplicates is zero for no duplicate advertisement packets in the report, not zero for duplicates included filter selects which kind of packets to include in the report (not yet implemented) addr selects which kind of device addresses are included in the report (not yet implemented) active selects active scanning if not zero start_scanning(duration=1000) Start scanning for advertising packets for duration milliseconds. Each scanned packet is retrieved int the EVT_SCAN_REPORT GAP event. stop_scanning() Stop scanning for advertising packets start() Initializes and start the BLE stack. Must be called after the configuration of GAP, GATT, advertising, scanning and security btos(addr) Converts a BLE address from a sequence of bytes to a string. It can also be used with longer sequences like entire packets.","title":"Module Functions"},{"location":"reference/core/stdlib/docs/wireless_ble/#service-class","text":"Service(uuid, base_uuid=None) This class abstracts a GATT Service. Services are defined by providing a uuid . BLE uuids are 128 bit sequences, but a shorter 16 bit version can be used in case of standard BLE services. The list of standard uuids can be found here . For custom uuids it is possible to specify all 128 bits passing a bytes or bytearray object to base_uuid . base_uuid represents the 128 bit uuid as a sequece of 16 bytes in little endian order. 13 th and 14 th bytes are ignored and substituted by uuid . To create a standard service: from wireless import ble s = ble . Service ( 0x180D ) # Heart Rate Service id is 0x180D To create a custom service from wireless import ble s = ble . Service ( 0xA001 , bytes ([ 0x01 , 0x02 , 0x03 , 0x04 , 0x05 , 0x06 , 0x07 , 0x08 , 0x09 , 0x0A , 0x0B , 0x0C , 0x00 , 0x00 , 0x0F , 0x10 ])) # the custom Service uuid becomes: 100FA001-0C0B-0A09-0807-060504030201 # 13th and 14th bytes are substituted with 0xA001 add_characteristic(ch) Add ch to the list of characteristic contained in the service. ch must be an instance of Characteristic() . ch is modified by setting ch.service to the service uuid.","title":"Service class"},{"location":"reference/core/stdlib/docs/wireless_ble/#characteristic-class","text":"Characteristic(uuid, permission, size, descriptor, type=NUMBER) This class abstracts a GATT Characteristic. Characteristics are defined by providing: uuid : a 16 bit uuid, standard uuids can be found here permission : an integer representing permissions available for the characteristic value. It is defined by ORing the following flags: READ for read permission WRITE for write permission NOTIFY for notify permission INDICATE for indication permission size : the length in bytes of the characteristic value descriptor : a string specifying the characteristic descriptor type : can be one of NUMBER , STRING , BYTES and specifies the type of the characteristic value. In BLE specifications, values are sequences of bytes. Using size and type , the BLE module interprets the sequence of bytes transforming it in a Python object. To create a characteristic: from wireless import ble c = ble . Characteristic ( 0x2A19 , ble . NOTIFY | ble . READ , 1 , \"Battery Level\" , ble . NUMBER ) # The characteristic has uuid 0x2A19, can be read and notified, is a number of size 1 byte and has a descriptor Once created, a characteristic must be added to a service to be usable set_value(value) Update the characteristic value to value . value is converted to bytes sequence according to the characteristic size and type. If connected, the NOTIFY permission is given and the central has enabled notifications, the updated value is notified to the central. get_value() Return the value of the characteristic converted to a Python object according to size and type. set_callback(fn) Characteristics with WRITE permission can be changed by the central. A callback can be used to be notified of such change. fn is called on every WRITE event and accepts two positional arguments; the first one is a status flag, the second one is the updated characteristic value. For example: from wireless import ble def led_toggle ( status , value ): if status & ble . WRITE : if value : digitalWrite ( LED0 , 1 ) else : digitalWrite ( LED0 , 0 ) c = ble . Characteristic ( 0x1525 , ble . WRITE | ble . READ , 1 , \"LED\" , ble . NUMBER ) c . set_callback ( led_toggle ) The status argument of the callback is set to a combination of READ , NOTIFY , WRITE events.","title":"Characteristic class"},{"location":"reference/core/stdlib/docs/wireless_ble_beacons/","text":"BLE Beacons \u00b6 This module implements utility functions to implement and scan iBeacons and Eddystone beacons. Refer to BLE examples for usage. Module Functions \u00b6 eddy_encode_tlm(battery, temperature, count, time) Return a bytearray representing an encoded Eddystone payload of type tlm (not encrypted). According to the specifications: battery is the battery charge in mV temperature is the beacon temperature in degrees. If None is give, temperature is set to -128 count is the pdu count, the number of advertised packets time is the time in seconds since beacon power up eddy_encode_uid(namespace, instance, txpower) Return a bytearray representing an encoded Eddystone payload of type uid (not encrypted). According to the specifications: namespace is a sequence of bytes of maximum length 10 (if less, it is zero padded to the right) representing the namespace of the uid instance is a sequence of bytes of maximum lengtth 6 (if less, it is zero padded to the right) representing the instance of the uid txpower is the power calibration measurement of the beacon (used to calculate distances) eddy_encode_url(url, txpower) Return a bytearray representing an encoded Eddystone payload of type url (not encrypted). According to the specifications: url is a string representing an URL to be encoded in the Eddystone format txpower is the power calibration measurement of the beacon (used to calculate distances) eddy_decode_type(packet) Given packet as a bytes or bytearray return the type of the Eddystone packet or raises ValueError if it is not an Eddystone packet. Return values are: EDDY_LTM for ltm packets EDDY_UID for uid packets EDDY_URL for url packets eddy_decode(packet) Given packet as a bytes or bytearray return a tuple with the packet decoded fields or raises ValueError in case packet is not Eddystone. Return values are: a tuple with namespace, instance and txpower for uid packets a tuple with url and txpower for url packets a tuple with battery, temperature, count and time for tlm packets ibeacon_encode(uuid, major, minor, txpower, manufacturer=0x4c00) Return a bytearray representing an encoded iBeacon payload. According to the specifications: uuid is a 16 bytes unique identifier major is the major version as integer minor is the minor version as integer txpower is the power calibration measurement of the beacon (used to calculate distances) manufacturer is set to Apple, but can be changed if needed ibeacon_decode(packet) Given packet as a bytes or bytearray return a tuple with the packet decoded fields or raises ValueError in case packet is not iBeacon. Return value is a tuple with uuid, major, minor and txpower","title":"BLE Beacons"},{"location":"reference/core/stdlib/docs/wireless_ble_beacons/#ble-beacons","text":"This module implements utility functions to implement and scan iBeacons and Eddystone beacons. Refer to BLE examples for usage.","title":"BLE Beacons"},{"location":"reference/core/stdlib/docs/wireless_ble_beacons/#module-functions","text":"eddy_encode_tlm(battery, temperature, count, time) Return a bytearray representing an encoded Eddystone payload of type tlm (not encrypted). According to the specifications: battery is the battery charge in mV temperature is the beacon temperature in degrees. If None is give, temperature is set to -128 count is the pdu count, the number of advertised packets time is the time in seconds since beacon power up eddy_encode_uid(namespace, instance, txpower) Return a bytearray representing an encoded Eddystone payload of type uid (not encrypted). According to the specifications: namespace is a sequence of bytes of maximum length 10 (if less, it is zero padded to the right) representing the namespace of the uid instance is a sequence of bytes of maximum lengtth 6 (if less, it is zero padded to the right) representing the instance of the uid txpower is the power calibration measurement of the beacon (used to calculate distances) eddy_encode_url(url, txpower) Return a bytearray representing an encoded Eddystone payload of type url (not encrypted). According to the specifications: url is a string representing an URL to be encoded in the Eddystone format txpower is the power calibration measurement of the beacon (used to calculate distances) eddy_decode_type(packet) Given packet as a bytes or bytearray return the type of the Eddystone packet or raises ValueError if it is not an Eddystone packet. Return values are: EDDY_LTM for ltm packets EDDY_UID for uid packets EDDY_URL for url packets eddy_decode(packet) Given packet as a bytes or bytearray return a tuple with the packet decoded fields or raises ValueError in case packet is not Eddystone. Return values are: a tuple with namespace, instance and txpower for uid packets a tuple with url and txpower for url packets a tuple with battery, temperature, count and time for tlm packets ibeacon_encode(uuid, major, minor, txpower, manufacturer=0x4c00) Return a bytearray representing an encoded iBeacon payload. According to the specifications: uuid is a 16 bytes unique identifier major is the major version as integer minor is the minor version as integer txpower is the power calibration measurement of the beacon (used to calculate distances) manufacturer is set to Apple, but can be changed if needed ibeacon_decode(packet) Given packet as a bytes or bytearray return a tuple with the packet decoded fields or raises ValueError in case packet is not iBeacon. Return value is a tuple with uuid, major, minor and txpower","title":"Module Functions"},{"location":"reference/core/stdlib/docs/wireless_gsm/","text":"GSM \u00b6 This module implements a generic gsm interface. To function correctly it needs a gsm driver to be loaded, so that the module can use the driver to access the underlying hardware. The link between the gsm module and the gsm driver is established without the programmer intervetion by the driver itself. Once the gsm driver is connected to the GSM network, this module can be used to access functionalities at different levels: Network level : query the operators/carriers, select a carrier, retrieve the signal strength, retrieve info about the current cell Device level : retrieve info about IMEI and SIM card Packet Switch Service level : once attached to an APN, the standard socket interface is available. Secure sockets are available if the underlying driver supports them. Due to the nature of GSM networks (private networks behind a NATing APN), listening sockets are not implemented both for UDP and TCP. SMS level : receive, read and send SMS (not yet available) The following constants are defined: AUTH_NONE , no authentication required with APN AUTH_DETECT , automatic authentication detection AUTH_PAP , use PAP authentication AUTH_CHAP , use CHAP authentication gethostbyname(hostname) Translate a host name to IPv4 address format. The IPv4 address is returned as a string, such as \u201c192.168.0.5\u201d. attach(apn, username = \"\", psw = \"\", auth = AUTH_NONE, timeout=120000) Try to establish a link with the chosen Access Point Name apn . auth must be one of AUTH_NONE (default), AUTH_PAP, AUTH_CHAP, AUTH_DETECT. username and psw are optional, depending on the operator. timeout is the time in milliseconds to wait for network registration (connecting to the carrier and receiving GPRS support) and APN negotiation (enabling the packet switch service) An exception can be raised if the connection is not successful. detach() Detach from APN. mobile_info() Return information on the mobile device and SIM card. The result is a tuple where the elements are, in order: The IMEI as a string The SIM card id as a string link_info() Return information on the currently established APN link. The result is a tuple where the elements are, in order: The assigned IP as a string The DNS IP as a string Note that the returned IP, is in the private range and doesn\u2019t match the IP seen by the other end of a socket. network_info() Return information on the GSM network. The result is a tuple where the elements are, in order: The service type as a string: GMS, UMTS, LTE The MCC as an integer, negative if not known the MNC as an integer, negative if not known The Base Station identifier as string The LAC (location area code) as a string The Cell Identity as a string The registration status to the mobile network: True or False The presence of a link to an APN: True or False rssi() Return an integer representing the signal strength in dB. operators() Retrieve the list of available operators/carrier. If the result is None , it was not possible to retrieve the list of operators. The result is a tuple where each items is a tuple of the following items: type , being 1 if available and 2 if currently connected long name , a string with the full name of the operator short name , a string with the short name of the operator identifier , the numeric identifier of the operator as a string set_operator(opname) Try to select the operator with long name opname . It is suggested to retrieve the list of operators before trying to set one. set_rat(rat, bands=[]) Try to set the Radio Access Technology to use. rat must be one of the constants: samp:GSM: for GSM radio samp:CAT_M1: for LTE Cat M1 samp:CAT_NB1: for LTE NB IoT The argument bands is used to select a subset of bands for the selected RAT. For samp:GSM the available bands are in the set (0,1,2,3) corresponding in order to 900 MHz, 1800MHz, 850MHz and 1900MHz. For LTE bands, the set of available bands can be looked up here (use the Band column). The underlying gsm driver may not support the RAT or the bands and can raise an exception or ignore unsupported bands. select(rlist, wlist, xlist, timeout=None) This is equivalent to the Unix select system call. The first three arguments are sequences of socket instances. rlist : wait until ready for reading wlist : wait until ready for writing xlist : wait for an \u201cexceptional condition\u201d (not supported by every gsm driver) Empty sequences are allowed. The optional timeout argument specifies a time-out as an integer number in milliseconds. When the timeout argument is omitted the function blocks until at least one socket is ready. A timeout value of zero specifies a poll and never blocks. The return value is a triple of lists of objects that are ready: subsets of the first three arguments. When the time-out is reached without a socket becoming ready, three empty lists are returned. list_sms(unread=False, maxsms=10, offset=0) Return a tuple of received SMS. Each SMS is a tuple with: Text of the message Number of the sender Timestamp of the SMS (7 integer elements YYYY,MM,DD,hh,mm,ss,tz where tz represents the difference in minutes with GMT) SMS index Parameter unread selects unread SMS only if set to True. maxsms defines the maximum number of SMS to return, while offset selects only SMS with index greater than or equal to offset . If the device stores many SMS, it is suggested to read them in chunks by incrementing offset . send_sms(num, txt) Try to send the SMS with text txt to receiver num . Return an integer representing the index of the SMS (but this may vary from driver to driver!). If the returned integer is negative, it has not been possible to send the SMS. An exception is raised if the underlying drivers fails while sending the SMS. delete_sms(index) Delete the SMS identified by index . The value of index to use must be taken from the result of list_sms. pending_sms() Return the number of SMS received since startup. It is not necessarily equal to the number of unread SMS. get_smsc() Return a string representing the Short Message Service Center set_smsc(smsc) Set the Short Message Service Center to the value of smsc","title":"GSM"},{"location":"reference/core/stdlib/docs/wireless_gsm/#gsm","text":"This module implements a generic gsm interface. To function correctly it needs a gsm driver to be loaded, so that the module can use the driver to access the underlying hardware. The link between the gsm module and the gsm driver is established without the programmer intervetion by the driver itself. Once the gsm driver is connected to the GSM network, this module can be used to access functionalities at different levels: Network level : query the operators/carriers, select a carrier, retrieve the signal strength, retrieve info about the current cell Device level : retrieve info about IMEI and SIM card Packet Switch Service level : once attached to an APN, the standard socket interface is available. Secure sockets are available if the underlying driver supports them. Due to the nature of GSM networks (private networks behind a NATing APN), listening sockets are not implemented both for UDP and TCP. SMS level : receive, read and send SMS (not yet available) The following constants are defined: AUTH_NONE , no authentication required with APN AUTH_DETECT , automatic authentication detection AUTH_PAP , use PAP authentication AUTH_CHAP , use CHAP authentication gethostbyname(hostname) Translate a host name to IPv4 address format. The IPv4 address is returned as a string, such as \u201c192.168.0.5\u201d. attach(apn, username = \"\", psw = \"\", auth = AUTH_NONE, timeout=120000) Try to establish a link with the chosen Access Point Name apn . auth must be one of AUTH_NONE (default), AUTH_PAP, AUTH_CHAP, AUTH_DETECT. username and psw are optional, depending on the operator. timeout is the time in milliseconds to wait for network registration (connecting to the carrier and receiving GPRS support) and APN negotiation (enabling the packet switch service) An exception can be raised if the connection is not successful. detach() Detach from APN. mobile_info() Return information on the mobile device and SIM card. The result is a tuple where the elements are, in order: The IMEI as a string The SIM card id as a string link_info() Return information on the currently established APN link. The result is a tuple where the elements are, in order: The assigned IP as a string The DNS IP as a string Note that the returned IP, is in the private range and doesn\u2019t match the IP seen by the other end of a socket. network_info() Return information on the GSM network. The result is a tuple where the elements are, in order: The service type as a string: GMS, UMTS, LTE The MCC as an integer, negative if not known the MNC as an integer, negative if not known The Base Station identifier as string The LAC (location area code) as a string The Cell Identity as a string The registration status to the mobile network: True or False The presence of a link to an APN: True or False rssi() Return an integer representing the signal strength in dB. operators() Retrieve the list of available operators/carrier. If the result is None , it was not possible to retrieve the list of operators. The result is a tuple where each items is a tuple of the following items: type , being 1 if available and 2 if currently connected long name , a string with the full name of the operator short name , a string with the short name of the operator identifier , the numeric identifier of the operator as a string set_operator(opname) Try to select the operator with long name opname . It is suggested to retrieve the list of operators before trying to set one. set_rat(rat, bands=[]) Try to set the Radio Access Technology to use. rat must be one of the constants: samp:GSM: for GSM radio samp:CAT_M1: for LTE Cat M1 samp:CAT_NB1: for LTE NB IoT The argument bands is used to select a subset of bands for the selected RAT. For samp:GSM the available bands are in the set (0,1,2,3) corresponding in order to 900 MHz, 1800MHz, 850MHz and 1900MHz. For LTE bands, the set of available bands can be looked up here (use the Band column). The underlying gsm driver may not support the RAT or the bands and can raise an exception or ignore unsupported bands. select(rlist, wlist, xlist, timeout=None) This is equivalent to the Unix select system call. The first three arguments are sequences of socket instances. rlist : wait until ready for reading wlist : wait until ready for writing xlist : wait for an \u201cexceptional condition\u201d (not supported by every gsm driver) Empty sequences are allowed. The optional timeout argument specifies a time-out as an integer number in milliseconds. When the timeout argument is omitted the function blocks until at least one socket is ready. A timeout value of zero specifies a poll and never blocks. The return value is a triple of lists of objects that are ready: subsets of the first three arguments. When the time-out is reached without a socket becoming ready, three empty lists are returned. list_sms(unread=False, maxsms=10, offset=0) Return a tuple of received SMS. Each SMS is a tuple with: Text of the message Number of the sender Timestamp of the SMS (7 integer elements YYYY,MM,DD,hh,mm,ss,tz where tz represents the difference in minutes with GMT) SMS index Parameter unread selects unread SMS only if set to True. maxsms defines the maximum number of SMS to return, while offset selects only SMS with index greater than or equal to offset . If the device stores many SMS, it is suggested to read them in chunks by incrementing offset . send_sms(num, txt) Try to send the SMS with text txt to receiver num . Return an integer representing the index of the SMS (but this may vary from driver to driver!). If the returned integer is negative, it has not been possible to send the SMS. An exception is raised if the underlying drivers fails while sending the SMS. delete_sms(index) Delete the SMS identified by index . The value of index to use must be taken from the result of list_sms. pending_sms() Return the number of SMS received since startup. It is not necessarily equal to the number of unread SMS. get_smsc() Return a string representing the Short Message Service Center set_smsc(smsc) Set the Short Message Service Center to the value of smsc","title":"GSM"},{"location":"reference/core/stdlib/docs/wireless_wifi/","text":"WiFi \u00b6 This module implements a generic wifi interface. To function correctly it needs a wifi driver to be loaded, so that the module can use the driver to access the underlying hardware. The link between the wifi module and the wifi driver is established without the programmer intervetion by the driver itself. This module defines the following constants: WIFI_OPEN = 0; Open Wifi network WIFI_WEP = 1; Wifi Network secured with WEP WIFI_WPA = 2; Wifi Network secured with WPA WIFI_WPA2 = 3; Wifi Network secured with WPA2 gethostbyname(hostname) Translate a host name to IPv4 address format. The IPv4 address is returned as a string, such as \u201c192.168.0.5\u201d. select(rlist, wlist, xlist, timeout=None) This is equivalent to the Unix select system call. The first three arguments are sequences of socket instances. rlist : wait until ready for reading wlist : wait until ready for writing xlist : wait for an \u201cexceptional condition\u201d (not supported by every wifi driver) Empty sequences are allowed. The optional timeout argument specifies a time-out as an integer number in milliseconds. When the timeout argument is omitted the function blocks until at least one socket is ready. A timeout value of zero specifies a poll and never blocks. The return value is a triple of lists of objects that are ready: subsets of the first three arguments. When the time-out is reached without a socket becoming ready, three empty lists are returned. scan(duration=5000) Return the list of available wifi networks as a tuple of tuples: (SSID, network_security, RSSI, BSSID). The format of RSSI depends on the specific wifi driver loaded. duration is the maximum time in milliseconds the scan can last. link(ssid, security, password=\"\") Try to establish a link with the Access Point handling the wifi network identified by ssid . security must be one of the WIFI constants, and password is needed if security is different from WIFI_OPEN An exception can be raised if the link is not successful. unlink() Disconnect from the currently linked wifi network. is_linked() Return True if linked to the Access Point set_link_info(ip, mask, gw, dns) Set desired wifi interface parameters: ip, the static ipv4 address mask, the network mask gw, the default gateway dns, the default dns If 0.0.0.0 is given, a default address will be used. link_info() Return information on the currently established AP link. The result is a tuple where the elements are, in order: The assigned IP as a string The network mask as a string The gateway IP as a string The DNS IP as a string The MAC address of the wifi interface as a sequence of 6 bytes softap_init(ssid, sec, password=\"\", max_conn=4) Try to activate the Access Point operating mode exposing a wifi network identified by ssid . security must be one of the WIFI constants, and password is needed if security is different from WIFI_OPEN; max_conn represents the maximum number of connections available (default is 4) An exception can be raised if the activation is not successful. Note Not guaranteed to be supported by every wifi driver! softap_config(ip=\"192.168.0.1\", gw=\"192.168.0.1\", net=\"255.255.255.0\") Try to configure the Access Point setting the IP address, the Gateway address and the Netmask address. Default values are: \u201c192.168.0.1\u201d as IP address, \u201c192.168.0.1\u201d as Gateway address, \u201c255.255.255.0\u201d as Netmask address. An exception can be raised if the configuration is not successful. Note Not guaranteed to be supported by every wifi driver! softap_get_info() Return information on the current devices connected to the Access Point. The result is a tuple where every element represents a device connected and includes: The assigned IP as a string The MAC address of the wifi interface as a sequence of 6 bytes Note Not guaranteed to be supported by every wifi driver! softap_off() Try to turn off the Access Point operating mode. An exception can be raised if the Access Point disabling is not successful. Note Not guaranteed to be supported by every wifi driver! station_on() Try to turn on the Station operating mode. An exception can be raised if the Station enabling is not successful. Note Not guaranteed to be supported by every wifi driver! station_off() Try to turn off the Station operating mode. An exception can be raised if the Station disabling is not successful. Note Not guaranteed to be supported by every wifi driver!","title":"WiFi"},{"location":"reference/core/stdlib/docs/wireless_wifi/#wifi","text":"This module implements a generic wifi interface. To function correctly it needs a wifi driver to be loaded, so that the module can use the driver to access the underlying hardware. The link between the wifi module and the wifi driver is established without the programmer intervetion by the driver itself. This module defines the following constants: WIFI_OPEN = 0; Open Wifi network WIFI_WEP = 1; Wifi Network secured with WEP WIFI_WPA = 2; Wifi Network secured with WPA WIFI_WPA2 = 3; Wifi Network secured with WPA2 gethostbyname(hostname) Translate a host name to IPv4 address format. The IPv4 address is returned as a string, such as \u201c192.168.0.5\u201d. select(rlist, wlist, xlist, timeout=None) This is equivalent to the Unix select system call. The first three arguments are sequences of socket instances. rlist : wait until ready for reading wlist : wait until ready for writing xlist : wait for an \u201cexceptional condition\u201d (not supported by every wifi driver) Empty sequences are allowed. The optional timeout argument specifies a time-out as an integer number in milliseconds. When the timeout argument is omitted the function blocks until at least one socket is ready. A timeout value of zero specifies a poll and never blocks. The return value is a triple of lists of objects that are ready: subsets of the first three arguments. When the time-out is reached without a socket becoming ready, three empty lists are returned. scan(duration=5000) Return the list of available wifi networks as a tuple of tuples: (SSID, network_security, RSSI, BSSID). The format of RSSI depends on the specific wifi driver loaded. duration is the maximum time in milliseconds the scan can last. link(ssid, security, password=\"\") Try to establish a link with the Access Point handling the wifi network identified by ssid . security must be one of the WIFI constants, and password is needed if security is different from WIFI_OPEN An exception can be raised if the link is not successful. unlink() Disconnect from the currently linked wifi network. is_linked() Return True if linked to the Access Point set_link_info(ip, mask, gw, dns) Set desired wifi interface parameters: ip, the static ipv4 address mask, the network mask gw, the default gateway dns, the default dns If 0.0.0.0 is given, a default address will be used. link_info() Return information on the currently established AP link. The result is a tuple where the elements are, in order: The assigned IP as a string The network mask as a string The gateway IP as a string The DNS IP as a string The MAC address of the wifi interface as a sequence of 6 bytes softap_init(ssid, sec, password=\"\", max_conn=4) Try to activate the Access Point operating mode exposing a wifi network identified by ssid . security must be one of the WIFI constants, and password is needed if security is different from WIFI_OPEN; max_conn represents the maximum number of connections available (default is 4) An exception can be raised if the activation is not successful. Note Not guaranteed to be supported by every wifi driver! softap_config(ip=\"192.168.0.1\", gw=\"192.168.0.1\", net=\"255.255.255.0\") Try to configure the Access Point setting the IP address, the Gateway address and the Netmask address. Default values are: \u201c192.168.0.1\u201d as IP address, \u201c192.168.0.1\u201d as Gateway address, \u201c255.255.255.0\u201d as Netmask address. An exception can be raised if the configuration is not successful. Note Not guaranteed to be supported by every wifi driver! softap_get_info() Return information on the current devices connected to the Access Point. The result is a tuple where every element represents a device connected and includes: The assigned IP as a string The MAC address of the wifi interface as a sequence of 6 bytes Note Not guaranteed to be supported by every wifi driver! softap_off() Try to turn off the Access Point operating mode. An exception can be raised if the Access Point disabling is not successful. Note Not guaranteed to be supported by every wifi driver! station_on() Try to turn on the Station operating mode. An exception can be raised if the Station enabling is not successful. Note Not guaranteed to be supported by every wifi driver! station_off() Try to turn off the Station operating mode. An exception can be raised if the Station disabling is not successful. Note Not guaranteed to be supported by every wifi driver!","title":"WiFi"},{"location":"reference/core/stdlib/docs/x509/","text":"X509 \u00b6 This module allows to perform useful operations involving x509 certificates . generate_csr_for_key(key, subject) Generate a Certificate Signing Request from subject signed with key key . param subject is a string containing a comma-separated list of OID types and values (e.g. \"C=IT,O=ZER,CN=device 1\" ) param key can be: a null terminated string (must end with a 0 byte) containing a valid key or an empty string to use a hardware one. To enable the use of hardware keys a hardware cryptographic interface must be started. For example, with an ATECC508A (ATECCx08A interface): import x509 from microchip.ateccx08a import ateccx08a # ... ateccx08a . hwcrypto_init ( I2C0 , 0 ) # select private key stored in slot 0 x509 . generate_csr_for_key ( '' , subject ) (in this case ZERYNTH_HWCRYPTO_ATECCx08A must be also set to true in project.yml ) Note generating a CSR requires a big stack, probably not available inside the main thread. It is suggested to call this function from a separate thread with a custom stack size (e.g. thread(generate_function, size=12288) ) .","title":"X509"},{"location":"reference/core/stdlib/docs/x509/#x509","text":"This module allows to perform useful operations involving x509 certificates . generate_csr_for_key(key, subject) Generate a Certificate Signing Request from subject signed with key key . param subject is a string containing a comma-separated list of OID types and values (e.g. \"C=IT,O=ZER,CN=device 1\" ) param key can be: a null terminated string (must end with a 0 byte) containing a valid key or an empty string to use a hardware one. To enable the use of hardware keys a hardware cryptographic interface must be started. For example, with an ATECC508A (ATECCx08A interface): import x509 from microchip.ateccx08a import ateccx08a # ... ateccx08a . hwcrypto_init ( I2C0 , 0 ) # select private key stored in slot 0 x509 . generate_csr_for_key ( '' , subject ) (in this case ZERYNTH_HWCRYPTO_ATECCx08A must be also set to true in project.yml ) Note generating a CSR requires a big stack, probably not available inside the main thread. It is suggested to call this function from a separate thread with a custom stack size (e.g. thread(generate_function, size=12288) ) .","title":"X509"},{"location":"reference/core/studio/docs/","text":"Zerynth Studio \u00b6 Zerynth Studio is an integrated development environment (IDE) that runs on Windows, Linux and Mac. Through Zerynth Studio all the supported boards can be managed and programs can be developed in Python 3 or hybrid C/Python. Projects developed with Zerynth Studio can be saved locally or pushed as private git repository to the Zerynth backend. Zerynth Studio includes: A code editor with syntax highlighting, multi-tab support, code auto-completion and error highlighting features; A seamless integration of all the Zerynth Toolchain commands; Board discovery and management; Multiple serial port monitors; Git integration; Tens of code examples. The Zerynth Studio interface is divided into functional areas: The Toolbar The Code Editor The Left Panel The System Log The Footer bar The Toolbar \u00b6 The Toolbar is placed at the top of the Zerynth Studio window just under the system menubar. It contains two separate sections; on the left side there is the list of opened projects with the current one highlighted. Buttons to compile, uplink and debug the current project lie just to the right of it. At the center of the toolbar there is the device management widget, whereas to the right of the screen, an account button allows accessing the user profile and assets. Device Management Widget \u00b6 Zerynth Studio automatically recognizes connected devices, being them development boards, usb to serial converters or board programming tools. The connected devices are listed in the device management widget. The currently selected device will be used as a target device by the compiler and the uplinker. !!! Project Debugging is available only coupled with Advanced Device Management By clicking \u201cChoose target devices\u2026\u201d in the dropdown, it is possible to add a target device not physically connected the the development machine. This way, projects can be verified for such target, but obviously not uplinked. The device discovery algorithm tries its best to infer the type of the connected device, but there are situations where this is not feasible without user intervention. In such cases, the discovered device is reported as \u201cambiguous\u201d and the final choiche on the device type is left to the user. Once a device has been connected, the buttons to the right of the device list allow the following interactions: Device Registration & Virtualization : by clicking the \u201cZ\u201d button, a registration and virtualization dialog is displayed. If the target device has never been connected before, the only possible action is to register the device. The registration procedure is necessary to retrieve enough device information for allowing the Zerynth backend to build a virtual machine for the device. Once registration has been performed, the user is given the option to create a Virtual Machine for the registered device. Here the user can select one of different virtual machines compatible with the target device. Finally, the created Virtual Machine can be virtualized (i.e. burned on the device). Some devices cannot be recognized automatically; for these devices, the dialog provides some more options to be specified before the actual registration/virtualization can take place. Finally, a device can always be registered again with the dedicated dialog button. Redeem licenses : upon registering a new device the option to acquire a license is given; the redeem process requires inserting a special code, often provided by the hardware vendor for Zerynth powered devices. The inserted code will transfer into the user account a certain amount of virtual machines licenses. Serial Console : by clicking the rightmost button,the serial port of the target device can be opened and the output inspected. Device information and PinMap : the central buttons can be used to retrieve device information (expecially the serial port and/or the mounted volume) and to show the device pinmap. Please refer to the Programming Guide section for more details on how pin names and functionalities are organized in Zerynth. When a serial console is opened, the port parameters are automatically configured to the defaults of the selected device. The baud rate for a device is displayed during bytecode upload. To open a serial port configured with a non default baudrate, a serial terminal like Putty should be used. It is important to close the serial terminal before trying to uplink or open a Zerynth serial console, because concurrent serial port usage from different programs is not allowed. Note The Zerynth Studio serial console also has scroll lock and clear all console functions accessible from the top right corner of the console The Getting Started section has a dedicated tutorial on how to manage devices. Advanced Device Widget \u00b6 Zerynth Studio gives the possibility to configure the connected devices in more details, overriding the automatic discovery process. This feature is particularly useful when the device needs to be registered, virtualized and programmed using a JTAG/SWD probe. To access the advanced device management mode the corresponding option must be selected in the device management widget. Once in advanced mode, new device configurations can be created and filled with the following details: port: the serial port exposed by the device (a list of available serial ports is automatically suggested) disk: some devices are seen as mass storage disks (a list of available disks is automatically suggested) probe: most used JTAG/SWD probes are supported and can be selected In advanced mode, the behaviour of the \u201cZ\u201d button, console button and uplink button are modified: the console is available only if a port has been specified in the device configuration the \u201cZ\u201d button functions will be perfomed using the specified port or disk; if a probe is specified, it will take priority and all registrations and virtualizations will be performed via JTAG/SWD (for the devices supporting the feature) the uplink button will use the configured port; again, if a probe is specified, it will take priority and the uplinking will be performed via JTAG/SWD Furthermore Project Debugging is enabled. Device configurations and the device management mode are remembered across Studio restarts (but not across different development machines). Device configurations can be deleted and modified. Some systems assign different devices parameters upon device reconnection (i.e. a different serial port): such changes are not automatically recognized in advanced mode and must be reconfigured manually! C Code Debugger \u00b6 Zerynth Studio integrates the powerful gdbgui as a GDB Front End to allow debugging with ease the C component of hybrid C/Python projects. Clicking the Debug Session button, current project is uplinked via JTAG/SWD and a gdbgui window is open. Inside gdbgui it is possible to place breakpoints on and inside C functions to control execution flow, inspect MCU memory and C variable values. Zerynth Account Profile Section \u00b6 Zerynth Studio provides all Zerynth Account Profile information in the Profile Section that can be accessed by clicking the profile icon at the top right of the screen. The Profile Section is divided into five main area: Account Info; Personal Info; Zerynth Starter Licenses Info; Zerynth Premium Licenses Info. History Purchase Info. Account Info Area \u00b6 In this section the Zerynth User can retrieve the username and email inserted during the registration sequence. \u201cActive Repositories\u201d field shows the list of library repositories available to the specific Zerynth User. The \u201cProfile Completeness\u201d bar shows the completion percentage of the user personal profile form. Personal Info Area \u00b6 This area show all the personal information. The Zerynth User is free to fill the form, inserting the name, last name, age, country, job, company/organization and website. After clicking the \u201csave\u201d button, the inserted information are stored and profile completeness percentage are recalculated. Zerynth Starter Licenses Section \u00b6 In this section the Zerynth User can monitor the status his Zerynth Starter assets in different views related to the available and supported real time operating system: VMs - FreeRTOS: the table shows how many Zerynth Starter VMs with FreeRTOS have been consumed out of the total owned, including the detail about the distribution of the consumed VMs among the user devices; VMs - ChibiOS: the table shows, as above, the status of the available and consumed Zerynth Starter VMs with ChibiOS. Zerynth Premium Licenses Section \u00b6 In this section the Zerynth User can monitor the status his Zerynth Premium assets in different views related to the available and supported real time operating system: VMs - FreeRTOS: the table shows how many Zerynth Premium VMs with FreeRTOS have been consumed out of the total owned, including the detail about the distribution of the consumed VMs among the user devices; VMs - ChibiOS: the table shows, as above, the status of the available and consumed Zerynth Premium VMs with ChibiOS. Note The difference between Starter and Premium is related to the Zerynth Virtual Machine features: a Starter VM is a basic virtual machine. a Premium VM is a virtual machine with special features like FOTA (Firmware Over The Air), Powersaving, Secure Firmware, or combination of them. Purchase History Section \u00b6 By clicking the orange \u201cPurchase History\u201d button, the Purchase History table is displayed. Through this table the user can retrieve all the information about the owned assets ordered by date with description and creation date; the receipt number is also indicated for purchased assets. Code Editor \u00b6 Zerynth Studio integrates a code editor based on the powerful Ace . The topmost part of the editor is reserved for tabs. Each tab displays a single project file and files belonging to different projects can be kept open at the same time. At the bottom of the editor, a status bar displays information about the currently opened file together with a series of menus to alter the editor font and theme. The rightmost menu contains the useful editor commands. Keyboard shortcuts are available: ctrl+c / ctrl+v / ctrl+x : copy/paste/cut ctrl+z / ctrl+y : undo/redo ctrl+f : find in the current file ctrl+g : find next ctrl+shift+g : find previous ctrl+h : find and replace ctrl+\\\\ : comment/uncomment selected lines tab : indent more shift+tab : indent less ctrl+alt+8 : auto pep8 (check and modify the script according to Python Enhancement Proposals 8 style convention) for more shortcuts refer to the Ace shortcut page The Left Panel \u00b6 The vertical panel located to the left of the screen displays different information panels that can be selected by clicking one of the vertically stacked icons. Project View \u00b6 The topmost icon selects the currently open project and the folder tree is shown. A double click on a project file opens it in the code editor. The user can open more than one project and can switch from a project to another by selecting it from the project top bar. Project related commands can be accessed both from the system menu and from the dropdowns in the top right corner of the project view. Note Drag and Drop feature is available for the project view Projects Browser \u00b6 All projects known to Zerynth Studio are listed in the projects browser panel. Projects are grouped into \u201cworkspaces\u201d, where a workspace is the parent folder that contains them. Different workspaces are automatically added and removed to the projects browser as soon as a new project is created or the last project in a workspace is deleted, respectively. Projects are also \u201ctagged\u201d by an icon with the following meaning: closed folder: project save locally folder with git fork icon: project is saved remotely on the Zerynth backend folder with a book icon: project has been published as a library package Examples Browser \u00b6 Zerynth Studio integrates an Example browser from which code examples can be cloned into projects. Examples are organized in a tree where different branches are usually labelled with the package namespace that provides them. In the Getting Started section a dedicated tutorial on how to use examples is available. Library Manager \u00b6 Zerynth Studio can be extended with new libraries from our community of users; these features are managed from the Library Manager panel, accessible by clicking the \u201cpuzzle\u201d icon on the Left Panel To search and install a library: type keywords in the search box and a list of matching libraries will be displayed. choose \u201cInstall\u201d or \u201cUpdate\u201d from the library info card click \u201cInstall\u201d in the summary popup for the library after choosing the version A the top right corner of the Library Manager panel, a \u201crefresh\u201d button allows retrieving an updated list of the available community libraries. The list is refreshed automatically by Zerynth Studio every hour. In the Getting Started section a dedicated tutorial on how to search, install and import packages is available. News Feed \u00b6 Zerynth Studio is also a tool to stay connected with the Zerynth community . The \u201cNews Feed\u201d tab displays the latest news available in the community forum about packages, updates, releases and bug fixes. Console List \u00b6 Each device output can be monitored through a dedicated serial console and each console lives in its own window. The console list panel is useful rapidly focus or close an opened console. ADM connected devices \u00b6 Devices present in the ADM database are shown in this panel. For each device, information about its status is displayed. If the device supports FOTA updates, the FOTA process can be performed directly from the provided buttons. More information on the ADM and FOTA updates can be found here and here. Custom Virtual Machines \u00b6 Custom Virtual Machines can be created and managed directly from Zerynth Studio. A new custom VM can be created by accessing the dropdown menu on the right side of the panel title. In particular a new VM can be created: from scratch (Add VM option) by importing VM packages created by other users (import from file option) by importing the custom VM from a Github repository (import from Github) By selecting option 1 a popup dialog is displayed asking for some info: the name of the custom VM (must be at most 31 lowercase characters with at most one underscore) the name of the custom device hosting the custom VM (it will appear on the Device Management Widget) the customizable VM to use as a starting point Once created, the custom VM will appear in the panel with a series of buttons (in order from left to right): edit button: open the Yaml template file where the VM customization takes place. The standard template is heavily commented and contains all the info to successfully configure a custom VM compile button: before being able to use a custom VM, it must be compiled starting from the info contained in the Yaml template. remove button: permanently deletes the custom VM. Not that custom VMs are not saved to the Zerynth servers, so be careful! export button: creates a package containing the custom VM details. Such package can be shared with other Zerynth users enabling them to use the custom VM. Github button: pushes the custom VM to a Github repository System Log \u00b6 Zerynth Studio also includes a System Log Panel under the code editor where all system messages are reported. The displayed messages usually comes from the output of ZTC commands executed under the hood by Zerynth Studio. In case of error a full traceback of the exception can be generated: it should be copied and reported on the community forum to have it solved and fixed. The Footer Bar \u00b6 A the bottom of the Zerynth Studio main window a footer bar displays two types of information: On the leftmost part, notification buttons appear when system updates or new supported boards are released. By clicking on the notification, the update process is started. On the rightmost part, a busy indicator appears during operations that takes some time to complete, like compiling, uplinking or updating the system Note When new versions of Zerynth Studio or of the Zerynth Toolchain are released, a manual restart of the Studio is required. The update process is non-disruptive and the previous working version of Zerynth Studio is preserved so that it can be started in case the new version has failed updating correctly. Quick Search \u00b6 Zerynth Studio has a quick search feature accessed through the shortcut Ctrl+P . The quick search bar allows to search projects, examples and installed packages rapidly. Each search result is tagged with a type that can be proj for projects, ex for examples and and doc for package documentation. The quick search bar has some advanced features. It is possible to prefix the search query with the type of the desired result followed by a colon in order to restrict the search to the specified type. For example, typing proj:blink displays only the projects that match the query term \u201cblink\u201d. Finally, by typing :ztc followed by a ZTC command, the specified command is executed and the output is shown in the System Log. Preferences Menu \u00b6 In the Zerynth Studio Preferences Menu, following options are available: Profile : Opens the Profile Section; Remove Installation : Lists of old installation instances that can be removed; Clean temp folder : Deletes all file in tmp folder under Zerynth Studio folder; Forget all devices : Forgets all devices stored in local database (virtual machines are not involved); Show messages : Shows the list of all received messages; Check Updates : Manual trigger to check if new updates are available. Redeem Licenses : Open up a dialog where redeemable codes can be turned into virtual machine licenses. Note the \u201cForget all devices\u201d option is needed when there are one or more errors in recognizing devices connected to the machine. Confirming this command local device database will be cleaned. ======= \u2192 origin/dev-voja","title":"Zerynth Studio"},{"location":"reference/core/studio/docs/#zerynth-studio","text":"Zerynth Studio is an integrated development environment (IDE) that runs on Windows, Linux and Mac. Through Zerynth Studio all the supported boards can be managed and programs can be developed in Python 3 or hybrid C/Python. Projects developed with Zerynth Studio can be saved locally or pushed as private git repository to the Zerynth backend. Zerynth Studio includes: A code editor with syntax highlighting, multi-tab support, code auto-completion and error highlighting features; A seamless integration of all the Zerynth Toolchain commands; Board discovery and management; Multiple serial port monitors; Git integration; Tens of code examples. The Zerynth Studio interface is divided into functional areas: The Toolbar The Code Editor The Left Panel The System Log The Footer bar","title":"Zerynth Studio"},{"location":"reference/core/studio/docs/#the-toolbar","text":"The Toolbar is placed at the top of the Zerynth Studio window just under the system menubar. It contains two separate sections; on the left side there is the list of opened projects with the current one highlighted. Buttons to compile, uplink and debug the current project lie just to the right of it. At the center of the toolbar there is the device management widget, whereas to the right of the screen, an account button allows accessing the user profile and assets.","title":"The Toolbar"},{"location":"reference/core/studio/docs/#device-management-widget","text":"Zerynth Studio automatically recognizes connected devices, being them development boards, usb to serial converters or board programming tools. The connected devices are listed in the device management widget. The currently selected device will be used as a target device by the compiler and the uplinker. !!! Project Debugging is available only coupled with Advanced Device Management By clicking \u201cChoose target devices\u2026\u201d in the dropdown, it is possible to add a target device not physically connected the the development machine. This way, projects can be verified for such target, but obviously not uplinked. The device discovery algorithm tries its best to infer the type of the connected device, but there are situations where this is not feasible without user intervention. In such cases, the discovered device is reported as \u201cambiguous\u201d and the final choiche on the device type is left to the user. Once a device has been connected, the buttons to the right of the device list allow the following interactions: Device Registration & Virtualization : by clicking the \u201cZ\u201d button, a registration and virtualization dialog is displayed. If the target device has never been connected before, the only possible action is to register the device. The registration procedure is necessary to retrieve enough device information for allowing the Zerynth backend to build a virtual machine for the device. Once registration has been performed, the user is given the option to create a Virtual Machine for the registered device. Here the user can select one of different virtual machines compatible with the target device. Finally, the created Virtual Machine can be virtualized (i.e. burned on the device). Some devices cannot be recognized automatically; for these devices, the dialog provides some more options to be specified before the actual registration/virtualization can take place. Finally, a device can always be registered again with the dedicated dialog button. Redeem licenses : upon registering a new device the option to acquire a license is given; the redeem process requires inserting a special code, often provided by the hardware vendor for Zerynth powered devices. The inserted code will transfer into the user account a certain amount of virtual machines licenses. Serial Console : by clicking the rightmost button,the serial port of the target device can be opened and the output inspected. Device information and PinMap : the central buttons can be used to retrieve device information (expecially the serial port and/or the mounted volume) and to show the device pinmap. Please refer to the Programming Guide section for more details on how pin names and functionalities are organized in Zerynth. When a serial console is opened, the port parameters are automatically configured to the defaults of the selected device. The baud rate for a device is displayed during bytecode upload. To open a serial port configured with a non default baudrate, a serial terminal like Putty should be used. It is important to close the serial terminal before trying to uplink or open a Zerynth serial console, because concurrent serial port usage from different programs is not allowed. Note The Zerynth Studio serial console also has scroll lock and clear all console functions accessible from the top right corner of the console The Getting Started section has a dedicated tutorial on how to manage devices.","title":"Device Management Widget"},{"location":"reference/core/studio/docs/#advanced-device-widget","text":"Zerynth Studio gives the possibility to configure the connected devices in more details, overriding the automatic discovery process. This feature is particularly useful when the device needs to be registered, virtualized and programmed using a JTAG/SWD probe. To access the advanced device management mode the corresponding option must be selected in the device management widget. Once in advanced mode, new device configurations can be created and filled with the following details: port: the serial port exposed by the device (a list of available serial ports is automatically suggested) disk: some devices are seen as mass storage disks (a list of available disks is automatically suggested) probe: most used JTAG/SWD probes are supported and can be selected In advanced mode, the behaviour of the \u201cZ\u201d button, console button and uplink button are modified: the console is available only if a port has been specified in the device configuration the \u201cZ\u201d button functions will be perfomed using the specified port or disk; if a probe is specified, it will take priority and all registrations and virtualizations will be performed via JTAG/SWD (for the devices supporting the feature) the uplink button will use the configured port; again, if a probe is specified, it will take priority and the uplinking will be performed via JTAG/SWD Furthermore Project Debugging is enabled. Device configurations and the device management mode are remembered across Studio restarts (but not across different development machines). Device configurations can be deleted and modified. Some systems assign different devices parameters upon device reconnection (i.e. a different serial port): such changes are not automatically recognized in advanced mode and must be reconfigured manually!","title":"Advanced Device Widget"},{"location":"reference/core/studio/docs/#c-code-debugger","text":"Zerynth Studio integrates the powerful gdbgui as a GDB Front End to allow debugging with ease the C component of hybrid C/Python projects. Clicking the Debug Session button, current project is uplinked via JTAG/SWD and a gdbgui window is open. Inside gdbgui it is possible to place breakpoints on and inside C functions to control execution flow, inspect MCU memory and C variable values.","title":"C Code Debugger"},{"location":"reference/core/studio/docs/#zerynth-account-profile-section","text":"Zerynth Studio provides all Zerynth Account Profile information in the Profile Section that can be accessed by clicking the profile icon at the top right of the screen. The Profile Section is divided into five main area: Account Info; Personal Info; Zerynth Starter Licenses Info; Zerynth Premium Licenses Info. History Purchase Info.","title":"Zerynth Account Profile Section"},{"location":"reference/core/studio/docs/#account-info-area","text":"In this section the Zerynth User can retrieve the username and email inserted during the registration sequence. \u201cActive Repositories\u201d field shows the list of library repositories available to the specific Zerynth User. The \u201cProfile Completeness\u201d bar shows the completion percentage of the user personal profile form.","title":"Account Info Area"},{"location":"reference/core/studio/docs/#personal-info-area","text":"This area show all the personal information. The Zerynth User is free to fill the form, inserting the name, last name, age, country, job, company/organization and website. After clicking the \u201csave\u201d button, the inserted information are stored and profile completeness percentage are recalculated.","title":"Personal Info Area"},{"location":"reference/core/studio/docs/#zerynth-starter-licenses-section","text":"In this section the Zerynth User can monitor the status his Zerynth Starter assets in different views related to the available and supported real time operating system: VMs - FreeRTOS: the table shows how many Zerynth Starter VMs with FreeRTOS have been consumed out of the total owned, including the detail about the distribution of the consumed VMs among the user devices; VMs - ChibiOS: the table shows, as above, the status of the available and consumed Zerynth Starter VMs with ChibiOS.","title":"Zerynth Starter Licenses Section"},{"location":"reference/core/studio/docs/#zerynth-premium-licenses-section","text":"In this section the Zerynth User can monitor the status his Zerynth Premium assets in different views related to the available and supported real time operating system: VMs - FreeRTOS: the table shows how many Zerynth Premium VMs with FreeRTOS have been consumed out of the total owned, including the detail about the distribution of the consumed VMs among the user devices; VMs - ChibiOS: the table shows, as above, the status of the available and consumed Zerynth Premium VMs with ChibiOS. Note The difference between Starter and Premium is related to the Zerynth Virtual Machine features: a Starter VM is a basic virtual machine. a Premium VM is a virtual machine with special features like FOTA (Firmware Over The Air), Powersaving, Secure Firmware, or combination of them.","title":"Zerynth Premium Licenses Section"},{"location":"reference/core/studio/docs/#purchase-history-section","text":"By clicking the orange \u201cPurchase History\u201d button, the Purchase History table is displayed. Through this table the user can retrieve all the information about the owned assets ordered by date with description and creation date; the receipt number is also indicated for purchased assets.","title":"Purchase History Section"},{"location":"reference/core/studio/docs/#code-editor","text":"Zerynth Studio integrates a code editor based on the powerful Ace . The topmost part of the editor is reserved for tabs. Each tab displays a single project file and files belonging to different projects can be kept open at the same time. At the bottom of the editor, a status bar displays information about the currently opened file together with a series of menus to alter the editor font and theme. The rightmost menu contains the useful editor commands. Keyboard shortcuts are available: ctrl+c / ctrl+v / ctrl+x : copy/paste/cut ctrl+z / ctrl+y : undo/redo ctrl+f : find in the current file ctrl+g : find next ctrl+shift+g : find previous ctrl+h : find and replace ctrl+\\\\ : comment/uncomment selected lines tab : indent more shift+tab : indent less ctrl+alt+8 : auto pep8 (check and modify the script according to Python Enhancement Proposals 8 style convention) for more shortcuts refer to the Ace shortcut page","title":"Code Editor"},{"location":"reference/core/studio/docs/#the-left-panel","text":"The vertical panel located to the left of the screen displays different information panels that can be selected by clicking one of the vertically stacked icons.","title":"The Left Panel"},{"location":"reference/core/studio/docs/#project-view","text":"The topmost icon selects the currently open project and the folder tree is shown. A double click on a project file opens it in the code editor. The user can open more than one project and can switch from a project to another by selecting it from the project top bar. Project related commands can be accessed both from the system menu and from the dropdowns in the top right corner of the project view. Note Drag and Drop feature is available for the project view","title":"Project View"},{"location":"reference/core/studio/docs/#projects-browser","text":"All projects known to Zerynth Studio are listed in the projects browser panel. Projects are grouped into \u201cworkspaces\u201d, where a workspace is the parent folder that contains them. Different workspaces are automatically added and removed to the projects browser as soon as a new project is created or the last project in a workspace is deleted, respectively. Projects are also \u201ctagged\u201d by an icon with the following meaning: closed folder: project save locally folder with git fork icon: project is saved remotely on the Zerynth backend folder with a book icon: project has been published as a library package","title":"Projects Browser"},{"location":"reference/core/studio/docs/#examples-browser","text":"Zerynth Studio integrates an Example browser from which code examples can be cloned into projects. Examples are organized in a tree where different branches are usually labelled with the package namespace that provides them. In the Getting Started section a dedicated tutorial on how to use examples is available.","title":"Examples Browser"},{"location":"reference/core/studio/docs/#library-manager","text":"Zerynth Studio can be extended with new libraries from our community of users; these features are managed from the Library Manager panel, accessible by clicking the \u201cpuzzle\u201d icon on the Left Panel To search and install a library: type keywords in the search box and a list of matching libraries will be displayed. choose \u201cInstall\u201d or \u201cUpdate\u201d from the library info card click \u201cInstall\u201d in the summary popup for the library after choosing the version A the top right corner of the Library Manager panel, a \u201crefresh\u201d button allows retrieving an updated list of the available community libraries. The list is refreshed automatically by Zerynth Studio every hour. In the Getting Started section a dedicated tutorial on how to search, install and import packages is available.","title":"Library Manager"},{"location":"reference/core/studio/docs/#news-feed","text":"Zerynth Studio is also a tool to stay connected with the Zerynth community . The \u201cNews Feed\u201d tab displays the latest news available in the community forum about packages, updates, releases and bug fixes.","title":"News Feed"},{"location":"reference/core/studio/docs/#console-list","text":"Each device output can be monitored through a dedicated serial console and each console lives in its own window. The console list panel is useful rapidly focus or close an opened console.","title":"Console List"},{"location":"reference/core/studio/docs/#adm-connected-devices","text":"Devices present in the ADM database are shown in this panel. For each device, information about its status is displayed. If the device supports FOTA updates, the FOTA process can be performed directly from the provided buttons. More information on the ADM and FOTA updates can be found here and here.","title":"ADM connected devices"},{"location":"reference/core/studio/docs/#custom-virtual-machines","text":"Custom Virtual Machines can be created and managed directly from Zerynth Studio. A new custom VM can be created by accessing the dropdown menu on the right side of the panel title. In particular a new VM can be created: from scratch (Add VM option) by importing VM packages created by other users (import from file option) by importing the custom VM from a Github repository (import from Github) By selecting option 1 a popup dialog is displayed asking for some info: the name of the custom VM (must be at most 31 lowercase characters with at most one underscore) the name of the custom device hosting the custom VM (it will appear on the Device Management Widget) the customizable VM to use as a starting point Once created, the custom VM will appear in the panel with a series of buttons (in order from left to right): edit button: open the Yaml template file where the VM customization takes place. The standard template is heavily commented and contains all the info to successfully configure a custom VM compile button: before being able to use a custom VM, it must be compiled starting from the info contained in the Yaml template. remove button: permanently deletes the custom VM. Not that custom VMs are not saved to the Zerynth servers, so be careful! export button: creates a package containing the custom VM details. Such package can be shared with other Zerynth users enabling them to use the custom VM. Github button: pushes the custom VM to a Github repository","title":"Custom Virtual Machines"},{"location":"reference/core/studio/docs/#system-log","text":"Zerynth Studio also includes a System Log Panel under the code editor where all system messages are reported. The displayed messages usually comes from the output of ZTC commands executed under the hood by Zerynth Studio. In case of error a full traceback of the exception can be generated: it should be copied and reported on the community forum to have it solved and fixed.","title":"System Log"},{"location":"reference/core/studio/docs/#the-footer-bar","text":"A the bottom of the Zerynth Studio main window a footer bar displays two types of information: On the leftmost part, notification buttons appear when system updates or new supported boards are released. By clicking on the notification, the update process is started. On the rightmost part, a busy indicator appears during operations that takes some time to complete, like compiling, uplinking or updating the system Note When new versions of Zerynth Studio or of the Zerynth Toolchain are released, a manual restart of the Studio is required. The update process is non-disruptive and the previous working version of Zerynth Studio is preserved so that it can be started in case the new version has failed updating correctly.","title":"The Footer Bar"},{"location":"reference/core/studio/docs/#quick-search","text":"Zerynth Studio has a quick search feature accessed through the shortcut Ctrl+P . The quick search bar allows to search projects, examples and installed packages rapidly. Each search result is tagged with a type that can be proj for projects, ex for examples and and doc for package documentation. The quick search bar has some advanced features. It is possible to prefix the search query with the type of the desired result followed by a colon in order to restrict the search to the specified type. For example, typing proj:blink displays only the projects that match the query term \u201cblink\u201d. Finally, by typing :ztc followed by a ZTC command, the specified command is executed and the output is shown in the System Log.","title":"Quick Search"},{"location":"reference/core/studio/docs/#preferences-menu","text":"In the Zerynth Studio Preferences Menu, following options are available: Profile : Opens the Profile Section; Remove Installation : Lists of old installation instances that can be removed; Clean temp folder : Deletes all file in tmp folder under Zerynth Studio folder; Forget all devices : Forgets all devices stored in local database (virtual machines are not involved); Show messages : Shows the list of all received messages; Check Updates : Manual trigger to check if new updates are available. Redeem Licenses : Open up a dialog where redeemable codes can be turned into virtual machine licenses. Note the \u201cForget all devices\u201d option is needed when there are one or more errors in recognizing devices connected to the machine. Confirming this command local device database will be cleaned. ======= \u2192 origin/dev-voja","title":"Preferences Menu"},{"location":"reference/core/toolchain/docs/","text":"Zerynth Toolchain \u00b6 The Zerynth Toolchain (ZTC) is a command line tool that allows managing all the aspects of the typical Zerynth workflow. Such workflow extends across different areas of the Zerynth programming experience: Managing projects Discovering, managing and virtualizing devices with virtual machines Compiling projects into executable bytecode Uplinking bytecode to virtualized devices Adding packages (e.g. libraries, drivers, device classes\u2026) to the current installation Turn projects into libraries and publish them to the community repository The workflow is made possible by the Zerynth backend that provides a set of REST API called by the ZTC. Therefore, most ZTC commands require an authentication token to act on the Zerynth backend on behalf of the user. Such token can be obtained by specific commands. A typical workflow consists in: Creating a project Choosing a target device Preparing the device to execute Zerynth code by loading a virtual machine on it, a process called \u201cvirtualization\u201d Adding Python files (and optionally other files) to the project Compiling the project for the target device obtaining executable bytecode Uplinking the bytecode to the virtualized device Inspecting the output of the device via serial monitor Contents: Synopsis Global options Command List Output conventions Directories Account related commands Login Reset Password Logout Get/Set Profile Info Projects Create a project Initialize a Git Repository Check repository status Fetch repository Commit Push to remote Pull from remote Switch/Create branch Clone a project Clone a project List remote projects Build Documentation Configure Devices Discover Device configuration Device Registration Device Registration by UID Device Raw Registration Virtualization Raw Virtualization Serial Console Serial Console (raw) Supported Devices Erase of the device flash memory Execute a device custom action Configured Devices Add Configured Devices Remove Configured Devices Compiler Uplink Uplink (raw) Uplink by probe Link FOTA updates Device Configuration and Mass Programming Device Configuration Zones Mass Programming Massprog command Virtual Machines Create a Virtual Machine List Virtual Machines Virtual Machine parameters Virtual Machine Binary File Registering Binary File Custom Virtual Machines Create Custom VM Compile Custom VM Template Remove Custom VM Export Custom VMs Import Custom VMs List customizable VMs List custom VMs Packages Available versions Available packages Trigger Update Install community packages Github Authorization Publishing a community library Installed packages Connected Devices Create a connected device Retrieves device info Configure a device Connected devices list Create a group of devices Group configuration Group configuration Create a device template Upload a template Retrieve template list Prepare a FOTA update Start a FOTA update Stop a FOTA update Check a FOTA update Amazon Web Services AWS IoT Platform Miscellanea Linter Info Clean Provisioning Uplink Configurator Firmware to the device Scan for a Crypto Element Address Read Crypto Element Configuration Retrieve Public Key Write Crypto Element Configuration Get Certificate Signing Request Locked Serial Number Store Public Store Certificate","title":"Zerynth Toolchain"},{"location":"reference/core/toolchain/docs/#zerynth-toolchain","text":"The Zerynth Toolchain (ZTC) is a command line tool that allows managing all the aspects of the typical Zerynth workflow. Such workflow extends across different areas of the Zerynth programming experience: Managing projects Discovering, managing and virtualizing devices with virtual machines Compiling projects into executable bytecode Uplinking bytecode to virtualized devices Adding packages (e.g. libraries, drivers, device classes\u2026) to the current installation Turn projects into libraries and publish them to the community repository The workflow is made possible by the Zerynth backend that provides a set of REST API called by the ZTC. Therefore, most ZTC commands require an authentication token to act on the Zerynth backend on behalf of the user. Such token can be obtained by specific commands. A typical workflow consists in: Creating a project Choosing a target device Preparing the device to execute Zerynth code by loading a virtual machine on it, a process called \u201cvirtualization\u201d Adding Python files (and optionally other files) to the project Compiling the project for the target device obtaining executable bytecode Uplinking the bytecode to the virtualized device Inspecting the output of the device via serial monitor Contents: Synopsis Global options Command List Output conventions Directories Account related commands Login Reset Password Logout Get/Set Profile Info Projects Create a project Initialize a Git Repository Check repository status Fetch repository Commit Push to remote Pull from remote Switch/Create branch Clone a project Clone a project List remote projects Build Documentation Configure Devices Discover Device configuration Device Registration Device Registration by UID Device Raw Registration Virtualization Raw Virtualization Serial Console Serial Console (raw) Supported Devices Erase of the device flash memory Execute a device custom action Configured Devices Add Configured Devices Remove Configured Devices Compiler Uplink Uplink (raw) Uplink by probe Link FOTA updates Device Configuration and Mass Programming Device Configuration Zones Mass Programming Massprog command Virtual Machines Create a Virtual Machine List Virtual Machines Virtual Machine parameters Virtual Machine Binary File Registering Binary File Custom Virtual Machines Create Custom VM Compile Custom VM Template Remove Custom VM Export Custom VMs Import Custom VMs List customizable VMs List custom VMs Packages Available versions Available packages Trigger Update Install community packages Github Authorization Publishing a community library Installed packages Connected Devices Create a connected device Retrieves device info Configure a device Connected devices list Create a group of devices Group configuration Group configuration Create a device template Upload a template Retrieve template list Prepare a FOTA update Start a FOTA update Stop a FOTA update Check a FOTA update Amazon Web Services AWS IoT Platform Miscellanea Linter Info Clean Provisioning Uplink Configurator Firmware to the device Scan for a Crypto Element Address Read Crypto Element Configuration Retrieve Public Key Write Crypto Element Configuration Get Certificate Signing Request Locked Serial Number Store Public Store Certificate","title":"Zerynth Toolchain"},{"location":"reference/core/toolchain/docs/aws_awscmd/","text":"Amazon Web Services \u00b6 The integration between the Zerynth Toolchain and AWS command line tool allows to easily manage AWS resources while working on your embedded project. Note The Zerynth Toolchain assumes AWS command line tool to be available and configured to handle AWS resources. Since AWS Platform provides several services, this page wil report the documentation of each ztc-aws-integrated command in a proper section depending on referred AWS service: AWS IoT Platform: * thing - project - from - template * add - things * set - active - thing * iot - cleanup * iot - fota - start AWS IoT Platform \u00b6 AWS IoT is a managed cloud platform that lets connected devices easily and securely interact with cloud applications and other devices: AWS IoT platform . It is officially supported by Zerynth powered devices through a specific module. Zerynth Toolchain and AWS IoT Platform integration provides a full device project workflow: from single Thing creation and testing to mass programming utilies for production environment. New project setup is made easy thanks to the available aws-iot enabled device project template. Testing the project on a single device, authenticating as an on-the-fly generated AWS IoT Thing, is immediate with add-things command. Scaling to multiple devices is allowed by the same add-things in combination with set-active-thing command. Environment cleanup (both local and remote) is also possible through iot-cleanup command. Create a generic AWS IoT Thing project from template \u00b6 The command: ztc aws thing - project - from - template project - name path Creates a Zerynth project called project-name inside a newly created project-name folder placed at provided path . The Zerynth project will be a clone of a template project capable of connecting to a wifi network and sending mqtt messages to the AWS IoT MQTT Broker, and made of the following files: \u251c\u2500\u2500 main . py \u251c\u2500\u2500 helpers . py \u251c\u2500\u2500 readme . md \u2514\u2500\u2500 thing . conf . json Where main.py will contain device task logic, made independent of AWS IoT Thing specific names and references which will be placed inside thing.conf.json configuration file. The command provides also useful options: -- aws - endpoint endpoint - name -- aws - policy - name policy - name which allow to specify configuration parameters such as mqtt broker endpoint or devices policy, common to different Things, directly at project cloning time. These options simply set values inside thing.conf.json which can also be easily edited manually. After customizing the code it will be necessary to generate an AWS IoT Thing to allow device authentication to AWS IoT Platform. Bind AWS IoT Things to a Zerynth Project \u00b6 The command: ztc aws add - things project_path -- things - base - name first_project_thing will generate an AWS IoT Thing called first_project_thing_0 and download Thing private key and certificate inside Zerynth project folder placed at project_path . Private key and certificate among with a Thing specific thing.conf.json will be stored inside first_project_thing_0 folder under .aws_things_resources one placed at project top-level folder. The newly created Thing will be set as the active one and its specific configuration will be placed inside top-level thing.conf.json and its key and certificate copied into private.pem.key and certificate.pem.crt files respectively. The Project is now ready for compilation and uplink processes. After testing the project on a single Thing it will be possible to add multiple things to the same project through: ztc aws add - things project_path -- things - number 10 creating 10 new Things with private keys and certificates with names from first_project_thing_1 to first_project_thing_10 . Otherwise it will be possible to specify a new base name calling again the proper option: ztc aws add - things project_path -- things - number 10 -- things - base - name production_thing After creation it is needed to choose each time a single Thing for compilation and uplink. Set a Thing as active for compilation and uplink \u00b6 The command: ztc aws set - active - thing project_path -- thing - id 0 will set thing_base_name_0 as active Thing ( first_project_thing_0 following the example above) for the Zerynth project placed at project_path . The process consists in: copying Thing private key and certificate to top-level project folder; filling Thing specific fields inside thing.conf.json configuration file: * certificate [ Amazon Resource Name ( ARN )]( http : // docs . aws . amazon . com / general / latest / gr / aws - arns - and - namespaces . html ), * Thing name , * MQTT ID to log to AWS IoT MQTT Broker ( same as Thing name ). A note on mass programming \u00b6 The simple script #!/usr/bin/sh things_number = 1000 ztc =/ ztc_path / ztc $ ztc aws add - things project_path -- things - number $ things_number -- thing - base - name production_thing for thing_id in $ ( seq 0 $ ( expr $ things_number - 1 )); do $ ztc aws set - active - thing project_path -- thing - id $ thing_id $ ztc compile project_path target_device $ ztc uplink target_device project_path / main . vbo done allows to scale a single Thing project to an arbitrary number of Things. Cleanup project deleting bound AWS IoT Things \u00b6 The command: ztc aws iot - cleanup project_path Deletes AWS IoT Things bound to Zerynth project placed at project_path and attached keys and certificates. Warning Clean up process acts both locally and remotely Initiate a FOTA update via AWS IoT Jobs \u00b6 The command: ztc aws iot - fota_start thing - name thing - firmware s3 - bucket s3 - role Will perform the following operations: Extract FOTA information from the thing-firmware file (created with the link command and -J option) Upload the new firmware to the s3-bucket S3 bucket url (must start with s3:// ) Create an AWS IoT Job for the specified thing-name . The AWS IoT endpoint must be able to read from the S3 bucket so an S3 read role named s3-read-role must be assigned to the endpoint. Such role must be used in the creation of the Job and therefore its name must be passed to this command. The Thing will receive a pre-signed https S3 url to download the new firmware; such url will be valid for a duration of one hour. It is possible to increase or decrease the duration validity using the --duration followed by the number of seconds the link will remain valid.","title":"Amazon Web Services"},{"location":"reference/core/toolchain/docs/aws_awscmd/#amazon-web-services","text":"The integration between the Zerynth Toolchain and AWS command line tool allows to easily manage AWS resources while working on your embedded project. Note The Zerynth Toolchain assumes AWS command line tool to be available and configured to handle AWS resources. Since AWS Platform provides several services, this page wil report the documentation of each ztc-aws-integrated command in a proper section depending on referred AWS service: AWS IoT Platform: * thing - project - from - template * add - things * set - active - thing * iot - cleanup * iot - fota - start","title":"Amazon Web Services"},{"location":"reference/core/toolchain/docs/aws_awscmd/#aws-iot-platform","text":"AWS IoT is a managed cloud platform that lets connected devices easily and securely interact with cloud applications and other devices: AWS IoT platform . It is officially supported by Zerynth powered devices through a specific module. Zerynth Toolchain and AWS IoT Platform integration provides a full device project workflow: from single Thing creation and testing to mass programming utilies for production environment. New project setup is made easy thanks to the available aws-iot enabled device project template. Testing the project on a single device, authenticating as an on-the-fly generated AWS IoT Thing, is immediate with add-things command. Scaling to multiple devices is allowed by the same add-things in combination with set-active-thing command. Environment cleanup (both local and remote) is also possible through iot-cleanup command.","title":"AWS IoT Platform"},{"location":"reference/core/toolchain/docs/aws_awscmd/#create-a-generic-aws-iot-thing-project-from-template","text":"The command: ztc aws thing - project - from - template project - name path Creates a Zerynth project called project-name inside a newly created project-name folder placed at provided path . The Zerynth project will be a clone of a template project capable of connecting to a wifi network and sending mqtt messages to the AWS IoT MQTT Broker, and made of the following files: \u251c\u2500\u2500 main . py \u251c\u2500\u2500 helpers . py \u251c\u2500\u2500 readme . md \u2514\u2500\u2500 thing . conf . json Where main.py will contain device task logic, made independent of AWS IoT Thing specific names and references which will be placed inside thing.conf.json configuration file. The command provides also useful options: -- aws - endpoint endpoint - name -- aws - policy - name policy - name which allow to specify configuration parameters such as mqtt broker endpoint or devices policy, common to different Things, directly at project cloning time. These options simply set values inside thing.conf.json which can also be easily edited manually. After customizing the code it will be necessary to generate an AWS IoT Thing to allow device authentication to AWS IoT Platform.","title":"Create a generic AWS IoT Thing project from template"},{"location":"reference/core/toolchain/docs/aws_awscmd/#bind-aws-iot-things-to-a-zerynth-project","text":"The command: ztc aws add - things project_path -- things - base - name first_project_thing will generate an AWS IoT Thing called first_project_thing_0 and download Thing private key and certificate inside Zerynth project folder placed at project_path . Private key and certificate among with a Thing specific thing.conf.json will be stored inside first_project_thing_0 folder under .aws_things_resources one placed at project top-level folder. The newly created Thing will be set as the active one and its specific configuration will be placed inside top-level thing.conf.json and its key and certificate copied into private.pem.key and certificate.pem.crt files respectively. The Project is now ready for compilation and uplink processes. After testing the project on a single Thing it will be possible to add multiple things to the same project through: ztc aws add - things project_path -- things - number 10 creating 10 new Things with private keys and certificates with names from first_project_thing_1 to first_project_thing_10 . Otherwise it will be possible to specify a new base name calling again the proper option: ztc aws add - things project_path -- things - number 10 -- things - base - name production_thing After creation it is needed to choose each time a single Thing for compilation and uplink.","title":"Bind AWS IoT Things to a Zerynth Project"},{"location":"reference/core/toolchain/docs/aws_awscmd/#set-a-thing-as-active-for-compilation-and-uplink","text":"The command: ztc aws set - active - thing project_path -- thing - id 0 will set thing_base_name_0 as active Thing ( first_project_thing_0 following the example above) for the Zerynth project placed at project_path . The process consists in: copying Thing private key and certificate to top-level project folder; filling Thing specific fields inside thing.conf.json configuration file: * certificate [ Amazon Resource Name ( ARN )]( http : // docs . aws . amazon . com / general / latest / gr / aws - arns - and - namespaces . html ), * Thing name , * MQTT ID to log to AWS IoT MQTT Broker ( same as Thing name ).","title":"Set a Thing as active for compilation and uplink"},{"location":"reference/core/toolchain/docs/aws_awscmd/#a-note-on-mass-programming","text":"The simple script #!/usr/bin/sh things_number = 1000 ztc =/ ztc_path / ztc $ ztc aws add - things project_path -- things - number $ things_number -- thing - base - name production_thing for thing_id in $ ( seq 0 $ ( expr $ things_number - 1 )); do $ ztc aws set - active - thing project_path -- thing - id $ thing_id $ ztc compile project_path target_device $ ztc uplink target_device project_path / main . vbo done allows to scale a single Thing project to an arbitrary number of Things.","title":"A note on mass programming"},{"location":"reference/core/toolchain/docs/aws_awscmd/#cleanup-project-deleting-bound-aws-iot-things","text":"The command: ztc aws iot - cleanup project_path Deletes AWS IoT Things bound to Zerynth project placed at project_path and attached keys and certificates. Warning Clean up process acts both locally and remotely","title":"Cleanup project deleting bound AWS IoT Things"},{"location":"reference/core/toolchain/docs/aws_awscmd/#initiate-a-fota-update-via-aws-iot-jobs","text":"The command: ztc aws iot - fota_start thing - name thing - firmware s3 - bucket s3 - role Will perform the following operations: Extract FOTA information from the thing-firmware file (created with the link command and -J option) Upload the new firmware to the s3-bucket S3 bucket url (must start with s3:// ) Create an AWS IoT Job for the specified thing-name . The AWS IoT endpoint must be able to read from the S3 bucket so an S3 read role named s3-read-role must be assigned to the endpoint. Such role must be used in the creation of the Job and therefore its name must be passed to this command. The Thing will receive a pre-signed https S3 url to download the new firmware; such url will be valid for a duration of one hour. It is possible to increase or decrease the duration validity using the --duration followed by the number of seconds the link will remain valid.","title":"Initiate a FOTA update via AWS IoT Jobs"},{"location":"reference/core/toolchain/docs/comp_up/","text":"Compiler, Uplinker and Linter \u00b6 In this section are described the Zerynth Compiler, the Zerynth Uplinker and the Zerynth Linter. All components are described with a brief introduction and with the related command syntaxes including arguments and option informations. Contents: Compiler Uplink Uplink (raw) Uplink by probe Link FOTA updates Linter Linter Command - pep8","title":"Compiler, Uplinker and Linter"},{"location":"reference/core/toolchain/docs/comp_up/#compiler-uplinker-and-linter","text":"In this section are described the Zerynth Compiler, the Zerynth Uplinker and the Zerynth Linter. All components are described with a brief introduction and with the related command syntaxes including arguments and option informations. Contents: Compiler Uplink Uplink (raw) Uplink by probe Link FOTA updates Linter Linter Command - pep8","title":"Compiler, Uplinker and Linter"},{"location":"reference/core/toolchain/docs/compiler_compilercmd/","text":"Compiler \u00b6 The ZTC compiler takes a project as input and produces an executable bytecode file ready to be uplinked on a virtualized. The command: ztc compile project target compiles the source files found at project (the project path) for a device with target target . The entry point of the program is the file main.py . Every additional Python module needed wil be searched in the following order: Project directory Directories passed with the -I option in the given order (see below) The Zerynth standard library The installed libraries Since Zerynth programs allow mixed C/Python code, the compiler also scans for C source files and compiles them with the appropriate C compiler for target . C object files are packed and included in the output bytecode. The compile command accepts additional options: -I/--include path , adds path to the list of directories scanned for Zerynth modules. This option can be repeated multiple times. -D/--define def , adds a C macro definition as a parameter for native C compiler. This option can be repeated multiple times. -o/--output path , specifies the path for the output file. If not specified it is main.vbo in the project folder.","title":"Compiler"},{"location":"reference/core/toolchain/docs/compiler_compilercmd/#compiler","text":"The ZTC compiler takes a project as input and produces an executable bytecode file ready to be uplinked on a virtualized. The command: ztc compile project target compiles the source files found at project (the project path) for a device with target target . The entry point of the program is the file main.py . Every additional Python module needed wil be searched in the following order: Project directory Directories passed with the -I option in the given order (see below) The Zerynth standard library The installed libraries Since Zerynth programs allow mixed C/Python code, the compiler also scans for C source files and compiles them with the appropriate C compiler for target . C object files are packed and included in the output bytecode. The compile command accepts additional options: -I/--include path , adds path to the list of directories scanned for Zerynth modules. This option can be repeated multiple times. -D/--define def , adds a C macro definition as a parameter for native C compiler. This option can be repeated multiple times. -o/--output path , specifies the path for the output file. If not specified it is main.vbo in the project folder.","title":"Compiler"},{"location":"reference/core/toolchain/docs/devices_devcmd/","text":"Devices \u00b6 In the ZTC a device is a peripheral that can execute Zerynth bytecode. In order to do so a device must be prepared and customized with certain attributes. The main attributes of a device are: alias , a unique name given by the user to the device in order to identify it in ZTC commands uid , a unique id provided by the operative system identifying the device at hardware level target , specifies what kind of virtual machine can be run by the device name , a human readable name describing the device. Automatically set by the ZTC chipid , the unique identifier of the microcontroller present on the device remote_id , the unique identifier of the device in the pool of user registered device classname , a Python class name identifying the class containing commands to configure the device When a new device is connected, some steps must be taken in order to make it able to run Zerynth code: The device must be discovered, namely its hardware parameters must be collected ( uid ). Once discovered an alias must be assigned. Depending on the type of device target and classname can be assigned in the same step. The device must be registered in order to create virtual machines for it ( chipid and remote_id are obtained in this step) The device must be :ref:`virtualized , namely a suited virtual machine must be loaded on the device microcontroller Sometimes the device automatic recognition is not enough to gather all the device parameters or to allow the usage of JTAG/SWD probes. In such cases additional commands have been introduced in order to manually specify the additional parameters. A separate database of devices with advanced configurations is maintained. List of device commands: discover alias put register register by uid register raw virtualize virtualize raw supported open open raw db list db put db remove The list of supported devices is available here Discover \u00b6 Device discovery is performed by interrogating the operative system database for USB connected peripherals. Each peripheral returned by the system has at least the following \u201craw\u201d attributes: vid , the USB vendor id pid , the USB product id sid , the unique identifier assigned by the operative system, used to discriminate between multiple connected devices with the same vid:pid port , the virtual serial port used to communicate with the device, if present disk , the mount point of the device, if present uid , a unique identifier assigned by the ZTC desc , the device description provided by the operative system (can differ between different platforms) Raw peripheral data can be obtained by running: ztc device discover Note In Linux peripheral data is obtained by calling into libudev functions. In Windows the WMI interface is used. In Mac calls to ioreg are used. Raw peripheral data are not so useful apart from checking the effective presence of a device. To obtain more useful data the option -- matchdb must be provided. Such option adds another step of device discovery on top of raw peripheral data that is matched against the list of supported devices and the list of already known devices. A --matchdb discovery returns a different set of more high level information: name , the name of the device taken from the ZTC supported device list alias , the device alias (if set) target , the device target, specifying what kind of microcontroller and pcb routing is to be expected on the device uid , the device uid, same as raw peripheral data chipid , the unique identifier of the device microcontrolloer (if known) remote_id , the unique identifier of the device in the Zerynth backend (if set) classname , the Python class in charge of managing the device All the above information is needed to make a device usable in the ZTC. The information provided helps in distinguishing different devices with different behaviours. A device without an alias is a device that is not yet usable, therefore an alias must be set. A device without chipid and remote_id is a device that has not been :ref:`registered yet and can not be virtualized yet. To complicate the matter, there are additional cases that can be spotted during discovery: A physical device can match multiple entries in the ZTC supported device list. This happens because often many different devices are built with the same serial USB chip and therefore they all appear as the same hardware to the operative system. Such device are called \u201cambiguous\u201d because the ZTC can not discriminate their target . For example, both the Mikroelektronika Flip&Click development board and the Arduino Due, share the same microcontroller and the same USB to serial converter and they both appear as a raw peripheral with the same vid:pid . The only way for the ZTC to differentiate between them is to ask the user to set the device target . For ambiguous devices the target can be set while setting the alias . Once the target is set, the device is disambiguated and subsequent discovery will return only one device with the right target . A physical device can appear in two or more different configurations depending on its status. For example, the Particle Photon board has two different modes: the DFU modes in which the device can be flashed (and therefore virtualized) and a \u201cnormal\u201d mode in which the device executes the firmware (and hence the Zerynth bytecode). The device appears as a different raw peripherals in the two modes with different vid:pid . In such cases the two different devices will have the same target and, once registered, the same chipid and remote_id . They will appear to the Zerynth backend as a single device (same remote_id ), but the ZTC device list will have two different devices with different alias and different classname . The classname for such devices can be set while setting the alias. In the case of the Particle Photon, the classname will be \u201cPhotonDFU\u201d for DFU mode and \u201cPhoton\u201d for normal mode. PhotonDFU is the alter_ego of Photon in ZTC terminology. Some development boards do not have USB circuitry and can be programmed only through a JTAG or an external usb-to-serial converter. Such devices can not be discovered. To use them, the programmer device (JTAG or usb-to-serial) must be configured by setting alias and target to the ones the development device. Finally, the discover command can be run in continuous mode by specifying the option --loop . With --loop the command keeps printing the set of discovered devices each time it changes (i.e. a new device is plugged or a connected device is unplugged). In some operative system the continuous discovery is implemented by polling the operative system device database for changes. The polling time can be set with option --looptime milliseconds , by default it is 2000 milliseconds. Device configuration \u00b6 Before usage a device must be configured. The configuration consists in linking a physical device identified by its uid to a logical device identified by its alias and target attributes. Additional attributes can be optionally set. The configuration command is: ztc device alias put uid alias target where uid is the device hardware identifier (as reported by the discovery algorithm), alias is the user defined device name (no spaces allowed) and target is one of the supported the supported devices target. A target specifies what kind of microcontroller, pin routing and additional perpherals can be found on the device. For example, the target for NodeMCU2 development board id nodemcu2 and informs the ZTC about the fact that the configured device is a NodeMCU2 implying an esp8266 microcontroller, a certain pin routing and an onboard FTDI controller. There is no need to write the whole uid in the command, just a few initial character suffice, as the list of known uids is scanned and compared to the given partial uid (may fail if the given partial uid matches more than one uid). Additional options can be given to set other device attributes: --name name set the human readable device name to name (enclose in double quotes if the name contains spaces) --chipid chipid used by external tools to set the device chipid manually --remote_id remote_id used by external tools to set device remote_id manually --classname classname used to set the device classname in case of ambiguity. Aliases can be also removed from the known device list with the command: ztc device alias del alias Device Registration \u00b6 To obtain a virtual machine a device must be registered first. The registration process consists in flashing a registration firmware on the device, obtaining the microcontroller unique identifier and communicating it to the Zerynth backend. The process is almost completely automated, it may simply require the user to put the device is a mode compatible with burning firmware. Device registration is performed by issuing the command: ztc device register alias where alias is the device alias previously set (or just the initial part of it). The result of a correct registration is a device with the registration firmware on it, the device chipid and the device remote_id . Such attributes are automatically added to the device entry in the known device list. The option --skip_burn avoid flashing the device with the registering firmware (it must be made manually!); it can be helpful in contexts where the device is not recognized correctly. Note Devices with multiple modes can be registered one at a time only! Device Registration by UID \u00b6 If the microcontroller unique identifier is already known (i.e. obtained with a JTAG probe), the device can be registered skipping the registration firmware flashing phase. Device registration is performed by issuing the command: ztc device register_by_uid chipid target where chipid is the microcontroller unique identifier and target is the type of the device being registered. A list of available targets can be obtained with the ref:supported . Upon successful registration the device is assigned an UID by the backend. Device Raw Registration \u00b6 Sometimes it is useful to manually provide the device parameters for registration. The parameters that can be provided are: port , the serial port exposed by the device disk , the mass storage path provided by the device probe , the type of JTAG/SWD probe to use during registering The above parameters must be specified using the --spec option followed by the pair parameter name and value separated by a colon (see the example below). Device registration is performed by issuing the command: ztc device register_raw target -- spec port : the_port -- spec disk : the_disk -- spec probe : the_probe It is necessary to provide at least one device parameter and the registration will be attempted gibing priority to the probe parameter. Registration by probe is very fast (and recommended for production scenarios) beacuse the registration firmware is not required. Virtualization \u00b6 Device virtualization consists in flashing a Zerynth virtual machine on a registered device. One or more virtual machines for a device can be obtained with specific ZTC commands. Virtualization is started by: ztc device virtualize alias vmuid where alias is the device alias and vmuid is the unique identifier of the chosen vm. vmuid can be typed partially, ZTC will try to match it against known identifiers. vmuid is obtained during virtual machine creation. The virtualization process is automated, no user interaction is required. Raw Virtualization \u00b6 Device virtualization consists in flashing a Zerynth virtual machine on a registered device. One or more virtual machines for a device can be obtained with specific ZTC commands. Sometimes it is useful to manually provide the device parameters for virtualization. The parameters that can be provided are the same of the register_raw command. Virtualization is started by: ztc device virtualize vmuid -- spec port : the_port -- spec disk : the_disk -- spec probe : the_probe where vmuid is the unique identifier of the chosen vm. vmuid can be typed partially, ZTC will try to match it against known identifiers. vmuid is obtained during virtual machine creation. The virtualization by probe has priority over the other device parameters and is recommended for production scenarios. Serial Console \u00b6 Each virtual machine provides a default serial port where the output of the program is printed. Such port can be opened in full duplex mode allowing bidirectional communication between the device and the terminal. The command: ztc device open alias tries to open the default serial port with the correct parameters for the device. Output from the device is printed to stdout while stdin is redirected to the serial port. Adding the option --echo to the command echoes back the characters from stdin to stdout. Serial Console (raw) \u00b6 Each virtual machine provides a default serial port where the output of the program is printed. Such port can be opened in full duplex mode allowing bidirectional communication between the device and the terminal. it is sometime useful to directly specify the serial port on the command line. The command: ztc device open port tries to open port with the correct parameters for the device. Output from the device is printed to stdout while stdin is redirected to the serial port. Adding the option --echo to the command echoes back the characters from stdin to stdout. Supported Devices \u00b6 Different versions of the ZTC may have a different set of supported devices. To find the device supported by the current installation type: ztc device supported and a table of target names and paths to device support packages will be printed. Erase of the device flash memory \u00b6 Erase completely the flash memory of the device (all data stored will be deleted). This operation is performed by issuing the command: ztc device erase_flash alias where alias is the device alias previously set (or just the initial part of it). Execute a device custom action \u00b6 Some devices provide custom actions to be executed (e.g., burn proprietary bootloaders, put the device in a specific mode). These actions are performed by issuing the command: ztc device custom_action alias action where alias is the device alias previously set (or just the initial part of it) and action is the selected action. Configured Devices \u00b6 Manual device configurations can be saved in a local database in order to avoid retyping device parameters every time. The command: ztc device db list prints the list of configured devices with relevant parameters. By providing the oprion --filter-target the list for a specific target can be retrieved. Add Configured Devices \u00b6 Manual device configurations can be saved in a local database in order to avoid retyping device parameters every time. The relevant parameter for a device are: target , the device type name , the device name. It must be unique and human readable port , the device serial port (may change upon device reset!) disk , the mass storage path of the device (if exposed) probe , the JTAG/SWD probe used for device programming chipid , the device microcontroller unique identifier remote_id , the device UID assigned by the backend after registation If the device name is not present in the database, a new device is created; otherwise the existing device is updated with the provided parameters. To unset a parameter pass the \u201cnull\u201d value (as a string). If a parameter is not given it is not modified in the database. A parameter is set tonull if not specified upon device creation. The command: ztc device db put target device_name -- spec port : the_port -- spec disk : the_disk -- spec probe : the_probe -- spec chipid : the_chipid -- spec remote_uid : the_remote_uid inserts or modifies the configured device device_name in the database. The given parameters are updated as well. For the probe parameter, the list of available probes can be obtained with the probe list command. Remove Configured Devices \u00b6 The command: ztc device db remove device_name removes the device device_name from the configured devices.","title":"Devices"},{"location":"reference/core/toolchain/docs/devices_devcmd/#devices","text":"In the ZTC a device is a peripheral that can execute Zerynth bytecode. In order to do so a device must be prepared and customized with certain attributes. The main attributes of a device are: alias , a unique name given by the user to the device in order to identify it in ZTC commands uid , a unique id provided by the operative system identifying the device at hardware level target , specifies what kind of virtual machine can be run by the device name , a human readable name describing the device. Automatically set by the ZTC chipid , the unique identifier of the microcontroller present on the device remote_id , the unique identifier of the device in the pool of user registered device classname , a Python class name identifying the class containing commands to configure the device When a new device is connected, some steps must be taken in order to make it able to run Zerynth code: The device must be discovered, namely its hardware parameters must be collected ( uid ). Once discovered an alias must be assigned. Depending on the type of device target and classname can be assigned in the same step. The device must be registered in order to create virtual machines for it ( chipid and remote_id are obtained in this step) The device must be :ref:`virtualized , namely a suited virtual machine must be loaded on the device microcontroller Sometimes the device automatic recognition is not enough to gather all the device parameters or to allow the usage of JTAG/SWD probes. In such cases additional commands have been introduced in order to manually specify the additional parameters. A separate database of devices with advanced configurations is maintained. List of device commands: discover alias put register register by uid register raw virtualize virtualize raw supported open open raw db list db put db remove The list of supported devices is available here","title":"Devices"},{"location":"reference/core/toolchain/docs/devices_devcmd/#discover","text":"Device discovery is performed by interrogating the operative system database for USB connected peripherals. Each peripheral returned by the system has at least the following \u201craw\u201d attributes: vid , the USB vendor id pid , the USB product id sid , the unique identifier assigned by the operative system, used to discriminate between multiple connected devices with the same vid:pid port , the virtual serial port used to communicate with the device, if present disk , the mount point of the device, if present uid , a unique identifier assigned by the ZTC desc , the device description provided by the operative system (can differ between different platforms) Raw peripheral data can be obtained by running: ztc device discover Note In Linux peripheral data is obtained by calling into libudev functions. In Windows the WMI interface is used. In Mac calls to ioreg are used. Raw peripheral data are not so useful apart from checking the effective presence of a device. To obtain more useful data the option -- matchdb must be provided. Such option adds another step of device discovery on top of raw peripheral data that is matched against the list of supported devices and the list of already known devices. A --matchdb discovery returns a different set of more high level information: name , the name of the device taken from the ZTC supported device list alias , the device alias (if set) target , the device target, specifying what kind of microcontroller and pcb routing is to be expected on the device uid , the device uid, same as raw peripheral data chipid , the unique identifier of the device microcontrolloer (if known) remote_id , the unique identifier of the device in the Zerynth backend (if set) classname , the Python class in charge of managing the device All the above information is needed to make a device usable in the ZTC. The information provided helps in distinguishing different devices with different behaviours. A device without an alias is a device that is not yet usable, therefore an alias must be set. A device without chipid and remote_id is a device that has not been :ref:`registered yet and can not be virtualized yet. To complicate the matter, there are additional cases that can be spotted during discovery: A physical device can match multiple entries in the ZTC supported device list. This happens because often many different devices are built with the same serial USB chip and therefore they all appear as the same hardware to the operative system. Such device are called \u201cambiguous\u201d because the ZTC can not discriminate their target . For example, both the Mikroelektronika Flip&Click development board and the Arduino Due, share the same microcontroller and the same USB to serial converter and they both appear as a raw peripheral with the same vid:pid . The only way for the ZTC to differentiate between them is to ask the user to set the device target . For ambiguous devices the target can be set while setting the alias . Once the target is set, the device is disambiguated and subsequent discovery will return only one device with the right target . A physical device can appear in two or more different configurations depending on its status. For example, the Particle Photon board has two different modes: the DFU modes in which the device can be flashed (and therefore virtualized) and a \u201cnormal\u201d mode in which the device executes the firmware (and hence the Zerynth bytecode). The device appears as a different raw peripherals in the two modes with different vid:pid . In such cases the two different devices will have the same target and, once registered, the same chipid and remote_id . They will appear to the Zerynth backend as a single device (same remote_id ), but the ZTC device list will have two different devices with different alias and different classname . The classname for such devices can be set while setting the alias. In the case of the Particle Photon, the classname will be \u201cPhotonDFU\u201d for DFU mode and \u201cPhoton\u201d for normal mode. PhotonDFU is the alter_ego of Photon in ZTC terminology. Some development boards do not have USB circuitry and can be programmed only through a JTAG or an external usb-to-serial converter. Such devices can not be discovered. To use them, the programmer device (JTAG or usb-to-serial) must be configured by setting alias and target to the ones the development device. Finally, the discover command can be run in continuous mode by specifying the option --loop . With --loop the command keeps printing the set of discovered devices each time it changes (i.e. a new device is plugged or a connected device is unplugged). In some operative system the continuous discovery is implemented by polling the operative system device database for changes. The polling time can be set with option --looptime milliseconds , by default it is 2000 milliseconds.","title":"Discover"},{"location":"reference/core/toolchain/docs/devices_devcmd/#device-configuration","text":"Before usage a device must be configured. The configuration consists in linking a physical device identified by its uid to a logical device identified by its alias and target attributes. Additional attributes can be optionally set. The configuration command is: ztc device alias put uid alias target where uid is the device hardware identifier (as reported by the discovery algorithm), alias is the user defined device name (no spaces allowed) and target is one of the supported the supported devices target. A target specifies what kind of microcontroller, pin routing and additional perpherals can be found on the device. For example, the target for NodeMCU2 development board id nodemcu2 and informs the ZTC about the fact that the configured device is a NodeMCU2 implying an esp8266 microcontroller, a certain pin routing and an onboard FTDI controller. There is no need to write the whole uid in the command, just a few initial character suffice, as the list of known uids is scanned and compared to the given partial uid (may fail if the given partial uid matches more than one uid). Additional options can be given to set other device attributes: --name name set the human readable device name to name (enclose in double quotes if the name contains spaces) --chipid chipid used by external tools to set the device chipid manually --remote_id remote_id used by external tools to set device remote_id manually --classname classname used to set the device classname in case of ambiguity. Aliases can be also removed from the known device list with the command: ztc device alias del alias","title":"Device configuration"},{"location":"reference/core/toolchain/docs/devices_devcmd/#device-registration","text":"To obtain a virtual machine a device must be registered first. The registration process consists in flashing a registration firmware on the device, obtaining the microcontroller unique identifier and communicating it to the Zerynth backend. The process is almost completely automated, it may simply require the user to put the device is a mode compatible with burning firmware. Device registration is performed by issuing the command: ztc device register alias where alias is the device alias previously set (or just the initial part of it). The result of a correct registration is a device with the registration firmware on it, the device chipid and the device remote_id . Such attributes are automatically added to the device entry in the known device list. The option --skip_burn avoid flashing the device with the registering firmware (it must be made manually!); it can be helpful in contexts where the device is not recognized correctly. Note Devices with multiple modes can be registered one at a time only!","title":"Device Registration"},{"location":"reference/core/toolchain/docs/devices_devcmd/#device-registration-by-uid","text":"If the microcontroller unique identifier is already known (i.e. obtained with a JTAG probe), the device can be registered skipping the registration firmware flashing phase. Device registration is performed by issuing the command: ztc device register_by_uid chipid target where chipid is the microcontroller unique identifier and target is the type of the device being registered. A list of available targets can be obtained with the ref:supported . Upon successful registration the device is assigned an UID by the backend.","title":"Device Registration by UID"},{"location":"reference/core/toolchain/docs/devices_devcmd/#device-raw-registration","text":"Sometimes it is useful to manually provide the device parameters for registration. The parameters that can be provided are: port , the serial port exposed by the device disk , the mass storage path provided by the device probe , the type of JTAG/SWD probe to use during registering The above parameters must be specified using the --spec option followed by the pair parameter name and value separated by a colon (see the example below). Device registration is performed by issuing the command: ztc device register_raw target -- spec port : the_port -- spec disk : the_disk -- spec probe : the_probe It is necessary to provide at least one device parameter and the registration will be attempted gibing priority to the probe parameter. Registration by probe is very fast (and recommended for production scenarios) beacuse the registration firmware is not required.","title":"Device Raw Registration"},{"location":"reference/core/toolchain/docs/devices_devcmd/#virtualization","text":"Device virtualization consists in flashing a Zerynth virtual machine on a registered device. One or more virtual machines for a device can be obtained with specific ZTC commands. Virtualization is started by: ztc device virtualize alias vmuid where alias is the device alias and vmuid is the unique identifier of the chosen vm. vmuid can be typed partially, ZTC will try to match it against known identifiers. vmuid is obtained during virtual machine creation. The virtualization process is automated, no user interaction is required.","title":"Virtualization"},{"location":"reference/core/toolchain/docs/devices_devcmd/#raw-virtualization","text":"Device virtualization consists in flashing a Zerynth virtual machine on a registered device. One or more virtual machines for a device can be obtained with specific ZTC commands. Sometimes it is useful to manually provide the device parameters for virtualization. The parameters that can be provided are the same of the register_raw command. Virtualization is started by: ztc device virtualize vmuid -- spec port : the_port -- spec disk : the_disk -- spec probe : the_probe where vmuid is the unique identifier of the chosen vm. vmuid can be typed partially, ZTC will try to match it against known identifiers. vmuid is obtained during virtual machine creation. The virtualization by probe has priority over the other device parameters and is recommended for production scenarios.","title":"Raw Virtualization"},{"location":"reference/core/toolchain/docs/devices_devcmd/#serial-console","text":"Each virtual machine provides a default serial port where the output of the program is printed. Such port can be opened in full duplex mode allowing bidirectional communication between the device and the terminal. The command: ztc device open alias tries to open the default serial port with the correct parameters for the device. Output from the device is printed to stdout while stdin is redirected to the serial port. Adding the option --echo to the command echoes back the characters from stdin to stdout.","title":"Serial Console"},{"location":"reference/core/toolchain/docs/devices_devcmd/#serial-console-raw","text":"Each virtual machine provides a default serial port where the output of the program is printed. Such port can be opened in full duplex mode allowing bidirectional communication between the device and the terminal. it is sometime useful to directly specify the serial port on the command line. The command: ztc device open port tries to open port with the correct parameters for the device. Output from the device is printed to stdout while stdin is redirected to the serial port. Adding the option --echo to the command echoes back the characters from stdin to stdout.","title":"Serial Console (raw)"},{"location":"reference/core/toolchain/docs/devices_devcmd/#supported-devices","text":"Different versions of the ZTC may have a different set of supported devices. To find the device supported by the current installation type: ztc device supported and a table of target names and paths to device support packages will be printed.","title":"Supported Devices"},{"location":"reference/core/toolchain/docs/devices_devcmd/#erase-of-the-device-flash-memory","text":"Erase completely the flash memory of the device (all data stored will be deleted). This operation is performed by issuing the command: ztc device erase_flash alias where alias is the device alias previously set (or just the initial part of it).","title":"Erase of the device flash memory"},{"location":"reference/core/toolchain/docs/devices_devcmd/#execute-a-device-custom-action","text":"Some devices provide custom actions to be executed (e.g., burn proprietary bootloaders, put the device in a specific mode). These actions are performed by issuing the command: ztc device custom_action alias action where alias is the device alias previously set (or just the initial part of it) and action is the selected action.","title":"Execute a device custom action"},{"location":"reference/core/toolchain/docs/devices_devcmd/#configured-devices","text":"Manual device configurations can be saved in a local database in order to avoid retyping device parameters every time. The command: ztc device db list prints the list of configured devices with relevant parameters. By providing the oprion --filter-target the list for a specific target can be retrieved.","title":"Configured Devices"},{"location":"reference/core/toolchain/docs/devices_devcmd/#add-configured-devices","text":"Manual device configurations can be saved in a local database in order to avoid retyping device parameters every time. The relevant parameter for a device are: target , the device type name , the device name. It must be unique and human readable port , the device serial port (may change upon device reset!) disk , the mass storage path of the device (if exposed) probe , the JTAG/SWD probe used for device programming chipid , the device microcontroller unique identifier remote_id , the device UID assigned by the backend after registation If the device name is not present in the database, a new device is created; otherwise the existing device is updated with the provided parameters. To unset a parameter pass the \u201cnull\u201d value (as a string). If a parameter is not given it is not modified in the database. A parameter is set tonull if not specified upon device creation. The command: ztc device db put target device_name -- spec port : the_port -- spec disk : the_disk -- spec probe : the_probe -- spec chipid : the_chipid -- spec remote_uid : the_remote_uid inserts or modifies the configured device device_name in the database. The given parameters are updated as well. For the probe parameter, the list of available probes can be obtained with the probe list command.","title":"Add Configured Devices"},{"location":"reference/core/toolchain/docs/devices_devcmd/#remove-configured-devices","text":"The command: ztc device db remove device_name removes the device device_name from the configured devices.","title":"Remove Configured Devices"},{"location":"reference/core/toolchain/docs/linter_lintercmd/","text":"Linter \u00b6 The Zerynth Linter permits to check Python code against some of the style conventions. In z-linter command is present a --help option to show to the users a brief description of the related command and its syntax including arguments and option informations. The command return several log messages grouped in 4 main levels (info, warning, error, fatal) to inform the users about the results of the operation. The action that can be executed on Zerynth Linter is: pep8: to check Python script with pep8 style convention Linter Command - pep8 \u00b6 This command is used to check a Python source code against Python Enhancement Proposals 8 (pep8) coding convention from the command line with this syntax: Syntax : ./ ztc linter pep8 data -- file -- json Example : ./ ztc linter pep8 script . py -- file -- json This command take as input the following arguments: * ```data``` ( str ) \u2013 > data to check in raw string format or in path file format ( ```required``` ) * ```file``` ( bool ) \u2013 > select data source : if true is from a file , else is from string ( ```optional``` , default = False ) * ```json``` ( bool ) \u2013 > flag for output format : if true is in json format ( ```optional``` ; default = False ) Errors : * Missing required input data","title":"Linter"},{"location":"reference/core/toolchain/docs/linter_lintercmd/#linter","text":"The Zerynth Linter permits to check Python code against some of the style conventions. In z-linter command is present a --help option to show to the users a brief description of the related command and its syntax including arguments and option informations. The command return several log messages grouped in 4 main levels (info, warning, error, fatal) to inform the users about the results of the operation. The action that can be executed on Zerynth Linter is: pep8: to check Python script with pep8 style convention","title":"Linter"},{"location":"reference/core/toolchain/docs/linter_lintercmd/#linter-command-pep8","text":"This command is used to check a Python source code against Python Enhancement Proposals 8 (pep8) coding convention from the command line with this syntax: Syntax : ./ ztc linter pep8 data -- file -- json Example : ./ ztc linter pep8 script . py -- file -- json This command take as input the following arguments: * ```data``` ( str ) \u2013 > data to check in raw string format or in path file format ( ```required``` ) * ```file``` ( bool ) \u2013 > select data source : if true is from a file , else is from string ( ```optional``` , default = False ) * ```json``` ( bool ) \u2013 > flag for output format : if true is in json format ( ```optional``` ; default = False ) Errors : * Missing required input data","title":"Linter Command - pep8"},{"location":"reference/core/toolchain/docs/misc_misccmd/","text":"Miscellanea \u00b6 Non specific commands are grouped in this section. Linter \u00b6 Not documented yet. Info \u00b6 The info command displays information about the status of the ZTC. It takes the following options (one at a time): --version display the current version of the ZTC. --fullversion display the current version of the ZTC together with current update. --devices display the list of supported devices currently installed. --tools display the list of available ZTC tools. A ZTC tool is a third party program used to accomplish a particular task. For example the gcc compiler for various architecture is a ZTC tool. --modules display the list of installed Zerynth libraries that can be imported in a Zerynth program. --examples display the list of installed examples gathered from all the installed libraries. --vms target display the list of virtual machines in the current installation for the specified target --messages display the list of unread system messages Clean \u00b6 The clean command behave differently based on the following options: --tmp if given clears the temporary folder. --inst version can be repeated multiple times and removes a previous installed version of Zerynth --db if given forgets all devices (clears all devices from database).","title":"Miscellanea"},{"location":"reference/core/toolchain/docs/misc_misccmd/#miscellanea","text":"Non specific commands are grouped in this section.","title":"Miscellanea"},{"location":"reference/core/toolchain/docs/misc_misccmd/#linter","text":"Not documented yet.","title":"Linter"},{"location":"reference/core/toolchain/docs/misc_misccmd/#info","text":"The info command displays information about the status of the ZTC. It takes the following options (one at a time): --version display the current version of the ZTC. --fullversion display the current version of the ZTC together with current update. --devices display the list of supported devices currently installed. --tools display the list of available ZTC tools. A ZTC tool is a third party program used to accomplish a particular task. For example the gcc compiler for various architecture is a ZTC tool. --modules display the list of installed Zerynth libraries that can be imported in a Zerynth program. --examples display the list of installed examples gathered from all the installed libraries. --vms target display the list of virtual machines in the current installation for the specified target --messages display the list of unread system messages","title":"Info"},{"location":"reference/core/toolchain/docs/misc_misccmd/#clean","text":"The clean command behave differently based on the following options: --tmp if given clears the temporary folder. --inst version can be repeated multiple times and removes a previous installed version of Zerynth --db if given forgets all devices (clears all devices from database).","title":"Clean"},{"location":"reference/core/toolchain/docs/packages_nscmd/","text":"Namespaces \u00b6 Namespaces are attributes of packages used to better organize them. A namespace can be created by a user and packages can be subsequently published under it. A namespace is owned by a single user that can publish under it. A namespace can be shared with other users to grant them publishing rights. Create \u00b6 The command: ztc namespace create name will create the namespace name and associate it with the user. There is a limit on the number of namespaces a user can own and the command fails if the limit is reached. Share \u00b6 This feature is not implemented yet. List \u00b6 The command: ztc namespace list retrieves the list of the user namespaces.","title":"Namespaces"},{"location":"reference/core/toolchain/docs/packages_nscmd/#namespaces","text":"Namespaces are attributes of packages used to better organize them. A namespace can be created by a user and packages can be subsequently published under it. A namespace is owned by a single user that can publish under it. A namespace can be shared with other users to grant them publishing rights.","title":"Namespaces"},{"location":"reference/core/toolchain/docs/packages_nscmd/#create","text":"The command: ztc namespace create name will create the namespace name and associate it with the user. There is a limit on the number of namespaces a user can own and the command fails if the limit is reached.","title":"Create"},{"location":"reference/core/toolchain/docs/packages_nscmd/#share","text":"This feature is not implemented yet.","title":"Share"},{"location":"reference/core/toolchain/docs/packages_nscmd/#list","text":"The command: ztc namespace list retrieves the list of the user namespaces.","title":"List"},{"location":"reference/core/toolchain/docs/packages_packagecmd/","text":"Packages \u00b6 The ZTC features a package manager to search and install components of the Zerynth ecosystem. A package is an archive generated from a tagged git repository and identified by a unique fullname . There exist several package types, each one targeting a different Zerynth functionality: core packages contain core Zerynth components (i.e. the ZTC, the Studio, etc\u2026) sys packages contain plaform dependent third party tools used by the ZTC (i.e. gcc, device specific tools, the Python runtime, etc..) board packages contain device definitions vhal packages contain low level drivers for various microcontroller families lib packages contain Zerynth libraries to add new modules to Zerynth programs A package fullname is composed of three fields uniquely identifying the package: type namespace package name For example, the package lib.broadcom.bmc43362 contains the Python driver for the Broadcom bcm43362 wifi chip. Its fullname contains the type ( lib ), the namespace ( broadcom ) grouping all packages implementing Broadcom drivers, and the actual package name ( bcm43362 ) specifying which particular driver is implemented. A package has one or more available versions each one tagged following a modified semantic versioning scheme. Moreover packages can belong to multiple \u201crepositories\u201d (collections of packages). There are two main public repositories, the official one, containing packages created, published and mantained by the Zerynth team, and the community one, containing packages created by community members. The ZTC mantains a local databases of installed packages and refers to the online database of packages to check for updates and new packages. Available versions \u00b6 The available versions of the full Zerynth suite can be retrieved with the command: ztc package versions The command overwrites the local copy of available versions. Details about patches for each version are also contained in the database. Available packages \u00b6 The list of official packages for a specific version of Zerynth can be retrieved with the command: ztc package available version The command returns info on every official Zerynth package. Trigger Update \u00b6 As soon as a new major release of Zerynth is available, it can be installed by triggering it with the following command: ztc package trigger_update The next time the Zerynth installer is started, it will try to install the new version of Zerynth. Install community packages \u00b6 Community packages can be installed and updated with the following command: ztc package install fullname version The package archive will be downloaded and installed from the corresponding Github release tarball. Github Authorization \u00b6 A necessary step in order to publish community packages is the generation of a Github authorization token allowing the ZTC to interact with the user\u2019s Github repositories where the packages are stored and mantained. Retrieve an authorization token with the following command: ztc package authorize The Github authorization url for Zerynth will be opened in the system browser asking for the user credentials. Upon correct authorization, the Zerynth backend will display the user access token that must be copied back to the ZTC prompt. From this point on, the Zerynth user account will be associated with the Github account. Publishing a community library \u00b6 Zerynth projects can be published as library packages and publicly shared on different repositories (default is community ). The library files need to be stored on a public Github repository owned by the user and the repository must be associated with the Zerynth user account by means of the authorize command. The authorization is necessary only on first time publishing; from there on, the Zerynth backend will automatically query Github for library updates. The library updates are managed through Github releases ; when a new version is ready, a Github release is created (manually or via ZTC) with a tag and a description. The release tag will be used as the library version while the release description will be used as library changelog. In order to convert a project into a publishable library, a json file with the library info must be created and filled with: title : the title of the library (will be shown in Zerynth Studio library manager) description : a longer description of the library (will be shown in Zerynth Studio library manager) keywords : an array of keywords to make the library easily searchable version : the version to assign to the current release of the library. It is suggested to keep using the Zerynth convention (rx.y.z). release : the current release description. It can be used as a changelog and it will be shown in Zerynth Studio as the text associated to this specific version of the library. An example of such file: { \"title\" : \"DS1307 Real Time Clock\" , \"description\" : \"Foo's DS1307 RTC Driver ... \" , \"keywords\" : [ \"rtc\" , \"maxim\" , \"time\" ], \"release\" : \"Fixed I2C bugs\" , \"version\" : \"r2.0.0\" } The library can be published in two ways: manual and automatic. In the manual procedure, the user is responsible for manually updating the Github repository and create the Github release. In this case, it is necessary to publish the library just once providing title ,:samp:description and keywords in the json file. Each time the user adds a new release, the Zerynth backend will automatically include the new release in the available versions of the library. In the automatic procedure, the user is responsible for the creation of a Github repository to store the library while the management of the repository updates and the release creation is performed by th ZTC. In this case the additional version and release must be given in the json file. It is suggested to store the json file in the Github repository itself to track its changes. The command: ztc package publish reponame json_file will publish the library with the manual procedure. It just informs the Zerynth backend of a new association between reponame and the user account (already associated with a Github account). The user must then create every new Github release to make the library updates available to users. The command: ztc package publish reponame json_file -- automatic project_dir will publish the library with the automatic procedure. The following operations are performed: the Zerynth backend is informed of a new association between reponame and the user account the reponame Github repository is clone to a temp directory the project files in the folder project_dir are copied to the cloned repository a new commit is created the commit is pushed to the Github repository master branch the commit is tagged with the version field of json_file a new Github release is created using the release field of json_file as the descriptive text The resulting library will be importable as: from community.github_username.repo_name import ... where github_username and repo_name are the Github username and Github repository name associated to the library, with minus signs ( - ) replaced by underscores ( _ ). For example, if the user foo wants to publish the bar library, the following steps must be taken: a json file with the required fields is created, bar.json . the library files are stored in the folder bar_lib . the command ztc package publish bar --automatic bar_lib is used to publish the library community.foo.bar Library Documentation \u00b6 It is suggested to write the library documentation in the README.md file in the root of the repository. Zerynth Studio will redirect users to the Github repository page for doc info. Library Examples \u00b6 Libraries can bedistributed with a set of examples stored under an examples folder in the project. Each example must be contained in its own folder accordinto to the following requirements: The example folder name will be converted into the example \u201ctitle\u201d (shown in the Zerynth Studio example panel) by replacing underscores (\u201c_\u201d) with spaces The example folder can contain any number of files, but only two are mandatory: main.py , the entry point file and project.md , a description of the example. Both files will be automatically included in the library documentation. Moreover, for the examples to be displayed in the Zerynth Studio example panel, a file order.txt must be placed in the examples folder. It contains information about the example positioning in the example tree: ; order . txt of the lib . adafruit . neopixel package ; comments starts with \";\" ; inner tree nodes labels start with a number of \"#\" corresponding to their level ; leaves corresponds to the actual example folder name #Adafruit ##Neopixel Neopixel_LED_Strips Neopixel_Advanced ; this files is translated to : ; example root ; | ; |--- ... ; |--- ... ; |--- Adafruit ; | |--- ... ; | \\ --- Neopixel ; | |--- Neopixel LED Strips ; | \\ --- Neopixel Advanced ; |--- ... ; |--- ... Installed packages \u00b6 The list of currently installed official and community packages (of type lib) can be retrieved with: ztc package installed","title":"Packages"},{"location":"reference/core/toolchain/docs/packages_packagecmd/#packages","text":"The ZTC features a package manager to search and install components of the Zerynth ecosystem. A package is an archive generated from a tagged git repository and identified by a unique fullname . There exist several package types, each one targeting a different Zerynth functionality: core packages contain core Zerynth components (i.e. the ZTC, the Studio, etc\u2026) sys packages contain plaform dependent third party tools used by the ZTC (i.e. gcc, device specific tools, the Python runtime, etc..) board packages contain device definitions vhal packages contain low level drivers for various microcontroller families lib packages contain Zerynth libraries to add new modules to Zerynth programs A package fullname is composed of three fields uniquely identifying the package: type namespace package name For example, the package lib.broadcom.bmc43362 contains the Python driver for the Broadcom bcm43362 wifi chip. Its fullname contains the type ( lib ), the namespace ( broadcom ) grouping all packages implementing Broadcom drivers, and the actual package name ( bcm43362 ) specifying which particular driver is implemented. A package has one or more available versions each one tagged following a modified semantic versioning scheme. Moreover packages can belong to multiple \u201crepositories\u201d (collections of packages). There are two main public repositories, the official one, containing packages created, published and mantained by the Zerynth team, and the community one, containing packages created by community members. The ZTC mantains a local databases of installed packages and refers to the online database of packages to check for updates and new packages.","title":"Packages"},{"location":"reference/core/toolchain/docs/packages_packagecmd/#available-versions","text":"The available versions of the full Zerynth suite can be retrieved with the command: ztc package versions The command overwrites the local copy of available versions. Details about patches for each version are also contained in the database.","title":"Available versions"},{"location":"reference/core/toolchain/docs/packages_packagecmd/#available-packages","text":"The list of official packages for a specific version of Zerynth can be retrieved with the command: ztc package available version The command returns info on every official Zerynth package.","title":"Available packages"},{"location":"reference/core/toolchain/docs/packages_packagecmd/#trigger-update","text":"As soon as a new major release of Zerynth is available, it can be installed by triggering it with the following command: ztc package trigger_update The next time the Zerynth installer is started, it will try to install the new version of Zerynth.","title":"Trigger Update"},{"location":"reference/core/toolchain/docs/packages_packagecmd/#install-community-packages","text":"Community packages can be installed and updated with the following command: ztc package install fullname version The package archive will be downloaded and installed from the corresponding Github release tarball.","title":"Install community packages"},{"location":"reference/core/toolchain/docs/packages_packagecmd/#github-authorization","text":"A necessary step in order to publish community packages is the generation of a Github authorization token allowing the ZTC to interact with the user\u2019s Github repositories where the packages are stored and mantained. Retrieve an authorization token with the following command: ztc package authorize The Github authorization url for Zerynth will be opened in the system browser asking for the user credentials. Upon correct authorization, the Zerynth backend will display the user access token that must be copied back to the ZTC prompt. From this point on, the Zerynth user account will be associated with the Github account.","title":"Github Authorization"},{"location":"reference/core/toolchain/docs/packages_packagecmd/#publishing-a-community-library","text":"Zerynth projects can be published as library packages and publicly shared on different repositories (default is community ). The library files need to be stored on a public Github repository owned by the user and the repository must be associated with the Zerynth user account by means of the authorize command. The authorization is necessary only on first time publishing; from there on, the Zerynth backend will automatically query Github for library updates. The library updates are managed through Github releases ; when a new version is ready, a Github release is created (manually or via ZTC) with a tag and a description. The release tag will be used as the library version while the release description will be used as library changelog. In order to convert a project into a publishable library, a json file with the library info must be created and filled with: title : the title of the library (will be shown in Zerynth Studio library manager) description : a longer description of the library (will be shown in Zerynth Studio library manager) keywords : an array of keywords to make the library easily searchable version : the version to assign to the current release of the library. It is suggested to keep using the Zerynth convention (rx.y.z). release : the current release description. It can be used as a changelog and it will be shown in Zerynth Studio as the text associated to this specific version of the library. An example of such file: { \"title\" : \"DS1307 Real Time Clock\" , \"description\" : \"Foo's DS1307 RTC Driver ... \" , \"keywords\" : [ \"rtc\" , \"maxim\" , \"time\" ], \"release\" : \"Fixed I2C bugs\" , \"version\" : \"r2.0.0\" } The library can be published in two ways: manual and automatic. In the manual procedure, the user is responsible for manually updating the Github repository and create the Github release. In this case, it is necessary to publish the library just once providing title ,:samp:description and keywords in the json file. Each time the user adds a new release, the Zerynth backend will automatically include the new release in the available versions of the library. In the automatic procedure, the user is responsible for the creation of a Github repository to store the library while the management of the repository updates and the release creation is performed by th ZTC. In this case the additional version and release must be given in the json file. It is suggested to store the json file in the Github repository itself to track its changes. The command: ztc package publish reponame json_file will publish the library with the manual procedure. It just informs the Zerynth backend of a new association between reponame and the user account (already associated with a Github account). The user must then create every new Github release to make the library updates available to users. The command: ztc package publish reponame json_file -- automatic project_dir will publish the library with the automatic procedure. The following operations are performed: the Zerynth backend is informed of a new association between reponame and the user account the reponame Github repository is clone to a temp directory the project files in the folder project_dir are copied to the cloned repository a new commit is created the commit is pushed to the Github repository master branch the commit is tagged with the version field of json_file a new Github release is created using the release field of json_file as the descriptive text The resulting library will be importable as: from community.github_username.repo_name import ... where github_username and repo_name are the Github username and Github repository name associated to the library, with minus signs ( - ) replaced by underscores ( _ ). For example, if the user foo wants to publish the bar library, the following steps must be taken: a json file with the required fields is created, bar.json . the library files are stored in the folder bar_lib . the command ztc package publish bar --automatic bar_lib is used to publish the library community.foo.bar","title":"Publishing a community library"},{"location":"reference/core/toolchain/docs/packages_packagecmd/#library-documentation","text":"It is suggested to write the library documentation in the README.md file in the root of the repository. Zerynth Studio will redirect users to the Github repository page for doc info.","title":"Library Documentation"},{"location":"reference/core/toolchain/docs/packages_packagecmd/#library-examples","text":"Libraries can bedistributed with a set of examples stored under an examples folder in the project. Each example must be contained in its own folder accordinto to the following requirements: The example folder name will be converted into the example \u201ctitle\u201d (shown in the Zerynth Studio example panel) by replacing underscores (\u201c_\u201d) with spaces The example folder can contain any number of files, but only two are mandatory: main.py , the entry point file and project.md , a description of the example. Both files will be automatically included in the library documentation. Moreover, for the examples to be displayed in the Zerynth Studio example panel, a file order.txt must be placed in the examples folder. It contains information about the example positioning in the example tree: ; order . txt of the lib . adafruit . neopixel package ; comments starts with \";\" ; inner tree nodes labels start with a number of \"#\" corresponding to their level ; leaves corresponds to the actual example folder name #Adafruit ##Neopixel Neopixel_LED_Strips Neopixel_Advanced ; this files is translated to : ; example root ; | ; |--- ... ; |--- ... ; |--- Adafruit ; | |--- ... ; | \\ --- Neopixel ; | |--- Neopixel LED Strips ; | \\ --- Neopixel Advanced ; |--- ... ; |--- ...","title":"Library Examples"},{"location":"reference/core/toolchain/docs/packages_packagecmd/#installed-packages","text":"The list of currently installed official and community packages (of type lib) can be retrieved with: ztc package installed","title":"Installed packages"},{"location":"reference/core/toolchain/docs/projects_projectcmd/","text":"Projects \u00b6 A Zerynth project consists of a directory containing source code files, documentation files and other assets as needed. The project directory must also contain a .zproject file containing information about the project. .zproject creation and management is completely handled by the ZTC. The following project commands are available: create git_init and related repository management commands list remote projects make_doc Create a project \u00b6 A project can be created by issuing the following command: ztc project create title path where title is a string (preferably enclosed in double quotes) representing the title of the project and path is the path to the directory that will hold the project files. If such directory does not exist, it is created. If a project already exists at path , the command fails. An empty project consists of three files: main.py , the empty template for the entry point of the program. readme.md , a description file initially filled with project title and description in markdown format. .zproject , a project info file used by the ZTC. Projects can also be stored remotely on the Zerynth backend as git repositories. In order to do so, during project creation, an attempt is made to create a new project entity on the backend and prepare it to receive git operations. If such attempt fails, the project is still usable locally and can be remotely added later. The create can also accept the following options: --from from where from is a path. If the option is given, all files and directories stored at from will be recursively copied in the new project directory. If the project directory at path already exists, its contents will be deleted before copying from from . --description desc where desc is a string (preferably enclosed in double quotes) that will be written in readme.md Initialize a Git Repository \u00b6 Projects can be stored as private remote git repositories on the Zerynth backend. In order to do so it is necessary to initialize a project as a git repository with the command: ztc project git_init path where path is the project directory. If the project is not already registered in the backend, the remote creation is performed first and a bare remote repository is setup. Subsequently, if the project directory already contains a git repository, such repository is configured by adding a new remote called zerynth . Otherwise a fresh git repository is initialized. Zerynth remote repositories require authentication by basic HTTP authentication mechanism. The HTTPS url of the git repository is modified by adding the user token as username and x-oath-basic as password. If the token expires or is invalidated, the git_init command can be repeated to update the remote with a fresh token. Check repository status \u00b6 The command: ztc project git_status path Returns information about the current status of the repository at path . In particular the current branch and tag, together with the list of modified files not yet committed. It also returns the status of the repository HEAD with respect to the selected remote. The default remote is zerynth and can be changed with the option --remote . Fetch repository \u00b6 The command: ztc project git_fetch path is equivalent to the git fetch command executed at path'. The default remote is :samp:\\ zerynth and can be changed with the option --remote`. Commit \u00b6 The command: ztc project git_commit path - m message is equivalent to the command sequence git add . and git commit -m \"message\" executed at path . Push to remote \u00b6 The command: ztc project git_push path -- remote remote is equivalent to the command git push origin remote executed at path . Pull from remote \u00b6 The command: ztc project git_pull path -- remote remote is equivalent to the command git pull executed at path for remote remote . Switch/Create branch \u00b6 The command: ztc project git_branch path branch -- remote remote behave differently if the branch already exists locally. In this case the command checks out the branch. If branch does not exist, it is created locally and pushed to the remote . Clone a project \u00b6 The command: ztc project git_clone project path retrieves a project repository saved to the Zerynth backend and clones it to path . The parameter project is the project uid assigned dring project creation. It can be retrieved with the list command. Clone a project \u00b6 The command: ztc project git_clone project path retrieves a project repository saved to the Zerynth backend and clones it to path . The parameter project is the project uid assigned dring project creation. It can be retrieved with the list command. List remote projects \u00b6 The command: ztc project list retrieves the list of projects saved to the Zerynth backend. Each project is identified by an uid . The max number of results is 50, the option --from n can be used to specify the starting index of the list to be retrieved. Build Documentation \u00b6 A project can be documented in reStructuredText format and the corresponding HTML documentation can be generated by Sphinx . The process is automated by the following command: ztc project make_doc path where path is the path to the project directory. If the command has never been run before on the project, some documentation accessory files are created. In particular: docs directory inside the project docs/index.rst , the main documentation file docs/docs.json , a configuration file to specify the structure of the documentation. When automatically created, it contains the following fields: title , the title of the documentation version , not used at the moment copyright , not used at the moment text , used for nested json files, see below files , a list of tuples. The second element of the tuple is the file to be scanned for documentation: the first element of the tuple is the title of the corresponding generated documentation. The file types accepted are .py, .rst and .json. File paths are specified relative to the project directory. All files specified in docs.json are processed: Python files are scanned for docstrings that are extracted to generate the corresponding .rst file inside docs . rst files are included in the documentation as is json files must have the same structure of docs/docs.json and generate a rst file containing the specified title, the field text (if given) as a preamble and a table of contents generated from the contents of the files field. By default the documentation is generated in a temporary directory, but it can also be generated in a user specified directory by adding the option --to doc_path to the command. The option --open can be added to fire up the system browser and show the built documentation at the end of the command. Note a docs/__toc.rst file is always generated containing the table of contents for the project documentation. It MUST be included in docs/index.rst in order to correctly build the documentation. Configure \u00b6 The command: ztc project config path - D ZERYNTH_SSL 1 - X ZERYNTH_SSL_ECDSA configures some project variables that turn on and off advanced features for the project at path . In particular the -D option adds a new variable with its corresponding value to the project configuration, whereas the -X option remove a variable. Both options can be repeated multiple times.","title":"Projects"},{"location":"reference/core/toolchain/docs/projects_projectcmd/#projects","text":"A Zerynth project consists of a directory containing source code files, documentation files and other assets as needed. The project directory must also contain a .zproject file containing information about the project. .zproject creation and management is completely handled by the ZTC. The following project commands are available: create git_init and related repository management commands list remote projects make_doc","title":"Projects"},{"location":"reference/core/toolchain/docs/projects_projectcmd/#create-a-project","text":"A project can be created by issuing the following command: ztc project create title path where title is a string (preferably enclosed in double quotes) representing the title of the project and path is the path to the directory that will hold the project files. If such directory does not exist, it is created. If a project already exists at path , the command fails. An empty project consists of three files: main.py , the empty template for the entry point of the program. readme.md , a description file initially filled with project title and description in markdown format. .zproject , a project info file used by the ZTC. Projects can also be stored remotely on the Zerynth backend as git repositories. In order to do so, during project creation, an attempt is made to create a new project entity on the backend and prepare it to receive git operations. If such attempt fails, the project is still usable locally and can be remotely added later. The create can also accept the following options: --from from where from is a path. If the option is given, all files and directories stored at from will be recursively copied in the new project directory. If the project directory at path already exists, its contents will be deleted before copying from from . --description desc where desc is a string (preferably enclosed in double quotes) that will be written in readme.md","title":"Create a project"},{"location":"reference/core/toolchain/docs/projects_projectcmd/#initialize-a-git-repository","text":"Projects can be stored as private remote git repositories on the Zerynth backend. In order to do so it is necessary to initialize a project as a git repository with the command: ztc project git_init path where path is the project directory. If the project is not already registered in the backend, the remote creation is performed first and a bare remote repository is setup. Subsequently, if the project directory already contains a git repository, such repository is configured by adding a new remote called zerynth . Otherwise a fresh git repository is initialized. Zerynth remote repositories require authentication by basic HTTP authentication mechanism. The HTTPS url of the git repository is modified by adding the user token as username and x-oath-basic as password. If the token expires or is invalidated, the git_init command can be repeated to update the remote with a fresh token.","title":"Initialize a Git Repository"},{"location":"reference/core/toolchain/docs/projects_projectcmd/#check-repository-status","text":"The command: ztc project git_status path Returns information about the current status of the repository at path . In particular the current branch and tag, together with the list of modified files not yet committed. It also returns the status of the repository HEAD with respect to the selected remote. The default remote is zerynth and can be changed with the option --remote .","title":"Check repository status"},{"location":"reference/core/toolchain/docs/projects_projectcmd/#fetch-repository","text":"The command: ztc project git_fetch path is equivalent to the git fetch command executed at path'. The default remote is :samp:\\ zerynth and can be changed with the option --remote`.","title":"Fetch repository"},{"location":"reference/core/toolchain/docs/projects_projectcmd/#commit","text":"The command: ztc project git_commit path - m message is equivalent to the command sequence git add . and git commit -m \"message\" executed at path .","title":"Commit"},{"location":"reference/core/toolchain/docs/projects_projectcmd/#push-to-remote","text":"The command: ztc project git_push path -- remote remote is equivalent to the command git push origin remote executed at path .","title":"Push to remote"},{"location":"reference/core/toolchain/docs/projects_projectcmd/#pull-from-remote","text":"The command: ztc project git_pull path -- remote remote is equivalent to the command git pull executed at path for remote remote .","title":"Pull from remote"},{"location":"reference/core/toolchain/docs/projects_projectcmd/#switchcreate-branch","text":"The command: ztc project git_branch path branch -- remote remote behave differently if the branch already exists locally. In this case the command checks out the branch. If branch does not exist, it is created locally and pushed to the remote .","title":"Switch/Create branch"},{"location":"reference/core/toolchain/docs/projects_projectcmd/#clone-a-project","text":"The command: ztc project git_clone project path retrieves a project repository saved to the Zerynth backend and clones it to path . The parameter project is the project uid assigned dring project creation. It can be retrieved with the list command.","title":"Clone a project"},{"location":"reference/core/toolchain/docs/projects_projectcmd/#clone-a-project_1","text":"The command: ztc project git_clone project path retrieves a project repository saved to the Zerynth backend and clones it to path . The parameter project is the project uid assigned dring project creation. It can be retrieved with the list command.","title":"Clone a project"},{"location":"reference/core/toolchain/docs/projects_projectcmd/#list-remote-projects","text":"The command: ztc project list retrieves the list of projects saved to the Zerynth backend. Each project is identified by an uid . The max number of results is 50, the option --from n can be used to specify the starting index of the list to be retrieved.","title":"List remote projects"},{"location":"reference/core/toolchain/docs/projects_projectcmd/#build-documentation","text":"A project can be documented in reStructuredText format and the corresponding HTML documentation can be generated by Sphinx . The process is automated by the following command: ztc project make_doc path where path is the path to the project directory. If the command has never been run before on the project, some documentation accessory files are created. In particular: docs directory inside the project docs/index.rst , the main documentation file docs/docs.json , a configuration file to specify the structure of the documentation. When automatically created, it contains the following fields: title , the title of the documentation version , not used at the moment copyright , not used at the moment text , used for nested json files, see below files , a list of tuples. The second element of the tuple is the file to be scanned for documentation: the first element of the tuple is the title of the corresponding generated documentation. The file types accepted are .py, .rst and .json. File paths are specified relative to the project directory. All files specified in docs.json are processed: Python files are scanned for docstrings that are extracted to generate the corresponding .rst file inside docs . rst files are included in the documentation as is json files must have the same structure of docs/docs.json and generate a rst file containing the specified title, the field text (if given) as a preamble and a table of contents generated from the contents of the files field. By default the documentation is generated in a temporary directory, but it can also be generated in a user specified directory by adding the option --to doc_path to the command. The option --open can be added to fire up the system browser and show the built documentation at the end of the command. Note a docs/__toc.rst file is always generated containing the table of contents for the project documentation. It MUST be included in docs/index.rst in order to correctly build the documentation.","title":"Build Documentation"},{"location":"reference/core/toolchain/docs/projects_projectcmd/#configure","text":"The command: ztc project config path - D ZERYNTH_SSL 1 - X ZERYNTH_SSL_ECDSA configures some project variables that turn on and off advanced features for the project at path . In particular the -D option adds a new variable with its corresponding value to the project configuration, whereas the -X option remove a variable. Both options can be repeated multiple times.","title":"Configure"},{"location":"reference/core/toolchain/docs/provisioning_provisioningcmd/","text":"Provisioning \u00b6 The Zerynth Toolchain allows to easily provision cryto elements by means of the provisioning commands group. Uplink Configurator Firmware to the device \u00b6 The command: ztc provisioning uplink - config - firmware device_alias Performs a preliminary step for subsequent provisioning commands. A Configurator firmware is compiled and flashed onto the device, with alias alias , the crypto element to provision is plugged to. The Configurator makes the device ready to accept serial commands which will be translated into provisioning actions. The implementation of the Configurator is dependent on target cryptoelement, but not on the device used to provision it. Available command options are: --cryptofamily family , to specify the family of the crypto element to provision (at the moment ateccx08a is the only supported option). Default family is ateccx08a ; --cryptodevice device , to specify the device, from those available in chosen family, to provision. For ateccx08a family, devices atecc508a is supported and can be chosen with a device value of 5 which is also the default for ateccx08a family; --i2caddr address , to specify the i2c address of the crypto element. Needed only if the crypto element uses an i2c interface. Default address value depends on chosen family: 0x60 for ateccx08a family; --i2cdrv drv , to specify the device i2c driver the crypto element is plugged to. Needed only if the crypto element uses an i2c interface. drv can be I2C0 , I2C1 , \u2026 . Default drv value is I2C0 . Scan for a Crypto Element Address \u00b6 The command: ztc provisioning crypto - scan device_alias Available command options are: --output path , to specify a path to store scanned device address and type. If a folder is given, retrieved info is saved to scanned_crypto.json file. Note It is mandatory for the following commands to correctly execute to flash the Configurator firmware first. Read Crypto Element Configuration \u00b6 The command: ztc provisioning read - config device_alias Reads and outputs the configuration of the crypto element plugged to device with alias alias . Available command options are: --output path , to specify a path to store read configuration in binary format. Retrieve Public Key \u00b6 The command: ztc provisioning get - public device_alias private_slot Retrieves the public key derived from private key stored in private_slot key slot of the crypto element plugged to the device with alias device_alias . Available command options are: --format pubkey_format , to specify the output format of the public key: pem or hex . pem by default; --output path , to specify a path to store retrieved public key. If a folder is given, the key is saved to public.pubkey_format file. Write Crypto Element Configuration \u00b6 The command: ztc provisioning write - config device_alias configuration_file Writes configuration specified in configuration_file file to the crypto element plugged to device with alias device_alias . Configuration can be a YAML or a binary file. An example YAML configuration file can be copied to configuration_file path if get is passed as device_alias : ztc provisioning write - config get 'my_configuration.yaml' while valid binary configurations are output by the read config command. Available command options are: --lock lock_value , if True locks written configuration; Get Certificate Signing Request \u00b6 The command: ztc provisioning get - csr device_alias private_slot subject Retrieves a Certificate Signing Request built on subject subject and signed with private key store in slot private_slot of the crypto element plugged to device with alias alias . subject is a string containing a comma-separated list of OID types and values (e.g. \"C=IT,O=ZER,CN=device 1\" ). Available command options are: --output path , to specify a path to store retrieved CSR. If a folder is given, the CSR is saved to atecc.csr file. Locked \u00b6 The command: ztc provisioning locked device_alias Outputs the lock state of the crypto element plugged to device with alias alias . Serial Number \u00b6 The command: ztc provisioning serial - number device_alias Outputs the serial number of the crypto element plugged to device with alias alias . Store Public \u00b6 The command: ztc provisioning store - public device_alias slot public_key Stores a public key in slot slot of the crypto element plugged to device with alias alias . Public key is retrieved from file public_key and is expected to be in pem format. Store Certificate \u00b6 The command: ztc provisioning store - certificate device_alias certificate_type certificate Stores a compressed certificate to the crypto element plugged to device with alias alias . Certificate is retrieved from file certificate and is expected to be in pem format.","title":"Provisioning"},{"location":"reference/core/toolchain/docs/provisioning_provisioningcmd/#provisioning","text":"The Zerynth Toolchain allows to easily provision cryto elements by means of the provisioning commands group.","title":"Provisioning"},{"location":"reference/core/toolchain/docs/provisioning_provisioningcmd/#uplink-configurator-firmware-to-the-device","text":"The command: ztc provisioning uplink - config - firmware device_alias Performs a preliminary step for subsequent provisioning commands. A Configurator firmware is compiled and flashed onto the device, with alias alias , the crypto element to provision is plugged to. The Configurator makes the device ready to accept serial commands which will be translated into provisioning actions. The implementation of the Configurator is dependent on target cryptoelement, but not on the device used to provision it. Available command options are: --cryptofamily family , to specify the family of the crypto element to provision (at the moment ateccx08a is the only supported option). Default family is ateccx08a ; --cryptodevice device , to specify the device, from those available in chosen family, to provision. For ateccx08a family, devices atecc508a is supported and can be chosen with a device value of 5 which is also the default for ateccx08a family; --i2caddr address , to specify the i2c address of the crypto element. Needed only if the crypto element uses an i2c interface. Default address value depends on chosen family: 0x60 for ateccx08a family; --i2cdrv drv , to specify the device i2c driver the crypto element is plugged to. Needed only if the crypto element uses an i2c interface. drv can be I2C0 , I2C1 , \u2026 . Default drv value is I2C0 .","title":"Uplink Configurator Firmware to the device"},{"location":"reference/core/toolchain/docs/provisioning_provisioningcmd/#scan-for-a-crypto-element-address","text":"The command: ztc provisioning crypto - scan device_alias Available command options are: --output path , to specify a path to store scanned device address and type. If a folder is given, retrieved info is saved to scanned_crypto.json file. Note It is mandatory for the following commands to correctly execute to flash the Configurator firmware first.","title":"Scan for a Crypto Element Address"},{"location":"reference/core/toolchain/docs/provisioning_provisioningcmd/#read-crypto-element-configuration","text":"The command: ztc provisioning read - config device_alias Reads and outputs the configuration of the crypto element plugged to device with alias alias . Available command options are: --output path , to specify a path to store read configuration in binary format.","title":"Read Crypto Element Configuration"},{"location":"reference/core/toolchain/docs/provisioning_provisioningcmd/#retrieve-public-key","text":"The command: ztc provisioning get - public device_alias private_slot Retrieves the public key derived from private key stored in private_slot key slot of the crypto element plugged to the device with alias device_alias . Available command options are: --format pubkey_format , to specify the output format of the public key: pem or hex . pem by default; --output path , to specify a path to store retrieved public key. If a folder is given, the key is saved to public.pubkey_format file.","title":"Retrieve Public Key"},{"location":"reference/core/toolchain/docs/provisioning_provisioningcmd/#write-crypto-element-configuration","text":"The command: ztc provisioning write - config device_alias configuration_file Writes configuration specified in configuration_file file to the crypto element plugged to device with alias device_alias . Configuration can be a YAML or a binary file. An example YAML configuration file can be copied to configuration_file path if get is passed as device_alias : ztc provisioning write - config get 'my_configuration.yaml' while valid binary configurations are output by the read config command. Available command options are: --lock lock_value , if True locks written configuration;","title":"Write Crypto Element Configuration"},{"location":"reference/core/toolchain/docs/provisioning_provisioningcmd/#get-certificate-signing-request","text":"The command: ztc provisioning get - csr device_alias private_slot subject Retrieves a Certificate Signing Request built on subject subject and signed with private key store in slot private_slot of the crypto element plugged to device with alias alias . subject is a string containing a comma-separated list of OID types and values (e.g. \"C=IT,O=ZER,CN=device 1\" ). Available command options are: --output path , to specify a path to store retrieved CSR. If a folder is given, the CSR is saved to atecc.csr file.","title":"Get Certificate Signing Request"},{"location":"reference/core/toolchain/docs/provisioning_provisioningcmd/#locked","text":"The command: ztc provisioning locked device_alias Outputs the lock state of the crypto element plugged to device with alias alias .","title":"Locked"},{"location":"reference/core/toolchain/docs/provisioning_provisioningcmd/#serial-number","text":"The command: ztc provisioning serial - number device_alias Outputs the serial number of the crypto element plugged to device with alias alias .","title":"Serial Number"},{"location":"reference/core/toolchain/docs/provisioning_provisioningcmd/#store-public","text":"The command: ztc provisioning store - public device_alias slot public_key Stores a public key in slot slot of the crypto element plugged to device with alias alias . Public key is retrieved from file public_key and is expected to be in pem format.","title":"Store Public"},{"location":"reference/core/toolchain/docs/provisioning_provisioningcmd/#store-certificate","text":"The command: ztc provisioning store - certificate device_alias certificate_type certificate Stores a compressed certificate to the crypto element plugged to device with alias alias . Certificate is retrieved from file certificate and is expected to be in pem format.","title":"Store Certificate"},{"location":"reference/core/toolchain/docs/things_thingcmd/","text":"Connected Devices \u00b6 The Zerynth Advanced Device Manager (ADM) allows connections between the devices programmed with Zerynth and the ADM sandbox instance hosted on the Zerynth backend server. The ADM adds to each connected device the following functionalities: executing functions triggered by a remote request (remote procedure call) performing over the air firmware update (FOTA) displaying and interacting with a graphical user interface both on a mobile app or desktop browser Such functionalities can be configured and controlled through the following ZTC commands: Create a connected device Retrieve info on a connected device Set properties of a connected device Retrieve the list of connected devices Create groups of devices Add a connected device to a group List groups of devices Create a graphical template Update a graphical template List all graphical templates Prepare for a FOTA update Check for FOTA status Start a FOTA update Stop a FOTA update Details about the ADM can be found here. Create a connected device \u00b6 In order to connect a physical device to the ADM, a bit of device provisioning must be made. In particular, a new connected device instance must be created on the ADM and the assigned credentials used in the script running on the physical device. The command: ztc thing add name creates a new connected device instance with name name in the ADM server. Such instance can have many different properties, but only a subset of them is mandatory and generated by the ADM: uid : the unique identifier of the connected device token : the security token used to authenticate the physical device to the ADM Additional properties can be specified at the moment of creation by specifying the corresponding options: --location loc adds the description of the location the physical device is placed --lat lat --lon lon attaches coordinates to the device --description desc specifies the device description --tag tag attaches a set of tags to the device (the option can be given multiple times) Each Zerynth user can create an unlimited number of connected devices instances, however only a subset of them is allowed to be connected to the ADM at the same moment. Retrieves device info \u00b6 The command: ztc thing info uid retrieves information about the connected device with unique identifier uid . The information retrieved consists of: token , the security token for the device name , the device name description , the device description location , the description of the device location geo , the latitude and longitude of the device position groups , the list of groups the device belongs to last_seen , the time of the last detected presence of the connected device online , the status of the device connection platform , the type of the physical device using this connected device credentials notifications , a boolean determing if mobile notifications are enabled for this device Configure a device \u00b6 The command: ztc thing config uid sets the properties of the connected device with unique identifier uid . The properties are specified with the following options: --name name , changes the device name :option: \u2013description desc, changes the device description --location loc , changes the device location --lat x / --lon y , change the device coordinates --token , asks for a new security token --template template_uid , sets the device template Connected devices list \u00b6 The command: ztc thing config list retrieves the list of connected devices. Options can be specified to filter the results: --from n , skips the first n connected devices. Default n is zero. --status online/offline , filters connected devices based on online status. If not given, all devices are retrieved Create a group of devices \u00b6 The command: ztc thing group add name creates a group named name , initially empty. Devices can be added to the group with the config command. Group configuration \u00b6 The command: ztc thing group config uid -- add dev0_uid -- remove dev1_uid can be used to add or remove devices (identified by their uids dev0_uid and dev1_uid ) to the group identifiedby uid . The options --add and --remove can be repeated multiple times in the same command. Group configuration \u00b6 The command: ztc thing group list retrieves the list of all groups. The option --from n can be used to skip the first n groups. Create a device template \u00b6 The Zerynth ADM allows to remotely store a graphical interface for each connected device called device template. A template is just a collection of HTML5, javascript, css and image files hosted on the ADM backend. The template is able to receive and send messages to the connected device in response to user interactions with its graphical components. The command: ztc thing template add name creates a new empty template named name . A template is identified by a generated uid. Upload a template \u00b6 A newly created template is empty. Files and subfolders can be added to the template with the following command: ztc thing template upload uid path where path is the folder containing the template files and uid is the uid indentifying the template to update. The files at path are compressed and transferred to the ADM backend. There are limitations on the size of a template and on the type of files that can be uploaded. If the upload is successfull, the files previously associated with the template are erased permanently (no history is kept). Retrieve template list \u00b6 The command: ztc thing template list retrieves all the created templates. The option --from n skips the first n templates. Prepare a FOTA update \u00b6 The command: ztc ota prepare device firmware uploads to the ADM instance the correctly compiled and linked firmware update contained in the firmware file for device with uid device . To correctly prepare a FOTA update refer to the link command. Start a FOTA update \u00b6 The command: ztc ota start device signals the ADM to start the previously prepared FOTA update for device device . Stop a FOTA update \u00b6 The command: ztc ota stop device signals the ADM to stop the previously prepared or started FOTA update for device device . Check a FOTA update \u00b6 The command: ztc ota check device display the status of the FOTA process for device . The displayed information is: ota_support , True if the connected device runs a FOTA enabled VM bcslot , the index of the slot the current bytecode is running on vmslot , the index of the slot the current VM is running on vmuid , the unique identifier of the running VM ota_request , a unique identifier specifying the ongoing FOTA update, empty if FOTA is not ongoing ota_next_request , a unique identifier specifying the FOTA update that will be started by the start command, empty if no FOTA has been prepared ota_fail , a message specifying the last failed FOTA update error message, empty if ok last_ota , the timestamp of last successful FOTA update","title":"Connected Devices"},{"location":"reference/core/toolchain/docs/things_thingcmd/#connected-devices","text":"The Zerynth Advanced Device Manager (ADM) allows connections between the devices programmed with Zerynth and the ADM sandbox instance hosted on the Zerynth backend server. The ADM adds to each connected device the following functionalities: executing functions triggered by a remote request (remote procedure call) performing over the air firmware update (FOTA) displaying and interacting with a graphical user interface both on a mobile app or desktop browser Such functionalities can be configured and controlled through the following ZTC commands: Create a connected device Retrieve info on a connected device Set properties of a connected device Retrieve the list of connected devices Create groups of devices Add a connected device to a group List groups of devices Create a graphical template Update a graphical template List all graphical templates Prepare for a FOTA update Check for FOTA status Start a FOTA update Stop a FOTA update Details about the ADM can be found here.","title":"Connected Devices"},{"location":"reference/core/toolchain/docs/things_thingcmd/#create-a-connected-device","text":"In order to connect a physical device to the ADM, a bit of device provisioning must be made. In particular, a new connected device instance must be created on the ADM and the assigned credentials used in the script running on the physical device. The command: ztc thing add name creates a new connected device instance with name name in the ADM server. Such instance can have many different properties, but only a subset of them is mandatory and generated by the ADM: uid : the unique identifier of the connected device token : the security token used to authenticate the physical device to the ADM Additional properties can be specified at the moment of creation by specifying the corresponding options: --location loc adds the description of the location the physical device is placed --lat lat --lon lon attaches coordinates to the device --description desc specifies the device description --tag tag attaches a set of tags to the device (the option can be given multiple times) Each Zerynth user can create an unlimited number of connected devices instances, however only a subset of them is allowed to be connected to the ADM at the same moment.","title":"Create a connected device"},{"location":"reference/core/toolchain/docs/things_thingcmd/#retrieves-device-info","text":"The command: ztc thing info uid retrieves information about the connected device with unique identifier uid . The information retrieved consists of: token , the security token for the device name , the device name description , the device description location , the description of the device location geo , the latitude and longitude of the device position groups , the list of groups the device belongs to last_seen , the time of the last detected presence of the connected device online , the status of the device connection platform , the type of the physical device using this connected device credentials notifications , a boolean determing if mobile notifications are enabled for this device","title":"Retrieves device info"},{"location":"reference/core/toolchain/docs/things_thingcmd/#configure-a-device","text":"The command: ztc thing config uid sets the properties of the connected device with unique identifier uid . The properties are specified with the following options: --name name , changes the device name :option: \u2013description desc, changes the device description --location loc , changes the device location --lat x / --lon y , change the device coordinates --token , asks for a new security token --template template_uid , sets the device template","title":"Configure a device"},{"location":"reference/core/toolchain/docs/things_thingcmd/#connected-devices-list","text":"The command: ztc thing config list retrieves the list of connected devices. Options can be specified to filter the results: --from n , skips the first n connected devices. Default n is zero. --status online/offline , filters connected devices based on online status. If not given, all devices are retrieved","title":"Connected devices list"},{"location":"reference/core/toolchain/docs/things_thingcmd/#create-a-group-of-devices","text":"The command: ztc thing group add name creates a group named name , initially empty. Devices can be added to the group with the config command.","title":"Create a group of devices"},{"location":"reference/core/toolchain/docs/things_thingcmd/#group-configuration","text":"The command: ztc thing group config uid -- add dev0_uid -- remove dev1_uid can be used to add or remove devices (identified by their uids dev0_uid and dev1_uid ) to the group identifiedby uid . The options --add and --remove can be repeated multiple times in the same command.","title":"Group configuration"},{"location":"reference/core/toolchain/docs/things_thingcmd/#group-configuration_1","text":"The command: ztc thing group list retrieves the list of all groups. The option --from n can be used to skip the first n groups.","title":"Group configuration"},{"location":"reference/core/toolchain/docs/things_thingcmd/#create-a-device-template","text":"The Zerynth ADM allows to remotely store a graphical interface for each connected device called device template. A template is just a collection of HTML5, javascript, css and image files hosted on the ADM backend. The template is able to receive and send messages to the connected device in response to user interactions with its graphical components. The command: ztc thing template add name creates a new empty template named name . A template is identified by a generated uid.","title":"Create a device template"},{"location":"reference/core/toolchain/docs/things_thingcmd/#upload-a-template","text":"A newly created template is empty. Files and subfolders can be added to the template with the following command: ztc thing template upload uid path where path is the folder containing the template files and uid is the uid indentifying the template to update. The files at path are compressed and transferred to the ADM backend. There are limitations on the size of a template and on the type of files that can be uploaded. If the upload is successfull, the files previously associated with the template are erased permanently (no history is kept).","title":"Upload a template"},{"location":"reference/core/toolchain/docs/things_thingcmd/#retrieve-template-list","text":"The command: ztc thing template list retrieves all the created templates. The option --from n skips the first n templates.","title":"Retrieve template list"},{"location":"reference/core/toolchain/docs/things_thingcmd/#prepare-a-fota-update","text":"The command: ztc ota prepare device firmware uploads to the ADM instance the correctly compiled and linked firmware update contained in the firmware file for device with uid device . To correctly prepare a FOTA update refer to the link command.","title":"Prepare a FOTA update"},{"location":"reference/core/toolchain/docs/things_thingcmd/#start-a-fota-update","text":"The command: ztc ota start device signals the ADM to start the previously prepared FOTA update for device device .","title":"Start a FOTA update"},{"location":"reference/core/toolchain/docs/things_thingcmd/#stop-a-fota-update","text":"The command: ztc ota stop device signals the ADM to stop the previously prepared or started FOTA update for device device .","title":"Stop a FOTA update"},{"location":"reference/core/toolchain/docs/things_thingcmd/#check-a-fota-update","text":"The command: ztc ota check device display the status of the FOTA process for device . The displayed information is: ota_support , True if the connected device runs a FOTA enabled VM bcslot , the index of the slot the current bytecode is running on vmslot , the index of the slot the current VM is running on vmuid , the unique identifier of the running VM ota_request , a unique identifier specifying the ongoing FOTA update, empty if FOTA is not ongoing ota_next_request , a unique identifier specifying the FOTA update that will be started by the start command, empty if no FOTA has been prepared ota_fail , a message specifying the last failed FOTA update error message, empty if ok last_ota , the timestamp of last successful FOTA update","title":"Check a FOTA update"},{"location":"reference/core/toolchain/docs/uplinker_massprog/","text":"Device Configuration and Mass Programming \u00b6 In the lifecycle of an IoT device particular attention must be given to the initial programming and provisioning. Zerynth provides some firmware modules and toolchain commands to ease the task. In particular the toolchain is capable of accepting a description of the resources needed by the device and automatically store them in the device flash memory together with the VM and the firmware. To do so, a Zerynth project must be accompained by a dcz.yml file with all the information on the needed resources and the ways to generate them. To automate the task of mass programming, it is also possible to write a massprog.yml file containing the information about the kind of device to mass program, its vm parameters and more. In this way it is not necessary to manually register-virtualize-uplink all the devices and the whole task is performed by a single command. Device Configuration Zones \u00b6 If a valid dcz.yml file is present in the project folder, every time an uplink command is performed, the file is read and the described resources are generated and stored in the device flash before any uplinking. The device must support some means of programming with jtag probes or custom uploaders for this process to work correctly. The dcz.yml file is composed of various sections: # Zerynth Device Configuration Map # # this file declares a set of resources to be loaded on the device # in a way that is indipendent from the firmware in order to facilitate # mass programming and mass provisioning. # # It is in Yaml format, and the various sections/options are documented below # this field must be true to enable this configuration! # if not present or false, the configuration is skipped # and no resource is transferred in the device active : true ############################ # Provisioning Section # # in the \"provisioning\" section, the various resources # with their location and their generation method are listed # # For each resource the following fields are mandatory: # # - name: an ascii string specifying the resource name (max 16 bytes) # - type: the type of the resource [file, prvkey, pubkey, cert] # - args: a list of arguments needed to load or generate the resource # - mapping: a list of addresses where the resource must be copied # # When using DCZ (see next section), an optional parameter \"format\" can be given. # It must be an ascii string of at most 4 bytes, by default it is set to \"bin\" # # uncomment the following section to enable provisioning provisioning : # the provisioning method (used to generate device credentials) method : aws_iot_key_cert # the list of resources resources : # the device CA certificate: obtained from the ones provided by Amazon - name : cacert type : cacert mapping : [ 0x326000 , 0x327000 ] # the device certificate: will be created by calling into AWS API - name : clicert type : clicert mapping : [ 0x320000 , 0x321000 ] # the device private key: will be created by calling into AWS API and will be encrypted - name : prvkey type : prvkey mapping : [ 0x322000 , 0x323000 ] encrypt : True # the endpoint where to connect to. Obtained by calling into AWS API - name : endpoint type : endpoint mapping : [ 0x324000 , 0x325000 ] format : json # some device info useful to have in the firmware (for this to work, aws.thing_prefix must be given!) - name : devinfo type : devinfo mapping : [ 0x328000 , 0x329000 ] format : json # an encrypted resource where wifi credentials can be stored - name : wificred type : file args : files / wificred . json mapping : [ 0x330000 , 0x331000 ] format : json encrypt : True ############################ # DCZ Section # # in the \"dcz\" section the provisioned resources (or a subset of them) # can be included in the Device Configuration Zone. The DCZ is a versionable index # of the available resources that can be easily accessed and updated # with the dcz Zerynth module. # # DCZ supports up to 8 replication zones for safety. If a resource is included in a DCZ # with replication n, it must be placed in exactly n different locations for versioning # # uncomment the section below to enable dcz dcz : # locations of the DCZs (replication 2) mapping : [ 0x310000 , 0x311000 ] # list of resource names to be included resources : - endpoint - clicert - prvkey - cacert - devinfo - wificred ############################ # AWS Section # # in the \"aws\" section, the various credentials and options # for aws iot services are spcified aws : # specify the access key id of the IAM user that can create certificate and things aws_access_key_id : \"your-access-key\" # the IAM user credentials aws_secret_access_key : \"your-secret-key\" # the region where certificates will be created region_name : \"your-region\" # specify the Amazon CA certificate to use [verisign, ecc, rsa] endpoint_type : verisign # activation of certificate upon creation activate_cert : true # the thing prefix for the thing name (optional: if not given, no thing is created) thing_prefix : \"MyThing\" # the thing policy to attach to the certificate (optional if not given no policy is attached to cert) thing_policy : test_policy The flexibility provided by dcz.yml is very high. The provisioning section contains a list of resources of different types. Resource types and the provisioning method specify how the resouce is generated. The following types of resources are available: file , specifies an existing file identified by the path in the args field cacert , specifies a CA certificate. clicert , specifies a device certificate. prvkey , specifies a device private key. pubkey , specifies a device public key. endpoint , specifies the list of endpoints the device can connect to. devinfo , specifies some device properties needed to correctly connect to the cloud service. Resources are created in a different way depending on provisioning.method : manual method treats all resource types as files loaded from the path given in args . aws_iot_key_cert method generates device credentials by calling the appropriate AWS API endpoint (via boto3). In particular, both the private key and the device certificate are requested, while the CA certificate is loaded from file shipping with the erynth toolchain. Device info and endpoints are again generated through API calls and saved in json format. Optionally a Thing is also automatically created and the policy/certificate are attached to it. aws_iot_csr_cert method generates device credentials from a CSR signed with an openssl generated private key. [Not yet implemented] gcp_jwt method generates device credentials for GCP based on JWT tokens. [Not yet implemented] Resources also have a name (max 16 characters) and a mapping , a list of addresses on the device flash where the resource will be saved. Addresses can be more than one since resources can be replicated and versioned for a safer device lifecycle. Optionally resources can have a format (default \u201cbin\u201d) and can be ecnrypted. Encrypted resources are stored in clear and are encrypted by the device using the DCZ module when the firmware first run (typically during end of line testing). This method does not replace gold standard security approaches like the use of dedicated crypto elements, but can protect sensitive data from simple attacks. The encryption is device dependent and a ciphertext can only be decrypted by the device that produced it. The optional dcz section provides information to be used together with the DCZ module. Mass Programming \u00b6 When producing small to medium batches of IoT devices, it is useful to have an automatic mean of provisioning and flashing. This feature is provided by the mass programming command documented below. A mass programming configuration file is needed to describe the device parameters: ############################ # Mass Programming Section # # in the \"config\" section, all the options necessary # to avoid human intervention are specified. config : # the name of the target micro/board (i.e. esp32_devkitc) target : esp32_devkitc # options relative to the device itself (port, baudrate, probe, etc...) dev : # the serial port of the device port : / dev / ttyUSB0 # the baud rate of the port (defaults to 115200) baud : 1500000 # the programming probe probe : null # specify the method for device registration [jtag, target_custom] register : target_custom # specify the parameters for VM to be mass programmed vm : # the specific rtos of the VM rtos : \"esp32-rtos\" # vm version version : \"r2.2.0\" # vm patch patch : \"base\" # list of vm features feats : [] # set vm to shareable [if set to True, the final user of the device will be able to uplink firmware to the device and obtain a copy of the VM : useful for demo boards and kits ] shareable : False # if set to true, the VM will not accept any new firmware from the uplink command [Not yet implemented] locked : False # path of the project to compile project : awesome / zerynth / project Massprog command \u00b6 The command: ztc massprog start path will start a register-virtualize-uplink process in a single command using information contained in the massprog.yml file present at path . If the project specified in massprog.yml contains a dcz.yml file, resources will be provisioned and flashed to the device together with the VM and the firmware. The massprog may take the additional --clean option that forces a firmware compilation and link.","title":"Device Configuration and Mass Programming"},{"location":"reference/core/toolchain/docs/uplinker_massprog/#device-configuration-and-mass-programming","text":"In the lifecycle of an IoT device particular attention must be given to the initial programming and provisioning. Zerynth provides some firmware modules and toolchain commands to ease the task. In particular the toolchain is capable of accepting a description of the resources needed by the device and automatically store them in the device flash memory together with the VM and the firmware. To do so, a Zerynth project must be accompained by a dcz.yml file with all the information on the needed resources and the ways to generate them. To automate the task of mass programming, it is also possible to write a massprog.yml file containing the information about the kind of device to mass program, its vm parameters and more. In this way it is not necessary to manually register-virtualize-uplink all the devices and the whole task is performed by a single command.","title":"Device Configuration and Mass Programming"},{"location":"reference/core/toolchain/docs/uplinker_massprog/#device-configuration-zones","text":"If a valid dcz.yml file is present in the project folder, every time an uplink command is performed, the file is read and the described resources are generated and stored in the device flash before any uplinking. The device must support some means of programming with jtag probes or custom uploaders for this process to work correctly. The dcz.yml file is composed of various sections: # Zerynth Device Configuration Map # # this file declares a set of resources to be loaded on the device # in a way that is indipendent from the firmware in order to facilitate # mass programming and mass provisioning. # # It is in Yaml format, and the various sections/options are documented below # this field must be true to enable this configuration! # if not present or false, the configuration is skipped # and no resource is transferred in the device active : true ############################ # Provisioning Section # # in the \"provisioning\" section, the various resources # with their location and their generation method are listed # # For each resource the following fields are mandatory: # # - name: an ascii string specifying the resource name (max 16 bytes) # - type: the type of the resource [file, prvkey, pubkey, cert] # - args: a list of arguments needed to load or generate the resource # - mapping: a list of addresses where the resource must be copied # # When using DCZ (see next section), an optional parameter \"format\" can be given. # It must be an ascii string of at most 4 bytes, by default it is set to \"bin\" # # uncomment the following section to enable provisioning provisioning : # the provisioning method (used to generate device credentials) method : aws_iot_key_cert # the list of resources resources : # the device CA certificate: obtained from the ones provided by Amazon - name : cacert type : cacert mapping : [ 0x326000 , 0x327000 ] # the device certificate: will be created by calling into AWS API - name : clicert type : clicert mapping : [ 0x320000 , 0x321000 ] # the device private key: will be created by calling into AWS API and will be encrypted - name : prvkey type : prvkey mapping : [ 0x322000 , 0x323000 ] encrypt : True # the endpoint where to connect to. Obtained by calling into AWS API - name : endpoint type : endpoint mapping : [ 0x324000 , 0x325000 ] format : json # some device info useful to have in the firmware (for this to work, aws.thing_prefix must be given!) - name : devinfo type : devinfo mapping : [ 0x328000 , 0x329000 ] format : json # an encrypted resource where wifi credentials can be stored - name : wificred type : file args : files / wificred . json mapping : [ 0x330000 , 0x331000 ] format : json encrypt : True ############################ # DCZ Section # # in the \"dcz\" section the provisioned resources (or a subset of them) # can be included in the Device Configuration Zone. The DCZ is a versionable index # of the available resources that can be easily accessed and updated # with the dcz Zerynth module. # # DCZ supports up to 8 replication zones for safety. If a resource is included in a DCZ # with replication n, it must be placed in exactly n different locations for versioning # # uncomment the section below to enable dcz dcz : # locations of the DCZs (replication 2) mapping : [ 0x310000 , 0x311000 ] # list of resource names to be included resources : - endpoint - clicert - prvkey - cacert - devinfo - wificred ############################ # AWS Section # # in the \"aws\" section, the various credentials and options # for aws iot services are spcified aws : # specify the access key id of the IAM user that can create certificate and things aws_access_key_id : \"your-access-key\" # the IAM user credentials aws_secret_access_key : \"your-secret-key\" # the region where certificates will be created region_name : \"your-region\" # specify the Amazon CA certificate to use [verisign, ecc, rsa] endpoint_type : verisign # activation of certificate upon creation activate_cert : true # the thing prefix for the thing name (optional: if not given, no thing is created) thing_prefix : \"MyThing\" # the thing policy to attach to the certificate (optional if not given no policy is attached to cert) thing_policy : test_policy The flexibility provided by dcz.yml is very high. The provisioning section contains a list of resources of different types. Resource types and the provisioning method specify how the resouce is generated. The following types of resources are available: file , specifies an existing file identified by the path in the args field cacert , specifies a CA certificate. clicert , specifies a device certificate. prvkey , specifies a device private key. pubkey , specifies a device public key. endpoint , specifies the list of endpoints the device can connect to. devinfo , specifies some device properties needed to correctly connect to the cloud service. Resources are created in a different way depending on provisioning.method : manual method treats all resource types as files loaded from the path given in args . aws_iot_key_cert method generates device credentials by calling the appropriate AWS API endpoint (via boto3). In particular, both the private key and the device certificate are requested, while the CA certificate is loaded from file shipping with the erynth toolchain. Device info and endpoints are again generated through API calls and saved in json format. Optionally a Thing is also automatically created and the policy/certificate are attached to it. aws_iot_csr_cert method generates device credentials from a CSR signed with an openssl generated private key. [Not yet implemented] gcp_jwt method generates device credentials for GCP based on JWT tokens. [Not yet implemented] Resources also have a name (max 16 characters) and a mapping , a list of addresses on the device flash where the resource will be saved. Addresses can be more than one since resources can be replicated and versioned for a safer device lifecycle. Optionally resources can have a format (default \u201cbin\u201d) and can be ecnrypted. Encrypted resources are stored in clear and are encrypted by the device using the DCZ module when the firmware first run (typically during end of line testing). This method does not replace gold standard security approaches like the use of dedicated crypto elements, but can protect sensitive data from simple attacks. The encryption is device dependent and a ciphertext can only be decrypted by the device that produced it. The optional dcz section provides information to be used together with the DCZ module.","title":"Device Configuration Zones"},{"location":"reference/core/toolchain/docs/uplinker_massprog/#mass-programming","text":"When producing small to medium batches of IoT devices, it is useful to have an automatic mean of provisioning and flashing. This feature is provided by the mass programming command documented below. A mass programming configuration file is needed to describe the device parameters: ############################ # Mass Programming Section # # in the \"config\" section, all the options necessary # to avoid human intervention are specified. config : # the name of the target micro/board (i.e. esp32_devkitc) target : esp32_devkitc # options relative to the device itself (port, baudrate, probe, etc...) dev : # the serial port of the device port : / dev / ttyUSB0 # the baud rate of the port (defaults to 115200) baud : 1500000 # the programming probe probe : null # specify the method for device registration [jtag, target_custom] register : target_custom # specify the parameters for VM to be mass programmed vm : # the specific rtos of the VM rtos : \"esp32-rtos\" # vm version version : \"r2.2.0\" # vm patch patch : \"base\" # list of vm features feats : [] # set vm to shareable [if set to True, the final user of the device will be able to uplink firmware to the device and obtain a copy of the VM : useful for demo boards and kits ] shareable : False # if set to true, the VM will not accept any new firmware from the uplink command [Not yet implemented] locked : False # path of the project to compile project : awesome / zerynth / project","title":"Mass Programming"},{"location":"reference/core/toolchain/docs/uplinker_massprog/#massprog-command","text":"The command: ztc massprog start path will start a register-virtualize-uplink process in a single command using information contained in the massprog.yml file present at path . If the project specified in massprog.yml contains a dcz.yml file, resources will be provisioned and flashed to the device together with the VM and the firmware. The massprog may take the additional --clean option that forces a firmware compilation and link.","title":"Massprog command"},{"location":"reference/core/toolchain/docs/uplinker_uplinker/","text":"Uplink \u00b6 Once a Zerynth program is compiled to bytecode it can be executed by transferring such bytecode to a running virtual machine on a device. This operation is called \u201cuplinking\u201d in the ZTC terminology. Indeed Zerynth virtual machines act as a bootloader waiting a small amount of time after device reset to check if new bytecode is incoming. If not, they go on executing a previously loaded bytecode or just wait forever. The command: ztc uplink alias bytecode will start the uplinking process for the device with alias alias using the compiled .vbo file given in the bytecode argument. As usual alias ca be partially specified. The uplinking process may require user interaction for manual resetting the device whan appropriate. The process consists of: a discovery phase: the device with the given alias is searched and its attributes are checked a probing phase: depending on the device target a manual reset can be asked to the user. It is needed to reset the virtual machine and put it in a receptive state. In this phase a \u201cprobe\u201d is sent to the virtual machine, asking for runtime details a handshake phase: once runtime details are known, additional info are exchanged between the linker and the virtual machine to ensure correct bytecode transfer a relocation phase: the bytecode is not usually executable as is and some symbols must be resolved against runtime details a flashing phase: the relocated bytecode is sent to the virtual machine Each of the previous phases may fail in different ways and the cause can be determined by inspecting error messages. The uplink may the additional --loop times option that specifies the number of retries during the discovery phase (each retry lasts one second). Uplink (raw) \u00b6 It is possible to perform an uplink against a configured device by specifying the relevant device parameters as in the register raw command, by specifying the port parameter. The command: ztc uplink_raw target bytecode -- spec port : the_port performs an uplink on the device of type target using the bytecode file at bytecode using the serial port port . Uplink by probe \u00b6 It is possible to perform an uplink against a configured device by using a probe. Contrary to other uplink commands that require a bytecode file argument, the uplink_by_probe command requires a linked bytecode file argument (obtained with the link command). The command: ztc uplink_by_probe target probe linked_bytecode perform an uplink on the device type target using probe probe to transfer the linked_bytecode file to the running VM. It is possible to change the address where the bytecode will be flashed by specifying the --address option followed by the hexadecimal representation of the address (useful for OTA VMs scenarios) Link \u00b6 The command: ztc link vmuid bytecode generates a file containing the bytecode bytecode modified in such a way that it can be executed on the VM vmuid without the need for an uplink. This command is mainly used to generate executable bytecode for FOTA updates. Alternatively it can be used to generate a binary firmware to be manually flashed on a device, skipping both device recognition and uplinking. It takes the following options: --vm n , for FOTA enabled VMs, generate a bytecode that can be executed by a VM running on slot n . Default n is zero. --bc n , for FOTA enabled VMs, generate a bytecode that can be executed by on bytecode slot n . Default n is zero. --include_vm , generate a single binary containing both the VM and the bytecode, ready to be flashed on the device. Not compatible with FOTA VMs! --otavm , generate both bytecode and VM ready for a FOTA update --file file , save the output to file file FOTA updates \u00b6 Generating firmware for FOTA updates can be tricky. The following information is needed: The VM unique identifier, vmuid The unique identifier of a new FOTA enabled VM, vmuid_new The current slot the VM is running on, vmslot . Can be retrieved with fota library The current slot the bytecode is running on, bcslot , Can be retrieved with fota library For example, assuming a project has been compiled to the bytecode file project.vbo and vmslot=0 and bcslot=0 , the following commands can be given: # generate bytecode capable of running on slot 1 with VM in slot 0 # the resulting file can be used for a FOTA update of the bytecode ztc link vmuid project . vbo -- bc 1 -- file project . vbe # generate bytecode capable of running on slot 1 with VM in slot 1 # the resulting file CAN'T be used for a FOTA update because the running VM is in slot 0 # and project.vbe does not contain the new VM ztc link vmuid_new project . vbo -- bc 1 -- vm 1 -- file project . vbe # generate bytecode capable of running on slot 1 with VM in slot 1 # the resulting file can be used for a FOTA update of the bytecode and VM # because project.vbe contains the new VM ztc link vmuid_new project . vbo -- bc 1 -- vm 1 -- otavm -- file project . vbe Note It is not possible to generate a FOTA update of the VM only! Note To generate a Zerynth ADM compatible FOTA bytecode update, add option -J before the link command. The resulting file will be JSON and not binary.","title":"Uplink"},{"location":"reference/core/toolchain/docs/uplinker_uplinker/#uplink","text":"Once a Zerynth program is compiled to bytecode it can be executed by transferring such bytecode to a running virtual machine on a device. This operation is called \u201cuplinking\u201d in the ZTC terminology. Indeed Zerynth virtual machines act as a bootloader waiting a small amount of time after device reset to check if new bytecode is incoming. If not, they go on executing a previously loaded bytecode or just wait forever. The command: ztc uplink alias bytecode will start the uplinking process for the device with alias alias using the compiled .vbo file given in the bytecode argument. As usual alias ca be partially specified. The uplinking process may require user interaction for manual resetting the device whan appropriate. The process consists of: a discovery phase: the device with the given alias is searched and its attributes are checked a probing phase: depending on the device target a manual reset can be asked to the user. It is needed to reset the virtual machine and put it in a receptive state. In this phase a \u201cprobe\u201d is sent to the virtual machine, asking for runtime details a handshake phase: once runtime details are known, additional info are exchanged between the linker and the virtual machine to ensure correct bytecode transfer a relocation phase: the bytecode is not usually executable as is and some symbols must be resolved against runtime details a flashing phase: the relocated bytecode is sent to the virtual machine Each of the previous phases may fail in different ways and the cause can be determined by inspecting error messages. The uplink may the additional --loop times option that specifies the number of retries during the discovery phase (each retry lasts one second).","title":"Uplink"},{"location":"reference/core/toolchain/docs/uplinker_uplinker/#uplink-raw","text":"It is possible to perform an uplink against a configured device by specifying the relevant device parameters as in the register raw command, by specifying the port parameter. The command: ztc uplink_raw target bytecode -- spec port : the_port performs an uplink on the device of type target using the bytecode file at bytecode using the serial port port .","title":"Uplink (raw)"},{"location":"reference/core/toolchain/docs/uplinker_uplinker/#uplink-by-probe","text":"It is possible to perform an uplink against a configured device by using a probe. Contrary to other uplink commands that require a bytecode file argument, the uplink_by_probe command requires a linked bytecode file argument (obtained with the link command). The command: ztc uplink_by_probe target probe linked_bytecode perform an uplink on the device type target using probe probe to transfer the linked_bytecode file to the running VM. It is possible to change the address where the bytecode will be flashed by specifying the --address option followed by the hexadecimal representation of the address (useful for OTA VMs scenarios)","title":"Uplink by probe"},{"location":"reference/core/toolchain/docs/uplinker_uplinker/#link","text":"The command: ztc link vmuid bytecode generates a file containing the bytecode bytecode modified in such a way that it can be executed on the VM vmuid without the need for an uplink. This command is mainly used to generate executable bytecode for FOTA updates. Alternatively it can be used to generate a binary firmware to be manually flashed on a device, skipping both device recognition and uplinking. It takes the following options: --vm n , for FOTA enabled VMs, generate a bytecode that can be executed by a VM running on slot n . Default n is zero. --bc n , for FOTA enabled VMs, generate a bytecode that can be executed by on bytecode slot n . Default n is zero. --include_vm , generate a single binary containing both the VM and the bytecode, ready to be flashed on the device. Not compatible with FOTA VMs! --otavm , generate both bytecode and VM ready for a FOTA update --file file , save the output to file file","title":"Link"},{"location":"reference/core/toolchain/docs/uplinker_uplinker/#fota-updates","text":"Generating firmware for FOTA updates can be tricky. The following information is needed: The VM unique identifier, vmuid The unique identifier of a new FOTA enabled VM, vmuid_new The current slot the VM is running on, vmslot . Can be retrieved with fota library The current slot the bytecode is running on, bcslot , Can be retrieved with fota library For example, assuming a project has been compiled to the bytecode file project.vbo and vmslot=0 and bcslot=0 , the following commands can be given: # generate bytecode capable of running on slot 1 with VM in slot 0 # the resulting file can be used for a FOTA update of the bytecode ztc link vmuid project . vbo -- bc 1 -- file project . vbe # generate bytecode capable of running on slot 1 with VM in slot 1 # the resulting file CAN'T be used for a FOTA update because the running VM is in slot 0 # and project.vbe does not contain the new VM ztc link vmuid_new project . vbo -- bc 1 -- vm 1 -- file project . vbe # generate bytecode capable of running on slot 1 with VM in slot 1 # the resulting file can be used for a FOTA update of the bytecode and VM # because project.vbe contains the new VM ztc link vmuid_new project . vbo -- bc 1 -- vm 1 -- otavm -- file project . vbe Note It is not possible to generate a FOTA update of the VM only! Note To generate a Zerynth ADM compatible FOTA bytecode update, add option -J before the link command. The resulting file will be JSON and not binary.","title":"FOTA updates"},{"location":"reference/core/toolchain/docs/user_usercmd/","text":"Account related commands \u00b6 The ZTC allows the user to authenticate against the Zerytnh backend and modify profile information. The following commands are available: login to retrieve an authentication token. reset reset to request a password reset. profile set and get profile information. Login \u00b6 The login command enables the user to retrieve an authentication token. The token is used in most ZTC commands to communicate with the Zerynth backend. The login can be issued in interactive and non interactive mode. Interactive mode is started by typing: ztc login The ZTC opens the default system browser to the login/registration page and waits for user input. In the login/registration page, the user can login providing a valid email and the corresponding password. It is also possible (and faster) to login using Google plus or Facebook OAuth services. If the user do not have a Zerynth account it is possible to register providing a valid email, a nick name and a password. Social login is also available for registration via OAuth. Once a correct login/registration is performed, the browser will display an authentication token. Such token can be copied and pasted to the ZTC prompt. Warning multiple logins with different methods (manual or social) are allowed provided that the email linked to the social OAuth service is the same as the one used in the manual login. Non interactive mode is started by typing: ztc login -- token authentication_token The authentication_token can be obtained by manually opening the login/registration page Warning For manual registrations, email address confirmation is needed. An email will be sent at the provided address with instructions. Reset Password \u00b6 If a manual registration has been performed, it is possible to change the password by issuing a password reset: ztc reset email where email is the email address used in the manual registration flow. An email with instruction will be sent to such address in order to allow a password change. Note on password change, all active sessions of the user will be invalidated and a new token must be retrieved. Logout \u00b6 Delete current session with the following command ztc logout Note it will be necessary to login again. Get/Set Profile Info \u00b6 By issuing the command: ztc profile the user profile is retrieved and displayed. The user profile consists of the following data: Generic Info Username (non mutable) Email (non mutable) Name Surname Age Country Job Company Website # * Subscription Info * Subscription type #* Date of subscription expiration #* List of roles #* List of active repositories \u00b6 Asset and Purchase History list List of account linked assets List of bought virtual machines The profile command can be used to change mutable generic info with the following syntax: ztc profile -- set options where options is a list of one or more of the following options: --name name update the Name field --surname name update the Surname field --age age update the Age field --country country update the Country field --job job update the Job field --company company update the Company field --website website update the Website field","title":"Account related commands"},{"location":"reference/core/toolchain/docs/user_usercmd/#account-related-commands","text":"The ZTC allows the user to authenticate against the Zerytnh backend and modify profile information. The following commands are available: login to retrieve an authentication token. reset reset to request a password reset. profile set and get profile information.","title":"Account related commands"},{"location":"reference/core/toolchain/docs/user_usercmd/#login","text":"The login command enables the user to retrieve an authentication token. The token is used in most ZTC commands to communicate with the Zerynth backend. The login can be issued in interactive and non interactive mode. Interactive mode is started by typing: ztc login The ZTC opens the default system browser to the login/registration page and waits for user input. In the login/registration page, the user can login providing a valid email and the corresponding password. It is also possible (and faster) to login using Google plus or Facebook OAuth services. If the user do not have a Zerynth account it is possible to register providing a valid email, a nick name and a password. Social login is also available for registration via OAuth. Once a correct login/registration is performed, the browser will display an authentication token. Such token can be copied and pasted to the ZTC prompt. Warning multiple logins with different methods (manual or social) are allowed provided that the email linked to the social OAuth service is the same as the one used in the manual login. Non interactive mode is started by typing: ztc login -- token authentication_token The authentication_token can be obtained by manually opening the login/registration page Warning For manual registrations, email address confirmation is needed. An email will be sent at the provided address with instructions.","title":"Login"},{"location":"reference/core/toolchain/docs/user_usercmd/#reset-password","text":"If a manual registration has been performed, it is possible to change the password by issuing a password reset: ztc reset email where email is the email address used in the manual registration flow. An email with instruction will be sent to such address in order to allow a password change. Note on password change, all active sessions of the user will be invalidated and a new token must be retrieved.","title":"Reset Password"},{"location":"reference/core/toolchain/docs/user_usercmd/#logout","text":"Delete current session with the following command ztc logout Note it will be necessary to login again.","title":"Logout"},{"location":"reference/core/toolchain/docs/user_usercmd/#getset-profile-info","text":"By issuing the command: ztc profile the user profile is retrieved and displayed. The user profile consists of the following data: Generic Info Username (non mutable) Email (non mutable) Name Surname Age Country Job Company Website # * Subscription Info","title":"Get/Set Profile Info"},{"location":"reference/core/toolchain/docs/user_usercmd/#subscription-type-date-of-subscription-expiration-list-of-roles-list-of-active-repositories","text":"Asset and Purchase History list List of account linked assets List of bought virtual machines The profile command can be used to change mutable generic info with the following syntax: ztc profile -- set options where options is a list of one or more of the following options: --name name update the Name field --surname name update the Surname field --age age update the Age field --country country update the Country field --job job update the Job field --company company update the Company field --website website update the Website field","title":"* Subscription type #* Date of subscription expiration #* List of roles #* List of active repositories"},{"location":"reference/core/toolchain/docs/virtualmachines_vmcmd/","text":"Virtual Machines \u00b6 Virtual machines are the core of Zerynth. From the point of view of the ZTC, a virtual machine is a binary blob to be flashed on a device in order to enable Zerynth code execution. Virtual machines are tied to the unique identifier of the device microcontroller, therefore for each microcontroller a specific virtual machine must be created. Virtual machines can be managed with the following commands: create list available bin It is also possible to create custom Virtual Machines for proprietary PCBs based on some Zerytnh supported microcontroller. The customizable parameters pertain to the GPIO routing (custom pinmap) and the selection of available peripherals. More custom parameters will be added in the future. For the customization process please refer to the dedicated section Create a Virtual Machine \u00b6 Virtual machine can be created with custom features for a specific device. Creation consists in requesting a virtual machine unique identifier ( vmuid ) to the Zerynth backend for a registered device. The command: ztc vm create alias version rtos patch executes a REST call to the Zerynth backend asking for the creation of a virtual machine for the registered device with alias alias . The created virtual machine will run on the RTOS specified by rtos using the virtual machine release version version at patch patch . It is also possible to specify the additional option --feat feature to customize the virtual machine with feature . Some features are available for pro accounts only. Multiple features can be specified repeating the option. If virtual machine creation ends succesfully, the virtual machine binary is also downloaded and added to the local virtual machine storage. The vmuid is printed as a result. List Virtual Machines \u00b6 The list of created virtual machines can be retrieved with the command: ztc vm list The retrieved list contains at most 50 virtual machines. Additional options can be provided to filter the returned virtual machine set: --from n , skip the first n virtual machines Virtual Machine parameters \u00b6 For each device target a different set of virtual machines can be created that takes into consideration the features of the hardware. Not every device can run every virtual machine. The list of available virtual machines for a specific target can be retrieved by: ztc vm available target For the device target, a list of possible virtual machine configurations is returned with the following attributes: virtual machine version RTOS additional features free/pro only Virtual Machine Binary File \u00b6 The binary file(s) of an existing virtual machine can be obtained with the command: ztc vm bin uid where uid is the unique identifier of the virtual machine Additional options can be provided: --path path to specify the destination path Registering Binary File \u00b6 The binary file(s) of a a registering bootloader can be obtained with the command: ztc vm reg target where target is the name of the device to register. Additional options can be provided: --path path to specify the destination path Custom Virtual Machines \u00b6 Some Zerynth VMs are customizable. The process of customization can be handled entirely via ZTC commands. In order to create a custom VMs the following steps are needed: List the supported customizable microcontrollers with the vm custom original command Choose a short name for the custom VM and create it starting from one of the available microcontrollers listed in step 1 The newly created custom VM configuration can be found under the Zerynth folder in the cvm/short_name directory Before being usable, the custom VM template specifying the role of each pin must be compiled with the dedicated command The compilation step takes as input a Yaml template file (short_name.yml) and generates the binary file (port.bin) needed for VM customization Once compiled, the new VM will behave as a normal VM and the standard Zerynth flow of device registration, VM creation and virtualization will be available for the choosen short_name. The only difference is that the port.bin file will be transparently flashed during the virtualization phase. As an add-on, a new device type is create together with the VM in order to allow automatic discovery of the custom device for seamless integration in Zerynth Studio and other third party IDEs. As detailed below, some parameters of the device (e.g. usb VID:PID) can be defined in the custom VM template Each time the VM template is changed, it must be recompiled and the VM revirtualized in order for the changes to take effect It is also possible to export custom VMs to file or to Github in order to easily distribute custom VMs. Create Custom VM \u00b6 The command: ztc vm custom create target short_name clones the configuration files for the target customizable VM into a custom VM instance named short_name . The command creates a directory cvm/short_name under the Zerynth folder containing the following items: short_name.yml : the Yaml template file specifying the VM custom parameters. Upon creation, it is initialized with the parameters for one of the existing devices based on the selected microcontroller device.json : a json document containing info about the device that will host the VM. Such document is generated starting from parameters contained in the Yanml template. short_name.py : a Python module that is used by the ZTC to automatically discover the custom device. port and svg folders: configuration files needed for correct bytecode generation and management for the custom VM. The only possible customization is adding a short_name.svg under the svg folder in order to provide a visual representation of the custom device pinmap in Zerynth Studio. register.vm : the registration bootloader to allow registering the custom device. The custom VMs are entirely local and not saved on Zerynth servers. For this reason it is suggested to export the custom VM files and store them somewhere safe. Moreover, the choosen short name is never saved on Zerynth server and each custom device will be registered as a device of type target . The link between target and short_name is done on the development machine. Compile Custom VM Template \u00b6 The command: ztc vm custom compile short_name compiles the short_name.yml template file of a custom VM to binary form. The format of the template file is documented in the Yaml file itself. Upon successful compilation, the custom VM is made available to all other VM related commands (registration, virtualization,\u2026). Remove Custom VM \u00b6 The command: ztc vm custom remove short_name deletes the custom VM identified by short_name from the system. Export Custom VMs \u00b6 The command: ztc vm custom export short_name destination exports the custom VM identified by short_name to destination . If destination is a folder, a file short_name.tar.xz will be generated in the folder packing together all the needed custom VM files. Such archive can be shared with other users completely enabling them to use the custom device and custom VM with their ZTC. If destination is a Github url, the custom VM files are pushed to the repository (provided that Github credentials are known to the ZTC). Import Custom VMs \u00b6 The command: ztc vm custom import source imports a custom VM from source . If source is a tar.xz file generated by the export command, it is unpacked and installed in the current Zerynth instance. If source is a Github repository, it is cloned and installed. List customizable VMs \u00b6 The command: ztc vm custom original lists the VMs that are customizable. Not all VMs support customization. The output of the command contains the list of target names to be used in the create command. List custom VMs \u00b6 The command: ztc vm custom list prints the list of custom VMs available on the current Zerynth instance.","title":"Virtual Machines"},{"location":"reference/core/toolchain/docs/virtualmachines_vmcmd/#virtual-machines","text":"Virtual machines are the core of Zerynth. From the point of view of the ZTC, a virtual machine is a binary blob to be flashed on a device in order to enable Zerynth code execution. Virtual machines are tied to the unique identifier of the device microcontroller, therefore for each microcontroller a specific virtual machine must be created. Virtual machines can be managed with the following commands: create list available bin It is also possible to create custom Virtual Machines for proprietary PCBs based on some Zerytnh supported microcontroller. The customizable parameters pertain to the GPIO routing (custom pinmap) and the selection of available peripherals. More custom parameters will be added in the future. For the customization process please refer to the dedicated section","title":"Virtual Machines"},{"location":"reference/core/toolchain/docs/virtualmachines_vmcmd/#create-a-virtual-machine","text":"Virtual machine can be created with custom features for a specific device. Creation consists in requesting a virtual machine unique identifier ( vmuid ) to the Zerynth backend for a registered device. The command: ztc vm create alias version rtos patch executes a REST call to the Zerynth backend asking for the creation of a virtual machine for the registered device with alias alias . The created virtual machine will run on the RTOS specified by rtos using the virtual machine release version version at patch patch . It is also possible to specify the additional option --feat feature to customize the virtual machine with feature . Some features are available for pro accounts only. Multiple features can be specified repeating the option. If virtual machine creation ends succesfully, the virtual machine binary is also downloaded and added to the local virtual machine storage. The vmuid is printed as a result.","title":"Create a Virtual Machine"},{"location":"reference/core/toolchain/docs/virtualmachines_vmcmd/#list-virtual-machines","text":"The list of created virtual machines can be retrieved with the command: ztc vm list The retrieved list contains at most 50 virtual machines. Additional options can be provided to filter the returned virtual machine set: --from n , skip the first n virtual machines","title":"List Virtual Machines"},{"location":"reference/core/toolchain/docs/virtualmachines_vmcmd/#virtual-machine-parameters","text":"For each device target a different set of virtual machines can be created that takes into consideration the features of the hardware. Not every device can run every virtual machine. The list of available virtual machines for a specific target can be retrieved by: ztc vm available target For the device target, a list of possible virtual machine configurations is returned with the following attributes: virtual machine version RTOS additional features free/pro only","title":"Virtual Machine parameters"},{"location":"reference/core/toolchain/docs/virtualmachines_vmcmd/#virtual-machine-binary-file","text":"The binary file(s) of an existing virtual machine can be obtained with the command: ztc vm bin uid where uid is the unique identifier of the virtual machine Additional options can be provided: --path path to specify the destination path","title":"Virtual Machine Binary File"},{"location":"reference/core/toolchain/docs/virtualmachines_vmcmd/#registering-binary-file","text":"The binary file(s) of a a registering bootloader can be obtained with the command: ztc vm reg target where target is the name of the device to register. Additional options can be provided: --path path to specify the destination path","title":"Registering Binary File"},{"location":"reference/core/toolchain/docs/virtualmachines_vmcmd/#custom-virtual-machines","text":"Some Zerynth VMs are customizable. The process of customization can be handled entirely via ZTC commands. In order to create a custom VMs the following steps are needed: List the supported customizable microcontrollers with the vm custom original command Choose a short name for the custom VM and create it starting from one of the available microcontrollers listed in step 1 The newly created custom VM configuration can be found under the Zerynth folder in the cvm/short_name directory Before being usable, the custom VM template specifying the role of each pin must be compiled with the dedicated command The compilation step takes as input a Yaml template file (short_name.yml) and generates the binary file (port.bin) needed for VM customization Once compiled, the new VM will behave as a normal VM and the standard Zerynth flow of device registration, VM creation and virtualization will be available for the choosen short_name. The only difference is that the port.bin file will be transparently flashed during the virtualization phase. As an add-on, a new device type is create together with the VM in order to allow automatic discovery of the custom device for seamless integration in Zerynth Studio and other third party IDEs. As detailed below, some parameters of the device (e.g. usb VID:PID) can be defined in the custom VM template Each time the VM template is changed, it must be recompiled and the VM revirtualized in order for the changes to take effect It is also possible to export custom VMs to file or to Github in order to easily distribute custom VMs.","title":"Custom Virtual Machines"},{"location":"reference/core/toolchain/docs/virtualmachines_vmcmd/#create-custom-vm","text":"The command: ztc vm custom create target short_name clones the configuration files for the target customizable VM into a custom VM instance named short_name . The command creates a directory cvm/short_name under the Zerynth folder containing the following items: short_name.yml : the Yaml template file specifying the VM custom parameters. Upon creation, it is initialized with the parameters for one of the existing devices based on the selected microcontroller device.json : a json document containing info about the device that will host the VM. Such document is generated starting from parameters contained in the Yanml template. short_name.py : a Python module that is used by the ZTC to automatically discover the custom device. port and svg folders: configuration files needed for correct bytecode generation and management for the custom VM. The only possible customization is adding a short_name.svg under the svg folder in order to provide a visual representation of the custom device pinmap in Zerynth Studio. register.vm : the registration bootloader to allow registering the custom device. The custom VMs are entirely local and not saved on Zerynth servers. For this reason it is suggested to export the custom VM files and store them somewhere safe. Moreover, the choosen short name is never saved on Zerynth server and each custom device will be registered as a device of type target . The link between target and short_name is done on the development machine.","title":"Create Custom VM"},{"location":"reference/core/toolchain/docs/virtualmachines_vmcmd/#compile-custom-vm-template","text":"The command: ztc vm custom compile short_name compiles the short_name.yml template file of a custom VM to binary form. The format of the template file is documented in the Yaml file itself. Upon successful compilation, the custom VM is made available to all other VM related commands (registration, virtualization,\u2026).","title":"Compile Custom VM Template"},{"location":"reference/core/toolchain/docs/virtualmachines_vmcmd/#remove-custom-vm","text":"The command: ztc vm custom remove short_name deletes the custom VM identified by short_name from the system.","title":"Remove Custom VM"},{"location":"reference/core/toolchain/docs/virtualmachines_vmcmd/#export-custom-vms","text":"The command: ztc vm custom export short_name destination exports the custom VM identified by short_name to destination . If destination is a folder, a file short_name.tar.xz will be generated in the folder packing together all the needed custom VM files. Such archive can be shared with other users completely enabling them to use the custom device and custom VM with their ZTC. If destination is a Github url, the custom VM files are pushed to the repository (provided that Github credentials are known to the ZTC).","title":"Export Custom VMs"},{"location":"reference/core/toolchain/docs/virtualmachines_vmcmd/#import-custom-vms","text":"The command: ztc vm custom import source imports a custom VM from source . If source is a tar.xz file generated by the export command, it is unpacked and installed in the current Zerynth instance. If source is a Github repository, it is cloned and installed.","title":"Import Custom VMs"},{"location":"reference/core/toolchain/docs/virtualmachines_vmcmd/#list-customizable-vms","text":"The command: ztc vm custom original lists the VMs that are customizable. Not all VMs support customization. The output of the command contains the list of target names to be used in the create command.","title":"List customizable VMs"},{"location":"reference/core/toolchain/docs/virtualmachines_vmcmd/#list-custom-vms","text":"The command: ztc vm custom list prints the list of custom VMs available on the current Zerynth instance.","title":"List custom VMs"},{"location":"reference/core/toolchain/docs/ztc/","text":"Synopsis \u00b6 The ZTC is launched by typing ztc in a console. Note In Windows and Mac installations, the PATH environmental variable is automatically updated in such a way that ztc is globally available for the user. In Linux installations, due to the many different shells, the PATH must be set manually to the following path: <installation-dir>/ztc/linux64 . ztc takes commands and options as arguments: ztc [ g_options ] [ command ] [ l_options ] [g_options] are global options that alter the behaviour of all subcommands [command] is a specific command for the available list of commands [l_options] are options specific to the command and are documented in each command section Global options \u00b6 The following global options are accepted by ztc --help shows the global options and avaialable commands. --help can also be used as a local option showing the help relative to the given command. --colors / --no-colors enables/disables colored output. Default is enabled. ztc automatically detect if it is launched in a terminal capable of colored output and disables colors if not supported. --traceback / --no-traceback enables/disables the full output for exceptions. The ZTC is written in Python and in case of unexpected errors can output the full Python traceback for debugging purposes. --user-agent agent set the user-agent http header used in REST calls. It is used to monitor the integration of the ZTC in different tools. In general the agent value should be the name of the tool integrating the ZTC. The value ztc and ide are reserved for command line usage of the ZTC or usage through Zerynth Studio, respectively. -J enables the JSON output for commands. It is generally used by external tools using the ZTC to get easily machine readable output. If the -J is not given, the output of commands is more human readable. --pretty is used in conjuction with -J and produces nicely formatted JSON output. Command List \u00b6 The ZTC contains many different commands and each one may take subcommand as additional parameters. Commands are best listed by grouping them by functionality as follows. Account related commands Project related commands Device related commands Virtual Machine related commands Compile command Uplink command Package related commands Namespace related commands Other commands Output conventions \u00b6 All commands can produce tagged and untagged messages. Tagged messages are prefixed by [type] where type can be one of: info : informative message, printed to stdout warning : warning message, printed to stderr error : error message, printed to stderr . Signals a non fatal error condition without stopping the execution fatal : error message, printed to stderr . Signals a fatal error condition stopping the execution and setting an error return value. It can optionally be followed by a Python traceback in case of unexpected Exception. Untagged messages are not colored and not prefixed. The result of a command generally consists of one or more untagged messages. If the -J option is given without --pretty , almost every command output is a single untagged line. Directories \u00b6 The ZTC is organized on disk in a set of directories stored under ~/zerynth2 for Linux and Mac or under C:Usersusernamezerynth2 for Windows. The following directory tree is created: zerynth2 | |-- cfg # configuration files, device database, clone of online package database | |-- sys # system packages, platform dependent | |-- vms # virtual machines storage | \\ -- dist # all installed ZTC versions | |-- r2 . 0.0 # ZTC version r2.0.0 |-- r2 . 0.1 # ZTC version r2.0.1 | . . Every successful ZTC installation or update is kept in a separate directory ( dist/version ) so that in case of corrupted installation, the previous working ZTC can be used.","title":"Synopsis"},{"location":"reference/core/toolchain/docs/ztc/#synopsis","text":"The ZTC is launched by typing ztc in a console. Note In Windows and Mac installations, the PATH environmental variable is automatically updated in such a way that ztc is globally available for the user. In Linux installations, due to the many different shells, the PATH must be set manually to the following path: <installation-dir>/ztc/linux64 . ztc takes commands and options as arguments: ztc [ g_options ] [ command ] [ l_options ] [g_options] are global options that alter the behaviour of all subcommands [command] is a specific command for the available list of commands [l_options] are options specific to the command and are documented in each command section","title":"Synopsis"},{"location":"reference/core/toolchain/docs/ztc/#global-options","text":"The following global options are accepted by ztc --help shows the global options and avaialable commands. --help can also be used as a local option showing the help relative to the given command. --colors / --no-colors enables/disables colored output. Default is enabled. ztc automatically detect if it is launched in a terminal capable of colored output and disables colors if not supported. --traceback / --no-traceback enables/disables the full output for exceptions. The ZTC is written in Python and in case of unexpected errors can output the full Python traceback for debugging purposes. --user-agent agent set the user-agent http header used in REST calls. It is used to monitor the integration of the ZTC in different tools. In general the agent value should be the name of the tool integrating the ZTC. The value ztc and ide are reserved for command line usage of the ZTC or usage through Zerynth Studio, respectively. -J enables the JSON output for commands. It is generally used by external tools using the ZTC to get easily machine readable output. If the -J is not given, the output of commands is more human readable. --pretty is used in conjuction with -J and produces nicely formatted JSON output.","title":"Global options"},{"location":"reference/core/toolchain/docs/ztc/#command-list","text":"The ZTC contains many different commands and each one may take subcommand as additional parameters. Commands are best listed by grouping them by functionality as follows. Account related commands Project related commands Device related commands Virtual Machine related commands Compile command Uplink command Package related commands Namespace related commands Other commands","title":"Command List"},{"location":"reference/core/toolchain/docs/ztc/#output-conventions","text":"All commands can produce tagged and untagged messages. Tagged messages are prefixed by [type] where type can be one of: info : informative message, printed to stdout warning : warning message, printed to stderr error : error message, printed to stderr . Signals a non fatal error condition without stopping the execution fatal : error message, printed to stderr . Signals a fatal error condition stopping the execution and setting an error return value. It can optionally be followed by a Python traceback in case of unexpected Exception. Untagged messages are not colored and not prefixed. The result of a command generally consists of one or more untagged messages. If the -J option is given without --pretty , almost every command output is a single untagged line.","title":"Output conventions"},{"location":"reference/core/toolchain/docs/ztc/#directories","text":"The ZTC is organized on disk in a set of directories stored under ~/zerynth2 for Linux and Mac or under C:Usersusernamezerynth2 for Windows. The following directory tree is created: zerynth2 | |-- cfg # configuration files, device database, clone of online package database | |-- sys # system packages, platform dependent | |-- vms # virtual machines storage | \\ -- dist # all installed ZTC versions | |-- r2 . 0.0 # ZTC version r2.0.0 |-- r2 . 0.1 # ZTC version r2.0.1 | . . Every successful ZTC installation or update is kept in a separate directory ( dist/version ) so that in case of corrupted installation, the previous working ZTC can be used.","title":"Directories"},{"location":"reference/guide/docs/","text":"Programming Guide \u00b6 Zerynth scripts are developed in Python 3.4. Most of the Python Standard Library functions, types and operators are available also in Zerynth, some high level processing features have been removed because not usable in embedded setups and also to reduce the VM dimension allowing the embedded porting. Differences from Zerynth and Python 3.4 standard library are reported in VM Guide. The following guide is consequently an adaptation of Python 3.0 official standard library guide that can be used for Python syntax, types, operators and constants details and use. The \u201cPython standard library\u201d contains several different kinds of components. It contains data types that would normally be considered part of the \u201ccore\u201d of a language, such as numbers and lists. In addition, the Zerynth library also contains a set of builtins that can be used in Zerynth scripts without the need of an import statement. The bulk of the library, however, consists of a collection of modules (that require import to be used in scripts). Some modules provide interfaces that are highly specific to Zerynth, like managing threads and the board\u2019s hardware and peripherals and connections; some other provides interfaces that are specific for particular sensors, shields and auxiliary boards. This manual is organized \u201cfrom top to bottom\u201d it first describes how to start with Zerynth, then shows you some examples and finally goes in details with description of Zerynth built-in functions and modules.","title":"Programming Guide"},{"location":"reference/guide/docs/#programming-guide","text":"Zerynth scripts are developed in Python 3.4. Most of the Python Standard Library functions, types and operators are available also in Zerynth, some high level processing features have been removed because not usable in embedded setups and also to reduce the VM dimension allowing the embedded porting. Differences from Zerynth and Python 3.4 standard library are reported in VM Guide. The following guide is consequently an adaptation of Python 3.0 official standard library guide that can be used for Python syntax, types, operators and constants details and use. The \u201cPython standard library\u201d contains several different kinds of components. It contains data types that would normally be considered part of the \u201ccore\u201d of a language, such as numbers and lists. In addition, the Zerynth library also contains a set of builtins that can be used in Zerynth scripts without the need of an import statement. The bulk of the library, however, consists of a collection of modules (that require import to be used in scripts). Some modules provide interfaces that are highly specific to Zerynth, like managing threads and the board\u2019s hardware and peripherals and connections; some other provides interfaces that are specific for particular sensors, shields and auxiliary boards. This manual is organized \u201cfrom top to bottom\u201d it first describes how to start with Zerynth, then shows you some examples and finally goes in details with description of Zerynth built-in functions and modules.","title":"Programming Guide"},{"location":"reference/guide/docs/basics/","text":"Python Basics \u00b6 Types and Operators \u00b6 This is quick reference guide for Python 3 Syntax that can be usefull during Zerynth scripts development. This section is based on the official Python 3 guide . In this guide input (what is wrote in the Zerynth Python script) and output (the results of the operations) are distinguished by the presence or absence of the prompts line characters (>>> and \u2026). This reference has been adopted in order to be aligned with the official Python 3 guide and also to allow testing these examples, if necessary for better understanding, also on the the Python interpreter. Let\u2019s go step by step. Comments \u00b6 Comments in Python start with the hash character, # , and extend to the end of the physical line. Some examples: # this is the first comment spam = 1 # and this is the second comment # ... and now a third! text = \"# This is not a comment because it's inside quotes.\" Let\u2019s see some simple Python operations. Numbers \u00b6 The operators + , - , * and / work just like in most other languages; parentheses () can be used for grouping. For example: >>> 2 + 2 4 >>> 50 - 5 * 6 20 >>> ( 50 - 5 * 6 ) / 4 5.0 >>> 8 / 5 # division always returns a floating point number 1.6 The integer numbers (e.g. 2 , 4 , 20 ) have type int() , the ones with a fractional part (e.g. 5.0 , 1.6 ) have type float() . Division ( / ) always returns a float. To do floor division and get an integer result (discarding any fractional result) you can use the // operator; to calculate the remainder you can use % : >>> 17 / 3 # classic division returns a float 5.666666666666667 >>> >>> 17 // 3 # floor division discards the fractional part 5 >>> 17 % 3 # the % operator returns the remainder of the division 2 >>> 5 * 3 + 2 # result * divisor + remainder 17 With Python, it is possible to use the ** operator to calculate powers >>> 5 ** 2 # 5 squared 25 >>> 2 ** 7 # 2 to the power of 7 128 The equal sign ( = ) is used to assign a value to a variable. >>> width = 20 >>> height = 5 * 9 If a variable is not \u201cdefined\u201d (assigned a value), trying to use it will give you an error. Strings \u00b6 Besides numbers, Python can also manipulate strings, which can be expressed in several ways. They can be enclosed in single quotes ( '...' ) or double quotes ( \"...\" ) with the same result. \\\\ can be used to escape quotes: >>> 'spam eggs' # single quotes 'spam eggs' >>> 'doesn \\' t' # use \\' to escape the single quote... \"doesn't\" >>> \"doesn't\" # ...or use double quotes instead \"doesn't\" >>> '\"Yes,\" he said.' '\"Yes,\" he said.' >>> \" \\\" Yes, \\\" he said.\" '\"Yes,\" he said.' >>> '\"Isn \\' t,\" she said.' '\"Isn \\' t,\" she said.' Strings can be concatenated (glued together) with the + operator, and repeated with * : >>> # 3 times 'un', followed by 'ium' >>> 3 * 'un' + 'ium' 'unununium' Two or more string literals (i.e. the ones enclosed between quotes) next to each other are automatically concatenated. >>> 'Py' 'thon' 'Python' This only works with two literals though, not with variables or expressions: >>> prefix = 'Py' >>> prefix 'thon' # can't concatenate a variable and a string literal ... SyntaxError : invalid syntax >>> ( 'un' * 3 ) 'ium' ... SyntaxError : invalid syntax If you want to concatenate variables or a variable and a literal, use + : >>> prefix + 'thon' 'Python' This feature is particularly useful when you want to break long strings: >>> text = ( 'Put several strings within parentheses ' 'to have them joined together.' ) >>> text 'Put several strings within parentheses to have them joined together.' Strings can be indexed (subscripted), with the first character having index 0. There is no separate character type; a character is simply a string of size one: >>> word = 'Python' >>> word [ 0 ] # character in position 0 'P' >>> word [ 5 ] # character in position 5 'n' Indices may also be negative numbers, to start counting from the right: >>> word [ - 1 ] # last character 'n' >>> word [ - 2 ] # second-last character 'o' >>> word [ - 6 ] 'P' Note that since -0 is the same as 0, negative indices start from -1. In addition to indexing, slicing is also supported. While indexing is used to obtain individual characters, slicing allows you to obtain substring: >>> word [ 0 : 2 ] # characters from position 0 (included) to 2 (excluded) 'Py' >>> word [ 2 : 5 ] # characters from position 2 (included) to 5 (excluded) 'tho' Note how the start is always included, and the end always excluded. This makes sure that s[:i] + s[i:] is always equal to s : >>> word [: 2 ] + word [ 2 :] 'Python' >>> word [: 4 ] + word [ 4 :] 'Python' Slice indices have useful defaults; an omitted first index defaults to zero, an omitted second index defaults to the size of the string being sliced. >>> word [: 2 ] # character from the beginning to position 2 (excluded) 'Py' >>> word [ 4 :] # characters from position 4 (included) to the end 'on' >>> word [ - 2 :] # characters from the second-last (included) to the end 'on' Python strings cannot be changed \u2014 they are immutable. Therefore, assigning to an indexed position in the string results in an error: >>> word [ 0 ] = 'J' ... TypeError : 'str' object does not support item assignment >>> word [ 2 :] = 'py' ... TypeError : 'str' object does not support item assignment If you need a different string, you should create a new one: >>> 'J' + word [ 1 :] 'Jython' >>> word [: 2 ] + 'py' 'Pypy' The built-in function len() returns the length of a string: >>> s = 'supercalifragilisticexpialidocious' >>> len ( s ) 34 Lists \u00b6 Python knows a number of compound data types, used to group together other values. The most versatile is the list , which can be written as a list of comma-separated values (items) between square brackets. Lists might contain items of different types, but usually the items all have the same type. >>> squares = [ 1 , 4 , 9 , 16 , 25 ] >>> squares [ 1 , 4 , 9 , 16 , 25 ] Like strings (and all other built-in sequence type), lists can be indexed and sliced: >>> squares [ 0 ] # indexing returns the item 1 >>> squares [ - 1 ] 25 >>> squares [ - 3 :] # slicing returns a new list [ 9 , 16 , 25 ] All slice operations return a new list containing the requested elements. This means that the following slice returns a new (shallow) copy of the list: >>> squares [:] [ 1 , 4 , 9 , 16 , 25 ] Lists also support operations like concatenation: >>> squares + [ 36 , 49 , 64 , 81 , 100 ] [ 1 , 4 , 9 , 16 , 25 , 36 , 49 , 64 , 81 , 100 ] Unlike strings, which are immutable, lists are a mutable type, i.e. it is possible to change their content: >>> cubes = [ 1 , 8 , 27 , 65 , 125 ] # something's wrong here >>> 4 ** 3 # the cube of 4 is 64, not 65! 64 >>> cubes [ 3 ] = 64 # replace the wrong value >>> cubes [ 1 , 8 , 27 , 64 , 125 ] You can also add new items at the end of the list, by using the append() method (we will see more about methods later): >>> cubes . append ( 216 ) # add the cube of 6 >>> cubes . append ( 7 ** 3 ) # and the cube of 7 >>> cubes [ 1 , 8 , 27 , 64 , 125 , 216 , 343 ] Assignment to slices is also possible, and this can even change the size of the list or clear it entirely: >>> letters = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' ] >>> letters [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' ] >>> # replace some values >>> letters [ 2 : 5 ] = [ 'C' , 'D' , 'E' ] >>> letters [ 'a' , 'b' , 'C' , 'D' , 'E' , 'f' , 'g' ] >>> # now remove them >>> letters [ 2 : 5 ] = [] >>> letters [ 'a' , 'b' , 'f' , 'g' ] >>> # clear the list by replacing all the elements with an empty list >>> letters [:] = [] >>> letters [] The built-in function len() also applies to lists: >>> letters = [ 'a' , 'b' , 'c' , 'd' ] >>> len ( letters ) 4 It is possible to nest lists (create lists containing other lists), for example: >>> a = [ 'a' , 'b' , 'c' ] >>> n = [ 1 , 2 , 3 ] >>> x = [ a , n ] >>> x [[ 'a' , 'b' , 'c' ], [ 1 , 2 , 3 ]] >>> x [ 0 ] [ 'a' , 'b' , 'c' ] >>> x [ 0 ][ 1 ] 'b' Control Flow Tools \u00b6 Python knows the usual control flow statements known from other languages, with some twists. if Statements \u00b6 Perhaps the most well-known statement type is the if statement. For example: >>> x = int ( input ( \"Please enter an integer: \" )) Please enter an integer : 42 >>> if x < 0 : ... x = 0 ... print ( 'Negative changed to zero' ) ... elif x == 0 : ... print ( 'Zero' ) ... elif x == 1 : ... print ( 'Single' ) ... else : ... print ( 'More' ) ... More There can be zero or more elif parts, and the else part is optional. The keyword \u2018 elif \u2019 is short for \u2018else if\u2019, and is useful to avoid excessive indentation. An if \u2026 elif \u2026 elif \u2026 sequence is a substitute for the switch or case statements found in other languages. while Statements \u00b6 The while statement is in Python similar to C and other most used languages. The basic example is: while True : a = a + 1 print ( a ) This code will print 1, 2, 3\u2026.. until the execution is killed. The True can be replaced by any boolean expression: x = 0 while x < 5 : x = x + 1 print ( x ) ... ... 1 2 3 4 for Statements \u00b6 The for statement in Python differs a bit from what you may be used to in C or Pascal. Rather than always iterating over an arithmetic progression of numbers (like in Pascal), or giving the user the ability to define both the iteration step and halting condition (as C), Python\u2019s for statement iterates over the items of any sequence (a list or a string), in the order that they appear in the sequence. For example (no pun intended): >>> # Measure some strings: ... words = [ 'cat' , 'window' , 'defenestrate' ] >>> for w in words : ... print ( w , len ( w )) ... cat 3 window 6 defenestrate 12 If you need to modify the sequence you are iterating over while inside the loop (for example to duplicate selected items), it is recommended that you first make a copy. Iterating over a sequence does not implicitly make a copy. The range() Function \u00b6 If you do need to iterate over a sequence of numbers, the built-in function range() comes in handy. It generates arithmetic progressions: >>> for i in range ( 5 ): ... print ( i ) ... 0 1 2 3 4 The given end point is never part of the generated sequence; range(10) generates 10 values, the legal indices for items of a sequence of length 10. It is possible to let the range start at another number, or to specify a different increment (even negative; sometimes this is called the \u2018step\u2019): range ( 5 , 10 ) 5 through 9 range ( 0 , 10 , 3 ) 0 , 3 , 6 , 9 range ( - 10 , - 100 , - 30 ) - 10 , - 40 , - 70 To iterate over the indices of a sequence, you can combine range() and len() as follows: >>> a = [ 'Mary' , 'had' , 'a' , 'little' , 'lamb' ] >>> for i in range ( len ( a )): ... print ( i , a [ i ]) ... 0 Mary 1 had 2 a 3 little 4 lamb break and continue Statements, and else Clauses on Loops \u00b6 The break statement, like in C, breaks out of the smallest enclosing for or while loop. Loop statements may have an else clause; it is executed when the loop terminates through exhaustion of the list (with for ) or when the condition becomes false (with while ), but not when the loop is terminated by a break statement. This is exemplified by the following loop, which searches for prime numbers: >>> for n in range ( 2 , 10 ): ... for x in range ( 2 , n ): ... if n % x == 0 : ... print ( n , 'equals' , x , '*' , n // x ) ... break ... else : ... # loop fell through without finding a factor ... print ( n , 'is a prime number' ) ... 2 is a prime number 3 is a prime number 4 equals 2 * 2 5 is a prime number 6 equals 2 * 3 7 is a prime number 8 equals 2 * 4 9 equals 3 * 3 (Yes, this is the correct code. Look closely: the else clause belongs to the for loop, not the if statement.) When used with a loop, the else clause has more in common with the else clause of a try statement than it does that of if statements: a try statement\u2019s else clause runs when no exception occurs, and a loop\u2019s else clause runs when no break occurs. For more on the try statement and exceptions, see tut-handling. The continue statement, also borrowed from C, continues with the next iteration of the loop: >>> for num in range ( 2 , 10 ): ... if num % 2 == 0 : ... print ( \"Found an even number\" , num ) ... continue ... print ( \"Found a number\" , num ) Found an even number 2 Found a number 3 Found an even number 4 Found a number 5 Found an even number 6 Found a number 7 Found an even number 8 Found a number 9 pass Statements \u00b6 The pass statement does nothing. It can be used when a statement is required syntactically but the program requires no action. For example: >>> while True : ... pass # Busy-wait for keyboard interrupt (Ctrl+C) ... This is commonly used for creating minimal classes: >>> class MyEmptyClass : ... pass ... Another place pass can be used is as a place-holder for a function or conditional body when you are working on new code, allowing you to keep thinking at a more abstract level. The pass is silently ignored: >>> def initlog ( * args ): ... pass # Remember to implement this! ... Defining Functions \u00b6 We can create a function that writes the Fibonacci series to an arbitrary boundary: >>> def fib ( n ): # write Fibonacci series up to n ... \"\"\"Print a Fibonacci series up to n.\"\"\" ... a , b = 0 , 1 ... while a < n : ... print ( a , end = ' ' ) ... a , b = b , a + b ... print () ... >>> # Now call the function we just defined: ... fib ( 2000 ) 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 The keyword def introduces a function definition . It must be followed by the function name and the parenthesized list of formal parameters. The statements that form the body of the function start at the next line, and must be indented. The first statement of the function body can optionally be a string literal; this string literal is the function\u2019s documentation string, or docstring . There are tools which use docstrings to automatically produce online or printed documentation, or to let the user interactively browse through code; it\u2019s good practice to include docstrings in code that you write, so make a habit of it. The execution of a function introduces a new symbol table used for the local variables of the function. More precisely, all variable assignments in a function store the value in the local symbol table; whereas variable references first look in the local symbol table, then in the local symbol tables of enclosing functions, then in the global symbol table, and finally in the table of built-in names. Thus, global variables cannot be directly assigned a value within a function (unless named in a global statement), although they may be referenced. The actual parameters (arguments) to a function call are introduced in the local symbol table of the called function when it is called; thus, arguments are passed using call by value (where the value is always an object reference , not the value of the object). # When a function calls another function, a new local symbol table is created for that call. It is simple to write a function that returns a list of the numbers of the Fibonacci series, instead of printing it: >>> def fib2 ( n ): # return Fibonacci series up to n ... \"\"\"Return a list containing the Fibonacci series up to n.\"\"\" ... result = [] ... a , b = 0 , 1 ... while a < n : ... result . append ( a ) # see below ... a , b = b , a + b ... return result ... >>> f100 = fib2 ( 100 ) # call it >>> f100 # write the result [ 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 ] This example, as usual, demonstrates some new Python features: The return statement returns with a value from a function. return without an expression argument returns None . Falling off the end of a function also returns None . The statement result.append(a) calls a method of the list object result . A method is a function that \u2018belongs\u2019 to an object and is named obj.methodname , where obj is some object (this may be an expression), and methodname is the name of a method that is defined by the object\u2019s type. Different types define different methods. Methods of different types may have the same name without causing ambiguity. (It is possible to define your own object types and methods, using classes , see tut-classes)The method append() shown in the example is defined for list objects; it adds a new element at the end of the list. In this example it is equivalent to result = result + [a] , but more efficient. Default Argument Values \u00b6 The most useful form is to specify a default value for one or more arguments. This creates a function that can be called with fewer arguments than it is defined to allow. For example: def ask_ok ( prompt , retries = 4 , complaint = 'Yes or no, please!' ): while True : ok = input ( prompt ) if ok in ( 'y' , 'ye' , 'yes' ): return True if ok in ( 'n' , 'no' , 'nop' , 'nope' ): return False retries = retries - 1 if retries < 0 : raise OSError ( 'uncooperative user' ) print ( complaint ) This function can be called in several ways: giving only the mandatory argument: ask_ok('Do you really want to quit?') giving one of the optional arguments: ask_ok('OK to overwrite the file?', 2) or even giving all arguments: ask_ok('OK to overwrite the file?', 2, 'Come on, only yes or no!') This example also introduces the in keyword. This tests whether or not a sequence contains a certain value. The default values are evaluated at the point of function definition in the defining scope, so that i = 5 def f ( arg = i ): print ( arg ) i = 6 f () will print 5 . Important warning: The default value is evaluated only once. This makes a difference when the default is a mutable object such as a list, dictionary, or instances of most classes. For example, the following function accumulates the arguments passed to it on subsequent calls: def f ( a , L = []): L . append ( a ) return L print ( f ( 1 )) print ( f ( 2 )) print ( f ( 3 )) This will print [ 1 ] [ 1 , 2 ] [ 1 , 2 , 3 ] If you don\u2019t want the default to be shared between subsequent calls, you can write the function like this instead: def f ( a , L = None ): if L is None : L = [] L . append ( a ) return L Keyword Arguments \u00b6 Functions can also be called using keyword arguments of the form kwarg=value . For instance, the following function: def parrot ( voltage , state = 'a stiff' , action = 'voom' , type = 'Norwegian Blue' ): print ( \"-- This parrot wouldn't\" , action , end = ' ' ) print ( \"if you put\" , voltage , \"volts through it.\" ) print ( \"-- Lovely plumage, the\" , type ) print ( \"-- It's\" , state , \"!\" ) accepts one required argument ( voltage ) and three optional arguments ( state , action , and type ). This function can be called in any of the following ways: parrot ( 1000 ) # 1 positional argument parrot ( voltage = 1000 ) # 1 keyword argument parrot ( voltage = 1000000 , action = 'VOOOOOM' ) # 2 keyword arguments parrot ( action = 'VOOOOOM' , voltage = 1000000 ) # 2 keyword arguments parrot ( 'a million' , 'bereft of life' , 'jump' ) # 3 positional arguments parrot ( 'a thousand' , state = 'pushing up the daisies' ) # 1 positional, 1 keyword but all the following calls would be invalid: parrot () # required argument missing parrot ( voltage = 5.0 , 'dead' ) # non-keyword argument after a keyword argument parrot ( 110 , voltage = 220 ) # duplicate value for the same argument parrot ( actor = 'John Cleese' ) # unknown keyword argument In a function call, keyword arguments must follow positional arguments. All the keyword arguments passed must match one of the arguments accepted by the function (e.g. actor is not a valid argument for the parrot function), and their order is not important. This also includes non-optional arguments (e.g. parrot(voltage=1000) is valid too). No argument may receive a value more than once. Here\u2019s an example that fails due to this restriction: >>> def function ( a ): ... pass ... >>> function ( 0 , a = 0 ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in ? TypeError : function () got multiple values for keyword argument 'a' In Python when a final formal parameter of the form **name is present, it receives a dictionary (see Mapping Types) containing all keyword arguments except for those corresponding to a formal parameter. However this syntax is not yet supported in Zerynth. Arbitrary Argument Lists \u00b6 Finally, a frequently used option is to specify that a function can be called with an arbitrary number of arguments. These arguments will be wrapped up in a tuple (see tut-tuples). Before the variable number of arguments, zero or more normal arguments may occur. def write_multiple_items ( file , separator , * args ): file . write ( separator . join ( args )) Normally, these variadic arguments will be last in the list of formal parameters, because they scoop up all remaining input arguments that are passed to the function. Any formal parameters which occur after the *args parameter are \u2018keyword-only\u2019 arguments, meaning that they can only be used as keywords rather than positional arguments. >>> def concat ( * args , sep = \"/\" ): ... return sep . join ( args ) ... >>> concat ( \"earth\" , \"mars\" , \"venus\" ) 'earth/mars/venus' >>> concat ( \"earth\" , \"mars\" , \"venus\" , sep = \".\" ) 'earth.mars.venus' Unpacking Argument Lists \u00b6 The reverse situation occurs when the arguments are already in a list or tuple but need to be unpacked for a function call requiring separate positional arguments. For instance, the built-in range() function expects separate start and stop arguments. If they are not available separately, write the function call with the * -operator to unpack the arguments out of a list or tuple: >>> list ( range ( 3 , 6 )) # normal call with separate arguments [ 3 , 4 , 5 ] >>> args = [ 3 , 6 ] >>> list ( range ( * args )) # call with arguments unpacked from a list [ 3 , 4 , 5 ] In Python, dictionaries can deliver keyword arguments with the ** -operator. However this syntax is not yet supported in Zerynth.","title":"Python Basics"},{"location":"reference/guide/docs/basics/#python-basics","text":"","title":"Python Basics"},{"location":"reference/guide/docs/basics/#types-and-operators","text":"This is quick reference guide for Python 3 Syntax that can be usefull during Zerynth scripts development. This section is based on the official Python 3 guide . In this guide input (what is wrote in the Zerynth Python script) and output (the results of the operations) are distinguished by the presence or absence of the prompts line characters (>>> and \u2026). This reference has been adopted in order to be aligned with the official Python 3 guide and also to allow testing these examples, if necessary for better understanding, also on the the Python interpreter. Let\u2019s go step by step.","title":"Types and Operators"},{"location":"reference/guide/docs/basics/#comments","text":"Comments in Python start with the hash character, # , and extend to the end of the physical line. Some examples: # this is the first comment spam = 1 # and this is the second comment # ... and now a third! text = \"# This is not a comment because it's inside quotes.\" Let\u2019s see some simple Python operations.","title":"Comments"},{"location":"reference/guide/docs/basics/#numbers","text":"The operators + , - , * and / work just like in most other languages; parentheses () can be used for grouping. For example: >>> 2 + 2 4 >>> 50 - 5 * 6 20 >>> ( 50 - 5 * 6 ) / 4 5.0 >>> 8 / 5 # division always returns a floating point number 1.6 The integer numbers (e.g. 2 , 4 , 20 ) have type int() , the ones with a fractional part (e.g. 5.0 , 1.6 ) have type float() . Division ( / ) always returns a float. To do floor division and get an integer result (discarding any fractional result) you can use the // operator; to calculate the remainder you can use % : >>> 17 / 3 # classic division returns a float 5.666666666666667 >>> >>> 17 // 3 # floor division discards the fractional part 5 >>> 17 % 3 # the % operator returns the remainder of the division 2 >>> 5 * 3 + 2 # result * divisor + remainder 17 With Python, it is possible to use the ** operator to calculate powers >>> 5 ** 2 # 5 squared 25 >>> 2 ** 7 # 2 to the power of 7 128 The equal sign ( = ) is used to assign a value to a variable. >>> width = 20 >>> height = 5 * 9 If a variable is not \u201cdefined\u201d (assigned a value), trying to use it will give you an error.","title":"Numbers"},{"location":"reference/guide/docs/basics/#strings","text":"Besides numbers, Python can also manipulate strings, which can be expressed in several ways. They can be enclosed in single quotes ( '...' ) or double quotes ( \"...\" ) with the same result. \\\\ can be used to escape quotes: >>> 'spam eggs' # single quotes 'spam eggs' >>> 'doesn \\' t' # use \\' to escape the single quote... \"doesn't\" >>> \"doesn't\" # ...or use double quotes instead \"doesn't\" >>> '\"Yes,\" he said.' '\"Yes,\" he said.' >>> \" \\\" Yes, \\\" he said.\" '\"Yes,\" he said.' >>> '\"Isn \\' t,\" she said.' '\"Isn \\' t,\" she said.' Strings can be concatenated (glued together) with the + operator, and repeated with * : >>> # 3 times 'un', followed by 'ium' >>> 3 * 'un' + 'ium' 'unununium' Two or more string literals (i.e. the ones enclosed between quotes) next to each other are automatically concatenated. >>> 'Py' 'thon' 'Python' This only works with two literals though, not with variables or expressions: >>> prefix = 'Py' >>> prefix 'thon' # can't concatenate a variable and a string literal ... SyntaxError : invalid syntax >>> ( 'un' * 3 ) 'ium' ... SyntaxError : invalid syntax If you want to concatenate variables or a variable and a literal, use + : >>> prefix + 'thon' 'Python' This feature is particularly useful when you want to break long strings: >>> text = ( 'Put several strings within parentheses ' 'to have them joined together.' ) >>> text 'Put several strings within parentheses to have them joined together.' Strings can be indexed (subscripted), with the first character having index 0. There is no separate character type; a character is simply a string of size one: >>> word = 'Python' >>> word [ 0 ] # character in position 0 'P' >>> word [ 5 ] # character in position 5 'n' Indices may also be negative numbers, to start counting from the right: >>> word [ - 1 ] # last character 'n' >>> word [ - 2 ] # second-last character 'o' >>> word [ - 6 ] 'P' Note that since -0 is the same as 0, negative indices start from -1. In addition to indexing, slicing is also supported. While indexing is used to obtain individual characters, slicing allows you to obtain substring: >>> word [ 0 : 2 ] # characters from position 0 (included) to 2 (excluded) 'Py' >>> word [ 2 : 5 ] # characters from position 2 (included) to 5 (excluded) 'tho' Note how the start is always included, and the end always excluded. This makes sure that s[:i] + s[i:] is always equal to s : >>> word [: 2 ] + word [ 2 :] 'Python' >>> word [: 4 ] + word [ 4 :] 'Python' Slice indices have useful defaults; an omitted first index defaults to zero, an omitted second index defaults to the size of the string being sliced. >>> word [: 2 ] # character from the beginning to position 2 (excluded) 'Py' >>> word [ 4 :] # characters from position 4 (included) to the end 'on' >>> word [ - 2 :] # characters from the second-last (included) to the end 'on' Python strings cannot be changed \u2014 they are immutable. Therefore, assigning to an indexed position in the string results in an error: >>> word [ 0 ] = 'J' ... TypeError : 'str' object does not support item assignment >>> word [ 2 :] = 'py' ... TypeError : 'str' object does not support item assignment If you need a different string, you should create a new one: >>> 'J' + word [ 1 :] 'Jython' >>> word [: 2 ] + 'py' 'Pypy' The built-in function len() returns the length of a string: >>> s = 'supercalifragilisticexpialidocious' >>> len ( s ) 34","title":"Strings"},{"location":"reference/guide/docs/basics/#lists","text":"Python knows a number of compound data types, used to group together other values. The most versatile is the list , which can be written as a list of comma-separated values (items) between square brackets. Lists might contain items of different types, but usually the items all have the same type. >>> squares = [ 1 , 4 , 9 , 16 , 25 ] >>> squares [ 1 , 4 , 9 , 16 , 25 ] Like strings (and all other built-in sequence type), lists can be indexed and sliced: >>> squares [ 0 ] # indexing returns the item 1 >>> squares [ - 1 ] 25 >>> squares [ - 3 :] # slicing returns a new list [ 9 , 16 , 25 ] All slice operations return a new list containing the requested elements. This means that the following slice returns a new (shallow) copy of the list: >>> squares [:] [ 1 , 4 , 9 , 16 , 25 ] Lists also support operations like concatenation: >>> squares + [ 36 , 49 , 64 , 81 , 100 ] [ 1 , 4 , 9 , 16 , 25 , 36 , 49 , 64 , 81 , 100 ] Unlike strings, which are immutable, lists are a mutable type, i.e. it is possible to change their content: >>> cubes = [ 1 , 8 , 27 , 65 , 125 ] # something's wrong here >>> 4 ** 3 # the cube of 4 is 64, not 65! 64 >>> cubes [ 3 ] = 64 # replace the wrong value >>> cubes [ 1 , 8 , 27 , 64 , 125 ] You can also add new items at the end of the list, by using the append() method (we will see more about methods later): >>> cubes . append ( 216 ) # add the cube of 6 >>> cubes . append ( 7 ** 3 ) # and the cube of 7 >>> cubes [ 1 , 8 , 27 , 64 , 125 , 216 , 343 ] Assignment to slices is also possible, and this can even change the size of the list or clear it entirely: >>> letters = [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' ] >>> letters [ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , 'g' ] >>> # replace some values >>> letters [ 2 : 5 ] = [ 'C' , 'D' , 'E' ] >>> letters [ 'a' , 'b' , 'C' , 'D' , 'E' , 'f' , 'g' ] >>> # now remove them >>> letters [ 2 : 5 ] = [] >>> letters [ 'a' , 'b' , 'f' , 'g' ] >>> # clear the list by replacing all the elements with an empty list >>> letters [:] = [] >>> letters [] The built-in function len() also applies to lists: >>> letters = [ 'a' , 'b' , 'c' , 'd' ] >>> len ( letters ) 4 It is possible to nest lists (create lists containing other lists), for example: >>> a = [ 'a' , 'b' , 'c' ] >>> n = [ 1 , 2 , 3 ] >>> x = [ a , n ] >>> x [[ 'a' , 'b' , 'c' ], [ 1 , 2 , 3 ]] >>> x [ 0 ] [ 'a' , 'b' , 'c' ] >>> x [ 0 ][ 1 ] 'b'","title":"Lists"},{"location":"reference/guide/docs/basics/#control-flow-tools","text":"Python knows the usual control flow statements known from other languages, with some twists.","title":"Control Flow Tools"},{"location":"reference/guide/docs/basics/#if-statements","text":"Perhaps the most well-known statement type is the if statement. For example: >>> x = int ( input ( \"Please enter an integer: \" )) Please enter an integer : 42 >>> if x < 0 : ... x = 0 ... print ( 'Negative changed to zero' ) ... elif x == 0 : ... print ( 'Zero' ) ... elif x == 1 : ... print ( 'Single' ) ... else : ... print ( 'More' ) ... More There can be zero or more elif parts, and the else part is optional. The keyword \u2018 elif \u2019 is short for \u2018else if\u2019, and is useful to avoid excessive indentation. An if \u2026 elif \u2026 elif \u2026 sequence is a substitute for the switch or case statements found in other languages.","title":"if Statements"},{"location":"reference/guide/docs/basics/#while-statements","text":"The while statement is in Python similar to C and other most used languages. The basic example is: while True : a = a + 1 print ( a ) This code will print 1, 2, 3\u2026.. until the execution is killed. The True can be replaced by any boolean expression: x = 0 while x < 5 : x = x + 1 print ( x ) ... ... 1 2 3 4","title":"while Statements"},{"location":"reference/guide/docs/basics/#for-statements","text":"The for statement in Python differs a bit from what you may be used to in C or Pascal. Rather than always iterating over an arithmetic progression of numbers (like in Pascal), or giving the user the ability to define both the iteration step and halting condition (as C), Python\u2019s for statement iterates over the items of any sequence (a list or a string), in the order that they appear in the sequence. For example (no pun intended): >>> # Measure some strings: ... words = [ 'cat' , 'window' , 'defenestrate' ] >>> for w in words : ... print ( w , len ( w )) ... cat 3 window 6 defenestrate 12 If you need to modify the sequence you are iterating over while inside the loop (for example to duplicate selected items), it is recommended that you first make a copy. Iterating over a sequence does not implicitly make a copy.","title":"for Statements"},{"location":"reference/guide/docs/basics/#the-range-function","text":"If you do need to iterate over a sequence of numbers, the built-in function range() comes in handy. It generates arithmetic progressions: >>> for i in range ( 5 ): ... print ( i ) ... 0 1 2 3 4 The given end point is never part of the generated sequence; range(10) generates 10 values, the legal indices for items of a sequence of length 10. It is possible to let the range start at another number, or to specify a different increment (even negative; sometimes this is called the \u2018step\u2019): range ( 5 , 10 ) 5 through 9 range ( 0 , 10 , 3 ) 0 , 3 , 6 , 9 range ( - 10 , - 100 , - 30 ) - 10 , - 40 , - 70 To iterate over the indices of a sequence, you can combine range() and len() as follows: >>> a = [ 'Mary' , 'had' , 'a' , 'little' , 'lamb' ] >>> for i in range ( len ( a )): ... print ( i , a [ i ]) ... 0 Mary 1 had 2 a 3 little 4 lamb","title":"The range() Function"},{"location":"reference/guide/docs/basics/#break-and-continue-statements-and-else-clauses-on-loops","text":"The break statement, like in C, breaks out of the smallest enclosing for or while loop. Loop statements may have an else clause; it is executed when the loop terminates through exhaustion of the list (with for ) or when the condition becomes false (with while ), but not when the loop is terminated by a break statement. This is exemplified by the following loop, which searches for prime numbers: >>> for n in range ( 2 , 10 ): ... for x in range ( 2 , n ): ... if n % x == 0 : ... print ( n , 'equals' , x , '*' , n // x ) ... break ... else : ... # loop fell through without finding a factor ... print ( n , 'is a prime number' ) ... 2 is a prime number 3 is a prime number 4 equals 2 * 2 5 is a prime number 6 equals 2 * 3 7 is a prime number 8 equals 2 * 4 9 equals 3 * 3 (Yes, this is the correct code. Look closely: the else clause belongs to the for loop, not the if statement.) When used with a loop, the else clause has more in common with the else clause of a try statement than it does that of if statements: a try statement\u2019s else clause runs when no exception occurs, and a loop\u2019s else clause runs when no break occurs. For more on the try statement and exceptions, see tut-handling. The continue statement, also borrowed from C, continues with the next iteration of the loop: >>> for num in range ( 2 , 10 ): ... if num % 2 == 0 : ... print ( \"Found an even number\" , num ) ... continue ... print ( \"Found a number\" , num ) Found an even number 2 Found a number 3 Found an even number 4 Found a number 5 Found an even number 6 Found a number 7 Found an even number 8 Found a number 9","title":"break and continue Statements, and else Clauses on Loops"},{"location":"reference/guide/docs/basics/#pass-statements","text":"The pass statement does nothing. It can be used when a statement is required syntactically but the program requires no action. For example: >>> while True : ... pass # Busy-wait for keyboard interrupt (Ctrl+C) ... This is commonly used for creating minimal classes: >>> class MyEmptyClass : ... pass ... Another place pass can be used is as a place-holder for a function or conditional body when you are working on new code, allowing you to keep thinking at a more abstract level. The pass is silently ignored: >>> def initlog ( * args ): ... pass # Remember to implement this! ...","title":"pass Statements"},{"location":"reference/guide/docs/basics/#defining-functions","text":"We can create a function that writes the Fibonacci series to an arbitrary boundary: >>> def fib ( n ): # write Fibonacci series up to n ... \"\"\"Print a Fibonacci series up to n.\"\"\" ... a , b = 0 , 1 ... while a < n : ... print ( a , end = ' ' ) ... a , b = b , a + b ... print () ... >>> # Now call the function we just defined: ... fib ( 2000 ) 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 The keyword def introduces a function definition . It must be followed by the function name and the parenthesized list of formal parameters. The statements that form the body of the function start at the next line, and must be indented. The first statement of the function body can optionally be a string literal; this string literal is the function\u2019s documentation string, or docstring . There are tools which use docstrings to automatically produce online or printed documentation, or to let the user interactively browse through code; it\u2019s good practice to include docstrings in code that you write, so make a habit of it. The execution of a function introduces a new symbol table used for the local variables of the function. More precisely, all variable assignments in a function store the value in the local symbol table; whereas variable references first look in the local symbol table, then in the local symbol tables of enclosing functions, then in the global symbol table, and finally in the table of built-in names. Thus, global variables cannot be directly assigned a value within a function (unless named in a global statement), although they may be referenced. The actual parameters (arguments) to a function call are introduced in the local symbol table of the called function when it is called; thus, arguments are passed using call by value (where the value is always an object reference , not the value of the object). # When a function calls another function, a new local symbol table is created for that call. It is simple to write a function that returns a list of the numbers of the Fibonacci series, instead of printing it: >>> def fib2 ( n ): # return Fibonacci series up to n ... \"\"\"Return a list containing the Fibonacci series up to n.\"\"\" ... result = [] ... a , b = 0 , 1 ... while a < n : ... result . append ( a ) # see below ... a , b = b , a + b ... return result ... >>> f100 = fib2 ( 100 ) # call it >>> f100 # write the result [ 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 ] This example, as usual, demonstrates some new Python features: The return statement returns with a value from a function. return without an expression argument returns None . Falling off the end of a function also returns None . The statement result.append(a) calls a method of the list object result . A method is a function that \u2018belongs\u2019 to an object and is named obj.methodname , where obj is some object (this may be an expression), and methodname is the name of a method that is defined by the object\u2019s type. Different types define different methods. Methods of different types may have the same name without causing ambiguity. (It is possible to define your own object types and methods, using classes , see tut-classes)The method append() shown in the example is defined for list objects; it adds a new element at the end of the list. In this example it is equivalent to result = result + [a] , but more efficient.","title":"Defining Functions"},{"location":"reference/guide/docs/basics/#default-argument-values","text":"The most useful form is to specify a default value for one or more arguments. This creates a function that can be called with fewer arguments than it is defined to allow. For example: def ask_ok ( prompt , retries = 4 , complaint = 'Yes or no, please!' ): while True : ok = input ( prompt ) if ok in ( 'y' , 'ye' , 'yes' ): return True if ok in ( 'n' , 'no' , 'nop' , 'nope' ): return False retries = retries - 1 if retries < 0 : raise OSError ( 'uncooperative user' ) print ( complaint ) This function can be called in several ways: giving only the mandatory argument: ask_ok('Do you really want to quit?') giving one of the optional arguments: ask_ok('OK to overwrite the file?', 2) or even giving all arguments: ask_ok('OK to overwrite the file?', 2, 'Come on, only yes or no!') This example also introduces the in keyword. This tests whether or not a sequence contains a certain value. The default values are evaluated at the point of function definition in the defining scope, so that i = 5 def f ( arg = i ): print ( arg ) i = 6 f () will print 5 . Important warning: The default value is evaluated only once. This makes a difference when the default is a mutable object such as a list, dictionary, or instances of most classes. For example, the following function accumulates the arguments passed to it on subsequent calls: def f ( a , L = []): L . append ( a ) return L print ( f ( 1 )) print ( f ( 2 )) print ( f ( 3 )) This will print [ 1 ] [ 1 , 2 ] [ 1 , 2 , 3 ] If you don\u2019t want the default to be shared between subsequent calls, you can write the function like this instead: def f ( a , L = None ): if L is None : L = [] L . append ( a ) return L","title":"Default Argument Values"},{"location":"reference/guide/docs/basics/#keyword-arguments","text":"Functions can also be called using keyword arguments of the form kwarg=value . For instance, the following function: def parrot ( voltage , state = 'a stiff' , action = 'voom' , type = 'Norwegian Blue' ): print ( \"-- This parrot wouldn't\" , action , end = ' ' ) print ( \"if you put\" , voltage , \"volts through it.\" ) print ( \"-- Lovely plumage, the\" , type ) print ( \"-- It's\" , state , \"!\" ) accepts one required argument ( voltage ) and three optional arguments ( state , action , and type ). This function can be called in any of the following ways: parrot ( 1000 ) # 1 positional argument parrot ( voltage = 1000 ) # 1 keyword argument parrot ( voltage = 1000000 , action = 'VOOOOOM' ) # 2 keyword arguments parrot ( action = 'VOOOOOM' , voltage = 1000000 ) # 2 keyword arguments parrot ( 'a million' , 'bereft of life' , 'jump' ) # 3 positional arguments parrot ( 'a thousand' , state = 'pushing up the daisies' ) # 1 positional, 1 keyword but all the following calls would be invalid: parrot () # required argument missing parrot ( voltage = 5.0 , 'dead' ) # non-keyword argument after a keyword argument parrot ( 110 , voltage = 220 ) # duplicate value for the same argument parrot ( actor = 'John Cleese' ) # unknown keyword argument In a function call, keyword arguments must follow positional arguments. All the keyword arguments passed must match one of the arguments accepted by the function (e.g. actor is not a valid argument for the parrot function), and their order is not important. This also includes non-optional arguments (e.g. parrot(voltage=1000) is valid too). No argument may receive a value more than once. Here\u2019s an example that fails due to this restriction: >>> def function ( a ): ... pass ... >>> function ( 0 , a = 0 ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in ? TypeError : function () got multiple values for keyword argument 'a' In Python when a final formal parameter of the form **name is present, it receives a dictionary (see Mapping Types) containing all keyword arguments except for those corresponding to a formal parameter. However this syntax is not yet supported in Zerynth.","title":"Keyword Arguments"},{"location":"reference/guide/docs/basics/#arbitrary-argument-lists","text":"Finally, a frequently used option is to specify that a function can be called with an arbitrary number of arguments. These arguments will be wrapped up in a tuple (see tut-tuples). Before the variable number of arguments, zero or more normal arguments may occur. def write_multiple_items ( file , separator , * args ): file . write ( separator . join ( args )) Normally, these variadic arguments will be last in the list of formal parameters, because they scoop up all remaining input arguments that are passed to the function. Any formal parameters which occur after the *args parameter are \u2018keyword-only\u2019 arguments, meaning that they can only be used as keywords rather than positional arguments. >>> def concat ( * args , sep = \"/\" ): ... return sep . join ( args ) ... >>> concat ( \"earth\" , \"mars\" , \"venus\" ) 'earth/mars/venus' >>> concat ( \"earth\" , \"mars\" , \"venus\" , sep = \".\" ) 'earth.mars.venus'","title":"Arbitrary Argument Lists"},{"location":"reference/guide/docs/basics/#unpacking-argument-lists","text":"The reverse situation occurs when the arguments are already in a list or tuple but need to be unpacked for a function call requiring separate positional arguments. For instance, the built-in range() function expects separate start and stop arguments. If they are not available separately, write the function call with the * -operator to unpack the arguments out of a list or tuple: >>> list ( range ( 3 , 6 )) # normal call with separate arguments [ 3 , 4 , 5 ] >>> args = [ 3 , 6 ] >>> list ( range ( * args )) # call with arguments unpacked from a list [ 3 , 4 , 5 ] In Python, dictionaries can deliver keyword arguments with the ** -operator. However this syntax is not yet supported in Zerynth.","title":"Unpacking Argument Lists"},{"location":"reference/guide/docs/clang/","text":"C Language Interface \u00b6 Zerynth allows mixing Python and C code in the same project. The Python language is compiled to bytecode and executed by the VM independently of the target board; C language is compiled to object code dependent on the target microcontroller instruction set. The two can coexist because during the uplinking phase, Zerynth resolves any unresolved symbol from the C code and saves C function addresses in the bytecode. This kind of \u201chybrid\u201d programming is extremely useful in those scenarios where the programmer needs to write or has already written performant low level code for time critical tasks, but wants to retain Python flexibility and readability for non time critical sections. In Zerynth it is therefore possible to call C functions from Python, but not (yet) Python functions from C. To call a C function from Python follow this procedure: Define an \u201cempty\u201d Python function decorated with @c_native (let\u2019s call it pyfn ) As arguments of @c_native pass the name of the C function to be called (let\u2019s call it cfn ), the source files where cfn implementation resides and a list of C macros to be defined during compilation Create the C source file containing cfn and declare cfn using the C macro C_NATIVE() At compile time, @c_native parameters will be used to locate the C source code files and compile them with the appropriate macros defined. When pyfn is called, the VM translates the Python call to a C call. C function call example \u00b6 A minimal example of C function calling from Python follows. In Python: # main.py @c_native ( \"my_c_function\" ,[ \"my_c_source.c\" ],[]) def my_py_function ( a , b ): \"\"\" a simple function that returns the sum of a and b, with a and b integers \"\"\" \" # just pass, the body of my_py_fun is ignored by the compiler pass In C: // my_c_source.c //include zerynth header #include \"zerynth.h\" C_NATIVE ( my_c_function ) { C_NATIVE_UNWARN (); int32_t a , b ; if ( parse_py_args ( \"ii\" , nargs , args , & a , & b ) != 2 ) return ERR_TYPE_EXC ; * res = PSMALLINT_NEW ( a + b ); return ERR_OK ; } In main.py the empty function my_py_function is defined, decorated with @c_native . The @c_native decorator informs the compiler that the body of my_py_fun will be a C function called my_c_function implemented in the file my_c_source.c in the same directory where main.py is residing. In my_c_source.c the function my_c_function is implemented. The macro C_NATIVE(my_c_function) expands to: err_t my_c_function ( int32_t nargs , PObject * self , PObject ** args , PObject ** res ) where: nargs is the number of arguments passed to my_py_function self is the self parameter in case my_py_function` is a method args is an array of PObject*, the generic structure used by the VM to represent Python objects res is a pointer to a PObject containing the result of the function call the returned value is of type err_t The VM passes Python arguments to the C function without touching them; it is responsibility of the C function to convert them as needed. To help the conversion, the function parse_py_args is provided by the VM. The return value of function my_py_function must be set into res and must be of type PObject*. The actual return value of my_c_function is an error code indicating success (ERR_OK) or an exception that is subsequently raised by the VM. For more details on the low level VM functions and macros available for hybrid programming, refer to VM Guide. Macros \u00b6 Some utility macros are added on top of the VM defined macro by the header zerynth.h . C_NATIVE(fn) Used to define the implementation of a C function callable from Python. It equals to: err_t fn ( int nargs , PObject * self , PObject ** args , PObject ** res ) C_NATIVE_UNWARN Silences C warnings about unused C_NATIVE arguments in the body of a C function callable from Python debug(...) If the user defines ZERYNTH_DEBUG before including zerynth.h , this macro behaves like a printf, writing to the default serial port of the virtual machine. Otherwise it does nothing. The printf funcionalities are limited to the following placeholders: %s %i %I %d %D %u %U %x %X %p %c %% . printf(...) If the user defines ZERYNTH_PRINTF before including zerynth.h , this macro behaves like a printf, writing to the default serial port of the virtual machine. Otherwise it does nothing. The printf funcionalities are limited to the following placeholders: %s %i %I %d %D %u %U %x %X %p %c %% . Zerynth \u201cC\u201d Limitations \u00b6 C functions callable from Python have some limitations: floating point math can not be used (yet) C standard library function are not available. Only the following subset can be used: memcpy , memset , memmove , memcmp , memchr malloc , free (implemented as macros calling the garbage collector allocator) strlen Refer to VM Guide for the available api.","title":"C Language Interface"},{"location":"reference/guide/docs/clang/#c-language-interface","text":"Zerynth allows mixing Python and C code in the same project. The Python language is compiled to bytecode and executed by the VM independently of the target board; C language is compiled to object code dependent on the target microcontroller instruction set. The two can coexist because during the uplinking phase, Zerynth resolves any unresolved symbol from the C code and saves C function addresses in the bytecode. This kind of \u201chybrid\u201d programming is extremely useful in those scenarios where the programmer needs to write or has already written performant low level code for time critical tasks, but wants to retain Python flexibility and readability for non time critical sections. In Zerynth it is therefore possible to call C functions from Python, but not (yet) Python functions from C. To call a C function from Python follow this procedure: Define an \u201cempty\u201d Python function decorated with @c_native (let\u2019s call it pyfn ) As arguments of @c_native pass the name of the C function to be called (let\u2019s call it cfn ), the source files where cfn implementation resides and a list of C macros to be defined during compilation Create the C source file containing cfn and declare cfn using the C macro C_NATIVE() At compile time, @c_native parameters will be used to locate the C source code files and compile them with the appropriate macros defined. When pyfn is called, the VM translates the Python call to a C call.","title":"C Language Interface"},{"location":"reference/guide/docs/clang/#c-function-call-example","text":"A minimal example of C function calling from Python follows. In Python: # main.py @c_native ( \"my_c_function\" ,[ \"my_c_source.c\" ],[]) def my_py_function ( a , b ): \"\"\" a simple function that returns the sum of a and b, with a and b integers \"\"\" \" # just pass, the body of my_py_fun is ignored by the compiler pass In C: // my_c_source.c //include zerynth header #include \"zerynth.h\" C_NATIVE ( my_c_function ) { C_NATIVE_UNWARN (); int32_t a , b ; if ( parse_py_args ( \"ii\" , nargs , args , & a , & b ) != 2 ) return ERR_TYPE_EXC ; * res = PSMALLINT_NEW ( a + b ); return ERR_OK ; } In main.py the empty function my_py_function is defined, decorated with @c_native . The @c_native decorator informs the compiler that the body of my_py_fun will be a C function called my_c_function implemented in the file my_c_source.c in the same directory where main.py is residing. In my_c_source.c the function my_c_function is implemented. The macro C_NATIVE(my_c_function) expands to: err_t my_c_function ( int32_t nargs , PObject * self , PObject ** args , PObject ** res ) where: nargs is the number of arguments passed to my_py_function self is the self parameter in case my_py_function` is a method args is an array of PObject*, the generic structure used by the VM to represent Python objects res is a pointer to a PObject containing the result of the function call the returned value is of type err_t The VM passes Python arguments to the C function without touching them; it is responsibility of the C function to convert them as needed. To help the conversion, the function parse_py_args is provided by the VM. The return value of function my_py_function must be set into res and must be of type PObject*. The actual return value of my_c_function is an error code indicating success (ERR_OK) or an exception that is subsequently raised by the VM. For more details on the low level VM functions and macros available for hybrid programming, refer to VM Guide.","title":"C function call example"},{"location":"reference/guide/docs/clang/#macros","text":"Some utility macros are added on top of the VM defined macro by the header zerynth.h . C_NATIVE(fn) Used to define the implementation of a C function callable from Python. It equals to: err_t fn ( int nargs , PObject * self , PObject ** args , PObject ** res ) C_NATIVE_UNWARN Silences C warnings about unused C_NATIVE arguments in the body of a C function callable from Python debug(...) If the user defines ZERYNTH_DEBUG before including zerynth.h , this macro behaves like a printf, writing to the default serial port of the virtual machine. Otherwise it does nothing. The printf funcionalities are limited to the following placeholders: %s %i %I %d %D %u %U %x %X %p %c %% . printf(...) If the user defines ZERYNTH_PRINTF before including zerynth.h , this macro behaves like a printf, writing to the default serial port of the virtual machine. Otherwise it does nothing. The printf funcionalities are limited to the following placeholders: %s %i %I %d %D %u %U %x %X %p %c %% .","title":"Macros"},{"location":"reference/guide/docs/clang/#zerynth-c-limitations","text":"C functions callable from Python have some limitations: floating point math can not be used (yet) C standard library function are not available. Only the following subset can be used: memcpy , memset , memmove , memcmp , memchr malloc , free (implemented as macros calling the garbage collector allocator) strlen Refer to VM Guide for the available api.","title":"Zerynth \u201cC\u201d Limitations"},{"location":"reference/guide/docs/lang/","text":"VM Interface \u00b6 C functions called from Python can create and handle Python entities like lists, tuples, dictionaries and so on. In the current version of Zerynth only a few selected Python data structures can be accessed from C. Since the internal organization of the VM may change without notice is very important to access VM structures via documented macros and functions only. PObject \u00b6 The VM treats every Python object as a pointer to a PObject structure. There exist two types of PObjects: tagged and untagged. Tagged PObjects contains all the object information encoded in the 4 bytes of the pointer. Untagged objects are pointers to actual C structures. As a consequence, tagged PObjects are not allocated on the heap but reside on the stack of a frame of execution. To better understand tagged PObjects imagine the case of integers: representing integers by allocating a PObject structure in memory is both a waste of ram and of computational power. Therefore small signed integers up to 31 bits are represented as tagged pointers . This \u201ctrick\u201d is possible because a PObject pointer is 4 bytes (32 bits) and due to architecture constraints a valid PObject pointer is at least aligned to 2 or 4. In practical terms it means that the least significant bit of a valid PObject pointer is always 0: by \u201ctagging\u201d the PObject pointer, namely changing its lsb to 1, the VM is able to distinguish between concrete PObjects residing on the heap (untagged, lsb=0) and tagged PObjects (lsb=1). The representation of the number 42 as a tagged PObject follows: MSB LSB 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 1 ^--- Sign bit Bit 0 ---^ ^--- TAG = 1 Instead, an untagged PObject is a valid pointer to a C structure organized like this: GCH : B0 B1 B2 B3 B4 B5 B6 B7 DATA : ..... where GCH is an 8 byte header holding both garbage collection info and type/size info; DATA is whatever fields are needed to implement the PObject. Macros \u00b6 S_TAGGED(obj) Check if obj is tagged or untagged. PTYPE(obj) Extract type info from obj (both tagged or untagged) PHEADERTYPE(obj) Extract type info from obj (untagged only) PSMALLINT Type of a PObject representing a small integer (30 bits signed). Tagged. PINTEGER Type of a PObject representing an integer up to int64_t. Untagged. PFLOAT Type of a PObject representing a 64 bits float. Untagged. PBOOL Type of a PObject representing a boolean. Tagged. PSTRING Type of a PObject representing a string. Untagged. PBYTES Type of a PObject representing a byte immutable sequence. Untagged. PBYTEARRAY Type of a PObject representing a byte mutable sequence. Tagged. PSHORTS Type of a PObject representing a 16 bits unsigned integer immutable sequence. Untagged. PSHORTARRAY Type of a PObject representing a 16 bits unsigned integer mutable sequence. Untagged. PLIST Type of a PObject representing a mutable sequence of PObjects. Untagged. PTUPLE Type of a PObject representing an immutable sequence of PObjects. Untagged. PRANGE Type of a PObject representing a range. Untagged. PFSET Type of a PObject representing an immutable set. Untagged. PSET Type of a PObject representing a mutable set. Untagged. PDICT Type of a PObject representing a dictionary. Untagged. PFUNCTION Type of a PObject representing a function. Untagged. PMETHOD Type of a PObject representing a method. Untagged. PCLASS Type of a PObject representing a class. Untagged. PINSTANCE Type of a PObject representing an instance. Untagged. PMODULE Type of a PObject representing a module. Untagged. PBUFFER Type of a PObject representing a buffer. Untagged. PSLICE Type of a PObject representing a slice. Untagged. PITERATOR Type of a PObject representing an iterator over a sequence. Untagged. PFRAME Type of a PObject representing an execution frame. Untagged. PCELL Type of a PObject representing a cell. Tagged. PNONE Type of a PObject representing None. Tagged. PEXCEPTION Type of a PObject representing an exception. Tagged. PNATIVE Type of a PObject representing a native function. Tagged. PSYSOBJ Type of a PObject representing a system object. Untagged. PDRIVER Type of a PObject representing a driver. Tagged. PTHREAD Type of a PObject representing a Python thread. Untagged. Functions \u00b6 int parse_py_args(const char *fmt, int nargs, PObject **args, ...) Given an array of PObject pointers args , with nargs elements, try to convert such elements to C structures according to a format string fmt . fmt is conceptually similar to the format string of printf. The variadic arguments (vararg) are usually pointers to store the converted value of args[n] . The nth character of fmt identifies the type of PObject expected in args[n] . If the length of fmt is greater than nargs , the remaining varargs must also specify default values. fmt may contain any of the following characters in the nth position: \u201cl\u201d: the nth argument must be of type PINTEGER. One vararg required of type int64_t* to store the converted value. \u201cL\u201d: the nth argument is an optional PINTEGER. Two varargs are required, one of type int64_t holding the default value, and one of type int64_t* holding the converted value. \u201ci\u201d: the nth argument must be of type PINTEGER. One vararg required of type int32_t* to store the converted value. \u201cI\u201d: the nth argument is an optional PINTEGER. Two varargs are required, one of type int32_t holding the default value, and one of type int32_t* holding the converted value. \u201cs\u201d: the nth argument must be of type PSTRING or PBYTES or PBYTEARRAY. Two varargs are required; the first of type uint8_t** to hold the byte sequence, the second of type int32_t* to hold the number of elements of the sequence. \u201cS\u201d: the nth argument must be of type PSTRING or PBYTES or PBYTEARRAY. Three varargs are required; the first of type uint_8* holding a default byte sequence, the second of type uint8_t** to hold the byte sequence, the third of type int32_t* to hold the number of elements of the sequence. \u201cb\u201d and \u201cB\u201d: same as \u201cs\u201d and \u201cS\u201d with the difference that the last vararg holds the maximum amount of elements storable in the sequence. \u201cf\u201d: the nth argument must be of type PFLOAT. One vararg required of type double* to store the converted value. \u201cF\u201d: the nth argument is an optional PFLOAT. Two varargs are required, one of type double holding the default value, and one of type double* holding the converted value. Return the number of converted objects. If the return value is less than the length of fmt , a conversion error has occurred. The following code illustrates the use of parse_py_args: int32_t a ; double b ; uint8_t * c ; int32_t len , d ; if ( parse_py_args ( \"ifsI\" , nargs , args , & a , & b , & c , & len , 2 , & d ) != 4 ) return ERR_TYPE_EXC ; // a will hold the converted value of args [ 0 ] ( must be a PSMALLINT ) // b will hold the converted value of args [ 1 ] ( must be a PFLOAT ) // c will hold the byte sequence in args [ 2 ], len will hold the number of bytes in args [ 2 ] // d will hold 2 if nargs <= 3 , otherwise it will hold args [ 3 ] converted from PSMALLINT to int32_t Numbers \u00b6 In the current version there are only three supported type of numbers: PSMALLINT, PINTEGER and PFLOAT. PSMALLINT_NEW(x) Return a tagged PObject of type PSMALLINT containing the integer value x. No overflow check is done. PSMALLINT_VALUE(x) Return the integer value contained in x , a PObject of type PSMALLINT. IS_PSMALLINT(x) Check if x is of type PSMALLINT. INTEGER_VALUE(x) Return the integer value contained in x ; works for PSMALLINT and PINTEGER types. PFLOAT_VALUE(x) Return the float value contained in x , an untagged PObject of type PFLOAT. Functions \u00b6 pinteger_new(int64_t x) Return a PINTEGER object with value x . pfloat_new(double x) Return a PFLOAT object with value x . Bool & None \u00b6 Python has some special values of boolean type, True and False, and a special value None. Accessing such values can be done with the following macros: IS_BOOL(x) Return true if x is a PObject of type PBOOL. PBOOL_TRUE Return a tagged PObject of type PBOOL and value True. PBOOL_FALSE Return a tagged PObject of type PBOOL and value False. MAKE_NONE Return a tagged PObject of type PNONE and value None. Sequences \u00b6 Python provides many objects representing sequences of items. Zerynth supports lists, tuples, bytes, bytearrays, strings and introduces shorts and shortarrays. All this PObjects must be created, accessed and manipulated through the following macros and functions. Macros \u00b6 PSEQUENCE_ELEMENTS(seq) Return the elements of seq . PSEQUENCE_ELEMENTS_SET(seq, n) Set the number of elements of seq to n . PSEQUENCE_SIZE(seq) Return the maximum number of elements storable in seq . PSEQUENCE_BYTES(seq) Return a uint8_t pointer to the bytes stored in seq . PSEQUENCE_SHORTS(seq) Return a uint16_t pointer to the integers stored in seq. PSEQUENCE_OBJECTS(seq) Return a PObject** to the PObjects stored in seq . PLIST_ITEM(lst, i) Return the i-th item in lst with lst of type PLIST. PLIST_SET_ITEM(lst, i, item) Set the i-th item in lst, with of type PLIST. PTUPLE_ITEM(lst, i) Return the i-th item in lst with lst of type PTUPLE. PTUPLE_SET_ITEM(lst, i, item) Set the i-th item in lst to item , with lst of type PTUPLE. Functions \u00b6 PObject *psequence_new(uint8_t type, uint16_t elements) Create an empty sequence of type type with space for at least elements elements. If the requested sequence is mutable, sequence elements are set to 0; if it is immutable, sequence elementes are set to elements and the sequence storage filled with zero. Return a pointer to the created sequence or NULL in case of failure. PObject *pstring_new(uint16_t len, uint8_t *buf) Create a sequence of type PSTRING with len elements. If buf is not NULL, len bytes from buf are used to initialize the string. Return NULL on failure. PObject *pbytes_new(uint16_t len, uint8_t *buf) Create a sequence of type PBYTES with len elements. If buf is not NULL, len bytes from buf are used to initialize the sequence. Return NULL on failure. PObject *pshorts_new(uint16_t len, uint16_t *buf) Create a sequence of type PSHORTS with len elements. If buf is not NULL, len words from buf are used to initialize the sequence. Return NULL on failure. PObject *ptuple_new(uint16_t len, PObject **buf) Create a sequence of type PTUPLE with len elements. If buf is not NULL, len objects from buf are used to initialize the sequence. Return NULL on failure. PObject *plist_new(uint16_t len, PObject **buf) Create a sequence of type PLIST with len elements. If buf is not NULL, len objects from buf are used to initialize the sequence. Sequence elements are set to len. Return NULL on failure. Dictionaries and Sets \u00b6 Some data structures in Python have functionalities similar to hash tables. In particular dictionaries are mappings from keys to values; set and frozenset are collections of items optimized to test the presence of a given item inside the set.Internally, the hash code of an item is calculated and used to find the item inside the structure in a fast way. Dictionaries and sets must be created, managed and manipulated with the following functions and macros only. Set and dictionaries automatically grow as needed. Macros \u00b6 PHASH_ELEMENTS(obj) Return the elements in obj with obj a PDICT, PSET or PFSET. PHASH_SIZE(obj) Return the total space for itens in obj with obj a PDICT, PSET or PFSET. PCHECK_HASHABLE(obj) Return true if obj is hashable, i.e. an hash can be calculated for obj . pdict_put(f,k,v) Add the hashable PObject as a key and PObject v as value, in of type PDICT. pset_put(f,k) Add the hashable PObject k in of type PSET. pdict_get(f,k) Return the value associated with the hashable PObject in of type PDICT. Return NULL if k is not present. pset_get(f,k) Return if the hashable PObject k is in of type PSET or PFSET. Return NULL if k is not present. pdict_del(f,k) Remove k and its associated value from of type PDICT. Return NULL if is not present. pset_del(f,k) Remove k from *f*k in f of type PSET. Return NULL if is not present. Functions \u00b6 PObject*pdict_new(int size) Create an empty dictionary with enough space to hold *size pairs (key,value) Return NULL on failure. PObject*pset_new(int type,int size) Create an empty set or frozenset depending on *type, with enough space to contain *size items. Return NULL on failure. Exceptions \u00b6 The following macros must be returned by functions declared with C_NATIVE to signal the result of the call and eventually rise an exception. Non builtin exception names can not be retrieved by VM system calls, so no exception macro exists; a workaround for this limitation is to pass exception names from Python and store them somewhere in a C structure to be raised when needed. ERR_OK Call successful. ERR_TYPE_EXC Raise TypeError. ERR_ZERODIV_EXC Raise ZeroDivisionError. ERR_ATTRIBUTE_EXC Raise AttributeError. ERR_RUNTIME_EXC Raise RuntimeError. ERR_VALUE_EXC Raise ValueError. ERR_INDEX_EXC Raise IndexError. ERR_KEY_EXC Raise KeyError. ERR_NOT_IMPLEMENTED_EXC Raise NotImplementedError. ERR_UNSUPPORTED_EXC Raise UnsupportedError. ERR_OVERFLOW_EXC Raise OverflowError. ERR_STOP_ITERATION Raise StopIteration. ERR_NAME_EXC Raise NameError. ERR_IOERROR_EXC Raise IOError. ERR_IOERROR_EXC Raise IOError. ERR_CONNECTION_REF_EXC Raise ConnectionRefusedError. ERR_CONNECTION_RES_EXC Raise ConnectionResetError. ERR_CONNECTION_ABR_EXC Raise ConnectionAbortedError. ERR_TIMEOUT_EXC Raise TimeoutError. ERR_PERIPHERAL_ERROR_EXC Raise PeripheralError. ERR_PERIPHERAL_INVALID_PIN_EXC Raise InvalidPinError. ERR_PERIPHERAL_INVALID_HARDWARE_STATUS_EXC Raise InvalidHardwareStatusError. ERR_PERIPHERAL_INITIALIZATION_ERROR Raise HardwareInitializationError.","title":"VM Interface"},{"location":"reference/guide/docs/lang/#vm-interface","text":"C functions called from Python can create and handle Python entities like lists, tuples, dictionaries and so on. In the current version of Zerynth only a few selected Python data structures can be accessed from C. Since the internal organization of the VM may change without notice is very important to access VM structures via documented macros and functions only.","title":"VM Interface"},{"location":"reference/guide/docs/lang/#pobject","text":"The VM treats every Python object as a pointer to a PObject structure. There exist two types of PObjects: tagged and untagged. Tagged PObjects contains all the object information encoded in the 4 bytes of the pointer. Untagged objects are pointers to actual C structures. As a consequence, tagged PObjects are not allocated on the heap but reside on the stack of a frame of execution. To better understand tagged PObjects imagine the case of integers: representing integers by allocating a PObject structure in memory is both a waste of ram and of computational power. Therefore small signed integers up to 31 bits are represented as tagged pointers . This \u201ctrick\u201d is possible because a PObject pointer is 4 bytes (32 bits) and due to architecture constraints a valid PObject pointer is at least aligned to 2 or 4. In practical terms it means that the least significant bit of a valid PObject pointer is always 0: by \u201ctagging\u201d the PObject pointer, namely changing its lsb to 1, the VM is able to distinguish between concrete PObjects residing on the heap (untagged, lsb=0) and tagged PObjects (lsb=1). The representation of the number 42 as a tagged PObject follows: MSB LSB 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0 1 ^--- Sign bit Bit 0 ---^ ^--- TAG = 1 Instead, an untagged PObject is a valid pointer to a C structure organized like this: GCH : B0 B1 B2 B3 B4 B5 B6 B7 DATA : ..... where GCH is an 8 byte header holding both garbage collection info and type/size info; DATA is whatever fields are needed to implement the PObject.","title":"PObject"},{"location":"reference/guide/docs/lang/#macros","text":"S_TAGGED(obj) Check if obj is tagged or untagged. PTYPE(obj) Extract type info from obj (both tagged or untagged) PHEADERTYPE(obj) Extract type info from obj (untagged only) PSMALLINT Type of a PObject representing a small integer (30 bits signed). Tagged. PINTEGER Type of a PObject representing an integer up to int64_t. Untagged. PFLOAT Type of a PObject representing a 64 bits float. Untagged. PBOOL Type of a PObject representing a boolean. Tagged. PSTRING Type of a PObject representing a string. Untagged. PBYTES Type of a PObject representing a byte immutable sequence. Untagged. PBYTEARRAY Type of a PObject representing a byte mutable sequence. Tagged. PSHORTS Type of a PObject representing a 16 bits unsigned integer immutable sequence. Untagged. PSHORTARRAY Type of a PObject representing a 16 bits unsigned integer mutable sequence. Untagged. PLIST Type of a PObject representing a mutable sequence of PObjects. Untagged. PTUPLE Type of a PObject representing an immutable sequence of PObjects. Untagged. PRANGE Type of a PObject representing a range. Untagged. PFSET Type of a PObject representing an immutable set. Untagged. PSET Type of a PObject representing a mutable set. Untagged. PDICT Type of a PObject representing a dictionary. Untagged. PFUNCTION Type of a PObject representing a function. Untagged. PMETHOD Type of a PObject representing a method. Untagged. PCLASS Type of a PObject representing a class. Untagged. PINSTANCE Type of a PObject representing an instance. Untagged. PMODULE Type of a PObject representing a module. Untagged. PBUFFER Type of a PObject representing a buffer. Untagged. PSLICE Type of a PObject representing a slice. Untagged. PITERATOR Type of a PObject representing an iterator over a sequence. Untagged. PFRAME Type of a PObject representing an execution frame. Untagged. PCELL Type of a PObject representing a cell. Tagged. PNONE Type of a PObject representing None. Tagged. PEXCEPTION Type of a PObject representing an exception. Tagged. PNATIVE Type of a PObject representing a native function. Tagged. PSYSOBJ Type of a PObject representing a system object. Untagged. PDRIVER Type of a PObject representing a driver. Tagged. PTHREAD Type of a PObject representing a Python thread. Untagged.","title":"Macros"},{"location":"reference/guide/docs/lang/#functions","text":"int parse_py_args(const char *fmt, int nargs, PObject **args, ...) Given an array of PObject pointers args , with nargs elements, try to convert such elements to C structures according to a format string fmt . fmt is conceptually similar to the format string of printf. The variadic arguments (vararg) are usually pointers to store the converted value of args[n] . The nth character of fmt identifies the type of PObject expected in args[n] . If the length of fmt is greater than nargs , the remaining varargs must also specify default values. fmt may contain any of the following characters in the nth position: \u201cl\u201d: the nth argument must be of type PINTEGER. One vararg required of type int64_t* to store the converted value. \u201cL\u201d: the nth argument is an optional PINTEGER. Two varargs are required, one of type int64_t holding the default value, and one of type int64_t* holding the converted value. \u201ci\u201d: the nth argument must be of type PINTEGER. One vararg required of type int32_t* to store the converted value. \u201cI\u201d: the nth argument is an optional PINTEGER. Two varargs are required, one of type int32_t holding the default value, and one of type int32_t* holding the converted value. \u201cs\u201d: the nth argument must be of type PSTRING or PBYTES or PBYTEARRAY. Two varargs are required; the first of type uint8_t** to hold the byte sequence, the second of type int32_t* to hold the number of elements of the sequence. \u201cS\u201d: the nth argument must be of type PSTRING or PBYTES or PBYTEARRAY. Three varargs are required; the first of type uint_8* holding a default byte sequence, the second of type uint8_t** to hold the byte sequence, the third of type int32_t* to hold the number of elements of the sequence. \u201cb\u201d and \u201cB\u201d: same as \u201cs\u201d and \u201cS\u201d with the difference that the last vararg holds the maximum amount of elements storable in the sequence. \u201cf\u201d: the nth argument must be of type PFLOAT. One vararg required of type double* to store the converted value. \u201cF\u201d: the nth argument is an optional PFLOAT. Two varargs are required, one of type double holding the default value, and one of type double* holding the converted value. Return the number of converted objects. If the return value is less than the length of fmt , a conversion error has occurred. The following code illustrates the use of parse_py_args: int32_t a ; double b ; uint8_t * c ; int32_t len , d ; if ( parse_py_args ( \"ifsI\" , nargs , args , & a , & b , & c , & len , 2 , & d ) != 4 ) return ERR_TYPE_EXC ; // a will hold the converted value of args [ 0 ] ( must be a PSMALLINT ) // b will hold the converted value of args [ 1 ] ( must be a PFLOAT ) // c will hold the byte sequence in args [ 2 ], len will hold the number of bytes in args [ 2 ] // d will hold 2 if nargs <= 3 , otherwise it will hold args [ 3 ] converted from PSMALLINT to int32_t","title":"Functions"},{"location":"reference/guide/docs/lang/#numbers","text":"In the current version there are only three supported type of numbers: PSMALLINT, PINTEGER and PFLOAT. PSMALLINT_NEW(x) Return a tagged PObject of type PSMALLINT containing the integer value x. No overflow check is done. PSMALLINT_VALUE(x) Return the integer value contained in x , a PObject of type PSMALLINT. IS_PSMALLINT(x) Check if x is of type PSMALLINT. INTEGER_VALUE(x) Return the integer value contained in x ; works for PSMALLINT and PINTEGER types. PFLOAT_VALUE(x) Return the float value contained in x , an untagged PObject of type PFLOAT.","title":"Numbers"},{"location":"reference/guide/docs/lang/#functions_1","text":"pinteger_new(int64_t x) Return a PINTEGER object with value x . pfloat_new(double x) Return a PFLOAT object with value x .","title":"Functions"},{"location":"reference/guide/docs/lang/#bool-none","text":"Python has some special values of boolean type, True and False, and a special value None. Accessing such values can be done with the following macros: IS_BOOL(x) Return true if x is a PObject of type PBOOL. PBOOL_TRUE Return a tagged PObject of type PBOOL and value True. PBOOL_FALSE Return a tagged PObject of type PBOOL and value False. MAKE_NONE Return a tagged PObject of type PNONE and value None.","title":"Bool &amp; None"},{"location":"reference/guide/docs/lang/#sequences","text":"Python provides many objects representing sequences of items. Zerynth supports lists, tuples, bytes, bytearrays, strings and introduces shorts and shortarrays. All this PObjects must be created, accessed and manipulated through the following macros and functions.","title":"Sequences"},{"location":"reference/guide/docs/lang/#macros_1","text":"PSEQUENCE_ELEMENTS(seq) Return the elements of seq . PSEQUENCE_ELEMENTS_SET(seq, n) Set the number of elements of seq to n . PSEQUENCE_SIZE(seq) Return the maximum number of elements storable in seq . PSEQUENCE_BYTES(seq) Return a uint8_t pointer to the bytes stored in seq . PSEQUENCE_SHORTS(seq) Return a uint16_t pointer to the integers stored in seq. PSEQUENCE_OBJECTS(seq) Return a PObject** to the PObjects stored in seq . PLIST_ITEM(lst, i) Return the i-th item in lst with lst of type PLIST. PLIST_SET_ITEM(lst, i, item) Set the i-th item in lst, with of type PLIST. PTUPLE_ITEM(lst, i) Return the i-th item in lst with lst of type PTUPLE. PTUPLE_SET_ITEM(lst, i, item) Set the i-th item in lst to item , with lst of type PTUPLE.","title":"Macros"},{"location":"reference/guide/docs/lang/#functions_2","text":"PObject *psequence_new(uint8_t type, uint16_t elements) Create an empty sequence of type type with space for at least elements elements. If the requested sequence is mutable, sequence elements are set to 0; if it is immutable, sequence elementes are set to elements and the sequence storage filled with zero. Return a pointer to the created sequence or NULL in case of failure. PObject *pstring_new(uint16_t len, uint8_t *buf) Create a sequence of type PSTRING with len elements. If buf is not NULL, len bytes from buf are used to initialize the string. Return NULL on failure. PObject *pbytes_new(uint16_t len, uint8_t *buf) Create a sequence of type PBYTES with len elements. If buf is not NULL, len bytes from buf are used to initialize the sequence. Return NULL on failure. PObject *pshorts_new(uint16_t len, uint16_t *buf) Create a sequence of type PSHORTS with len elements. If buf is not NULL, len words from buf are used to initialize the sequence. Return NULL on failure. PObject *ptuple_new(uint16_t len, PObject **buf) Create a sequence of type PTUPLE with len elements. If buf is not NULL, len objects from buf are used to initialize the sequence. Return NULL on failure. PObject *plist_new(uint16_t len, PObject **buf) Create a sequence of type PLIST with len elements. If buf is not NULL, len objects from buf are used to initialize the sequence. Sequence elements are set to len. Return NULL on failure.","title":"Functions"},{"location":"reference/guide/docs/lang/#dictionaries-and-sets","text":"Some data structures in Python have functionalities similar to hash tables. In particular dictionaries are mappings from keys to values; set and frozenset are collections of items optimized to test the presence of a given item inside the set.Internally, the hash code of an item is calculated and used to find the item inside the structure in a fast way. Dictionaries and sets must be created, managed and manipulated with the following functions and macros only. Set and dictionaries automatically grow as needed.","title":"Dictionaries and Sets"},{"location":"reference/guide/docs/lang/#macros_2","text":"PHASH_ELEMENTS(obj) Return the elements in obj with obj a PDICT, PSET or PFSET. PHASH_SIZE(obj) Return the total space for itens in obj with obj a PDICT, PSET or PFSET. PCHECK_HASHABLE(obj) Return true if obj is hashable, i.e. an hash can be calculated for obj . pdict_put(f,k,v) Add the hashable PObject as a key and PObject v as value, in of type PDICT. pset_put(f,k) Add the hashable PObject k in of type PSET. pdict_get(f,k) Return the value associated with the hashable PObject in of type PDICT. Return NULL if k is not present. pset_get(f,k) Return if the hashable PObject k is in of type PSET or PFSET. Return NULL if k is not present. pdict_del(f,k) Remove k and its associated value from of type PDICT. Return NULL if is not present. pset_del(f,k) Remove k from *f*k in f of type PSET. Return NULL if is not present.","title":"Macros"},{"location":"reference/guide/docs/lang/#functions_3","text":"PObject*pdict_new(int size) Create an empty dictionary with enough space to hold *size pairs (key,value) Return NULL on failure. PObject*pset_new(int type,int size) Create an empty set or frozenset depending on *type, with enough space to contain *size items. Return NULL on failure.","title":"Functions"},{"location":"reference/guide/docs/lang/#exceptions","text":"The following macros must be returned by functions declared with C_NATIVE to signal the result of the call and eventually rise an exception. Non builtin exception names can not be retrieved by VM system calls, so no exception macro exists; a workaround for this limitation is to pass exception names from Python and store them somewhere in a C structure to be raised when needed. ERR_OK Call successful. ERR_TYPE_EXC Raise TypeError. ERR_ZERODIV_EXC Raise ZeroDivisionError. ERR_ATTRIBUTE_EXC Raise AttributeError. ERR_RUNTIME_EXC Raise RuntimeError. ERR_VALUE_EXC Raise ValueError. ERR_INDEX_EXC Raise IndexError. ERR_KEY_EXC Raise KeyError. ERR_NOT_IMPLEMENTED_EXC Raise NotImplementedError. ERR_UNSUPPORTED_EXC Raise UnsupportedError. ERR_OVERFLOW_EXC Raise OverflowError. ERR_STOP_ITERATION Raise StopIteration. ERR_NAME_EXC Raise NameError. ERR_IOERROR_EXC Raise IOError. ERR_IOERROR_EXC Raise IOError. ERR_CONNECTION_REF_EXC Raise ConnectionRefusedError. ERR_CONNECTION_RES_EXC Raise ConnectionResetError. ERR_CONNECTION_ABR_EXC Raise ConnectionAbortedError. ERR_TIMEOUT_EXC Raise TimeoutError. ERR_PERIPHERAL_ERROR_EXC Raise PeripheralError. ERR_PERIPHERAL_INVALID_PIN_EXC Raise InvalidPinError. ERR_PERIPHERAL_INVALID_HARDWARE_STATUS_EXC Raise InvalidHardwareStatusError. ERR_PERIPHERAL_INITIALIZATION_ERROR Raise HardwareInitializationError.","title":"Exceptions"},{"location":"reference/guide/docs/pinmap/","text":"Pin Mapping and Naming \u00b6 Zerynth allows multi-board programming. To do this in a reliable and maintainable way it has been necessary to define a pin naming strategy that allows programming native multi-board scripts. In Zerynth we decided to follow the widely accepted Arduino derived pin naming schema where Digital pin are named with Dx where x is the number of the physical pin available on the board (not of the MCU pin!). Similarly, Analog pins are named with Ax . In Zerynth, an attribute* is added to the pin name for specifying the function we are going to use on that specific pin. For example, for using the PWM on pin D3 , we use the D3.PWM name while for capturing data with an ICU D3.ICU is used. DIO is the default attribute for digital pins Dx while ADC is the default for analog pins Ax . Moreover, digitalWrite and digitalRead functions don\u2019t require any attribute specification and can be always used specifying the pin name only ( Dx or Ax ). Let\u2019s see some examples: Zerynth Arduino/Wiring Note x=digitalRead(D1) x=digitalRead(D1) x=digitalRead(A1) x=digitalRead(A1) Use Ax pin as Dx pin x=analogRead(A1) x=analogRead(A1) x=analogRead(D1.ADC) x=analogRead(Ax) Use of ADC on Dx pin digitalWrite(D1,HIGH) digitalWrite(D1,HIGH) digitalWrite(A1,HIGH) digitalWrite(A1,HIGH) Use of Ax pin as Dx pin pwm.write(D1.PWM,period,duty) analogWrite(D1, value) pwm.write(A1.PWM,period,duty) analogWrite(D1, value) Use of Ax as PWM pin x=icu.capture(D1.ICU,samples,time) \u2014 x=icu.capture(A1.ICU,samples,time) \u2014 can.init(D30.CANRX, D31.CANTX) \u2014 Not yet released spi.init(D11.MOSI, D12.MISO, D13.SCK) \u2014 Not yet released i2c.init(D14.SDA,D15.SCL) \u2014 Not yet released In Zerynth names are always UPPERCASE. The following PIN names are included in the Zerynth built-ins: Pin Names: D0 to D127 representing the names of digital pins. A0 to A31 representing the names of analog pins. LED0 to LED7 representing the names of the on-board installed LEDs. BTN0 to BTN3 representing the names of the on-board installed buttons. Pin Attributes (Dx.YYY): MISO, MOSI, SCK representing the attributes of SPI pins. SCL, SDA representing the attributes of I2C pins. RX, TX representing the attributes of Serial pins. DAC representing the attributes of DAC pins. CANTX , CANRX representing the attributes of CAN pins. PWM representing the attributes of PWM pins. ICU representing the attributes of ICU (input capture unit) pins. This naming approach is required for allowing the Zerynth compiler to check for wrong uses of boards pin at scripts compiling time. This is necessary because despite the apparently uniformed Arduino-like pin naming not all the MCU based boards expose the same functionalities on their pins. E.i. on ST Nucleo F401RE pin D0 can be used as PWM, ADC and serial RX while on Arduino DUE the D0 is a serial RX only. For example, the following script can be compiled for the ST Nucleo but will rise an error at compiling time if compiled for an Arduino DUE import pwm pwm . write ( D0 . PWM , 100 , 50 ) while True : print ( \"running PWM on pin D0\" ) sleep ( 200 ) However, this pin naming is an advanced feature of the Zerynth suite and it is required only for specific uses and for functionalities directly related to board wiring and setups like the ICU and the PWM. In most frequent cases where Analog and Digital basic functionalities are used, the Zerynth defaults will automatically set the correct methods for the selected pin. Moreover, all the Zerynth init functions ( can.init() , spi.init() , i2c.init() ) also allow fast configuration by using short-names like ( CAN0 , I2C0 , SPI0 , SERIAL0 ). For example, it is possible to open the serial port 0 with default parameters by calling streams.serial() or opening the serial port 1 by calling streams.serial(SERIAL1) .","title":"Pin Mapping and Naming"},{"location":"reference/guide/docs/pinmap/#pin-mapping-and-naming","text":"Zerynth allows multi-board programming. To do this in a reliable and maintainable way it has been necessary to define a pin naming strategy that allows programming native multi-board scripts. In Zerynth we decided to follow the widely accepted Arduino derived pin naming schema where Digital pin are named with Dx where x is the number of the physical pin available on the board (not of the MCU pin!). Similarly, Analog pins are named with Ax . In Zerynth, an attribute* is added to the pin name for specifying the function we are going to use on that specific pin. For example, for using the PWM on pin D3 , we use the D3.PWM name while for capturing data with an ICU D3.ICU is used. DIO is the default attribute for digital pins Dx while ADC is the default for analog pins Ax . Moreover, digitalWrite and digitalRead functions don\u2019t require any attribute specification and can be always used specifying the pin name only ( Dx or Ax ). Let\u2019s see some examples: Zerynth Arduino/Wiring Note x=digitalRead(D1) x=digitalRead(D1) x=digitalRead(A1) x=digitalRead(A1) Use Ax pin as Dx pin x=analogRead(A1) x=analogRead(A1) x=analogRead(D1.ADC) x=analogRead(Ax) Use of ADC on Dx pin digitalWrite(D1,HIGH) digitalWrite(D1,HIGH) digitalWrite(A1,HIGH) digitalWrite(A1,HIGH) Use of Ax pin as Dx pin pwm.write(D1.PWM,period,duty) analogWrite(D1, value) pwm.write(A1.PWM,period,duty) analogWrite(D1, value) Use of Ax as PWM pin x=icu.capture(D1.ICU,samples,time) \u2014 x=icu.capture(A1.ICU,samples,time) \u2014 can.init(D30.CANRX, D31.CANTX) \u2014 Not yet released spi.init(D11.MOSI, D12.MISO, D13.SCK) \u2014 Not yet released i2c.init(D14.SDA,D15.SCL) \u2014 Not yet released In Zerynth names are always UPPERCASE. The following PIN names are included in the Zerynth built-ins: Pin Names: D0 to D127 representing the names of digital pins. A0 to A31 representing the names of analog pins. LED0 to LED7 representing the names of the on-board installed LEDs. BTN0 to BTN3 representing the names of the on-board installed buttons. Pin Attributes (Dx.YYY): MISO, MOSI, SCK representing the attributes of SPI pins. SCL, SDA representing the attributes of I2C pins. RX, TX representing the attributes of Serial pins. DAC representing the attributes of DAC pins. CANTX , CANRX representing the attributes of CAN pins. PWM representing the attributes of PWM pins. ICU representing the attributes of ICU (input capture unit) pins. This naming approach is required for allowing the Zerynth compiler to check for wrong uses of boards pin at scripts compiling time. This is necessary because despite the apparently uniformed Arduino-like pin naming not all the MCU based boards expose the same functionalities on their pins. E.i. on ST Nucleo F401RE pin D0 can be used as PWM, ADC and serial RX while on Arduino DUE the D0 is a serial RX only. For example, the following script can be compiled for the ST Nucleo but will rise an error at compiling time if compiled for an Arduino DUE import pwm pwm . write ( D0 . PWM , 100 , 50 ) while True : print ( \"running PWM on pin D0\" ) sleep ( 200 ) However, this pin naming is an advanced feature of the Zerynth suite and it is required only for specific uses and for functionalities directly related to board wiring and setups like the ICU and the PWM. In most frequent cases where Analog and Digital basic functionalities are used, the Zerynth defaults will automatically set the correct methods for the selected pin. Moreover, all the Zerynth init functions ( can.init() , spi.init() , i2c.init() ) also allow fast configuration by using short-names like ( CAN0 , I2C0 , SPI0 , SERIAL0 ). For example, it is possible to open the serial port 0 with default parameters by calling streams.serial() or opening the serial port 1 by calling streams.serial(SERIAL1) .","title":"Pin Mapping and Naming"},{"location":"reference/guide/docs/seqmap/","text":"Sequences and Map Types \u00b6 The following sections describe the sequence and mapping types that are built into Zerynth. Iterator Types \u00b6 Python supports a concept of iteration over containers. This is implemented using two distinct methods; these are used to allow user-defined classes to support iteration. One method needs to be defined for container objects to provide iteration support: container.__iter__() Return an iterator object. The object is required to support the iterator protocol described below. iterator objects themselves are required to support the following two methods, which together form the iterator protocol : iterator.\\__iter__() Return the iterator object itself. This is required to allow both containersand iterators to be used with the for and in statements. iterator.\\__next__() Return the next item from the container. If there are no further items, raise the StopIteration exception. Once an iterator\u2019s __next__() method raises StopIteration , it must continue to do so on subsequent calls. Implementations that do not obey this property are deemed broken. Sequence Types \u00b6 There are three basic sequence types: lists, tuples, and range objects. Additional sequence types tailored for processing of binary data and text strings are described in dedicated sections. Common Sequence Operations \u00b6 The operations in the following table are supported by most sequence types,both mutable and immutable. This table lists the sequence operations sorted in ascending priority. In the table, n , i , j and are sequences of the same type, n , i , j and k are integers and is an arbitrary object that meets any type and value restrictions imposed by s . The in and not in operations have the same priorities as thecomparison operations. The + (concatenation) and * (repetition)operations have the same priority as the corresponding numeric operations. Operation Result Notes x in s True if an item of s is equal to x, else False (1) x not in s False if an item of s is equal to x, else True (1) s + t the concatenation of s and t (6)(7) s * n or n * s equivalent to adding s to itself n times (2)(7) s[i] i-th item of s, origin 0 (3) s[i:j] slice of s from i to j (3)(4) s[i:j:k] slice of s from i to j with step k (3)(5) len(s) length of s min(s) smallest item of s max(s) largest item of s s.index(x[, i[, j]]) index of the first occurrence of x in s (at or after i and before j) (8) s.count(x) total number of occurrences of x in s Sequences of the same type also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements.This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. Notes: While the in and not in operations are used only for simple containment testing in the general case, some specialised sequences(such as str() , bytes() and bytearray() ) also use them for subsequence testing: >>> \"gg\" in \"eggs\" True Values of n less than 0 are treated as 0 (which yields an empty sequence of the same type as s ). Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; consider: >>> lists = [[]] * 3 >>> lists [[], [], []] >>> lists [ 0 ] . append ( 3 ) >>> lists [[ 3 ], [ 3 ], [ 3 ]] What has happened is that [[]] is a one-element list containing an empty list, so all three elements of [[]] * 3 are references to this single empty list. Modifying any of the elements of lists modifies this single list.You can create a list of different lists this way: >>> lists = [[] for i in range ( 3 )] >>> lists [ 0 ] . append ( 3 ) >>> lists [ 1 ] . append ( 5 ) >>> lists [ 2 ] . append ( 7 ) >>> lists [[ 3 ], [ 5 ], [ 7 ]] If i or j is negative, the index is relative to the end of the string: len(s) + i or len(s) + j is substituted. But note that -0 isstill 0 . The slice of s from i to is defined as the sequence of items with index k such that i <= k < j . If i or j , i or is greater than len(s) , use len(s) . If i is comitted or None , use 0 . If j is omitted or None , use len(s) . If i is greater than or equal to j , the slice is empty. The slice of s from i to j with step k is defined as the sequence of items with index x = i + n*k such that 0 <= n < (j-i)/k . In other words,the indices are i , i+k , i+2*k , i+3*k and so on, stopping when j is reached (but never including j ). If i or j ). If is greater than len(s) , use len(s) . If i or j are omitted or None , they become\u201cend\u201d values (which end depends on the sign of k ). Note, k cannot be zero. If is None , it is treated like 1`. Concatenating immutable sequences always results in a new object. This means that building up a sequence by repeated concatenation will have a quadratic runtime cost in the total sequence length. To get a linear runtime cost, you must switch to one of the alternatives below: if concatenating str() objects, you can build a list and use str.join() at the end. if concatenating bytes() objects, you can similarly use bytes.join() or you can do in-place concatenation with a bytearray() object. bytearray() objects are mutable and have an efficient overallocation mechanism if concatenating tuple() objects, extend a list() instead for other types, investigate the relevant class documentation Some sequence types (such as range() ) only support item sequences that follow specific patterns, and hence don\u2019t support sequence concatenation or repetition. index raises ValueError when x is not found in s. When supported, the additional arguments to the index method allow efficient searching of subsections of the sequence. Passing the extra arguments is roughly equivalent to using s[i:j].index(x) , only without copying any data and with the returned index being relative to the start of the sequence rather than the start of the slice. Immutable Sequence Types \u00b6 The only feature that immutable sequence types generally implement that is not also implemented by mutable sequence types is hashing support. This support allows immutable sequences, such as tuple() instances, to be used as dict() keys and stored in set() and frozenset() instances. Attempting to hash an immutable sequence that contains unhashable values will result in TypeError . Mutable Sequence Types \u00b6 The operations in the following table are defined on mutable sequence types. In the table s is an instance of a mutable sequence type, t is arbitrary object and x is an arbitrary object that meets any type and value restrictions imposed by s (for example, bytearray() only accepts integers that meet the value restriction 0 <= x <= 255 ). Operation Result Notes s[i] = x item i of s is replaced by x s[i:j] = t slice of s from i to j is replaced by the contents of the iterable t del s[i:j] same as s[i:j] = [] NOT SUPPORTED YET s[i:j:k] = t the elements of s[i:j:k] are replaced by those of t (1) del s[i:j:k] removes the elements of s[i:j:k] from the list NOT SUPPORTED YET s.append(x) appends x to the end of the sequence (same as s[len(s):len(s)] = [x]) s.clear() removes all items from s (same as del s[:]) (5) s.copy() creates a shallow copy of s (same as s[:]) (5) s.extend(t) or s += t extends s with the contents of t (for the most part the same as s[len(s):len(s)] = t) s *= n updates s with its contents repeated n times (6) s.insert(i, x) inserts x into s at the index given by i (same as s[i:i] = [x]) s.pop([i]) retrieves the item at i and also removes it from s (2) s.remove(x) remove the first item from s where s[i] == x (3) s.reverse() reverses the items of s in place (4) Notes: t must have the same length as the slice it is replacing. The optional argument i defaults to -1 , so that by default the last item is removed and returned. remove raises ValueError when x is not found in s . The reverse() method modifies the sequence in place for economy of space when reversing a large sequence. To remind users that it operates by side effect, it does not return the reversed sequence. clear() and copy() are included for consistency with the interfaces of mutable containers that don\u2019t support slicing operations(such as dict() and set() ) The value n is an integer. Zero and negative values of n clear the sequence. Items in the sequence are not copied; they are referenced multiple times, as explained for s * n . Lists \u00b6 Lists are mutable sequences, typically used to store collections of homogeneous items (where the precise degree of similarity will vary by application). Lists may be constructed in several ways: Using a pair of square brackets to denote the empty list: [] Using square brackets, separating items with commas: [a] , [a, b, c] Using a list comprehension: [x for x in iterable] Lists implement all of the common and mutable sequence operations. Tuples \u00b6 Tuples are immutable sequences, typically used to store collections of heterogeneous data (such as the 2-tuples produced by the enumerate() built-in). Tuples are also used for cases where an immutable sequence of homogeneous data is needed. Tuples may be constructed in a number of ways: Using a pair of parentheses to denote the empty tuple: () Using a trailing comma for a singleton tuple: a, or (a,) Separating items with commas: a, b, c or (a, b, c) Tuples implement all of the common sequence operations. Ranges \u00b6 The range type represents an immutable sequence of numbers and is commonly used for looping a specific number of times in for loops. class range(stop) class range(start,stop[,step] ) The arguments to the range constructor must be integers. If the step argument is omitted, it defaults to 1. If the start argument is omitted, it defaults to 0. If step is zero, ValueError is raised. For a positive st, the contents of a range r are determined by the formula r[i] = start + step*i where i >= 0 and r[i] < stop . For a negative *step, the contents of the range are still determined by the formula r[i] = start + step*i , but the constraints are i >= 0 and r[i] > stop . A range object will be empty if r[0] does not meet the value constraint. Ranges do support negative indices, but these are interpreted as indexing from the end of the sequence determined by the positive indices. Ranges implement all of the common sequence operations except concatenation and repetition (due to the fact that range objects can only represent sequences that follow a strict pattern and repetition and concatenation will usually violate that pattern). The advantage of the range() type over a regular list() or tuple() is that a range() object will always take the same(small) amount of memory, no matter the size of the range it represents (as it only stores the start,stop and step values, calculating individual items and sub ranges as needed). Testing range objects for equality with == and != compares them as sequences. That is, two range objects are considered equal if they represent the same sequence of values. (Note that two range objects that compare equal might have different start , stop and step attributes, for example range(0) == range(2, 1, 3) or range(0, 3, 2) == range(0, 4, 2) .) Strings \u00b6 Textual data in Python is handled with strin.. Strings are immutable sequences of 8 bit characters. Zerynth does not support Unicode yet. String literals are written in a variety of ways: Single quotes: 'allows embedded \"double\" quotes' Double quotes: \"allows embedded 'single' quotes\" . Triple quoted: '''Three single quotes''' , \"\"\"Three double quotes\"\"\" Triple quoted strings may span multiple lines - all associated white space will be included in the string literal. String literals that are part of a single expression and have only white space between them will be implicitly converted to a single string literal. That is, (\"spam \" \"eggs\") == \"spam eggs\" . Strings may also be created from other objects using the str builtin. Since there is no separate \u201ccharacter\u201d type, indexing a string produces strings of length 1. That is, for a non-empty string s, s[0] == s[0:1] . There is also no mutable string type, but str.join() can be used to efficiently construct strings from multiple fragments. class str(object='') Return a string version of object. If *object is not provided, returns the empty string. Returns object.__str__() , which is the \u201cinformal\u201d or nicely printable string representation of *object. For string objects, this is the string itself. If *object does not have a __str__() method, then str() raises TypeError. String Methods \u00b6 Strings implement all of the common sequence operations, along with the additional methods described below. Strings also support string formatting based on C printf style formatting.. str.count(sub[,start[,end] ]) Return the number of non-overlapping occurrences of substring sub in the range [ start]. Optional arguments start and *end are interpreted as in slice notation. str.endswith(suffix[,start[,end] ]) Return True if the string ends with the specified suffix, otherwise return False . With optional *start`, test beginning at that position. With optional *end , stop comparing at that position. str.find(sub[,start[,end] ]) Return the lowest index in the string where substring sub is found within the slice s[start:end] . Optional arguments start and end are interpreted as in slice notation. Return -1 if sub is not found. Note The find() method should be used only if you need to know the position of sub . To check if sub is a substring or not, use the in operator. str.index(sub[,start[,end] ]) Like find() , but raise ValueError when the substring is not found. str.join(iterable) Return a string which is the concatenation of the strings in the iterable iterableiterable must be a builtin sequence or builtin map. A TypeError will be raised if there are any non-string values in *iterable, excluding byte and byterray objects that are treated as strings. The separator between elements is the string providing this method. str.lower() Return a copy of the string with all the cased characters converted to lowercase. str.replace(old,new) Return a copy of the string with all occurrences of substring old replaced by new. str.split(sep=None, maxsplit=-1) Return a list of the words in the string, using sep as the delimiter string. If *maxsplit is given, at most *maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If *maxsplit is not specified or -1 , then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty strings (for example, '1,,2'.split(',') returns ['1', '', '2'] ). The sep argument may consist of multiple characters (for example, '1<>2<>3'.split('<>') returns ['1', '2', '3'] ). Splitting an empty string with a specified separator returns [''] . For example: >>> '1,2,3' . split ( ',' ) [ '1' , '2' , '3' ] >>> '1,2,3' . split ( ',' , maxsplit = 1 ) [ '1' , '2,3' ] >>> '1,2,,3,' . split ( ',' ) [ '1' , '2' , '' , '3' , '' ] If sep is not specified, a different splitting algorithm is applied: runs of consecutive whites pace are regarded as a single separator, and the result will contain no empty strings at the start or end if the string has leading or trailing white space. Consequently, splitting an empty string or a string consisting of just white space with a None separator returns [] . For example: >>> '1 2 3' . split () [ '1' , '2' , '3' ] >>> '1 2 3' . split ( maxsplit = 1 ) [ '1' , '2 3' ] >>> ' 1 2 3 ' . split () [ '1' , '2' , '3' ] str.startswith(prefix[,start[,end] ]) Return True if string starts with the prefix , otherwise return False . With optional start test string beginning at that position. With optional end , stop comparing string at that position. str.strip([chars[,dir=0] ]) Return a copy of the string with the leading and trailing characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted, the chars argument defaults to removing whitespace. The chars argument is not a prefix or suffix; rather, all combinations of its values are stripped: >>> ' spacious ' . strip () 'spacious' >>> 'www.example.com' . strip ( 'cmowz.' ) 'example' The dir parameter controls the side of stripping: dir=0, strip chars from left and right side of str dir>0, strip chars from left side of str dir<0, strip chars from right side of str upper() Return a copy of the string with all the cased characters converted to uppercase. printf -style String Formatting \u00b6 String objects have one unique built-in operation: the % operator (modulo). This is also known as the string formatting or interpolation* operator. Given format % values (where *format is a string), % conversion specifications in *format are replaced with zero or more elements of *valuesThe effect is similar to using the sprintf() in the C language. If format requires a single argument, values may be a single non-tuple object. Otherwise, values must be a tuple or list with exactly the number of items specified by the format string, or a single dictionary. A conversion specifier contains two or more characters and has the following components, which must occur in this order: The '%' character, which marks the start of the specifier. Mapping key (optional), consisting of a parenthesised sequence of characters (for example, (somename) ). Conversion flags (optional), which affect the result of some conversion types. Minimum field width (optional). If specified as an '*' (asterisk), the actual width is read from the next element of the tuple in values , and the object to convert comes after the minimum field width and optional precision. Precision (optional), given as a '.' (dot) followed by the precision. If specified as '*' (an asterisk), the actual precision is read from the next element of the tuple in values , and the value to convert comes after the precision. Conversion type. When the right argument is a dictionary (or other mapping type), then the formats in the string must include a parenthesized mapping key into that dictionary inserted immediately after the '%' character. The mapping key selects the value to be formatted from the mapping. For example: >>> print ( ' %(language)s has %(number)03d quote types.' % ... { 'language' : \"Python\" , \"number\" : 2 }) Python has 002 quote types . In this case no * specifiers may occur in a format (since they require a sequential parameter list). The conversion flag characters are: Conversion Meaning Notes 'd' Signed integer decimal. 'i' Signed integer decimal. 'u' Obsolete type \u2013 it is identical to 'd'. 'x' Signed hexadecimal (lowercase). (2) 'X' Signed hexadecimal (uppercase). (2) 'e' Floating point exponential format (lowercase). (3) 'E' Floating point exponential format (uppercase). (3) 'f' Floating point decimal format. (3) 'F' Floating point decimal format. (3) 'g' Floating point format. Uses lowercase exponential format if exponent is less than -4 or not less than precision, decimal format otherwise. (3) 'G' Floating point format. Uses uppercase exponential format if exponent is less than -4 or not less than precision, decimal format otherwise. (3) 's' String (converts any Python object using str()). (4) '%' No argument is converted, results in a '%' character in the result. Note Not all Python conversion types and conversion flags are supported by Zerynth. Refer to Python documentation for the (few) differences. Hexadecimal conversion does not produce the \u201c0x\u201d prefix. In Zerynth \u201cg\u201d and \u201ce\u201d modifiers, together with their uppercase versions are equivalent to \u201cf\u201d or \u201cF\u201d.The precision determines the number of digits after the decimal point and defaults to 6. If precision is N , the output is truncated to N characters. Binary Sequence Types \u00b6 The core built-in types for manipulating binary data are bytes() and bytearray() . Bytes \u00b6 Bytes objects are immutable sequences of single bytes. Bytes are very similar to strings in Zerynth, except that when iterating over them, integers are generated instead of strings. Firstly, the syntax for bytes literals is largely the same as that for string literals, except that a b prefix is added: Single quotes: b'still allows embedded \"double\" quotes' Double quotes: b\"still allows embedded 'single' quotes\". Triple quoted: b'''3 single quotes''' , b\"\"\"3 double quotes\"\"\" Only ASCII characters are permitted in bytes literals. Any binary values over 127 must be entered into bytes literals using the appropriate escape sequence. While bytes literals and representations are based on ASCII text, bytes objects actually behave like immutable sequences of integers, with each value in the sequence restricted such that 0 <= x < 256 (attempts to violate this restriction will trigger ValueError ). This is done deliberately to emphasize that while many binary formats include ASCII based elements and can be usefully manipulated with some text-oriented algorithms, this is not generally the case for arbitrary binary data (blindly applying text processing algorithms to binary data formats that are not ASCII compatible will usually lead to data corruption). In addition to the literal forms, bytes objects can be created in a number of other ways: A zero-filled bytes object of a specified length: bytes(10) From an iterable of integers: bytes([1,2,3]) Since 2 hexadecimal digits correspond precisely to a single byte, hexadecimalnumbers are a commonly used format for describing binary data. Since bytes objects are sequences of integers (akin to a tuple), for a bytes object , b[0] will be an integer, while b[0:1] will be a bytes object of length 1. (This contrasts with text strings, where both indexing and slicing will produce a string of length 1.) Bytearray Objects \u00b6 bytearray() objects are a mutable counterpart to bytes() objects. There is no dedicated literal syntax for bytearray objects, instead they are always created by calling the constructor: Creating an empty instance: bytearray() Creating a zero-filled instance with a given length: bytearray(10) From an iterable of integers: bytearray([1,2,3]) As bytearray objects are mutable, they support the mutable sequence operations in addition to the common bytes and bytearray operations described in Bytes and Bytearray Operations . Since 2 hexadecimal digits correspond precisely to a single byte, hexadecimal numbers are a commonly used format for describing binary data. Since bytearray objects are sequences of integers (akin to a list), for a bytearray object b , b[0] will be an integer, while b[0:1] will be a bytearray object of length 1. (This contrasts with text strings, where both indexing and slicing will produce a string of length 1.) Bytes and Bytearray Operations \u00b6 Both bytes and bytearray objects support the common sequence operations. They interoperate not just with operands of the same type, but with any bytes-like object. Due to this flexibility, they can be freely mixed in operations without causing errors. However, the return type of the result may depend on the order of operands. Note Contrary to Python, in Zerynth the methods on bytes and bytearray objects accept strings as their arguments, just as the methods on strings accept bytes as their arguments. For example, you can write: a = \"abc\" b = a . replace ( b \"a\" , \"f\" ) and: a = b \"abc\" b = a . replace ( \"a\" , b \"f\" ) bytes.count(sub[,start[,end] ]) bytearray.count(sub[, start[, end] ]) Return the number of non-overlapping occurrences of subsequence sub in the range [ start,end ]. Optional arguments start and end are interpreted as in slice notation. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. bytes.endswith(suffix[,start[,end] ]) bytearray.endswith(suffix[,start[,end] ]) Return True if the binary data ends with the specified suffix , otherwise return False . With optional start , test beginning at that position. With optional end , stop comparing at that position. bytes.find(sub[,start[,end] ]) bytearray.find(sub[,start[,end] ]) Return the lowest index in the data where the subsequence sub is found, such that sub is contained in the slice s[start:end] . Optional arguments start and end are interpreted as in slice notation. Return -1 if sub is not found. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Note The find() method should be used only if you need to know the position of sub . To check if sub is a substring or not, use the in operator. bytes.index(sub[, start[, end] ]) bytearray.index(sub[, start[, end] ]) Like find() , but raise ValueError when the subsequence is not found. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. bytes.join(iterable) bytearray.join(iterable) Return a bytes or bytearray object which is the concatenation of the binary data sequences in the iterable iterable . A TypeError will be raised if there are any values in iterable that are not bytes-like objects or strings. The separator between elements is the contents of the bytes or bytearray object providing this method. bytes.replace(old,new) bytearray.replace(old, new) Return a copy of the sequence with all occurrences of subsequence old replaced by new. Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. bytes.startswith(prefix[,start[,end] ]) bytearray.startswith(prefix[,start[,end] ]) Return True if the binary data starts with the specified prefix , otherwise return False . With optional start , test beginning at that position. With optional end , stop comparing at that position. bytes.split(sep=None,maxsplit=-1) bytearray.split(sep=None, maxsplit=-1) Split the binary sequence into subsequences of the same type, using sep as the delimiter string. If maxsplit is given and non-negative, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or is -1 , then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty subsequences (for example, b'1,,2'.split(b',') returns [b'1', b'', b'2'] ). The sep argument may consist of a multibyte sequence (for example, b'1<>2<>3'.split(b'<>') returns [b'1', b'2', b'3'] ). Splitting an empty sequence with a specified separator returns [b''] or [bytearray(b'')] depending on the type of object being split. For example: >>> b '1,2,3' . split ( b ',' ) [ b '1' , b '2' , b '3' ] >>> b '1,2,3' . split ( b ',' , maxsplit = 1 ) [ b '1' , b '2,3' ] >>> b '1,2,,3,' . split ( b ',' ) [ b '1' , b '2' , b '' , b '3' , b '' ] If sep is not specified, a different splitting algorithm is applied: runs of consecutive ASCII whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the sequence has leading or trailing whitespace. Consequently, splitting an empty sequence or a sequence consisting solely of ASCII whitespace without a specified separator returns [] . For example: >>> b '1 2 3' . split () [ b '1' , b '2' , b '3' ] >>> b '1 2 3' . split ( maxsplit = 1 ) [ b '1' , b '2 3' ] >>> b ' 1 2 3 ' . split () [ b '1' , b '2' , b '3' ] bytes.strip([chars[,dir=0] ]) bytearray.strip([chars[,dir=0] ]) Return a copy of the binary sequence with the leading and trailing characters removed. The chars argument is a string or binary sequence specifying the set of characters to be removed. If omitted, the chars argument defaults to removing whitespace. The chars argument is not a prefix or suffix; rather, all combinations of its values are stripped: >>> b ' spacious ' . strip () b 'spacious' >>> b 'www.example.com' . strip ( b 'cmowz.' ) b 'example' The dir parameter controls the side of stripping: dir=0, strip chars from left and right side of str dir>0, strip chars from left side of str dir<0, strip chars from right side of str The following methods on bytes and bytearray objects assume the use of ASCII compatible binary formats and should not be applied to arbitrary binary data. Note that all of the bytearray methods in this section do not operate in place, and instead produce new objects. bytes.lower() bytearray.lower() Return a copy of the sequence with all the uppercase ASCII characters converted to their corresponding lowercase counterpart. Lowercase ASCII characters are those byte values in the sequence b'abcdefghijklmnopqrstuvwxyz' . Uppercase ASCII characters are those byte values in the sequence b'ABCDEFGHIJKLMNOPQRSTUVWXYZ' . bytes.upper() bytearray.upper() Return a copy of the sequence with all the lowercase ASCII characters converted to their corresponding uppercase counterpart. Lowercase ASCII characters are those byte values in the sequence b'abcdefghijklmnopqrstuvwxyz' . Uppercase ASCII characters are those byte values in the sequence b'ABCDEFGHIJKLMNOPQRSTUVWXYZ' . Shorts and Shortarrays \u00b6 Both Shorts and Shortarrays are sequence types added by Zerynth to the standard Python. Shorts and shortsarray objects actually behave like sequences of integers, with each value in the sequence restricted such that 0 <= x < 65536 (attempts to violate this restriction will trigger ValueError ). Shorts objects are immutable sequences of 16 bits integers. Shorts and shortsarray can\u2019t be specified with literals, but only using one of the following ways: A zero-filled bytes object of a specified length: shorts(10) From an iterable of integers: shorts([1,2,3]) Since 4 hexadecimal digits correspond precisely to a 16 bit integer, hexadecimal numbers are a commonly used format for describing binary data. Since shorts objects are sequences of integers (akin to a tuple), for a shorts object b , b[0] will be an integer, while b[0:1] will be a shorts object of length 1. Shortarray objects are mutable sequences of 16 bits integers. Shorts and shortsarray can\u2019t be specified with literals, but only using one of the following ways: A zero-filled bytes object of a specified length: shortarray(10) From an iterable of integers: shortarray([1,2,3]) Since 4 hexadecimal digits correspond precisely to a 16 bit integer, hexadecimal numbers are a commonly used format for describing binary data. Since shortarray objects are sequences of integers (akin to a list), for a shortarray object b , b[0] will be an integer, while b[0:1] will be a shortarray object of length 1. Shorts and shortarryas support only a limited set of methods: count and index with the same syntax and semantics of the corresponding methods for bytes common methods for mutable objects (only for shortarrays). Set Types \u00b6 A set object is an unordered collection of distinct hashable objects. Common uses include membership testing, removing duplicates from a sequence, and computing mathematical operations such as intersection, union, difference, and symmetric difference. Like other collections, sets support x in set , len(set) , and for x in set . Being an unordered collection, sets do not record element position or order of insertion. Accordingly, sets do not support indexing, slicing, or other sequence-like behavior. There are currently two built-in set types, set() and frozenset() . The set() type is mutable \u2014 the contents can be changed using methods like add() and remove() . Since it is mutable, it has no hash value and cannot be used as either a dictionary key or as an element of another set. The frozenset() type is immutable and hashable \u2014 its contents cannot be altered after it is created; it can therefore be used as a dictionary key or as an element of another set. Non-empty sets (not frozensets) can be created by placing a comma-separated list of elements within braces, for example: {'jack', 'sjoerd'} , in addition to the set() constructor. The constructors for both classes work the same: class set ([iterable]) class frozenset ([iterable]) Return a new set or frozenset object whose elements are taken from iterable . The elements of a set must be hashable. To represent sets of sets, the inner sets must be frozenset() objects. If iterable is not specified, a new empty set is returned. Instances of set() and frozenset() provide the following operations: len(s) Return the cardinality of set s . x in s Test x for membership in s . x not in s Test x for non-membership in s . isdisjoint(other) Return True if the set has no elements in common with other . Sets are disjoint if and only if their intersection is the empty set. issubset(other) set <= other Test whether every element in the set is in other. set < other Test whether the set is a proper subset of other , that is, set <= other and set != other . issuperset(other) set >= other Test whether every element in other is in the set. set > other Test whether the set is a proper superset of other , that is, set >= other and set != other . union(other,...) set | other | ... Return a new set with elements from the set and all others. intersection(other,...) set & other & ... Return a new set with elements from the set and all others. difference(other,...) set - other - ... Return a new set with elements common to the set and all others. symmetric_difference(other) set ^ other Return a new set with elements in either the set or other but not both. copy() Return a new set with a shallow copy of s . The following table lists operations available for set() that do not apply to immutable instances of frozenset() : update(other,...) set |= other | ... Update the set, adding elements from all others. intersection_update(other, ...) set &= other & ... Update the set, keeping only elements found in it and all others. difference_update(other, ...) set -= other | ... Update the set, removing elements found in others. symmetric_difference_update(other) set ^= other Update the set, keeping only elements found in either set, but not in both. add(elem) Add element elem to the set. remove(elem) Remove element elem from the set. Raises KeyError if elem is not contained in the set. discard(elem) Remove element elem from the set if it is present. pop() Remove and return an arbitrary element from the set. Raises KeyError if the set is empty. clear() Remove all elements from the set. Mapping Types \u00b6 A mapping object maps hashable values to arbitrary objects. Mappings are mutable objects. There is currently only one standard mapping type, the dictionary . A dictionary\u2019s keys are almost arbitrary values. Values that are not hashable, that is, values containing lists, dictionaries or other mutable types (that are compared by value rather than by object identity) may not be used as keys. Numeric types used for keys obey the normal rules for numeric comparison: if two numbers compare equal (such as 1 and 1.0 ) then they can be used interchangeably to index the same dictionary entry. (Note however, that since computers store floating-point numbers as approximations it is usually unwise to use them as dictionary keys.) Dictionaries can be created by placing a comma-separated list of key: value pairs within braces, for example: {'jack': 4098, 'sjoerd': 4127} or {4098:'jack', 4127: 'sjoerd'} , or by the dict() constructor. class dict(*args) If no positional argument is given, an empty dictionary is created. If a positional argument is given and it is a mapping object, a dictionary is created with the same key-value pairs as the mapping object. Otherwise,the positional argument must be an iterable object. Each item in the iterable must itself be an iterable with exactly two objects. The first object of each item becomes a key in the new dictionary, and the second object the corresponding value. If a key occurs more than once, the last value for that key becomes the corresponding value in the new dictionary. These are the operations that dictionaries support: len(d) Return the number of items in the dictionary d . d[key] Return the item of d with key key . Raises a KeyError if key is not in the map. d[key] = value Set d[key] to value . del d[key] Remove d[key] from d . Raises a KeyError if key is not in the map. key in d Return True if d has a key key , else False . key not in d Equivalent to not key in d . clear() Remove all items from the dictionary. copy() Return a shallow copy of the dictionary. items() Return a new view of the dictionary\u2019s items ( (key, value) pairs). keys() Return a new view of the dictionary\u2019s keys. See the documentation of view objects. pop(key[, default]) If key is in the dictionary, remove it and return its value, else return default . If default is not given and key is not in the dictionary, a KeyError is raised. popitem() Remove and return an arbitrary (key, value) pair from the dictionary. popitem() is useful to destructively iterate over a dictionary, as often used in set algorithms. If the dictionary is empty, calling popitem() raises a KeyError . update([other]) Update the dictionary with the key/value pairs from other, overwriting existing keys. Return None . update() accepts another dictionary object. values() Return a new view of the dictionary\u2019s values.","title":"Sequences and Map Types"},{"location":"reference/guide/docs/seqmap/#sequences-and-map-types","text":"The following sections describe the sequence and mapping types that are built into Zerynth.","title":"Sequences and Map Types"},{"location":"reference/guide/docs/seqmap/#iterator-types","text":"Python supports a concept of iteration over containers. This is implemented using two distinct methods; these are used to allow user-defined classes to support iteration. One method needs to be defined for container objects to provide iteration support: container.__iter__() Return an iterator object. The object is required to support the iterator protocol described below. iterator objects themselves are required to support the following two methods, which together form the iterator protocol : iterator.\\__iter__() Return the iterator object itself. This is required to allow both containersand iterators to be used with the for and in statements. iterator.\\__next__() Return the next item from the container. If there are no further items, raise the StopIteration exception. Once an iterator\u2019s __next__() method raises StopIteration , it must continue to do so on subsequent calls. Implementations that do not obey this property are deemed broken.","title":"Iterator Types"},{"location":"reference/guide/docs/seqmap/#sequence-types","text":"There are three basic sequence types: lists, tuples, and range objects. Additional sequence types tailored for processing of binary data and text strings are described in dedicated sections.","title":"Sequence Types"},{"location":"reference/guide/docs/seqmap/#common-sequence-operations","text":"The operations in the following table are supported by most sequence types,both mutable and immutable. This table lists the sequence operations sorted in ascending priority. In the table, n , i , j and are sequences of the same type, n , i , j and k are integers and is an arbitrary object that meets any type and value restrictions imposed by s . The in and not in operations have the same priorities as thecomparison operations. The + (concatenation) and * (repetition)operations have the same priority as the corresponding numeric operations. Operation Result Notes x in s True if an item of s is equal to x, else False (1) x not in s False if an item of s is equal to x, else True (1) s + t the concatenation of s and t (6)(7) s * n or n * s equivalent to adding s to itself n times (2)(7) s[i] i-th item of s, origin 0 (3) s[i:j] slice of s from i to j (3)(4) s[i:j:k] slice of s from i to j with step k (3)(5) len(s) length of s min(s) smallest item of s max(s) largest item of s s.index(x[, i[, j]]) index of the first occurrence of x in s (at or after i and before j) (8) s.count(x) total number of occurrences of x in s Sequences of the same type also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements.This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. Notes: While the in and not in operations are used only for simple containment testing in the general case, some specialised sequences(such as str() , bytes() and bytearray() ) also use them for subsequence testing: >>> \"gg\" in \"eggs\" True Values of n less than 0 are treated as 0 (which yields an empty sequence of the same type as s ). Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; consider: >>> lists = [[]] * 3 >>> lists [[], [], []] >>> lists [ 0 ] . append ( 3 ) >>> lists [[ 3 ], [ 3 ], [ 3 ]] What has happened is that [[]] is a one-element list containing an empty list, so all three elements of [[]] * 3 are references to this single empty list. Modifying any of the elements of lists modifies this single list.You can create a list of different lists this way: >>> lists = [[] for i in range ( 3 )] >>> lists [ 0 ] . append ( 3 ) >>> lists [ 1 ] . append ( 5 ) >>> lists [ 2 ] . append ( 7 ) >>> lists [[ 3 ], [ 5 ], [ 7 ]] If i or j is negative, the index is relative to the end of the string: len(s) + i or len(s) + j is substituted. But note that -0 isstill 0 . The slice of s from i to is defined as the sequence of items with index k such that i <= k < j . If i or j , i or is greater than len(s) , use len(s) . If i is comitted or None , use 0 . If j is omitted or None , use len(s) . If i is greater than or equal to j , the slice is empty. The slice of s from i to j with step k is defined as the sequence of items with index x = i + n*k such that 0 <= n < (j-i)/k . In other words,the indices are i , i+k , i+2*k , i+3*k and so on, stopping when j is reached (but never including j ). If i or j ). If is greater than len(s) , use len(s) . If i or j are omitted or None , they become\u201cend\u201d values (which end depends on the sign of k ). Note, k cannot be zero. If is None , it is treated like 1`. Concatenating immutable sequences always results in a new object. This means that building up a sequence by repeated concatenation will have a quadratic runtime cost in the total sequence length. To get a linear runtime cost, you must switch to one of the alternatives below: if concatenating str() objects, you can build a list and use str.join() at the end. if concatenating bytes() objects, you can similarly use bytes.join() or you can do in-place concatenation with a bytearray() object. bytearray() objects are mutable and have an efficient overallocation mechanism if concatenating tuple() objects, extend a list() instead for other types, investigate the relevant class documentation Some sequence types (such as range() ) only support item sequences that follow specific patterns, and hence don\u2019t support sequence concatenation or repetition. index raises ValueError when x is not found in s. When supported, the additional arguments to the index method allow efficient searching of subsections of the sequence. Passing the extra arguments is roughly equivalent to using s[i:j].index(x) , only without copying any data and with the returned index being relative to the start of the sequence rather than the start of the slice.","title":"Common Sequence Operations"},{"location":"reference/guide/docs/seqmap/#immutable-sequence-types","text":"The only feature that immutable sequence types generally implement that is not also implemented by mutable sequence types is hashing support. This support allows immutable sequences, such as tuple() instances, to be used as dict() keys and stored in set() and frozenset() instances. Attempting to hash an immutable sequence that contains unhashable values will result in TypeError .","title":"Immutable Sequence Types"},{"location":"reference/guide/docs/seqmap/#mutable-sequence-types","text":"The operations in the following table are defined on mutable sequence types. In the table s is an instance of a mutable sequence type, t is arbitrary object and x is an arbitrary object that meets any type and value restrictions imposed by s (for example, bytearray() only accepts integers that meet the value restriction 0 <= x <= 255 ). Operation Result Notes s[i] = x item i of s is replaced by x s[i:j] = t slice of s from i to j is replaced by the contents of the iterable t del s[i:j] same as s[i:j] = [] NOT SUPPORTED YET s[i:j:k] = t the elements of s[i:j:k] are replaced by those of t (1) del s[i:j:k] removes the elements of s[i:j:k] from the list NOT SUPPORTED YET s.append(x) appends x to the end of the sequence (same as s[len(s):len(s)] = [x]) s.clear() removes all items from s (same as del s[:]) (5) s.copy() creates a shallow copy of s (same as s[:]) (5) s.extend(t) or s += t extends s with the contents of t (for the most part the same as s[len(s):len(s)] = t) s *= n updates s with its contents repeated n times (6) s.insert(i, x) inserts x into s at the index given by i (same as s[i:i] = [x]) s.pop([i]) retrieves the item at i and also removes it from s (2) s.remove(x) remove the first item from s where s[i] == x (3) s.reverse() reverses the items of s in place (4) Notes: t must have the same length as the slice it is replacing. The optional argument i defaults to -1 , so that by default the last item is removed and returned. remove raises ValueError when x is not found in s . The reverse() method modifies the sequence in place for economy of space when reversing a large sequence. To remind users that it operates by side effect, it does not return the reversed sequence. clear() and copy() are included for consistency with the interfaces of mutable containers that don\u2019t support slicing operations(such as dict() and set() ) The value n is an integer. Zero and negative values of n clear the sequence. Items in the sequence are not copied; they are referenced multiple times, as explained for s * n .","title":"Mutable Sequence Types"},{"location":"reference/guide/docs/seqmap/#lists","text":"Lists are mutable sequences, typically used to store collections of homogeneous items (where the precise degree of similarity will vary by application). Lists may be constructed in several ways: Using a pair of square brackets to denote the empty list: [] Using square brackets, separating items with commas: [a] , [a, b, c] Using a list comprehension: [x for x in iterable] Lists implement all of the common and mutable sequence operations.","title":"Lists"},{"location":"reference/guide/docs/seqmap/#tuples","text":"Tuples are immutable sequences, typically used to store collections of heterogeneous data (such as the 2-tuples produced by the enumerate() built-in). Tuples are also used for cases where an immutable sequence of homogeneous data is needed. Tuples may be constructed in a number of ways: Using a pair of parentheses to denote the empty tuple: () Using a trailing comma for a singleton tuple: a, or (a,) Separating items with commas: a, b, c or (a, b, c) Tuples implement all of the common sequence operations.","title":"Tuples"},{"location":"reference/guide/docs/seqmap/#ranges","text":"The range type represents an immutable sequence of numbers and is commonly used for looping a specific number of times in for loops. class range(stop) class range(start,stop[,step] ) The arguments to the range constructor must be integers. If the step argument is omitted, it defaults to 1. If the start argument is omitted, it defaults to 0. If step is zero, ValueError is raised. For a positive st, the contents of a range r are determined by the formula r[i] = start + step*i where i >= 0 and r[i] < stop . For a negative *step, the contents of the range are still determined by the formula r[i] = start + step*i , but the constraints are i >= 0 and r[i] > stop . A range object will be empty if r[0] does not meet the value constraint. Ranges do support negative indices, but these are interpreted as indexing from the end of the sequence determined by the positive indices. Ranges implement all of the common sequence operations except concatenation and repetition (due to the fact that range objects can only represent sequences that follow a strict pattern and repetition and concatenation will usually violate that pattern). The advantage of the range() type over a regular list() or tuple() is that a range() object will always take the same(small) amount of memory, no matter the size of the range it represents (as it only stores the start,stop and step values, calculating individual items and sub ranges as needed). Testing range objects for equality with == and != compares them as sequences. That is, two range objects are considered equal if they represent the same sequence of values. (Note that two range objects that compare equal might have different start , stop and step attributes, for example range(0) == range(2, 1, 3) or range(0, 3, 2) == range(0, 4, 2) .)","title":"Ranges"},{"location":"reference/guide/docs/seqmap/#strings","text":"Textual data in Python is handled with strin.. Strings are immutable sequences of 8 bit characters. Zerynth does not support Unicode yet. String literals are written in a variety of ways: Single quotes: 'allows embedded \"double\" quotes' Double quotes: \"allows embedded 'single' quotes\" . Triple quoted: '''Three single quotes''' , \"\"\"Three double quotes\"\"\" Triple quoted strings may span multiple lines - all associated white space will be included in the string literal. String literals that are part of a single expression and have only white space between them will be implicitly converted to a single string literal. That is, (\"spam \" \"eggs\") == \"spam eggs\" . Strings may also be created from other objects using the str builtin. Since there is no separate \u201ccharacter\u201d type, indexing a string produces strings of length 1. That is, for a non-empty string s, s[0] == s[0:1] . There is also no mutable string type, but str.join() can be used to efficiently construct strings from multiple fragments. class str(object='') Return a string version of object. If *object is not provided, returns the empty string. Returns object.__str__() , which is the \u201cinformal\u201d or nicely printable string representation of *object. For string objects, this is the string itself. If *object does not have a __str__() method, then str() raises TypeError.","title":"Strings"},{"location":"reference/guide/docs/seqmap/#string-methods","text":"Strings implement all of the common sequence operations, along with the additional methods described below. Strings also support string formatting based on C printf style formatting.. str.count(sub[,start[,end] ]) Return the number of non-overlapping occurrences of substring sub in the range [ start]. Optional arguments start and *end are interpreted as in slice notation. str.endswith(suffix[,start[,end] ]) Return True if the string ends with the specified suffix, otherwise return False . With optional *start`, test beginning at that position. With optional *end , stop comparing at that position. str.find(sub[,start[,end] ]) Return the lowest index in the string where substring sub is found within the slice s[start:end] . Optional arguments start and end are interpreted as in slice notation. Return -1 if sub is not found. Note The find() method should be used only if you need to know the position of sub . To check if sub is a substring or not, use the in operator. str.index(sub[,start[,end] ]) Like find() , but raise ValueError when the substring is not found. str.join(iterable) Return a string which is the concatenation of the strings in the iterable iterableiterable must be a builtin sequence or builtin map. A TypeError will be raised if there are any non-string values in *iterable, excluding byte and byterray objects that are treated as strings. The separator between elements is the string providing this method. str.lower() Return a copy of the string with all the cased characters converted to lowercase. str.replace(old,new) Return a copy of the string with all occurrences of substring old replaced by new. str.split(sep=None, maxsplit=-1) Return a list of the words in the string, using sep as the delimiter string. If *maxsplit is given, at most *maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If *maxsplit is not specified or -1 , then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty strings (for example, '1,,2'.split(',') returns ['1', '', '2'] ). The sep argument may consist of multiple characters (for example, '1<>2<>3'.split('<>') returns ['1', '2', '3'] ). Splitting an empty string with a specified separator returns [''] . For example: >>> '1,2,3' . split ( ',' ) [ '1' , '2' , '3' ] >>> '1,2,3' . split ( ',' , maxsplit = 1 ) [ '1' , '2,3' ] >>> '1,2,,3,' . split ( ',' ) [ '1' , '2' , '' , '3' , '' ] If sep is not specified, a different splitting algorithm is applied: runs of consecutive whites pace are regarded as a single separator, and the result will contain no empty strings at the start or end if the string has leading or trailing white space. Consequently, splitting an empty string or a string consisting of just white space with a None separator returns [] . For example: >>> '1 2 3' . split () [ '1' , '2' , '3' ] >>> '1 2 3' . split ( maxsplit = 1 ) [ '1' , '2 3' ] >>> ' 1 2 3 ' . split () [ '1' , '2' , '3' ] str.startswith(prefix[,start[,end] ]) Return True if string starts with the prefix , otherwise return False . With optional start test string beginning at that position. With optional end , stop comparing string at that position. str.strip([chars[,dir=0] ]) Return a copy of the string with the leading and trailing characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted, the chars argument defaults to removing whitespace. The chars argument is not a prefix or suffix; rather, all combinations of its values are stripped: >>> ' spacious ' . strip () 'spacious' >>> 'www.example.com' . strip ( 'cmowz.' ) 'example' The dir parameter controls the side of stripping: dir=0, strip chars from left and right side of str dir>0, strip chars from left side of str dir<0, strip chars from right side of str upper() Return a copy of the string with all the cased characters converted to uppercase.","title":"String Methods"},{"location":"reference/guide/docs/seqmap/#printf-style-string-formatting","text":"String objects have one unique built-in operation: the % operator (modulo). This is also known as the string formatting or interpolation* operator. Given format % values (where *format is a string), % conversion specifications in *format are replaced with zero or more elements of *valuesThe effect is similar to using the sprintf() in the C language. If format requires a single argument, values may be a single non-tuple object. Otherwise, values must be a tuple or list with exactly the number of items specified by the format string, or a single dictionary. A conversion specifier contains two or more characters and has the following components, which must occur in this order: The '%' character, which marks the start of the specifier. Mapping key (optional), consisting of a parenthesised sequence of characters (for example, (somename) ). Conversion flags (optional), which affect the result of some conversion types. Minimum field width (optional). If specified as an '*' (asterisk), the actual width is read from the next element of the tuple in values , and the object to convert comes after the minimum field width and optional precision. Precision (optional), given as a '.' (dot) followed by the precision. If specified as '*' (an asterisk), the actual precision is read from the next element of the tuple in values , and the value to convert comes after the precision. Conversion type. When the right argument is a dictionary (or other mapping type), then the formats in the string must include a parenthesized mapping key into that dictionary inserted immediately after the '%' character. The mapping key selects the value to be formatted from the mapping. For example: >>> print ( ' %(language)s has %(number)03d quote types.' % ... { 'language' : \"Python\" , \"number\" : 2 }) Python has 002 quote types . In this case no * specifiers may occur in a format (since they require a sequential parameter list). The conversion flag characters are: Conversion Meaning Notes 'd' Signed integer decimal. 'i' Signed integer decimal. 'u' Obsolete type \u2013 it is identical to 'd'. 'x' Signed hexadecimal (lowercase). (2) 'X' Signed hexadecimal (uppercase). (2) 'e' Floating point exponential format (lowercase). (3) 'E' Floating point exponential format (uppercase). (3) 'f' Floating point decimal format. (3) 'F' Floating point decimal format. (3) 'g' Floating point format. Uses lowercase exponential format if exponent is less than -4 or not less than precision, decimal format otherwise. (3) 'G' Floating point format. Uses uppercase exponential format if exponent is less than -4 or not less than precision, decimal format otherwise. (3) 's' String (converts any Python object using str()). (4) '%' No argument is converted, results in a '%' character in the result. Note Not all Python conversion types and conversion flags are supported by Zerynth. Refer to Python documentation for the (few) differences. Hexadecimal conversion does not produce the \u201c0x\u201d prefix. In Zerynth \u201cg\u201d and \u201ce\u201d modifiers, together with their uppercase versions are equivalent to \u201cf\u201d or \u201cF\u201d.The precision determines the number of digits after the decimal point and defaults to 6. If precision is N , the output is truncated to N characters.","title":"printf-style String Formatting"},{"location":"reference/guide/docs/seqmap/#binary-sequence-types","text":"The core built-in types for manipulating binary data are bytes() and bytearray() .","title":"Binary Sequence Types"},{"location":"reference/guide/docs/seqmap/#bytes","text":"Bytes objects are immutable sequences of single bytes. Bytes are very similar to strings in Zerynth, except that when iterating over them, integers are generated instead of strings. Firstly, the syntax for bytes literals is largely the same as that for string literals, except that a b prefix is added: Single quotes: b'still allows embedded \"double\" quotes' Double quotes: b\"still allows embedded 'single' quotes\". Triple quoted: b'''3 single quotes''' , b\"\"\"3 double quotes\"\"\" Only ASCII characters are permitted in bytes literals. Any binary values over 127 must be entered into bytes literals using the appropriate escape sequence. While bytes literals and representations are based on ASCII text, bytes objects actually behave like immutable sequences of integers, with each value in the sequence restricted such that 0 <= x < 256 (attempts to violate this restriction will trigger ValueError ). This is done deliberately to emphasize that while many binary formats include ASCII based elements and can be usefully manipulated with some text-oriented algorithms, this is not generally the case for arbitrary binary data (blindly applying text processing algorithms to binary data formats that are not ASCII compatible will usually lead to data corruption). In addition to the literal forms, bytes objects can be created in a number of other ways: A zero-filled bytes object of a specified length: bytes(10) From an iterable of integers: bytes([1,2,3]) Since 2 hexadecimal digits correspond precisely to a single byte, hexadecimalnumbers are a commonly used format for describing binary data. Since bytes objects are sequences of integers (akin to a tuple), for a bytes object , b[0] will be an integer, while b[0:1] will be a bytes object of length 1. (This contrasts with text strings, where both indexing and slicing will produce a string of length 1.)","title":"Bytes"},{"location":"reference/guide/docs/seqmap/#bytearray-objects","text":"bytearray() objects are a mutable counterpart to bytes() objects. There is no dedicated literal syntax for bytearray objects, instead they are always created by calling the constructor: Creating an empty instance: bytearray() Creating a zero-filled instance with a given length: bytearray(10) From an iterable of integers: bytearray([1,2,3]) As bytearray objects are mutable, they support the mutable sequence operations in addition to the common bytes and bytearray operations described in Bytes and Bytearray Operations . Since 2 hexadecimal digits correspond precisely to a single byte, hexadecimal numbers are a commonly used format for describing binary data. Since bytearray objects are sequences of integers (akin to a list), for a bytearray object b , b[0] will be an integer, while b[0:1] will be a bytearray object of length 1. (This contrasts with text strings, where both indexing and slicing will produce a string of length 1.)","title":"Bytearray Objects"},{"location":"reference/guide/docs/seqmap/#bytes-and-bytearray-operations","text":"Both bytes and bytearray objects support the common sequence operations. They interoperate not just with operands of the same type, but with any bytes-like object. Due to this flexibility, they can be freely mixed in operations without causing errors. However, the return type of the result may depend on the order of operands. Note Contrary to Python, in Zerynth the methods on bytes and bytearray objects accept strings as their arguments, just as the methods on strings accept bytes as their arguments. For example, you can write: a = \"abc\" b = a . replace ( b \"a\" , \"f\" ) and: a = b \"abc\" b = a . replace ( \"a\" , b \"f\" ) bytes.count(sub[,start[,end] ]) bytearray.count(sub[, start[, end] ]) Return the number of non-overlapping occurrences of subsequence sub in the range [ start,end ]. Optional arguments start and end are interpreted as in slice notation. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. bytes.endswith(suffix[,start[,end] ]) bytearray.endswith(suffix[,start[,end] ]) Return True if the binary data ends with the specified suffix , otherwise return False . With optional start , test beginning at that position. With optional end , stop comparing at that position. bytes.find(sub[,start[,end] ]) bytearray.find(sub[,start[,end] ]) Return the lowest index in the data where the subsequence sub is found, such that sub is contained in the slice s[start:end] . Optional arguments start and end are interpreted as in slice notation. Return -1 if sub is not found. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. Note The find() method should be used only if you need to know the position of sub . To check if sub is a substring or not, use the in operator. bytes.index(sub[, start[, end] ]) bytearray.index(sub[, start[, end] ]) Like find() , but raise ValueError when the subsequence is not found. The subsequence to search for may be any bytes-like object or an integer in the range 0 to 255. bytes.join(iterable) bytearray.join(iterable) Return a bytes or bytearray object which is the concatenation of the binary data sequences in the iterable iterable . A TypeError will be raised if there are any values in iterable that are not bytes-like objects or strings. The separator between elements is the contents of the bytes or bytearray object providing this method. bytes.replace(old,new) bytearray.replace(old, new) Return a copy of the sequence with all occurrences of subsequence old replaced by new. Note The bytearray version of this method does not operate in place - it always produces a new object, even if no changes were made. bytes.startswith(prefix[,start[,end] ]) bytearray.startswith(prefix[,start[,end] ]) Return True if the binary data starts with the specified prefix , otherwise return False . With optional start , test beginning at that position. With optional end , stop comparing at that position. bytes.split(sep=None,maxsplit=-1) bytearray.split(sep=None, maxsplit=-1) Split the binary sequence into subsequences of the same type, using sep as the delimiter string. If maxsplit is given and non-negative, at most maxsplit splits are done (thus, the list will have at most maxsplit+1 elements). If maxsplit is not specified or is -1 , then there is no limit on the number of splits (all possible splits are made). If sep is given, consecutive delimiters are not grouped together and are deemed to delimit empty subsequences (for example, b'1,,2'.split(b',') returns [b'1', b'', b'2'] ). The sep argument may consist of a multibyte sequence (for example, b'1<>2<>3'.split(b'<>') returns [b'1', b'2', b'3'] ). Splitting an empty sequence with a specified separator returns [b''] or [bytearray(b'')] depending on the type of object being split. For example: >>> b '1,2,3' . split ( b ',' ) [ b '1' , b '2' , b '3' ] >>> b '1,2,3' . split ( b ',' , maxsplit = 1 ) [ b '1' , b '2,3' ] >>> b '1,2,,3,' . split ( b ',' ) [ b '1' , b '2' , b '' , b '3' , b '' ] If sep is not specified, a different splitting algorithm is applied: runs of consecutive ASCII whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the sequence has leading or trailing whitespace. Consequently, splitting an empty sequence or a sequence consisting solely of ASCII whitespace without a specified separator returns [] . For example: >>> b '1 2 3' . split () [ b '1' , b '2' , b '3' ] >>> b '1 2 3' . split ( maxsplit = 1 ) [ b '1' , b '2 3' ] >>> b ' 1 2 3 ' . split () [ b '1' , b '2' , b '3' ] bytes.strip([chars[,dir=0] ]) bytearray.strip([chars[,dir=0] ]) Return a copy of the binary sequence with the leading and trailing characters removed. The chars argument is a string or binary sequence specifying the set of characters to be removed. If omitted, the chars argument defaults to removing whitespace. The chars argument is not a prefix or suffix; rather, all combinations of its values are stripped: >>> b ' spacious ' . strip () b 'spacious' >>> b 'www.example.com' . strip ( b 'cmowz.' ) b 'example' The dir parameter controls the side of stripping: dir=0, strip chars from left and right side of str dir>0, strip chars from left side of str dir<0, strip chars from right side of str The following methods on bytes and bytearray objects assume the use of ASCII compatible binary formats and should not be applied to arbitrary binary data. Note that all of the bytearray methods in this section do not operate in place, and instead produce new objects. bytes.lower() bytearray.lower() Return a copy of the sequence with all the uppercase ASCII characters converted to their corresponding lowercase counterpart. Lowercase ASCII characters are those byte values in the sequence b'abcdefghijklmnopqrstuvwxyz' . Uppercase ASCII characters are those byte values in the sequence b'ABCDEFGHIJKLMNOPQRSTUVWXYZ' . bytes.upper() bytearray.upper() Return a copy of the sequence with all the lowercase ASCII characters converted to their corresponding uppercase counterpart. Lowercase ASCII characters are those byte values in the sequence b'abcdefghijklmnopqrstuvwxyz' . Uppercase ASCII characters are those byte values in the sequence b'ABCDEFGHIJKLMNOPQRSTUVWXYZ' .","title":"Bytes and Bytearray Operations"},{"location":"reference/guide/docs/seqmap/#shorts-and-shortarrays","text":"Both Shorts and Shortarrays are sequence types added by Zerynth to the standard Python. Shorts and shortsarray objects actually behave like sequences of integers, with each value in the sequence restricted such that 0 <= x < 65536 (attempts to violate this restriction will trigger ValueError ). Shorts objects are immutable sequences of 16 bits integers. Shorts and shortsarray can\u2019t be specified with literals, but only using one of the following ways: A zero-filled bytes object of a specified length: shorts(10) From an iterable of integers: shorts([1,2,3]) Since 4 hexadecimal digits correspond precisely to a 16 bit integer, hexadecimal numbers are a commonly used format for describing binary data. Since shorts objects are sequences of integers (akin to a tuple), for a shorts object b , b[0] will be an integer, while b[0:1] will be a shorts object of length 1. Shortarray objects are mutable sequences of 16 bits integers. Shorts and shortsarray can\u2019t be specified with literals, but only using one of the following ways: A zero-filled bytes object of a specified length: shortarray(10) From an iterable of integers: shortarray([1,2,3]) Since 4 hexadecimal digits correspond precisely to a 16 bit integer, hexadecimal numbers are a commonly used format for describing binary data. Since shortarray objects are sequences of integers (akin to a list), for a shortarray object b , b[0] will be an integer, while b[0:1] will be a shortarray object of length 1. Shorts and shortarryas support only a limited set of methods: count and index with the same syntax and semantics of the corresponding methods for bytes common methods for mutable objects (only for shortarrays).","title":"Shorts and Shortarrays"},{"location":"reference/guide/docs/seqmap/#set-types","text":"A set object is an unordered collection of distinct hashable objects. Common uses include membership testing, removing duplicates from a sequence, and computing mathematical operations such as intersection, union, difference, and symmetric difference. Like other collections, sets support x in set , len(set) , and for x in set . Being an unordered collection, sets do not record element position or order of insertion. Accordingly, sets do not support indexing, slicing, or other sequence-like behavior. There are currently two built-in set types, set() and frozenset() . The set() type is mutable \u2014 the contents can be changed using methods like add() and remove() . Since it is mutable, it has no hash value and cannot be used as either a dictionary key or as an element of another set. The frozenset() type is immutable and hashable \u2014 its contents cannot be altered after it is created; it can therefore be used as a dictionary key or as an element of another set. Non-empty sets (not frozensets) can be created by placing a comma-separated list of elements within braces, for example: {'jack', 'sjoerd'} , in addition to the set() constructor. The constructors for both classes work the same: class set ([iterable]) class frozenset ([iterable]) Return a new set or frozenset object whose elements are taken from iterable . The elements of a set must be hashable. To represent sets of sets, the inner sets must be frozenset() objects. If iterable is not specified, a new empty set is returned. Instances of set() and frozenset() provide the following operations: len(s) Return the cardinality of set s . x in s Test x for membership in s . x not in s Test x for non-membership in s . isdisjoint(other) Return True if the set has no elements in common with other . Sets are disjoint if and only if their intersection is the empty set. issubset(other) set <= other Test whether every element in the set is in other. set < other Test whether the set is a proper subset of other , that is, set <= other and set != other . issuperset(other) set >= other Test whether every element in other is in the set. set > other Test whether the set is a proper superset of other , that is, set >= other and set != other . union(other,...) set | other | ... Return a new set with elements from the set and all others. intersection(other,...) set & other & ... Return a new set with elements from the set and all others. difference(other,...) set - other - ... Return a new set with elements common to the set and all others. symmetric_difference(other) set ^ other Return a new set with elements in either the set or other but not both. copy() Return a new set with a shallow copy of s . The following table lists operations available for set() that do not apply to immutable instances of frozenset() : update(other,...) set |= other | ... Update the set, adding elements from all others. intersection_update(other, ...) set &= other & ... Update the set, keeping only elements found in it and all others. difference_update(other, ...) set -= other | ... Update the set, removing elements found in others. symmetric_difference_update(other) set ^= other Update the set, keeping only elements found in either set, but not in both. add(elem) Add element elem to the set. remove(elem) Remove element elem from the set. Raises KeyError if elem is not contained in the set. discard(elem) Remove element elem from the set if it is present. pop() Remove and return an arbitrary element from the set. Raises KeyError if the set is empty. clear() Remove all elements from the set.","title":"Set Types"},{"location":"reference/guide/docs/seqmap/#mapping-types","text":"A mapping object maps hashable values to arbitrary objects. Mappings are mutable objects. There is currently only one standard mapping type, the dictionary . A dictionary\u2019s keys are almost arbitrary values. Values that are not hashable, that is, values containing lists, dictionaries or other mutable types (that are compared by value rather than by object identity) may not be used as keys. Numeric types used for keys obey the normal rules for numeric comparison: if two numbers compare equal (such as 1 and 1.0 ) then they can be used interchangeably to index the same dictionary entry. (Note however, that since computers store floating-point numbers as approximations it is usually unwise to use them as dictionary keys.) Dictionaries can be created by placing a comma-separated list of key: value pairs within braces, for example: {'jack': 4098, 'sjoerd': 4127} or {4098:'jack', 4127: 'sjoerd'} , or by the dict() constructor. class dict(*args) If no positional argument is given, an empty dictionary is created. If a positional argument is given and it is a mapping object, a dictionary is created with the same key-value pairs as the mapping object. Otherwise,the positional argument must be an iterable object. Each item in the iterable must itself be an iterable with exactly two objects. The first object of each item becomes a key in the new dictionary, and the second object the corresponding value. If a key occurs more than once, the last value for that key becomes the corresponding value in the new dictionary. These are the operations that dictionaries support: len(d) Return the number of items in the dictionary d . d[key] Return the item of d with key key . Raises a KeyError if key is not in the map. d[key] = value Set d[key] to value . del d[key] Remove d[key] from d . Raises a KeyError if key is not in the map. key in d Return True if d has a key key , else False . key not in d Equivalent to not key in d . clear() Remove all items from the dictionary. copy() Return a shallow copy of the dictionary. items() Return a new view of the dictionary\u2019s items ( (key, value) pairs). keys() Return a new view of the dictionary\u2019s keys. See the documentation of view objects. pop(key[, default]) If key is in the dictionary, remove it and return its value, else return default . If default is not given and key is not in the dictionary, a KeyError is raised. popitem() Remove and return an arbitrary (key, value) pair from the dictionary. popitem() is useful to destructively iterate over a dictionary, as often used in set algorithms. If the dictionary is empty, calling popitem() raises a KeyError . update([other]) Update the dictionary with the key/value pairs from other, overwriting existing keys. Return None . update() accepts another dictionary object. values() Return a new view of the dictionary\u2019s values.","title":"Mapping Types"},{"location":"reference/guide/docs/vhal/","text":"Hardware Abstraction Layer \u00b6 The Zerynth VM uses a common API to drive the underlying microcontroller peripherals. Such API is called VHAL and abstracts common peripherals operations so that peripheral access and management is identical across different microcontrollers. Pin Mapping \u00b6 The VHAL introduces a distinction between physical pins and virtual pins . Physical pins are the actual pins available on the board and are defined in the file port.c for every supported board. A physical pin usually maps to a microcontroller register and offset, needed to drive the pin. A virtual pin is just a name which refers to a particular configuration of a physical pin. Therefore different virtual pins can map to the same physical pin. For example, imagine a board where the first physical pin (P0) can be used as a general purpose input output (GPIO) or as the clock line (SCL) of the first instance of the I2C bus. Such physical pin is always controlled by same microcontroller register, but in the first case it is configured as a GPIO and the corresponding virtual pin name will be D0, while in the second case it is configured as I2C clock and the virtual pin name will be SCL0. The internal representation of virtual pins is a 16 bit integer where the high byte represents the name of the peripheral (the \u201cclass\u201d of the pin), while the low byte is the row number in the table of physical pins for that peripheral. All these levels of indirection are hidden by the VHAL using macros to access the relevant information about pins. All VHAL functions requiring pin names expect virtual pin names. The following scheme summarizes the available virtual pin info: Where Pin Name is a C Macro corresponding to Pin Value . For each string in Pin Class there exists a C macro with PINCLASS_ prepended, corresponding to the high byte of Pin Value (i.e. PINCLASS_DIGITAL is 0x00, PINCLASS_ANALOG is 0x01, etc\u2026). For each pin class, there exists a table containing configuration data. Such data can be accessed by the following macros: PIN_CLASS_ID(vpin) Returns a byte representing the index of the physical pin corresponding to vpin. PIN_CLASS_DATA0(vpin) Returns a byte representing the first byte of info about vpin. PIN_CLASS_DATA1(vpin) Returns a byte representing the second byte of info about vpin. PIN_CLASS_DATA2(vpin) Returns a byte representing the third byte of info about vpin. The meaning of the three bytes of info depends on the actual porting; usually they contain configuration values to correctly setup the peripheral. Peripherals Mapping \u00b6 Each microcontroller peripheral is mapped to a peripheral index in the board porting files. For each peripheral there exists a table mapping multiple peripheral instances of the same type to different indexes. The following example will clarify the mapping. Imagine a microcontroller with four different USART peripherals named USART1 to USART4. In the board porting each USART is mapped to a peripheral index by creating such table: Index Value 0 3 1 1 2 4 3 2 When a VHAL function is called, expecting a peripheral index for a serial peripheral, the table is used to map the passed index (e.g. 0) to the corresponding mcu peripheral (e.g. USART3). Each board porting defines this kind of tables for each supported peripheral. The following macros can be used to query the peripheral tables: GET_PERIPHERAL_ID(name,prph_idx) Returns the microcontroller peripheral index given the name of the peripheral and the vhal index prph_idx . Referring to the previous table, prph_idx corresponds to values in the Index column, while the return value correspondes to the Value column. The parameter name is a string identifying the peripheral: \u201cserial\u201d, \u201cspi\u201d, \u201ci2c\u201d, \u201cadc\u201d, \u201cpwm\u201d, \u201cicu\u201d, \u201chtm\u201d. PERIPHERAL_NUM(name) Returns the number of microcontroller peripherals given the peripheral name . GPIO \u00b6 A GPIO pin is a generic pin that can be used as input to read its digital status (low or high) or as output to set its digital status (low or high). On many microcontrollers it is possible to configure a GPIO to also generate an interrupt on status change. Macros \u00b6 The following macros are used to set the pin mode of operation. PINMODE_INPUT_PULLNONE Used to configure a pin as input with no pull up/down circuitry (floating mode). PINMODE_INPUT_PULLUP Used to configure a pin as input with pull up circuitry. PINMODE_INPUT_ANALOG Used to configure a pin as analog input by connecting it to an analog to digital converter. PINMODE_INPUT_PULLDOWN Used to configure a pin as input with pull down circuitry. PINMODE_OUTPUT_PUSHPULL Used to configure a pin as output. The pin will be able to both sink and source current. PINMODE_OUTPUT_OPENDRAIN Used to configure a pin as output. The pin will be able to only sink current. This means the pin output can only be set to low. PINMODE_OUTPUT_HIGHDRIVE Used to configure a pin as output. The pin will be able to only sink and source a higher current. Refer to each microcontroller datasheet for details. PINMODE_EXT_FALLING Used to configure a pin as input. An interrupt will be generated when the status of the pin goes from high to low. PINMODE_EXT_RISING Used to configure a pin as input. An interrupt will be generated when the status of the pin goes from low to high. PINMODE_EXT_BOTH Used to configure a pin as input. An interrupt will be generated when the status of the pin goes from low to high or from high to low. GPIO Functions \u00b6 int vhalPinSetMode(int vpin int mode) Set the digital mode of *vpin to *mode. Valid values for *mode are the digital input and output PINMODE macros. Return 0 in case of success. int vhalPinRead(int vpin) Read the digital value of *vpin. Return 0 if *vpin is low, non-zero if *vpin is high. int vhalPinWrite(int vpin, int value) Set the digital value of vpin to value . If value is zero, vpin is set to low, otherwise is set to high. Return 0 in case of success. int vhalPinToggle(int vpin) Invert the digital value of vpin. If *vpin is high it is set to low, if *vpin is low it is set to high. Return 0 in case of success. void* PinGetPort(int vpin) Get the pointer to a gpio microcontroller register corresponding to *vpin. The return value must be used in functions like vhalPinFastSet() and vhalPinFastClear() . int PinGetPad(int vpin) Get the offset into a gpio microcontroller register corresponding to vpin. The return value must be used in functions like vhalPinFastSet() and vhalPinFastClear() . void vhalPinFastSet(void *port,int pad) Bypass the virtual pin indirection by operating on the microcontroller register port with offset . Set the corresponding pin to high. void vhalPinFastClear(void *port,int pad) Bypass the virtual pin indirection by operating on the microcontroller register port with offset . Set the corresponding pin to low. int vhalPinFastRead(void *port,int pad) Bypass the virtual pin indirection by operating on the microcontroller register port with offset pad. Return 0 if the in is low, non-zero if it is high. int vhalPinSetToPeripheral(int vpin, int prph, uint32_t prms) Transfer the control of vp to a peripheral identified by prph . The configuration parameters for vpin are passed via prms in a format depending on the microcontroller porting. Return 0 in case of success. The parameter prph is ignored in the current version of the VHAL. int vhalPinAttachInterrupt(int vpinintmode,extCbkFn fn, uint32_t timeout) Attach callback fn to vpin . fn is called from an ISR when there is a status change identified by mode. mode can be one of the PINMODE_EXT macros. Return a non negative integer identifying the slot fn has been attached to. If fn is NULL the currently attached function is removed and the interrupt disabled. typedef void(*extCbkFn)(int slot int dir) The type of in vhalPinAttachInterrupt() . slot` is the slot the callback has been attached to. dir is 0 if the callback has been called on a falling edge, non-zero on a rising edge. if timeout is provided, fn is called only the status of the pin remains stable for at least timeout units of time, effectively implenting debouncing. ADC \u00b6 Analog to digital converters are peripherals that convert voltage on a pin to a number representing its magnitude. ADCs can be very complex devices with very advanced functions. The VHAL aims at supporting the following features when available: Single pin, single sample conversion Single pin, multiple samples conversion Multiple pin conversion Continuous conversion Conversion triggers The current version of VHAL supports features from 1 to 3. To enable ADC functions the macro VHAL_ADC must be defined. Macros \u00b6 ADC_CAPTURE_SINGLE Select non continuous conversion mode ADC_CAPTURE_CONTINUOUS Select continuous conversion mode Types \u00b6 typedef int (*adcCbkFn)(uint32_t adc, vhalAdcCaptureInfo *nfo) The type of the ADC callback for continuous mode. Not used in current version of VHAL. vhalAdcCaptureInfo A structure containing the parameters needed to configure the ADC for the conversion: typedef struct _vhal_adc_capture { uint32_t samples ; uint16_t * pins ; uint8_t npins ; uint8_t sample_size ; uint8_t capture_mode ; uint8_t trigger_mode ; uint16_t trigger_vpin ; void * buffer ; void * half_buffer ; int ( * callback )( uint32_t , struct _vhal_adc_capture * ); } vhalAdcCaptureInfo ; samples is the number of samples to capture pins is an array of virtual pin names to capture from npins is the length of pins sample_size will hold the size of a single sample capture_mode is one of the ADC_CAPTURE macros trigger_mode select the trigger type. Not yet used. trigger_vpin is the virtual pin to be used as gpio trigger. Not yet used. buffer is a pointer to a location of memory where captured samples will be stored. half_buffer is a pointer to the free half of buffer in continuous mode. Not yet used. callback is a function called in continuous mode when one half of the buffer is filled. Not yet used. vhalAdcConf A structure used to initialize the ADC. typedef struct _vhal_adc_conf { uint32_t samples_per_second ; uint32_t resolution ; } vhalAdcConf ; Functions \u00b6 int vhalInitADC(void* data) Must be called before any function starting with vhalAdc . int vhalAdcInit(uint32_t adc,vhalAdcConf *conf) Initialize the ADC identified by the peripheral index adc with values in conf . Return 0 on success, negative values in case of failure. int vhalAdcGetPeripheralForPin(int vpin) Return the ADC peripheral index associated with vpin . int vhalAdcPrepareCapture(uint32_t adc,vhalAdcCaptureInfo *info) Must be called before vhalAdcRead() to configure the conversion. Return 0 on success. The member sample_size of info is set to the actual sample size. int vhalAdcRead(uint32_t adc,vhalAdcCaptureInfo *info) Must be called after vhalAdcPrepareCapture() has configured the conversion. Return 0 on success. The member buffer of info must be set to the correct size according to samples and sample_size . The function suspends the current thread until the end of the conversion. The samples are stored in the order they are converted in info->buffer. int vhalAdcDone(uint32_t adc) Disable the ADC identified by the peripheral index adc . DAC \u00b6 Digital to Analog converters are peripherals that convert a number to a voltage on a pin. DACs can be very complex devices with very advanced functions. The VHAL aims at supporting the following features when available: Single pin, software triggered conversion Single pin, timed triggered conversion Multiple pin conversion To enable DAC functions the macro VHAL_DAC must be defined. int vhalInitDAC(void* data) Must be called before any function starting with vhalDac . int vhalDacInit(uint32_t vpin) Initialize the DAC identified by the virtual pin vpin . Return 0 on success, negative values in case of failure. int vhalDacWrite(uint32_t vpin,uint16_t *data,uint32_t len,uint32_t timestep) Return 0 on success. Starts sending data samples in data to DAC identified by vpin up to len samples, each one sent after a dealy of timestep . The function suspends the current thread until the last sample is sent. int ivhalDacDone(uint32_t vpin) Disable the DAC identified by the virtual pin vpin . PWM \u00b6 PWM peripherals are able to generate square waves on pins. Square waves are configurable in terms of total duration (period) and duration of high state (pulse). To enable PWM functions the macro VHAL_PWM must be defined. int vhalInitPWM(void* data) Must be called before any function starting with vhalPwm . int vhalPwmStart(int vpin,uint32_t period,uint32_t pulse,uint32_t npulses) Generate a square wave of period period and pulse pulse on vpin . Timings must be expressed using TIME_U and both period and pulse must be expressed in the same time unit. If npulses is positive, the function blocks the current thread until a number of square waves equal to npulses is generated; afterwards, pwm is disabled and the function returns. If npulses is zero or less, pwm is activated and the function returns immediately. If period is 0 or pulse is 0 or period is less than pulse pwm is deactivated regardless of npulses . Return 0 on success. On failure return a negative integer. ICU \u00b6 The Input Capture Unit of a microcontroller measures the timings of a square wave on a pin. Imagine to have this signal on a digital pin: HIGH _______ ________________ _________ | | | | | | | | | | | | _____| |__________| |___| |____ LOW <------><----------><---------------><-><---------> T0 T1 T2 T3 T4 The ICU is able to return the duration of T0, T1, T2, etc\u2026 in microseconds. To enable ICU functions the macro VHAL_ICU must be defined. Macros \u00b6 ICU_TRIGGER_LOW Set ICU trigger to the first transition from high to low ICU_TRIGGER_HIGH Set ICU trigger to the first transition from low to high ICU_TRIGGER_BOTH Set ICU trigger to the first transition ICU_INPUT_PULLUP Set pin used by ICU as input with pullup ICU_INPUT_PULLDOWN Set pin used by ICU as input with pulldown ICU_CFG(trigger,filter,input) Return a uint32_t encoding the information about icu triggering (one of the ICU_TRIGGER macros) and icu pin configuration (one of the ICU_INPUT macros). The parameter filter is not used at the moment and must be set to 0. ICU_CFG_GET_TRIGGER(cfg) Extract the trigger value from a cfg generated by ICU_CFG ICU_CFG_GET_INPUT(cfg) Extracts the input mode value from a cfg generated by ICU_CFG Functions \u00b6 int vhalInitICU(void* data) Must be called before any function starting with vhalIcu . int vhalIcuStart(int vpin,uint32_t cfg,uint32_t time_window,uint32_t *buffer,uint32_t *bufsize, uint32_t *firstbit) Start capturing on vpin . The capture will start with pin mode and trigger parameters specified in cfg by means of the ICU_CFG macro. Once the capture starts, it will continue until one of the following conditions verifies: a time equal to time_window has passed from the last captured value a number of values equal to the integer pointed by bufsize has been captured The function blocks the current thread until the end of the capture. On returning: bufsize will point to the number of captured values buffer will contain such values expressed in microseconds firstbit will point to ICU_TRIGGER_LOW if the first transition was from high to low, or to ICU_TRIGGER_HIGH if the first transition was from low to high. Return 0 on success. On failure, a negative value. HTM \u00b6 Hardware Timers can be used to keep track of time with a greater precision with respect to the RTOS software timers. To enable HTM functions the macro VHAL_HTM must be defined. typedef void (*htmFn)(uint32_t tm,voidb *args) Type of a hardware timer callback function. int vhalInitHTM(void* data) Must be called before any function starting with vhalHtm . int vhalHtmGetFreeTimer(void) Return the peripheral index of the first available hardware timer. Return value is negative in case of error. int vhalHtmOneShot(uint32_t tm,uint32_t delay,htmFn fn,void *args,uint32_t blocking) Given the peripheral index tm , configure such timer to generate an interrupt after a time represented by delay (with TIME_U ). On interrupt generation, fn is executed with arguments args . If blocking is non-zero, the function blocks the current thread until fn is called. If blocking is zero, the function immediately returns. If delay is zero, the timer is deactivated. Return 0 on success. int vhalHtmRecurrent(uint32_t tm,uint32_t delay,htmFn fn,void *args) Given the peripheral index tm , configure such timer to generate an interrupt after a time represented by delay (with TIME_U ). On interrupt generation, fn is executed with arguments args and the timer is reconfigured to generate another interrupt after the same delay . If delay is zero, the timer is deactivated and fn stops to be executed periodically. Return 0 on success. int vhalSleepMicros(uint32_t tm,uint32_t micros) Given the peripheral index tm , suspends the current thread for micros microseconds. Return 0 on success. SERIAL \u00b6 Serial communication interfaces in microcontrollers come in many flavours: USART, UART and Serial over USB. All this peripherals are grouped together in Zerynth and controlled with the same API. Macros \u00b6 SERIAL_PARITY_NONE Select no parity. SERIAL_PARITY_EVEN Select even parity. SERIAL_PARITY_ODD Select odd parity. SERIAL_STOP_ONE Select 1 stop bit. SERIAL_STOP_ONEHALF Select 1.5 stop bit. SERIAL_STOP_TWO Select 2 stop bits. SERIAL_BITS_8 Select 8 bits of data. SERIAL_BITS_7 Select 7 bits of data. SERIAL_CFG(parity, stop, bits, hw, other) Return a uint32_t representing the serial port configuration. hw and other are not yet used and must be set to 0. SERIAL_CFG_PARITY(cfg) Return parity configuration encoded in cfg . SERIAL_CFG_STOP(cfg) Return stop bits configuration encoded in cfg . SERIAL_CFG_BITS(cfg) Return data bits configuration encoded in cfg . Functions \u00b6 int vhalSerialInit(uint32_t ser,uint32_t baud,uint32_t cfg,uint16_t rxpin,uint16_t txpin) Initialize the serial peripheral identified by the peripheral index ser . Baud rate is set to baud and configuration parameters are taken from cfg encoded with SERIAL_CFG . rxpin and txpin are configured accordingly. Return 0 on success. int vhalSerialRead(uint32_t ser,uint8_t *buf,uint32_t len) Read len bytes from ser into buf blocking the current thread until all bytes are read. Return the actual number of bytes read. int vhalSerialWrite(uint32_t ser,uint8_t *buf, uint32_t len) Write len bytes from buf to ser . Depending on the implementation, the function may return before all bytes are actually written to ser. Return the number of bytes written to ser or to an internal buffer. int vhalSerialAvailable(uint32_t ser) Return the number of bytes available to the next vhalSerialRead() call. int vhalSerialDone(uint32_t ser) Deactivate ser . I2C \u00b6 I2C is a multimaster and multislave bus used to exchange data between microcontrollers and peripherals. Many microcontrollers can be configured both as I2C masters or I2C slaves; in the current version, the VHAL supports only master mode. vhalI2CConf The following structure is used to configure the I2C bus: typedef struct _vhal_i2c_conf { uint32_t clock ; uint16_t addr ; uint16_t sda ; uint16_t scl ; uint16_t mode ; } vhalI2CConf ; The meaning of vhalI2CConf members is: clock : number of Hz the I2C bus will be clocked to. Use up to 100k for slow mode, up to 400k for fast mode. Other modes are not supported yet. addr: the peripheral address to communicate with. sda : the virtual pin that will be configured as SDA (data line). scl: the virtual pin that will be configured as SCL (clock line). mode : not used yet. int vhalInitI2C(void *data) Must be called before any function starting with vhalI2C . int vhalI2CInit(uint32_t i2c,vhalI2CConf *conf) Initialize the I2C bus corresponding to the i2c peripheral index with configuration parameters taken from conf. Return 0 on success. int vhalI2CDone(uint32_t i2c) Deactivates i2c . int vhalI2CLock(uint32_t i2c) Lock the I2C bus. To be used when multiple threads share the same bus. int vhalI2CUnlock(uint32_t i2c) Unlock the I2C bus. To be used when multiple threads share the same bus. int vhalI2CRead(uint32_t i2c,uint8_t* buf,uint32_t len*,uint32_t timeout) Start reading from i2c (from configured addr ). Execution ends as soon as one of the following conditions verifies: after a message of len bytes has been read and transferred to buf an error occurs on the bus the bus is inactive for a time equal to timeout Return 0 on success. int vhalI2CTransmit(uint32_t i2c,uint8_t* tx,uint32_t txlen,uint8_t *rx,uint32_t rxlen,uint32_t timeout) Execute a two steps communication. First, txlen bytes from tx are written to the bus; second, rxlen bytes are read from the bus to rx . Execution ends as soon as one of the following conditions verifies: both write and read steps are executed without errors an error occurs on the bus the bus is inactive for a time equal to timeout Return 0 on success. int vhalI2CWrite(uint32_t i2c,uint8_t* tx,uint32_t txlen,uint32_t timeout) Implemented as a macro calling vhalI2CTransmit(i2c,tx,txlen,NULL,0,timeout) . int vhalI2CSetAddr(uint32_t i2c, uint16_t add) Change the peripheral address associated with i2c in vhalI2CInit() to addr . SPI \u00b6 Serial Peripheral Interface is one of the most used communication standards in embedded systems. Many microcontroller allow the SPI bus to be configured as master or as slave; the current version of VHAL supports master mode only. vhalSpiConf The following structure is used to configure the SPI bus: typedef struct _vhal_spi_conf { uint32_t clock ; uint16_t miso ; uint16_t mosi ; uint16_t sclk ; uint16_t nss ; uint8_t mode ; uint8_t bits ; uint8_t master ; uint8_t msbfirst ; } vhalSpiConf ; The meaning of vhalSpiConf members is: clock : the number of Hz the SPI bus will be clocked to. miso , mosi , sclk , nss : virtual pins representing the four wires used by the bus. nss is also called slave select or chip select in datasheets. mode : configuration parameters for polarity and phase bits : number of data bits master : not used yet **msbfirst*: if non-zero, data is transferred with the most significant bits first. Macros \u00b6 SPI_MODE_LOW_FIRST Low polarity (idle low), phase zero (bits captured on the first clock edge). SPI_MODE_LOW_SECOND Low polarity (idle low), phase one (bits captured on the second clock edge). SPI_MODE_HIGH_FIRST High polarity (idle high), phase zero (bits captured on the first clock edge). SPI_MODE_HIGH_SECOND High polarity (idle high), phase one (bits captured on the second clock edge). SPI_BITS_8 Data is transferred 8 bits at time. SPI_BITS_16 Data is transferred 16 bits at time. SPI_BITS_32 Data is transferred 32 bits at time. Functions \u00b6 int vhalInitSPI(void *data) Must be called before any function starting with vhalSpi. int vhalSpiInit(uint32_t spi,vhalSpiConf *conf) Initialize the SPI bus identified by the peripheral index spi with configuration parameters taken from conf . Return 0 on success. vhalSpiLock(uint32_t spi) Lock the SPI bus. To be used when multiple threads share the same bus. int vhalSpiUnlock(uint32_t spi) Unlock the SPI bus. To be used when multiple threads share the same bus. int vhalSpiSelect(uint32_t spi) Select the SPI peripheral connected to nss . int vhalSpiUnselect(uint32_t spi) Unselect the SPI peripheral connected to nss . int vhalSpiExchange(uint32_t spi,void *tosend,void *toread,uint32_t blocks) Start a SPI communication on spi , exchanging a number of data frames equal to blocks . Size of data frame is configured with SPI_BITS macros. Data is exchanged synchronously; bytes in tosend are written to MOSI while bytes incoming on MISO are stored in toread. If toread is NULL, incoming bytes are ignored (pure write). If tosend is NULL, nothing is written (pure read). If both toread and tosend are NULL, bytes on the bus are skipped. Return 0 on success. int vhalSpiDone(uint32_t spi) Deactivate spi. Macros \u00b6 QSPI_MODE_LOW_FIRST Low polarity (idle low), phase zero (bits captured on the first clock edge). QSPI_MODE_LOW_SECOND Low polarity (idle low), phase one (bits captured on the second clock edge). QSPI_MODE_HIGH_FIRST High polarity (idle high), phase zero (bits captured on the first clock edge). QSPI_MODE_HIGH_SECOND High polarity (idle high), phase one (bits captured on the second clock edge). NFO \u00b6 Nfo functions retrieve the unique identifier of a microcontroller. uint8_t *vhalNfoGetUIDStr(void) Return the unique identifier represented as a hex string. int vhalNfoGetUID(uint8_t *buf) Return the unique identifier as bytes in buf. int vhalNfoGetUIDLen(void) Return the length in bytes of the unique identifier. The length of the corresponding hex string is exactly two times. FLASH \u00b6 Microcontrollers usually have a non volatile storage memory (flash memory) to hold code. These memories are usually organized in sectors or blocks, each of which can be erased and written independently of others. int vhalFlashErase(void *addr,uint32_t size) Erase sector starting at addr for size bytes. If size is greater than the sector length, following sectors are erased. Return 0 on success. int vhalFlashWrite(void *addr,uint8_t *data,uint32_t len) Write data starting at addr for len bytes. In many architectures, for vhalFlashWrite to work, the sectors must be erased first. Return written bytes number. void *vhalFlashAlignToSector(void *add) If addr points to the start of a sector, return addr . Otherwise the start of the next sector is returned. Return NULL on error. RNG \u00b6 Random Number Generators are often implemented in hardware. When such MCU feature is missing, the VHAL provides a software implementation. int vhalRngSeed(uint32_t seed) Initialize the RNG with a seed. Must be called before using vhalRngGenerate() unit32_t vhalRngGenerate(void) Return a random 32 bits number. RTC \u00b6 A Real-Time Clock (RTC) might be available on-board to keep passing time with great accuracy. int vhalRTCInit(int rtc) Initialize the RTC identified by the peripheral index rtc . Return 0 on success. int vhalRTCGetUTC(int rtc,vhalRTCTimeInfo*vhal_time_info) Fill vhal_time_info structure with time information retrieved from the RTC. typedef struct _timeinfo { uint32_t tv_seconds ; uint32_t tv_microseconds ; uint32_t tm_sec ; uint32_t tm_min ; uint32_t tm_hour ; uint32_t tm_mday ; uint32_t tm_mon ; uint32_t tm_year ; uint32_t tm_wday ; uint32_t tm_yday ; uint32_t tm_isdst ; } vhalRTCTimeInfo ; Return 0 on success. int vhalRTCSetUTC(int rtc,uint32_t sec,uint32_t usec) Set an UTC reference for RTC identified by the peripheral index rtc passing reference Unix timestamp seconds and microseconds to obtain sub-second precision. Return 0 on success. Interrupts \u00b6 In most microcontrollers function to be called in response to an interrupt are stored in an interrupt table. Single interrupts can be enabled, disabled or given a priority (if supported). To change the function called on interrupt, refer to vosInstallHandler() . void vhalIrqEnablePrio(uint32_t irqn,uint32_t prio) Enables the interrupt irqn assigning a priority of prio . Priority must be passed with the PORT_PRIO_MASK macro defined in the microcontroller porting files. void vhalIrqDisable(uint32_t irqn) Disable interrupt irqn . void vhalIrqEnable(uint32_t irqn) Enable interrupt irqn assigning a default priority. Implemented as a macro. Error Codes \u00b6 VHAL functions usually return an error code. The following list of macros contains most of the possible error codes. Some undocumented error codes are still returned in the current version. Error code are non positive integers. They have been encoded in such a way that negating the error code results in the corresponding virtual machine exception number. VHAL_OK Evaluates to 0. Returned on success. VHAL_GENERIC_ERROR Generic peripheral error. Corresponds to PeripheralError exception. VHAL_INVALID_PIN A virtual pin not supporting a specific peripheral is passed. Corresponds to InvalidPin exception. VHAL_HARDWARE_STATUS_ERROR An hardware error condition happened during peripheral operations. Corresponds to InvalidHardwareStatus exception. VHAL_TIMEOUT_ERROR The peripheral operation reached a timeout condition. Corresponds to TimeoutError exception. VHAL_HARDWARE_INITIALIZATION_ERROR A peripheral error happened during initialization. Corresponds to HardwareInitializationError exception.","title":"Hardware Abstraction Layer"},{"location":"reference/guide/docs/vhal/#hardware-abstraction-layer","text":"The Zerynth VM uses a common API to drive the underlying microcontroller peripherals. Such API is called VHAL and abstracts common peripherals operations so that peripheral access and management is identical across different microcontrollers.","title":"Hardware Abstraction Layer"},{"location":"reference/guide/docs/vhal/#pin-mapping","text":"The VHAL introduces a distinction between physical pins and virtual pins . Physical pins are the actual pins available on the board and are defined in the file port.c for every supported board. A physical pin usually maps to a microcontroller register and offset, needed to drive the pin. A virtual pin is just a name which refers to a particular configuration of a physical pin. Therefore different virtual pins can map to the same physical pin. For example, imagine a board where the first physical pin (P0) can be used as a general purpose input output (GPIO) or as the clock line (SCL) of the first instance of the I2C bus. Such physical pin is always controlled by same microcontroller register, but in the first case it is configured as a GPIO and the corresponding virtual pin name will be D0, while in the second case it is configured as I2C clock and the virtual pin name will be SCL0. The internal representation of virtual pins is a 16 bit integer where the high byte represents the name of the peripheral (the \u201cclass\u201d of the pin), while the low byte is the row number in the table of physical pins for that peripheral. All these levels of indirection are hidden by the VHAL using macros to access the relevant information about pins. All VHAL functions requiring pin names expect virtual pin names. The following scheme summarizes the available virtual pin info: Where Pin Name is a C Macro corresponding to Pin Value . For each string in Pin Class there exists a C macro with PINCLASS_ prepended, corresponding to the high byte of Pin Value (i.e. PINCLASS_DIGITAL is 0x00, PINCLASS_ANALOG is 0x01, etc\u2026). For each pin class, there exists a table containing configuration data. Such data can be accessed by the following macros: PIN_CLASS_ID(vpin) Returns a byte representing the index of the physical pin corresponding to vpin. PIN_CLASS_DATA0(vpin) Returns a byte representing the first byte of info about vpin. PIN_CLASS_DATA1(vpin) Returns a byte representing the second byte of info about vpin. PIN_CLASS_DATA2(vpin) Returns a byte representing the third byte of info about vpin. The meaning of the three bytes of info depends on the actual porting; usually they contain configuration values to correctly setup the peripheral.","title":"Pin Mapping"},{"location":"reference/guide/docs/vhal/#peripherals-mapping","text":"Each microcontroller peripheral is mapped to a peripheral index in the board porting files. For each peripheral there exists a table mapping multiple peripheral instances of the same type to different indexes. The following example will clarify the mapping. Imagine a microcontroller with four different USART peripherals named USART1 to USART4. In the board porting each USART is mapped to a peripheral index by creating such table: Index Value 0 3 1 1 2 4 3 2 When a VHAL function is called, expecting a peripheral index for a serial peripheral, the table is used to map the passed index (e.g. 0) to the corresponding mcu peripheral (e.g. USART3). Each board porting defines this kind of tables for each supported peripheral. The following macros can be used to query the peripheral tables: GET_PERIPHERAL_ID(name,prph_idx) Returns the microcontroller peripheral index given the name of the peripheral and the vhal index prph_idx . Referring to the previous table, prph_idx corresponds to values in the Index column, while the return value correspondes to the Value column. The parameter name is a string identifying the peripheral: \u201cserial\u201d, \u201cspi\u201d, \u201ci2c\u201d, \u201cadc\u201d, \u201cpwm\u201d, \u201cicu\u201d, \u201chtm\u201d. PERIPHERAL_NUM(name) Returns the number of microcontroller peripherals given the peripheral name .","title":"Peripherals Mapping"},{"location":"reference/guide/docs/vhal/#gpio","text":"A GPIO pin is a generic pin that can be used as input to read its digital status (low or high) or as output to set its digital status (low or high). On many microcontrollers it is possible to configure a GPIO to also generate an interrupt on status change.","title":"GPIO"},{"location":"reference/guide/docs/vhal/#macros","text":"The following macros are used to set the pin mode of operation. PINMODE_INPUT_PULLNONE Used to configure a pin as input with no pull up/down circuitry (floating mode). PINMODE_INPUT_PULLUP Used to configure a pin as input with pull up circuitry. PINMODE_INPUT_ANALOG Used to configure a pin as analog input by connecting it to an analog to digital converter. PINMODE_INPUT_PULLDOWN Used to configure a pin as input with pull down circuitry. PINMODE_OUTPUT_PUSHPULL Used to configure a pin as output. The pin will be able to both sink and source current. PINMODE_OUTPUT_OPENDRAIN Used to configure a pin as output. The pin will be able to only sink current. This means the pin output can only be set to low. PINMODE_OUTPUT_HIGHDRIVE Used to configure a pin as output. The pin will be able to only sink and source a higher current. Refer to each microcontroller datasheet for details. PINMODE_EXT_FALLING Used to configure a pin as input. An interrupt will be generated when the status of the pin goes from high to low. PINMODE_EXT_RISING Used to configure a pin as input. An interrupt will be generated when the status of the pin goes from low to high. PINMODE_EXT_BOTH Used to configure a pin as input. An interrupt will be generated when the status of the pin goes from low to high or from high to low.","title":"Macros"},{"location":"reference/guide/docs/vhal/#gpio-functions","text":"int vhalPinSetMode(int vpin int mode) Set the digital mode of *vpin to *mode. Valid values for *mode are the digital input and output PINMODE macros. Return 0 in case of success. int vhalPinRead(int vpin) Read the digital value of *vpin. Return 0 if *vpin is low, non-zero if *vpin is high. int vhalPinWrite(int vpin, int value) Set the digital value of vpin to value . If value is zero, vpin is set to low, otherwise is set to high. Return 0 in case of success. int vhalPinToggle(int vpin) Invert the digital value of vpin. If *vpin is high it is set to low, if *vpin is low it is set to high. Return 0 in case of success. void* PinGetPort(int vpin) Get the pointer to a gpio microcontroller register corresponding to *vpin. The return value must be used in functions like vhalPinFastSet() and vhalPinFastClear() . int PinGetPad(int vpin) Get the offset into a gpio microcontroller register corresponding to vpin. The return value must be used in functions like vhalPinFastSet() and vhalPinFastClear() . void vhalPinFastSet(void *port,int pad) Bypass the virtual pin indirection by operating on the microcontroller register port with offset . Set the corresponding pin to high. void vhalPinFastClear(void *port,int pad) Bypass the virtual pin indirection by operating on the microcontroller register port with offset . Set the corresponding pin to low. int vhalPinFastRead(void *port,int pad) Bypass the virtual pin indirection by operating on the microcontroller register port with offset pad. Return 0 if the in is low, non-zero if it is high. int vhalPinSetToPeripheral(int vpin, int prph, uint32_t prms) Transfer the control of vp to a peripheral identified by prph . The configuration parameters for vpin are passed via prms in a format depending on the microcontroller porting. Return 0 in case of success. The parameter prph is ignored in the current version of the VHAL. int vhalPinAttachInterrupt(int vpinintmode,extCbkFn fn, uint32_t timeout) Attach callback fn to vpin . fn is called from an ISR when there is a status change identified by mode. mode can be one of the PINMODE_EXT macros. Return a non negative integer identifying the slot fn has been attached to. If fn is NULL the currently attached function is removed and the interrupt disabled. typedef void(*extCbkFn)(int slot int dir) The type of in vhalPinAttachInterrupt() . slot` is the slot the callback has been attached to. dir is 0 if the callback has been called on a falling edge, non-zero on a rising edge. if timeout is provided, fn is called only the status of the pin remains stable for at least timeout units of time, effectively implenting debouncing.","title":"GPIO Functions"},{"location":"reference/guide/docs/vhal/#adc","text":"Analog to digital converters are peripherals that convert voltage on a pin to a number representing its magnitude. ADCs can be very complex devices with very advanced functions. The VHAL aims at supporting the following features when available: Single pin, single sample conversion Single pin, multiple samples conversion Multiple pin conversion Continuous conversion Conversion triggers The current version of VHAL supports features from 1 to 3. To enable ADC functions the macro VHAL_ADC must be defined.","title":"ADC"},{"location":"reference/guide/docs/vhal/#macros_1","text":"ADC_CAPTURE_SINGLE Select non continuous conversion mode ADC_CAPTURE_CONTINUOUS Select continuous conversion mode","title":"Macros"},{"location":"reference/guide/docs/vhal/#types","text":"typedef int (*adcCbkFn)(uint32_t adc, vhalAdcCaptureInfo *nfo) The type of the ADC callback for continuous mode. Not used in current version of VHAL. vhalAdcCaptureInfo A structure containing the parameters needed to configure the ADC for the conversion: typedef struct _vhal_adc_capture { uint32_t samples ; uint16_t * pins ; uint8_t npins ; uint8_t sample_size ; uint8_t capture_mode ; uint8_t trigger_mode ; uint16_t trigger_vpin ; void * buffer ; void * half_buffer ; int ( * callback )( uint32_t , struct _vhal_adc_capture * ); } vhalAdcCaptureInfo ; samples is the number of samples to capture pins is an array of virtual pin names to capture from npins is the length of pins sample_size will hold the size of a single sample capture_mode is one of the ADC_CAPTURE macros trigger_mode select the trigger type. Not yet used. trigger_vpin is the virtual pin to be used as gpio trigger. Not yet used. buffer is a pointer to a location of memory where captured samples will be stored. half_buffer is a pointer to the free half of buffer in continuous mode. Not yet used. callback is a function called in continuous mode when one half of the buffer is filled. Not yet used. vhalAdcConf A structure used to initialize the ADC. typedef struct _vhal_adc_conf { uint32_t samples_per_second ; uint32_t resolution ; } vhalAdcConf ;","title":"Types"},{"location":"reference/guide/docs/vhal/#functions","text":"int vhalInitADC(void* data) Must be called before any function starting with vhalAdc . int vhalAdcInit(uint32_t adc,vhalAdcConf *conf) Initialize the ADC identified by the peripheral index adc with values in conf . Return 0 on success, negative values in case of failure. int vhalAdcGetPeripheralForPin(int vpin) Return the ADC peripheral index associated with vpin . int vhalAdcPrepareCapture(uint32_t adc,vhalAdcCaptureInfo *info) Must be called before vhalAdcRead() to configure the conversion. Return 0 on success. The member sample_size of info is set to the actual sample size. int vhalAdcRead(uint32_t adc,vhalAdcCaptureInfo *info) Must be called after vhalAdcPrepareCapture() has configured the conversion. Return 0 on success. The member buffer of info must be set to the correct size according to samples and sample_size . The function suspends the current thread until the end of the conversion. The samples are stored in the order they are converted in info->buffer. int vhalAdcDone(uint32_t adc) Disable the ADC identified by the peripheral index adc .","title":"Functions"},{"location":"reference/guide/docs/vhal/#dac","text":"Digital to Analog converters are peripherals that convert a number to a voltage on a pin. DACs can be very complex devices with very advanced functions. The VHAL aims at supporting the following features when available: Single pin, software triggered conversion Single pin, timed triggered conversion Multiple pin conversion To enable DAC functions the macro VHAL_DAC must be defined. int vhalInitDAC(void* data) Must be called before any function starting with vhalDac . int vhalDacInit(uint32_t vpin) Initialize the DAC identified by the virtual pin vpin . Return 0 on success, negative values in case of failure. int vhalDacWrite(uint32_t vpin,uint16_t *data,uint32_t len,uint32_t timestep) Return 0 on success. Starts sending data samples in data to DAC identified by vpin up to len samples, each one sent after a dealy of timestep . The function suspends the current thread until the last sample is sent. int ivhalDacDone(uint32_t vpin) Disable the DAC identified by the virtual pin vpin .","title":"DAC"},{"location":"reference/guide/docs/vhal/#pwm","text":"PWM peripherals are able to generate square waves on pins. Square waves are configurable in terms of total duration (period) and duration of high state (pulse). To enable PWM functions the macro VHAL_PWM must be defined. int vhalInitPWM(void* data) Must be called before any function starting with vhalPwm . int vhalPwmStart(int vpin,uint32_t period,uint32_t pulse,uint32_t npulses) Generate a square wave of period period and pulse pulse on vpin . Timings must be expressed using TIME_U and both period and pulse must be expressed in the same time unit. If npulses is positive, the function blocks the current thread until a number of square waves equal to npulses is generated; afterwards, pwm is disabled and the function returns. If npulses is zero or less, pwm is activated and the function returns immediately. If period is 0 or pulse is 0 or period is less than pulse pwm is deactivated regardless of npulses . Return 0 on success. On failure return a negative integer.","title":"PWM"},{"location":"reference/guide/docs/vhal/#icu","text":"The Input Capture Unit of a microcontroller measures the timings of a square wave on a pin. Imagine to have this signal on a digital pin: HIGH _______ ________________ _________ | | | | | | | | | | | | _____| |__________| |___| |____ LOW <------><----------><---------------><-><---------> T0 T1 T2 T3 T4 The ICU is able to return the duration of T0, T1, T2, etc\u2026 in microseconds. To enable ICU functions the macro VHAL_ICU must be defined.","title":"ICU"},{"location":"reference/guide/docs/vhal/#macros_2","text":"ICU_TRIGGER_LOW Set ICU trigger to the first transition from high to low ICU_TRIGGER_HIGH Set ICU trigger to the first transition from low to high ICU_TRIGGER_BOTH Set ICU trigger to the first transition ICU_INPUT_PULLUP Set pin used by ICU as input with pullup ICU_INPUT_PULLDOWN Set pin used by ICU as input with pulldown ICU_CFG(trigger,filter,input) Return a uint32_t encoding the information about icu triggering (one of the ICU_TRIGGER macros) and icu pin configuration (one of the ICU_INPUT macros). The parameter filter is not used at the moment and must be set to 0. ICU_CFG_GET_TRIGGER(cfg) Extract the trigger value from a cfg generated by ICU_CFG ICU_CFG_GET_INPUT(cfg) Extracts the input mode value from a cfg generated by ICU_CFG","title":"Macros"},{"location":"reference/guide/docs/vhal/#functions_1","text":"int vhalInitICU(void* data) Must be called before any function starting with vhalIcu . int vhalIcuStart(int vpin,uint32_t cfg,uint32_t time_window,uint32_t *buffer,uint32_t *bufsize, uint32_t *firstbit) Start capturing on vpin . The capture will start with pin mode and trigger parameters specified in cfg by means of the ICU_CFG macro. Once the capture starts, it will continue until one of the following conditions verifies: a time equal to time_window has passed from the last captured value a number of values equal to the integer pointed by bufsize has been captured The function blocks the current thread until the end of the capture. On returning: bufsize will point to the number of captured values buffer will contain such values expressed in microseconds firstbit will point to ICU_TRIGGER_LOW if the first transition was from high to low, or to ICU_TRIGGER_HIGH if the first transition was from low to high. Return 0 on success. On failure, a negative value.","title":"Functions"},{"location":"reference/guide/docs/vhal/#htm","text":"Hardware Timers can be used to keep track of time with a greater precision with respect to the RTOS software timers. To enable HTM functions the macro VHAL_HTM must be defined. typedef void (*htmFn)(uint32_t tm,voidb *args) Type of a hardware timer callback function. int vhalInitHTM(void* data) Must be called before any function starting with vhalHtm . int vhalHtmGetFreeTimer(void) Return the peripheral index of the first available hardware timer. Return value is negative in case of error. int vhalHtmOneShot(uint32_t tm,uint32_t delay,htmFn fn,void *args,uint32_t blocking) Given the peripheral index tm , configure such timer to generate an interrupt after a time represented by delay (with TIME_U ). On interrupt generation, fn is executed with arguments args . If blocking is non-zero, the function blocks the current thread until fn is called. If blocking is zero, the function immediately returns. If delay is zero, the timer is deactivated. Return 0 on success. int vhalHtmRecurrent(uint32_t tm,uint32_t delay,htmFn fn,void *args) Given the peripheral index tm , configure such timer to generate an interrupt after a time represented by delay (with TIME_U ). On interrupt generation, fn is executed with arguments args and the timer is reconfigured to generate another interrupt after the same delay . If delay is zero, the timer is deactivated and fn stops to be executed periodically. Return 0 on success. int vhalSleepMicros(uint32_t tm,uint32_t micros) Given the peripheral index tm , suspends the current thread for micros microseconds. Return 0 on success.","title":"HTM"},{"location":"reference/guide/docs/vhal/#serial","text":"Serial communication interfaces in microcontrollers come in many flavours: USART, UART and Serial over USB. All this peripherals are grouped together in Zerynth and controlled with the same API.","title":"SERIAL"},{"location":"reference/guide/docs/vhal/#macros_3","text":"SERIAL_PARITY_NONE Select no parity. SERIAL_PARITY_EVEN Select even parity. SERIAL_PARITY_ODD Select odd parity. SERIAL_STOP_ONE Select 1 stop bit. SERIAL_STOP_ONEHALF Select 1.5 stop bit. SERIAL_STOP_TWO Select 2 stop bits. SERIAL_BITS_8 Select 8 bits of data. SERIAL_BITS_7 Select 7 bits of data. SERIAL_CFG(parity, stop, bits, hw, other) Return a uint32_t representing the serial port configuration. hw and other are not yet used and must be set to 0. SERIAL_CFG_PARITY(cfg) Return parity configuration encoded in cfg . SERIAL_CFG_STOP(cfg) Return stop bits configuration encoded in cfg . SERIAL_CFG_BITS(cfg) Return data bits configuration encoded in cfg .","title":"Macros"},{"location":"reference/guide/docs/vhal/#functions_2","text":"int vhalSerialInit(uint32_t ser,uint32_t baud,uint32_t cfg,uint16_t rxpin,uint16_t txpin) Initialize the serial peripheral identified by the peripheral index ser . Baud rate is set to baud and configuration parameters are taken from cfg encoded with SERIAL_CFG . rxpin and txpin are configured accordingly. Return 0 on success. int vhalSerialRead(uint32_t ser,uint8_t *buf,uint32_t len) Read len bytes from ser into buf blocking the current thread until all bytes are read. Return the actual number of bytes read. int vhalSerialWrite(uint32_t ser,uint8_t *buf, uint32_t len) Write len bytes from buf to ser . Depending on the implementation, the function may return before all bytes are actually written to ser. Return the number of bytes written to ser or to an internal buffer. int vhalSerialAvailable(uint32_t ser) Return the number of bytes available to the next vhalSerialRead() call. int vhalSerialDone(uint32_t ser) Deactivate ser .","title":"Functions"},{"location":"reference/guide/docs/vhal/#i2c","text":"I2C is a multimaster and multislave bus used to exchange data between microcontrollers and peripherals. Many microcontrollers can be configured both as I2C masters or I2C slaves; in the current version, the VHAL supports only master mode. vhalI2CConf The following structure is used to configure the I2C bus: typedef struct _vhal_i2c_conf { uint32_t clock ; uint16_t addr ; uint16_t sda ; uint16_t scl ; uint16_t mode ; } vhalI2CConf ; The meaning of vhalI2CConf members is: clock : number of Hz the I2C bus will be clocked to. Use up to 100k for slow mode, up to 400k for fast mode. Other modes are not supported yet. addr: the peripheral address to communicate with. sda : the virtual pin that will be configured as SDA (data line). scl: the virtual pin that will be configured as SCL (clock line). mode : not used yet. int vhalInitI2C(void *data) Must be called before any function starting with vhalI2C . int vhalI2CInit(uint32_t i2c,vhalI2CConf *conf) Initialize the I2C bus corresponding to the i2c peripheral index with configuration parameters taken from conf. Return 0 on success. int vhalI2CDone(uint32_t i2c) Deactivates i2c . int vhalI2CLock(uint32_t i2c) Lock the I2C bus. To be used when multiple threads share the same bus. int vhalI2CUnlock(uint32_t i2c) Unlock the I2C bus. To be used when multiple threads share the same bus. int vhalI2CRead(uint32_t i2c,uint8_t* buf,uint32_t len*,uint32_t timeout) Start reading from i2c (from configured addr ). Execution ends as soon as one of the following conditions verifies: after a message of len bytes has been read and transferred to buf an error occurs on the bus the bus is inactive for a time equal to timeout Return 0 on success. int vhalI2CTransmit(uint32_t i2c,uint8_t* tx,uint32_t txlen,uint8_t *rx,uint32_t rxlen,uint32_t timeout) Execute a two steps communication. First, txlen bytes from tx are written to the bus; second, rxlen bytes are read from the bus to rx . Execution ends as soon as one of the following conditions verifies: both write and read steps are executed without errors an error occurs on the bus the bus is inactive for a time equal to timeout Return 0 on success. int vhalI2CWrite(uint32_t i2c,uint8_t* tx,uint32_t txlen,uint32_t timeout) Implemented as a macro calling vhalI2CTransmit(i2c,tx,txlen,NULL,0,timeout) . int vhalI2CSetAddr(uint32_t i2c, uint16_t add) Change the peripheral address associated with i2c in vhalI2CInit() to addr .","title":"I2C"},{"location":"reference/guide/docs/vhal/#spi","text":"Serial Peripheral Interface is one of the most used communication standards in embedded systems. Many microcontroller allow the SPI bus to be configured as master or as slave; the current version of VHAL supports master mode only. vhalSpiConf The following structure is used to configure the SPI bus: typedef struct _vhal_spi_conf { uint32_t clock ; uint16_t miso ; uint16_t mosi ; uint16_t sclk ; uint16_t nss ; uint8_t mode ; uint8_t bits ; uint8_t master ; uint8_t msbfirst ; } vhalSpiConf ; The meaning of vhalSpiConf members is: clock : the number of Hz the SPI bus will be clocked to. miso , mosi , sclk , nss : virtual pins representing the four wires used by the bus. nss is also called slave select or chip select in datasheets. mode : configuration parameters for polarity and phase bits : number of data bits master : not used yet **msbfirst*: if non-zero, data is transferred with the most significant bits first.","title":"SPI"},{"location":"reference/guide/docs/vhal/#macros_4","text":"SPI_MODE_LOW_FIRST Low polarity (idle low), phase zero (bits captured on the first clock edge). SPI_MODE_LOW_SECOND Low polarity (idle low), phase one (bits captured on the second clock edge). SPI_MODE_HIGH_FIRST High polarity (idle high), phase zero (bits captured on the first clock edge). SPI_MODE_HIGH_SECOND High polarity (idle high), phase one (bits captured on the second clock edge). SPI_BITS_8 Data is transferred 8 bits at time. SPI_BITS_16 Data is transferred 16 bits at time. SPI_BITS_32 Data is transferred 32 bits at time.","title":"Macros"},{"location":"reference/guide/docs/vhal/#functions_3","text":"int vhalInitSPI(void *data) Must be called before any function starting with vhalSpi. int vhalSpiInit(uint32_t spi,vhalSpiConf *conf) Initialize the SPI bus identified by the peripheral index spi with configuration parameters taken from conf . Return 0 on success. vhalSpiLock(uint32_t spi) Lock the SPI bus. To be used when multiple threads share the same bus. int vhalSpiUnlock(uint32_t spi) Unlock the SPI bus. To be used when multiple threads share the same bus. int vhalSpiSelect(uint32_t spi) Select the SPI peripheral connected to nss . int vhalSpiUnselect(uint32_t spi) Unselect the SPI peripheral connected to nss . int vhalSpiExchange(uint32_t spi,void *tosend,void *toread,uint32_t blocks) Start a SPI communication on spi , exchanging a number of data frames equal to blocks . Size of data frame is configured with SPI_BITS macros. Data is exchanged synchronously; bytes in tosend are written to MOSI while bytes incoming on MISO are stored in toread. If toread is NULL, incoming bytes are ignored (pure write). If tosend is NULL, nothing is written (pure read). If both toread and tosend are NULL, bytes on the bus are skipped. Return 0 on success. int vhalSpiDone(uint32_t spi) Deactivate spi.","title":"Functions"},{"location":"reference/guide/docs/vhal/#macros_5","text":"QSPI_MODE_LOW_FIRST Low polarity (idle low), phase zero (bits captured on the first clock edge). QSPI_MODE_LOW_SECOND Low polarity (idle low), phase one (bits captured on the second clock edge). QSPI_MODE_HIGH_FIRST High polarity (idle high), phase zero (bits captured on the first clock edge). QSPI_MODE_HIGH_SECOND High polarity (idle high), phase one (bits captured on the second clock edge).","title":"Macros"},{"location":"reference/guide/docs/vhal/#nfo","text":"Nfo functions retrieve the unique identifier of a microcontroller. uint8_t *vhalNfoGetUIDStr(void) Return the unique identifier represented as a hex string. int vhalNfoGetUID(uint8_t *buf) Return the unique identifier as bytes in buf. int vhalNfoGetUIDLen(void) Return the length in bytes of the unique identifier. The length of the corresponding hex string is exactly two times.","title":"NFO"},{"location":"reference/guide/docs/vhal/#flash","text":"Microcontrollers usually have a non volatile storage memory (flash memory) to hold code. These memories are usually organized in sectors or blocks, each of which can be erased and written independently of others. int vhalFlashErase(void *addr,uint32_t size) Erase sector starting at addr for size bytes. If size is greater than the sector length, following sectors are erased. Return 0 on success. int vhalFlashWrite(void *addr,uint8_t *data,uint32_t len) Write data starting at addr for len bytes. In many architectures, for vhalFlashWrite to work, the sectors must be erased first. Return written bytes number. void *vhalFlashAlignToSector(void *add) If addr points to the start of a sector, return addr . Otherwise the start of the next sector is returned. Return NULL on error.","title":"FLASH"},{"location":"reference/guide/docs/vhal/#rng","text":"Random Number Generators are often implemented in hardware. When such MCU feature is missing, the VHAL provides a software implementation. int vhalRngSeed(uint32_t seed) Initialize the RNG with a seed. Must be called before using vhalRngGenerate() unit32_t vhalRngGenerate(void) Return a random 32 bits number.","title":"RNG"},{"location":"reference/guide/docs/vhal/#rtc","text":"A Real-Time Clock (RTC) might be available on-board to keep passing time with great accuracy. int vhalRTCInit(int rtc) Initialize the RTC identified by the peripheral index rtc . Return 0 on success. int vhalRTCGetUTC(int rtc,vhalRTCTimeInfo*vhal_time_info) Fill vhal_time_info structure with time information retrieved from the RTC. typedef struct _timeinfo { uint32_t tv_seconds ; uint32_t tv_microseconds ; uint32_t tm_sec ; uint32_t tm_min ; uint32_t tm_hour ; uint32_t tm_mday ; uint32_t tm_mon ; uint32_t tm_year ; uint32_t tm_wday ; uint32_t tm_yday ; uint32_t tm_isdst ; } vhalRTCTimeInfo ; Return 0 on success. int vhalRTCSetUTC(int rtc,uint32_t sec,uint32_t usec) Set an UTC reference for RTC identified by the peripheral index rtc passing reference Unix timestamp seconds and microseconds to obtain sub-second precision. Return 0 on success.","title":"RTC"},{"location":"reference/guide/docs/vhal/#interrupts","text":"In most microcontrollers function to be called in response to an interrupt are stored in an interrupt table. Single interrupts can be enabled, disabled or given a priority (if supported). To change the function called on interrupt, refer to vosInstallHandler() . void vhalIrqEnablePrio(uint32_t irqn,uint32_t prio) Enables the interrupt irqn assigning a priority of prio . Priority must be passed with the PORT_PRIO_MASK macro defined in the microcontroller porting files. void vhalIrqDisable(uint32_t irqn) Disable interrupt irqn . void vhalIrqEnable(uint32_t irqn) Enable interrupt irqn assigning a default priority. Implemented as a macro.","title":"Interrupts"},{"location":"reference/guide/docs/vhal/#error-codes","text":"VHAL functions usually return an error code. The following list of macros contains most of the possible error codes. Some undocumented error codes are still returned in the current version. Error code are non positive integers. They have been encoded in such a way that negating the error code results in the corresponding virtual machine exception number. VHAL_OK Evaluates to 0. Returned on success. VHAL_GENERIC_ERROR Generic peripheral error. Corresponds to PeripheralError exception. VHAL_INVALID_PIN A virtual pin not supporting a specific peripheral is passed. Corresponds to InvalidPin exception. VHAL_HARDWARE_STATUS_ERROR An hardware error condition happened during peripheral operations. Corresponds to InvalidHardwareStatus exception. VHAL_TIMEOUT_ERROR The peripheral operation reached a timeout condition. Corresponds to TimeoutError exception. VHAL_HARDWARE_INITIALIZATION_ERROR A peripheral error happened during initialization. Corresponds to HardwareInitializationError exception.","title":"Error Codes"},{"location":"reference/guide/docs/vm/","text":"The Zerynth Virtual Machine \u00b6 The Zerynth Virtual Machine can run Python scripts that are board independent allowing a high reusability of code. Zerynth supports all the most used high-level features of Python like modules, classes, multithreading, callbacks, timers and exceptions, plus some hardware-related features like interrupts, PWM, digital I/O, etc. The Zerynth VM is natively multithread and realtime. Indeed it is built on top of a RTOS ( CHIBIOS and FreeRtos ), by wrapping its functionalities in a operative system abstraction layer (VOSAL). This means that the VM is agnostic of the underlying RTOS: porting activities are ongoing to have many VMs based on different RTOS. The inner workings of the Zerynth VM are complex but can be reduced to a few components: Bytecode Interpreter : the Zerynth Compiler turns Python scripts to a set of bytecode objects, each one containing not only a sequence of instructions, but also enough information for memory management and error checking. Each bytecode instruction, called opcode , is exactly one byte in length with optional arguments going from 0 to 4 bytes. The bytecode interpreter simply scans the bytecode an opcode at time, executes the opcode in the current thread and continues to the next opcode until a stop is encountered. Zerynth bytecode closely resembles Python but introduces some embedded specific opcodes. Global Interpreter Lock : the GIL is an object shared by all Python threads; it coordinates the sequence of opcode execution between threads so that each opcode can be considered \"atomic\". This means that while thread-one is executing opcode \"x\", thread-one has the right to do so until the execution of \"x\" reaches the end. No other thread can stop it without comproimising the interpreter integrity. When a Python thread goes to sleep, or its time quantum ends, the GIL is released so that another thread can take control of the bytecode interpreter. Garbage Collector : objects in Python have life cycle. They are created and used by the programmer and must be removed when they are not needed anymore. While in low level languages the responsibility of freeing unused memory rests on the programmer, in Python it's the garbage collector (gc) duty. When necessary, a complete scan of the created object is performed in order to search the ones that can be removed safely. The VM gc algorithm is a mark-and-sweep-stop-the-world variant. Interrupt Thread : it is a very high priority thread that is woken up when an interrupt configured to run a Python function is fired. Python bytecode is executed outside of the ISR routine, but inside the Interrupt Thread. This way the Python function can allocate memory as a normal function. However, since the interrupt thread has the highest priority it is important to spend the least time possible inside it. VOSAL : it is the Zerynth VM operative system abstration layer. It contains functions provided by the underlying RTOS to create threads, semaphores and other multi-threading related objects. The VOSAL is linked into the VM, but many of its functions can be called from hybrid C/Python code. Check the Programming Guide for more information on calling C from Python. VHAL : it is the Zerynth VM hardware abstraction layer. It contains functions to control the microcontroller peripherals: serial ports, SPI, I2C, ADC, PWM and so on. Each family of microcontroller has its own VHAL implementation so that the programmer calling C from Python can have an uniform hardware API across different microcontrollers. Zerynth and Python \u00b6 The Zerynth VM has been developed with the goal of making Python usable in the IoT world. To do so some features of Python have been discarded because they were too resource intensive, while non-Python features have been introduced because they were more functional in the embedded setting. Here is a non comprehensive list: Python Object size has been reduced as much as possible: integers are signed and 31 bits wide, so that they can be represented with 4 bytes without additional overhead. garbage collectore overhead has been brought down to 8 bytes per object (and there is still space for optimization) names are not saved as strings in the bytecode; they are converted to 16 bits integers to occupy much less space. This apparently minor change leads to a series of important consequences. First of all, Zerynth becomes a less \"dynamic\" language with respect to Python, since introspection is not allowed. However on the pro side, Zerynth scripts can be statically analyzed to remove unused bytecode greatly reducing memory usage. Another important consequence is that setattr and getattr can not be used with non constant arguments. sequences and dictionaries can have at most 65536 elements. exceptions have been transformed from full fledged classes to a name organized in an inheritance tree. So an exception can't have methods, but it is faster to raise and to handle and it just takes 4 bytes of memory. Compilation has been moved outside the language; by removing the compile() and eval() builtins the VM shrienked greatly in size. Not so often used Python features have been removed. Closures, generators and decorators will be added in future updates in a modular way. True multi-threading with priorities has been introduced. CPython implementations use green-threads to emulate multi-threaded environments without relying on any native OS capabilities, and they are managed in user space instead of kernel space, enabling them to work in environments that do not have native thread support. In Zerynth each thread is a RTOS thread with its own memory and priority. Because of the GIL, only one Zerynth thread can execute bytecode in a time quantum, but it is possible to have more than one non-Python thread running in parallel. For example, a complex driver can be structured as a VOSAL thread written in C to control hardware, with any number of Zerynth threads running bytecode. New data structures have been introduced like shorts and short-array to hold sequences of 16 bits integers. BigIints and fixed point math are in development.","title":"The Zerynth Virtual Machine"},{"location":"reference/guide/docs/vm/#the-zerynth-virtual-machine","text":"The Zerynth Virtual Machine can run Python scripts that are board independent allowing a high reusability of code. Zerynth supports all the most used high-level features of Python like modules, classes, multithreading, callbacks, timers and exceptions, plus some hardware-related features like interrupts, PWM, digital I/O, etc. The Zerynth VM is natively multithread and realtime. Indeed it is built on top of a RTOS ( CHIBIOS and FreeRtos ), by wrapping its functionalities in a operative system abstraction layer (VOSAL). This means that the VM is agnostic of the underlying RTOS: porting activities are ongoing to have many VMs based on different RTOS. The inner workings of the Zerynth VM are complex but can be reduced to a few components: Bytecode Interpreter : the Zerynth Compiler turns Python scripts to a set of bytecode objects, each one containing not only a sequence of instructions, but also enough information for memory management and error checking. Each bytecode instruction, called opcode , is exactly one byte in length with optional arguments going from 0 to 4 bytes. The bytecode interpreter simply scans the bytecode an opcode at time, executes the opcode in the current thread and continues to the next opcode until a stop is encountered. Zerynth bytecode closely resembles Python but introduces some embedded specific opcodes. Global Interpreter Lock : the GIL is an object shared by all Python threads; it coordinates the sequence of opcode execution between threads so that each opcode can be considered \"atomic\". This means that while thread-one is executing opcode \"x\", thread-one has the right to do so until the execution of \"x\" reaches the end. No other thread can stop it without comproimising the interpreter integrity. When a Python thread goes to sleep, or its time quantum ends, the GIL is released so that another thread can take control of the bytecode interpreter. Garbage Collector : objects in Python have life cycle. They are created and used by the programmer and must be removed when they are not needed anymore. While in low level languages the responsibility of freeing unused memory rests on the programmer, in Python it's the garbage collector (gc) duty. When necessary, a complete scan of the created object is performed in order to search the ones that can be removed safely. The VM gc algorithm is a mark-and-sweep-stop-the-world variant. Interrupt Thread : it is a very high priority thread that is woken up when an interrupt configured to run a Python function is fired. Python bytecode is executed outside of the ISR routine, but inside the Interrupt Thread. This way the Python function can allocate memory as a normal function. However, since the interrupt thread has the highest priority it is important to spend the least time possible inside it. VOSAL : it is the Zerynth VM operative system abstration layer. It contains functions provided by the underlying RTOS to create threads, semaphores and other multi-threading related objects. The VOSAL is linked into the VM, but many of its functions can be called from hybrid C/Python code. Check the Programming Guide for more information on calling C from Python. VHAL : it is the Zerynth VM hardware abstraction layer. It contains functions to control the microcontroller peripherals: serial ports, SPI, I2C, ADC, PWM and so on. Each family of microcontroller has its own VHAL implementation so that the programmer calling C from Python can have an uniform hardware API across different microcontrollers.","title":"The Zerynth Virtual Machine"},{"location":"reference/guide/docs/vm/#zerynth-and-python","text":"The Zerynth VM has been developed with the goal of making Python usable in the IoT world. To do so some features of Python have been discarded because they were too resource intensive, while non-Python features have been introduced because they were more functional in the embedded setting. Here is a non comprehensive list: Python Object size has been reduced as much as possible: integers are signed and 31 bits wide, so that they can be represented with 4 bytes without additional overhead. garbage collectore overhead has been brought down to 8 bytes per object (and there is still space for optimization) names are not saved as strings in the bytecode; they are converted to 16 bits integers to occupy much less space. This apparently minor change leads to a series of important consequences. First of all, Zerynth becomes a less \"dynamic\" language with respect to Python, since introspection is not allowed. However on the pro side, Zerynth scripts can be statically analyzed to remove unused bytecode greatly reducing memory usage. Another important consequence is that setattr and getattr can not be used with non constant arguments. sequences and dictionaries can have at most 65536 elements. exceptions have been transformed from full fledged classes to a name organized in an inheritance tree. So an exception can't have methods, but it is faster to raise and to handle and it just takes 4 bytes of memory. Compilation has been moved outside the language; by removing the compile() and eval() builtins the VM shrienked greatly in size. Not so often used Python features have been removed. Closures, generators and decorators will be added in future updates in a modular way. True multi-threading with priorities has been introduced. CPython implementations use green-threads to emulate multi-threaded environments without relying on any native OS capabilities, and they are managed in user space instead of kernel space, enabling them to work in environments that do not have native thread support. In Zerynth each thread is a RTOS thread with its own memory and priority. Because of the GIL, only one Zerynth thread can execute bytecode in a time quantum, but it is possible to have more than one non-Python thread running in parallel. For example, a complex driver can be structured as a VOSAL thread written in C to control hardware, with any number of Zerynth threads running bytecode. New data structures have been introduced like shorts and short-array to hold sequences of 16 bits integers. BigIints and fixed point math are in development.","title":"Zerynth and Python"},{"location":"reference/guide/docs/vosal/","text":"Operating System Abstraction Layer \u00b6 The Zerynth VM uses a common API to create and manage threads and synchronization objects. Such API is called VOSAL and abstracts the details of the underlying RTOS, so that it can be changed as needed for performance or licensing reasons. Types \u00b6 VThread VThread is defined as a pointer to a region of memory containing a thread representation. In order to be as abstract as possible the actual type of VThread is void*. Values of type VThread must be managed only by calling vosal functions starting with vosTh . VSemaphore VSemaphore is defined as a pointer to a region of memory containing a semaphore representation. In order to be as abstract as possible the actual type of VSemaphore is void*. Values of type VSemaphore must be managed only by calling vosal functions starting with vosSem . VSysTimer VSysTimer is defined as a pointer to a region of memory containing a rtos timer representation. In order to be as abstract as possible the actual type of VSysTimer is void*. Values of type VSysTimer must be managed only by calling vosal functions starting with vosTimer . VMailBox VMailBox is defined as a pointer to a region of memory containing a rtos mailbox representation. In order to be as abstract as possible the actual type of VMailBox is void*. Values of type VMailBox must be managed only by calling vosal function starting with vosMBox . Mailboxes are an optional feature and can be disabled when compiling a VM. VFifo VFifo is defined as a pointer to a region of memory containing a rtos fifo. In order to be as abstract as possible the actual type of VFifo is void*. Values of type VFifo must be managed only by calling vosal function starting with vosFifo . Fifos are an optional feature and can be disabled when compiling a VM. typedef void(*vsystimer_fn)(void *) Type of a timer callback function. Variables \u00b6 volatile uint32_t_systime_seconds Holds the number of seconds passed since VM startup. It is not guaranteed to be implemented in every architecture or RTOS. volatile uint64_t_systime_millis Holds the number of milliseconds passed since VM startup. It is not guaranteed to be implemented in every architecture or RTOS. volatile uint32_t_systime_frequency Holds the current frequency of the microcontroller in Hz. Macros \u00b6 Time Macros \u00b6 NANOS Represent the time unit nanoseconds. MICROS Represent the time unit microseconds. MILLIS Represent the time unit milliseconds. SECONDS Represent the time unit seconds. TIME_U(value,unit) Time values in VOSAL are represented as value plus time unit. This macro creates a valid time representation mixing together value (max 30 significant bits) with unit . Every vosal function expecting a time must be passed the result of TIME_U. GET_TIME_UNIT(time) Extracts the time unit from time to time . GET_TIME_VALUE(time) Extracts the time value from time to time . GET_TIME_MICROS(time) Extracts the time value from time converting it to microseconds. TIME_IS_ZERO(time) Evaluates to true if time is zero in the corresponding time unit. VTIME_IMMEDIATE A unitless time value representing no time at all. VTIME_INFINITE Infinite amount of time, used when an infinite timeout is requested. Priority Macros \u00b6 VOS_PRIO_IDLE This priority should not be used with normal threads. Only one thread exists with this priority and it is created at startup. VOS_PRIO_LOWEST Lowest possible thread priority. VOS_PRIO_LOWER This priority is greater than all preceding thread priorities. VOS_PRIO_LOW This priority is greater than all preceding thread priorities. VOS_PRIO_NORMAL This priority is greater than all preceding thread priorities. It is the default priority. VOS_PRIO_HIGH This priority is greater than all preceding thread priorities. VOS_PRIO_HIGHER This priority is greater than all preceding thread priorities. VOS_PRIO_HIGHEST This priority is greater than all preceding thread priorities. Thread Status \u00b6 VTHREAD_READY Status of a thread that has been created but not yet run. VTHREAD_RUNNING Status of a thread that is currently running. VTHREAD_INACTIVE Status of a thread that has finished its life cycle. VTHREAD_WAITING Status of a thread that is sleeping waiting for some event to occur. Return values \u00b6 VRES_OK If returned, the function execution encountered no problems. VRES_TIMEOUT If returned, the function exited with a timeout condition. VRES_RESET If returned, the function exited with a reset condition. System and Thread functions \u00b6 vosSysLock(void) Locks the system, usually by disabling interrupts. Thread scheduling is suspended and the following code is executed atomically. It can not be used inside ISRs. vosSysUnlock(void) Unlocks the system, usually by enabling interrupts. It is used together with vosSysLock() to protect small critical sections. It can not be used inside ISRs. vosSysLockIsr(void) Same as vosSysLock() , but must be called only inside an ISR. vosSysUnlockIsr(void) Same as vosSysUnlock() , but must be called only inside an ISR. vosEnterIsr(void) Must be called when entering an ISR. Depending on the underlyng RTOS and architecture it can be an empty macro. vosExitIsr(void) Must be called when exiting an ISR. Depending on the underlyng RTOS and architecture it can be an empty macro. vos_irq_handler vosInstallHandler(int32_t hpos,vos_irq handler fn) Install a new ISR fn at index hpos in the interrupt table. Previous ISR is returned. The type vos_irq_handler is: typedef void (*vos_irq_handler)(void) . void vosSysReset(void) Soft reset the microcontroller. vos_irq_handler vosInstallHandler(uint32_t size,int32_t prio,void *fn,void *arg,void *data) Create a VThread with a free workspace memory of size bytes. Actual memory usage is greater than size of an amount dependent on the underlying RTOS data structures. prio is the starting priority of the thread. The function run inside the thread is fn to which a single argument arg is passed. Some data can be associated to the created thread. After creation, the thread is not started. A call to vosThResume() is necessary to start the execution of fn . void vosThDestroy(VThread th) Frees the memory associated to th . Thread th must be terminated in order to call vosThDestroy, otherwise memory corruption ensues. void vosThSetData(VThread th,void *data) Attaches data to th . void* vosThGetData(VThread th) Retrieves data attached to th . void* vosThGetId(VThread th) Every created thread has a unique 32 bits id. Returns such id. unit32_ vosThGetStatus(VThread th) Returns the status of th . Possible return values are all the thread status macros. void vosThSetPriority(int32_t prio) Changes the priority of the current thread. Values for prio are all the priority macros. int32_T vosThGetPriority(void) Returns the priority of the current thread. vThread vosThCurrent(void) Returns the current thread. void vosThSleep(time) Suspend the current thread for an amount of time represented by time . time must be passed using TIME_U . The precision of vosThSleep depends on the priority of other threads with respect t the current one and to the scheduling strategy of the underlying RTOS. void vosThYield() The current thread is suspended and the control is given to the next thread in the scheduling order. void vosThSuspend() The current thread is suspended until the next call to vosThResume() . This function must be preceded by a call to vosSysLock() . The implementation of vosThSuspend will remove the lock if necessary. vThread vosThResume(VThread th) Resume the thread th . th must be a thread just created (and never resumed before) or suspended by vosThSuspend() . vThread vosThResumeIsr(VThread th) Resume the thread th . th must be a thread just created (and never resumed before) or suspended by vosThSuspend() . It must be used only inside an ISR. Semaphores \u00b6 vSemaphore vosSemCreate(uint32_t n) Creates a VSemaphore with initial value n . void vosSemReset(VSemaphore sem) Reset the semaphore sem . Every thread waiting on sem is woken up and the semaphore reset signaled with :macr: VRES_RESET . void vosSemDestroy(VSemaphore sem) Reset sem and free memory used by sem. void sSemSignal(VSemaphore sem) Signal the semaphore sem . If any thread is waiting on the semaphore, one thread is woken up. If no threads are waiting, the semaphore value is increased by one. void vosSemSignalCap(VSemaphore sem,uint32_t cap) Signal the semaphore sem . If any thread is waiting on the semaphore, one thread is woken up. If no threads are waiting, the semaphore value is increased by one only if it is less than cap . void vosSemSignalIsr(VSemaphore sem) Same as vosSemSignal() but must be used only inside ISRs. int32_t vosSemWaitTimeout(VSemaphore sem,uint32_t timeout) Wait on semaphore sem . If the value of sem is zero or less, the thread is suspended for a time equal to timeout (passed with TIME_U ). If the value of sem is one or greater, it is decreased by one and the thread is not suspended. Return VRES_OK if the timeout is not triggered, VRES_TIMEOUT if it is triggered or VRES_RESET if vosSemReset() is called on sem . int32_t vosSemWait(VSemaphore sem) It is implemented as a macro, calling voSemWaitTimeout() with timeout equal to VTIME_INFINITE . int32_t vosSemGetValue(VSemaphore sem) Return the current value of sem . This function must be called inside a system lock. int32_t vosSemTryWait(VSemaphore sem) Try to wait on semaphore sem . Return VRES_OK if the semaphore has been taken, VRES_TIMEOUT or VRES_RESET if the semaphore can\u2019t be taken without blocking. int32_t vosSemSignalWait(VSemaphore semS,VSemaphore semW) Atomically signal semaphore semS and wait with timeout on semW. Return VRES_OK if the semW is taken or VRES_RESET if vosSemReset() is called on semW . Mailboxes \u00b6 vMailBox vosMBoxCreate(int32_t n) Creates an empty VMailBox with a size of n elements. vMailBox vosMBoxDestroy(VMailBox mb) Reset mb and free memory used by mb . int vosMBoxPostTimeout(VMailBox mb,void** msg, uint32_t timeout) Try to insert message msg in mb . If mb is full, the thread is suspended on mb for a time less than or equal to timeout (passed with TIME_U ). If mb has at least one free slot, msg is inserted in mb and the thread is not suspended. Return one of the VRES macros. int vosMBoxFetchTimeout(VMailBox mb,void* msgp,uint32_t timeout) Try to retrieve a message from mb returning a pointer to it in msgp . If mb is empty, the thread is suspended on mb for a time les than or equal to timeout (passed with TIME_U ). If mb has at least one message, msgp is assigned such message and the thread is not suspended. Return one of the VRES macros. int vosMBoxPost(VMailBox mb,void* msg) Same as vosMBoxPostTimeout() but with infinite timeout. int vosMBoxFetch(VMailBox mb,void** msgp) Same as vosMBoxFetchTimeout() but with infinite timeout. int vosMBoxPostIsr(VMailBox mb,void* msg) Same as vosMBoxPostTimeout() but with infinite timeout and can be used only in an ISR.. int vosMBoxFetchIsr(VMailBox mb,void** msgp) Same as vosMBoxFetchTimeout() but with infinite timeout and can be used only in an ISR. int vosMBoxUsedSlots(VMailBox mb) Returns the number of messages in mb . Must be called in a system lock. int vosMBoxFreeSlots(VMailBox mb) Returns the number of free slots in mb . Must be called in a system lock. System Timers \u00b6 VSisTimer vosTimerCreate(void) Creates an inactive system timer. unit64_t vosTimerReadMillis(VSysTimer tm) Returns the amount of milliseconds elapsed since tm creation or last reset. unit32_t vosTimerReadMicros(VSysTimer tm) Returns the amount of microseconds elapsed since tm creation or last reset. unit32_t vosTimerOneShot(VSysTimer tm,uint32_t time,vsystimer_fn fn,void *arg) Configure the timer tm such that after time the function fn is execute exactly once as fn*(*arg) inside an ISR. Must be called inside a system lock. unit32_t vosTimerRecurrent(VSysTimer tm,uint32_t time,vsystimer_fn fn, void *arg) Configure the timer tm such that the function fn is execute periodically with period equal to time , as fn*(*arg) inside an ISR. Must be called inside a system lock. void vosTimerReset(VSysTimer tm) Reset the timer. Every configured callback function is removed and any subsequent call to vosTimerReadMillis() or vosTimerReadMicros() will be relative to the time of reset. Must be called inside a system lock. void vosTimerDestroy(VSysTimer tm) Reset the timer and free its memory. Events \u00b6 vEvent vosEventCreate(void) Creates a VEvent. A VEvent manages a flag that can be set or cleared and on whose value a thread can be blocked. The flag is initially false. void vosEventSet(VEvent event) Set the event flag. void vosEventClear(VEvent event) Clear the event flag. int32_t vosEventWait(VEvent event,uint32_t timeout) Wait for the event flag to be set. Return VRES_OK if the flag has been set, VRES_TIMEOUT if it has not been set in given timeout time. int32_t vosEventGetFlag(VEvent event) Get current flag value for selected event. void vosEventDestroy(VEvent event) Destroy the event and frees its memory.","title":"Operating System Abstraction Layer"},{"location":"reference/guide/docs/vosal/#operating-system-abstraction-layer","text":"The Zerynth VM uses a common API to create and manage threads and synchronization objects. Such API is called VOSAL and abstracts the details of the underlying RTOS, so that it can be changed as needed for performance or licensing reasons.","title":"Operating System Abstraction Layer"},{"location":"reference/guide/docs/vosal/#types","text":"VThread VThread is defined as a pointer to a region of memory containing a thread representation. In order to be as abstract as possible the actual type of VThread is void*. Values of type VThread must be managed only by calling vosal functions starting with vosTh . VSemaphore VSemaphore is defined as a pointer to a region of memory containing a semaphore representation. In order to be as abstract as possible the actual type of VSemaphore is void*. Values of type VSemaphore must be managed only by calling vosal functions starting with vosSem . VSysTimer VSysTimer is defined as a pointer to a region of memory containing a rtos timer representation. In order to be as abstract as possible the actual type of VSysTimer is void*. Values of type VSysTimer must be managed only by calling vosal functions starting with vosTimer . VMailBox VMailBox is defined as a pointer to a region of memory containing a rtos mailbox representation. In order to be as abstract as possible the actual type of VMailBox is void*. Values of type VMailBox must be managed only by calling vosal function starting with vosMBox . Mailboxes are an optional feature and can be disabled when compiling a VM. VFifo VFifo is defined as a pointer to a region of memory containing a rtos fifo. In order to be as abstract as possible the actual type of VFifo is void*. Values of type VFifo must be managed only by calling vosal function starting with vosFifo . Fifos are an optional feature and can be disabled when compiling a VM. typedef void(*vsystimer_fn)(void *) Type of a timer callback function.","title":"Types"},{"location":"reference/guide/docs/vosal/#variables","text":"volatile uint32_t_systime_seconds Holds the number of seconds passed since VM startup. It is not guaranteed to be implemented in every architecture or RTOS. volatile uint64_t_systime_millis Holds the number of milliseconds passed since VM startup. It is not guaranteed to be implemented in every architecture or RTOS. volatile uint32_t_systime_frequency Holds the current frequency of the microcontroller in Hz.","title":"Variables"},{"location":"reference/guide/docs/vosal/#macros","text":"","title":"Macros"},{"location":"reference/guide/docs/vosal/#time-macros","text":"NANOS Represent the time unit nanoseconds. MICROS Represent the time unit microseconds. MILLIS Represent the time unit milliseconds. SECONDS Represent the time unit seconds. TIME_U(value,unit) Time values in VOSAL are represented as value plus time unit. This macro creates a valid time representation mixing together value (max 30 significant bits) with unit . Every vosal function expecting a time must be passed the result of TIME_U. GET_TIME_UNIT(time) Extracts the time unit from time to time . GET_TIME_VALUE(time) Extracts the time value from time to time . GET_TIME_MICROS(time) Extracts the time value from time converting it to microseconds. TIME_IS_ZERO(time) Evaluates to true if time is zero in the corresponding time unit. VTIME_IMMEDIATE A unitless time value representing no time at all. VTIME_INFINITE Infinite amount of time, used when an infinite timeout is requested.","title":"Time Macros"},{"location":"reference/guide/docs/vosal/#priority-macros","text":"VOS_PRIO_IDLE This priority should not be used with normal threads. Only one thread exists with this priority and it is created at startup. VOS_PRIO_LOWEST Lowest possible thread priority. VOS_PRIO_LOWER This priority is greater than all preceding thread priorities. VOS_PRIO_LOW This priority is greater than all preceding thread priorities. VOS_PRIO_NORMAL This priority is greater than all preceding thread priorities. It is the default priority. VOS_PRIO_HIGH This priority is greater than all preceding thread priorities. VOS_PRIO_HIGHER This priority is greater than all preceding thread priorities. VOS_PRIO_HIGHEST This priority is greater than all preceding thread priorities.","title":"Priority Macros"},{"location":"reference/guide/docs/vosal/#thread-status","text":"VTHREAD_READY Status of a thread that has been created but not yet run. VTHREAD_RUNNING Status of a thread that is currently running. VTHREAD_INACTIVE Status of a thread that has finished its life cycle. VTHREAD_WAITING Status of a thread that is sleeping waiting for some event to occur.","title":"Thread Status"},{"location":"reference/guide/docs/vosal/#return-values","text":"VRES_OK If returned, the function execution encountered no problems. VRES_TIMEOUT If returned, the function exited with a timeout condition. VRES_RESET If returned, the function exited with a reset condition.","title":"Return values"},{"location":"reference/guide/docs/vosal/#system-and-thread-functions","text":"vosSysLock(void) Locks the system, usually by disabling interrupts. Thread scheduling is suspended and the following code is executed atomically. It can not be used inside ISRs. vosSysUnlock(void) Unlocks the system, usually by enabling interrupts. It is used together with vosSysLock() to protect small critical sections. It can not be used inside ISRs. vosSysLockIsr(void) Same as vosSysLock() , but must be called only inside an ISR. vosSysUnlockIsr(void) Same as vosSysUnlock() , but must be called only inside an ISR. vosEnterIsr(void) Must be called when entering an ISR. Depending on the underlyng RTOS and architecture it can be an empty macro. vosExitIsr(void) Must be called when exiting an ISR. Depending on the underlyng RTOS and architecture it can be an empty macro. vos_irq_handler vosInstallHandler(int32_t hpos,vos_irq handler fn) Install a new ISR fn at index hpos in the interrupt table. Previous ISR is returned. The type vos_irq_handler is: typedef void (*vos_irq_handler)(void) . void vosSysReset(void) Soft reset the microcontroller. vos_irq_handler vosInstallHandler(uint32_t size,int32_t prio,void *fn,void *arg,void *data) Create a VThread with a free workspace memory of size bytes. Actual memory usage is greater than size of an amount dependent on the underlying RTOS data structures. prio is the starting priority of the thread. The function run inside the thread is fn to which a single argument arg is passed. Some data can be associated to the created thread. After creation, the thread is not started. A call to vosThResume() is necessary to start the execution of fn . void vosThDestroy(VThread th) Frees the memory associated to th . Thread th must be terminated in order to call vosThDestroy, otherwise memory corruption ensues. void vosThSetData(VThread th,void *data) Attaches data to th . void* vosThGetData(VThread th) Retrieves data attached to th . void* vosThGetId(VThread th) Every created thread has a unique 32 bits id. Returns such id. unit32_ vosThGetStatus(VThread th) Returns the status of th . Possible return values are all the thread status macros. void vosThSetPriority(int32_t prio) Changes the priority of the current thread. Values for prio are all the priority macros. int32_T vosThGetPriority(void) Returns the priority of the current thread. vThread vosThCurrent(void) Returns the current thread. void vosThSleep(time) Suspend the current thread for an amount of time represented by time . time must be passed using TIME_U . The precision of vosThSleep depends on the priority of other threads with respect t the current one and to the scheduling strategy of the underlying RTOS. void vosThYield() The current thread is suspended and the control is given to the next thread in the scheduling order. void vosThSuspend() The current thread is suspended until the next call to vosThResume() . This function must be preceded by a call to vosSysLock() . The implementation of vosThSuspend will remove the lock if necessary. vThread vosThResume(VThread th) Resume the thread th . th must be a thread just created (and never resumed before) or suspended by vosThSuspend() . vThread vosThResumeIsr(VThread th) Resume the thread th . th must be a thread just created (and never resumed before) or suspended by vosThSuspend() . It must be used only inside an ISR.","title":"System and Thread functions"},{"location":"reference/guide/docs/vosal/#semaphores","text":"vSemaphore vosSemCreate(uint32_t n) Creates a VSemaphore with initial value n . void vosSemReset(VSemaphore sem) Reset the semaphore sem . Every thread waiting on sem is woken up and the semaphore reset signaled with :macr: VRES_RESET . void vosSemDestroy(VSemaphore sem) Reset sem and free memory used by sem. void sSemSignal(VSemaphore sem) Signal the semaphore sem . If any thread is waiting on the semaphore, one thread is woken up. If no threads are waiting, the semaphore value is increased by one. void vosSemSignalCap(VSemaphore sem,uint32_t cap) Signal the semaphore sem . If any thread is waiting on the semaphore, one thread is woken up. If no threads are waiting, the semaphore value is increased by one only if it is less than cap . void vosSemSignalIsr(VSemaphore sem) Same as vosSemSignal() but must be used only inside ISRs. int32_t vosSemWaitTimeout(VSemaphore sem,uint32_t timeout) Wait on semaphore sem . If the value of sem is zero or less, the thread is suspended for a time equal to timeout (passed with TIME_U ). If the value of sem is one or greater, it is decreased by one and the thread is not suspended. Return VRES_OK if the timeout is not triggered, VRES_TIMEOUT if it is triggered or VRES_RESET if vosSemReset() is called on sem . int32_t vosSemWait(VSemaphore sem) It is implemented as a macro, calling voSemWaitTimeout() with timeout equal to VTIME_INFINITE . int32_t vosSemGetValue(VSemaphore sem) Return the current value of sem . This function must be called inside a system lock. int32_t vosSemTryWait(VSemaphore sem) Try to wait on semaphore sem . Return VRES_OK if the semaphore has been taken, VRES_TIMEOUT or VRES_RESET if the semaphore can\u2019t be taken without blocking. int32_t vosSemSignalWait(VSemaphore semS,VSemaphore semW) Atomically signal semaphore semS and wait with timeout on semW. Return VRES_OK if the semW is taken or VRES_RESET if vosSemReset() is called on semW .","title":"Semaphores"},{"location":"reference/guide/docs/vosal/#mailboxes","text":"vMailBox vosMBoxCreate(int32_t n) Creates an empty VMailBox with a size of n elements. vMailBox vosMBoxDestroy(VMailBox mb) Reset mb and free memory used by mb . int vosMBoxPostTimeout(VMailBox mb,void** msg, uint32_t timeout) Try to insert message msg in mb . If mb is full, the thread is suspended on mb for a time less than or equal to timeout (passed with TIME_U ). If mb has at least one free slot, msg is inserted in mb and the thread is not suspended. Return one of the VRES macros. int vosMBoxFetchTimeout(VMailBox mb,void* msgp,uint32_t timeout) Try to retrieve a message from mb returning a pointer to it in msgp . If mb is empty, the thread is suspended on mb for a time les than or equal to timeout (passed with TIME_U ). If mb has at least one message, msgp is assigned such message and the thread is not suspended. Return one of the VRES macros. int vosMBoxPost(VMailBox mb,void* msg) Same as vosMBoxPostTimeout() but with infinite timeout. int vosMBoxFetch(VMailBox mb,void** msgp) Same as vosMBoxFetchTimeout() but with infinite timeout. int vosMBoxPostIsr(VMailBox mb,void* msg) Same as vosMBoxPostTimeout() but with infinite timeout and can be used only in an ISR.. int vosMBoxFetchIsr(VMailBox mb,void** msgp) Same as vosMBoxFetchTimeout() but with infinite timeout and can be used only in an ISR. int vosMBoxUsedSlots(VMailBox mb) Returns the number of messages in mb . Must be called in a system lock. int vosMBoxFreeSlots(VMailBox mb) Returns the number of free slots in mb . Must be called in a system lock.","title":"Mailboxes"},{"location":"reference/guide/docs/vosal/#system-timers","text":"VSisTimer vosTimerCreate(void) Creates an inactive system timer. unit64_t vosTimerReadMillis(VSysTimer tm) Returns the amount of milliseconds elapsed since tm creation or last reset. unit32_t vosTimerReadMicros(VSysTimer tm) Returns the amount of microseconds elapsed since tm creation or last reset. unit32_t vosTimerOneShot(VSysTimer tm,uint32_t time,vsystimer_fn fn,void *arg) Configure the timer tm such that after time the function fn is execute exactly once as fn*(*arg) inside an ISR. Must be called inside a system lock. unit32_t vosTimerRecurrent(VSysTimer tm,uint32_t time,vsystimer_fn fn, void *arg) Configure the timer tm such that the function fn is execute periodically with period equal to time , as fn*(*arg) inside an ISR. Must be called inside a system lock. void vosTimerReset(VSysTimer tm) Reset the timer. Every configured callback function is removed and any subsequent call to vosTimerReadMillis() or vosTimerReadMicros() will be relative to the time of reset. Must be called inside a system lock. void vosTimerDestroy(VSysTimer tm) Reset the timer and free its memory.","title":"System Timers"},{"location":"reference/guide/docs/vosal/#events","text":"vEvent vosEventCreate(void) Creates a VEvent. A VEvent manages a flag that can be set or cleared and on whose value a thread can be blocked. The flag is initially false. void vosEventSet(VEvent event) Set the event flag. void vosEventClear(VEvent event) Clear the event flag. int32_t vosEventWait(VEvent event,uint32_t timeout) Wait for the event flag to be set. Return VRES_OK if the flag has been set, VRES_TIMEOUT if it has not been set in given timeout time. int32_t vosEventGetFlag(VEvent event) Get current flag value for selected event. void vosEventDestroy(VEvent event) Destroy the event and frees its memory.","title":"Events"},{"location":"reference/guide/docs/zos/","text":"Virtual Machine \u00b6 The core of Zerynth is the Zerynth Virtual Machine. Zerynth VM has been developed from scratch with the goal of bringing Python to the embedded world with support for multi-thread and cross board compatibility. More info on Zerynth VM section. Contents: The Zerynth Virtual Machine Zerynth and Python Operative System Abstraction Layer Types Variables Macros Time Macros Priority Macros Thread Status Macros Return values System and Thread functions Semaphores Mailboxes System Timers Events Hardware Abstraction Layer Pin Mapping Peripherals Mapping GPIO ADC Macros Types DAC PWM ICU Macros Functions HTM SERIAL Macros Functions I2C SPI Macros Functions Macros NFO NFO FLASH RNG RTC Interrupts Error Codes VM Interface PObject Macros Functions Numbers Functions Bool & None Sequences Macros Functions Dictionaries and Sets Macros Function Exceptions","title":"Virtual Machine"},{"location":"reference/guide/docs/zos/#virtual-machine","text":"The core of Zerynth is the Zerynth Virtual Machine. Zerynth VM has been developed from scratch with the goal of bringing Python to the embedded world with support for multi-thread and cross board compatibility. More info on Zerynth VM section. Contents: The Zerynth Virtual Machine Zerynth and Python Operative System Abstraction Layer Types Variables Macros Time Macros Priority Macros Thread Status Macros Return values System and Thread functions Semaphores Mailboxes System Timers Events Hardware Abstraction Layer Pin Mapping Peripherals Mapping GPIO ADC Macros Types DAC PWM ICU Macros Functions HTM SERIAL Macros Functions I2C SPI Macros Functions Macros NFO NFO FLASH RNG RTC Interrupts Error Codes VM Interface PObject Macros Functions Numbers Functions Bool & None Sequences Macros Functions Dictionaries and Sets Macros Function Exceptions","title":"Virtual Machine"},{"location":"reference/libs/adafruit/bluefruit/docs/","text":"Bluefruit \u00b6 Adafruit Bluefruit LE SPI products family enables Bluetooth Low Energy connectivity to anything that supports SPI communication. Thanks to the connection between the Bluefruit LE chip and the device using the common four-pin SPI interface (MISO, MOSI, SCK and CS/SSEL), it is possible to enable the solution with wireless communication features; more information at Adafruit dedicated page . Technical Details \u00b6 ARM Cortex M0 core running at 16MHz 256KB flash memory 32KB SRAM Transport: SPI at 4MHz with HW IRQ 5V-safe inputs On-board 3.3V voltage regulation Bootloader with support for safe OTA firmware updates Easy AT command set to get up and running quickly Here below, the Zerynth driver for the Adafruit Bluefruit LE SPI products family and some examples to better understand how to use it. Contents: * Bluefruit Module * BLEStream class * Examples * Serial Over BLE * BLE Heart Rate","title":"Bluefruit"},{"location":"reference/libs/adafruit/bluefruit/docs/#bluefruit","text":"Adafruit Bluefruit LE SPI products family enables Bluetooth Low Energy connectivity to anything that supports SPI communication. Thanks to the connection between the Bluefruit LE chip and the device using the common four-pin SPI interface (MISO, MOSI, SCK and CS/SSEL), it is possible to enable the solution with wireless communication features; more information at Adafruit dedicated page .","title":"Bluefruit"},{"location":"reference/libs/adafruit/bluefruit/docs/#technical-details","text":"ARM Cortex M0 core running at 16MHz 256KB flash memory 32KB SRAM Transport: SPI at 4MHz with HW IRQ 5V-safe inputs On-board 3.3V voltage regulation Bootloader with support for safe OTA firmware updates Easy AT command set to get up and running quickly Here below, the Zerynth driver for the Adafruit Bluefruit LE SPI products family and some examples to better understand how to use it. Contents: * Bluefruit Module * BLEStream class * Examples * Serial Over BLE * BLE Heart Rate","title":"Technical Details"},{"location":"reference/libs/adafruit/bluefruit/docs/bluefruit/","text":"Bluefruit Module \u00b6 This module implements the driver for the Adafruit Bluefruit LE SPI products family, based on Bluefruit firmware v0.6.7 or higher link . Data between the mcu and the Bluefruit hardware is exchanged by SPI or serial communication. However, this module has support for SPI only. init \u00b6 init ( spidrv , nss , irqpin ) Manually initializes the Bluefruit peripheral by activating the following communication setup: spidrv is the SPI peripheral to use (usually SPI0 for devices with an Arduino compatible layout) nss is the chip select pin (usually D8) irqpin is the pin used by the Bluefruit hardware to signal incoming messages (usually D7) The SPI driver is started and the Bluefruit initialization sequence is sent. hard_reset \u00b6 hard_reset () Performs a software reset. Returns True on success. reset \u00b6 reset () Performs a software reset. Returns True on success. gap_name \u00b6 gap_name ( name = None ) If name is None, returns the current Bluefruit device name. Otherwise changes the current name to name . Returns True on success. gap_adv \u00b6 gap_adv ( data ) Setup advertising data. Please refer to this resource for a list of possible values accepted by the BLE standard. data is an iterable containing blocks of data in the following format: byte 1: length of the block (n) byte 2: type of the block byte 3 to n: value of the block Usually data is made of a flag block, followed by blocks advertising BLE services. For example the sequence [0x02, 0x01, 0x06, 0x05, 0x02, 0x0d, 0x18, 0x0a, 0x18] is an encoding of the following info: 0x02: length of block 1 0x01: type of the block (\u201cFlag\u201d) 0x06: value of the block 0x05: length of block 2 0x02: type of block (\u201cList of 16-bit Service UUID\u201d) 0x180d, 0x180a: two 16 bit uuids. The first one is for a \u201cHeart rate\u201d service, the second for \u201cDevice Info\u201d service. Refer to this for a list of block types. Returns True on success. gap_is_connected \u00b6 gap_is_connected () Returns 1 if Bluefruit hardware is connected to a client, 0 if not connected. Returns None on failure. gatt \u00b6 gatt ( cfg = None ) If cfg is None returns the current GATT configuration. Otherwise BLuefruit configuration is cleared first and then changed to cfg . The format of cfg is a list of lists: cfg = [ [ 0 , 0x180D ], # Service with UUID 0x180D = Heart Rate [ 1 , 0x2a37 ,( 0x00 , 0x40 ), 0x10 ], # Characteristic of last defined service [ 2 , 0x2a38 , 3 , 0x02 ] # another characteristic ] In the main list, a service is identified by a two elements list where the first element is an id (can be set to zero) and the second element is the UUID of the service. If the UUID of the service is more than 32 bit, it can be passed as a tuple of bytes or as a bytearray. Every list of 4 elements identifies a characteristic of the previously defined service. Characteristics are made of: a handle at position 0: can be set to zero a characteristic UUID: can be 16, 32 or 128 bits a default value for the characteristic: can be a string, an integer or an iterable of bytes. a permission flag: refer to this for reference Returns the configuration activated on the device or None on failure. After a configuration is successfully set, the return value contains handles modified to the actual ones choosen by the device. gatt_set \u00b6 gatt_set ( handle , value ) Sets the value of a characteristic given its handle (as returned after a successful configuration). Value can be an integer, a string or an iterable of bytes. Returns False on failure. gatt_get \u00b6 gatt_get ( handle ) Returns the value of the characteristic identified by handle (as returned after a successful configuration). Returns None on failure. addr \u00b6 addr () Returns the 48bit mac address of the device as an hex string. Returns None on failure. peer_addr \u00b6 peer_addr () Returns the 48bit mac address of the client connected device as an hex string. Returns None on failure. addr \u00b6 addr () Returns the RSSI level id dBm. Returns None on failure. tx_power \u00b6 tx_power ( dbm = None ) If dbm is None, returns the current transmission power level. Otherwise sets the power level to dbm (in the range -40 to 4). Returns None on failure. class BLEStream \u00b6 class BLEStream ( fifosize = 1024 ) This class implements a serial stream on the Bluefruit peripheral. The internal implementation uses a fifo buffer of fifosize bytes. The BLEStream is not automatically set as the global serial stream. Read and write methods are the same of any stream with the difference that they raise IOError if the BLEStream is not connected (namely, the Bluefruit peripheral is not paired with a BLE client). Also, due to the features of the Bluefruit firmware, read methods use a polling mechanism to check for incoming data.","title":"Bluefruit Module"},{"location":"reference/libs/adafruit/bluefruit/docs/bluefruit/#bluefruit-module","text":"This module implements the driver for the Adafruit Bluefruit LE SPI products family, based on Bluefruit firmware v0.6.7 or higher link . Data between the mcu and the Bluefruit hardware is exchanged by SPI or serial communication. However, this module has support for SPI only.","title":"Bluefruit Module"},{"location":"reference/libs/adafruit/bluefruit/docs/bluefruit/#init","text":"init ( spidrv , nss , irqpin ) Manually initializes the Bluefruit peripheral by activating the following communication setup: spidrv is the SPI peripheral to use (usually SPI0 for devices with an Arduino compatible layout) nss is the chip select pin (usually D8) irqpin is the pin used by the Bluefruit hardware to signal incoming messages (usually D7) The SPI driver is started and the Bluefruit initialization sequence is sent.","title":"init"},{"location":"reference/libs/adafruit/bluefruit/docs/bluefruit/#hard_reset","text":"hard_reset () Performs a software reset. Returns True on success.","title":"hard_reset"},{"location":"reference/libs/adafruit/bluefruit/docs/bluefruit/#reset","text":"reset () Performs a software reset. Returns True on success.","title":"reset"},{"location":"reference/libs/adafruit/bluefruit/docs/bluefruit/#gap_name","text":"gap_name ( name = None ) If name is None, returns the current Bluefruit device name. Otherwise changes the current name to name . Returns True on success.","title":"gap_name"},{"location":"reference/libs/adafruit/bluefruit/docs/bluefruit/#gap_adv","text":"gap_adv ( data ) Setup advertising data. Please refer to this resource for a list of possible values accepted by the BLE standard. data is an iterable containing blocks of data in the following format: byte 1: length of the block (n) byte 2: type of the block byte 3 to n: value of the block Usually data is made of a flag block, followed by blocks advertising BLE services. For example the sequence [0x02, 0x01, 0x06, 0x05, 0x02, 0x0d, 0x18, 0x0a, 0x18] is an encoding of the following info: 0x02: length of block 1 0x01: type of the block (\u201cFlag\u201d) 0x06: value of the block 0x05: length of block 2 0x02: type of block (\u201cList of 16-bit Service UUID\u201d) 0x180d, 0x180a: two 16 bit uuids. The first one is for a \u201cHeart rate\u201d service, the second for \u201cDevice Info\u201d service. Refer to this for a list of block types. Returns True on success.","title":"gap_adv"},{"location":"reference/libs/adafruit/bluefruit/docs/bluefruit/#gap_is_connected","text":"gap_is_connected () Returns 1 if Bluefruit hardware is connected to a client, 0 if not connected. Returns None on failure.","title":"gap_is_connected"},{"location":"reference/libs/adafruit/bluefruit/docs/bluefruit/#gatt","text":"gatt ( cfg = None ) If cfg is None returns the current GATT configuration. Otherwise BLuefruit configuration is cleared first and then changed to cfg . The format of cfg is a list of lists: cfg = [ [ 0 , 0x180D ], # Service with UUID 0x180D = Heart Rate [ 1 , 0x2a37 ,( 0x00 , 0x40 ), 0x10 ], # Characteristic of last defined service [ 2 , 0x2a38 , 3 , 0x02 ] # another characteristic ] In the main list, a service is identified by a two elements list where the first element is an id (can be set to zero) and the second element is the UUID of the service. If the UUID of the service is more than 32 bit, it can be passed as a tuple of bytes or as a bytearray. Every list of 4 elements identifies a characteristic of the previously defined service. Characteristics are made of: a handle at position 0: can be set to zero a characteristic UUID: can be 16, 32 or 128 bits a default value for the characteristic: can be a string, an integer or an iterable of bytes. a permission flag: refer to this for reference Returns the configuration activated on the device or None on failure. After a configuration is successfully set, the return value contains handles modified to the actual ones choosen by the device.","title":"gatt"},{"location":"reference/libs/adafruit/bluefruit/docs/bluefruit/#gatt_set","text":"gatt_set ( handle , value ) Sets the value of a characteristic given its handle (as returned after a successful configuration). Value can be an integer, a string or an iterable of bytes. Returns False on failure.","title":"gatt_set"},{"location":"reference/libs/adafruit/bluefruit/docs/bluefruit/#gatt_get","text":"gatt_get ( handle ) Returns the value of the characteristic identified by handle (as returned after a successful configuration). Returns None on failure.","title":"gatt_get"},{"location":"reference/libs/adafruit/bluefruit/docs/bluefruit/#addr","text":"addr () Returns the 48bit mac address of the device as an hex string. Returns None on failure.","title":"addr"},{"location":"reference/libs/adafruit/bluefruit/docs/bluefruit/#peer_addr","text":"peer_addr () Returns the 48bit mac address of the client connected device as an hex string. Returns None on failure.","title":"peer_addr"},{"location":"reference/libs/adafruit/bluefruit/docs/bluefruit/#addr_1","text":"addr () Returns the RSSI level id dBm. Returns None on failure.","title":"addr"},{"location":"reference/libs/adafruit/bluefruit/docs/bluefruit/#tx_power","text":"tx_power ( dbm = None ) If dbm is None, returns the current transmission power level. Otherwise sets the power level to dbm (in the range -40 to 4). Returns None on failure.","title":"tx_power"},{"location":"reference/libs/adafruit/bluefruit/docs/bluefruit/#class-blestream","text":"class BLEStream ( fifosize = 1024 ) This class implements a serial stream on the Bluefruit peripheral. The internal implementation uses a fifo buffer of fifosize bytes. The BLEStream is not automatically set as the global serial stream. Read and write methods are the same of any stream with the difference that they raise IOError if the BLEStream is not connected (namely, the Bluefruit peripheral is not paired with a BLE client). Also, due to the features of the Bluefruit firmware, read methods use a polling mechanism to check for incoming data.","title":"class BLEStream"},{"location":"reference/libs/adafruit/bluefruit/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.adafruit.bluefruit. Serial over BLE \u00b6 A simple example to establish a serial connection over BLE from your board to a smartphone. main.py ################################################################################ # bluefruit serial # # Created: 2016-01-07 14:11:04.262350 # ################################################################################ import streams # import the bluefruit driver from adafruit.bluefruit import bluefruit as ble streams . serial () try : print ( \"initializing...\" ) ble . init ( SPI0 , D8 , D7 ) # initialize BLE # pass the spi driver, the chip select pin and the irqpin # if you are using a Bluefruit shield, the following parameters should be correct. # If you are using a Bluefruit breakout, set them to your wiring # do a factory reset, to start fresh ble . hard_reset () # create a BLE stream instance blestream = ble . BLEStream () while True : # check if some client connected to using # otherwise the stream is not usable! if ble . gap_is_connected (): # print some connection info print ( \"Connection\" , ble . addr (), \" <-> \" , ble . peer_addr (), \"with RSSI\" , str ( ble . rssi ())) # send by BLE print ( \"Hello BLE! Tell me something...\" , stream = blestream ) # receive from BLE print ( \"answer:\" , blestream . readline ()) else : print ( \"waiting for connection\" ) sleep ( 1000 ) # you can test the serial over ble with the following app: # Android: https://play.google.com/store/apps/details?id=no.nordicsemi.android.nrftoolbox&hl=en # iOS: https://itunes.apple.com/us/app/nrf-toolbox/id820906058?mt=8 except Exception as e : print ( e ) BLE Heart Rate Monitor \u00b6 A simple example to set up the Bluefruit with custom services. The example is configured to work with a Bluefruit shield; change the chip select and irqpin if you are using a breakout. main.py ################################################################################ # bluefruit HRM # # Created: 2016-01-07 14:11:04.262350 # ################################################################################ import streams # import the bluefruit driver from adafruit.bluefruit import bluefruit as ble streams . serial () try : print ( \"initializing...\" ) # initialize BLE # pass the spi driver, the chip select pin and the irqpin # if you are using a Bluefruit shield, the following parameters should be correct. # If you are using a Bluefruit breakout, set them to your wiring ble . init ( SPI0 , D8 , D7 ) # do a factory reset, to start fresh ble . hard_reset () # set the advertised name ble . gap_name ( \"Zerynth HRM\" ) # prepare a configuration # by specifying the service(s) # and the corresponding characteristics srv = [ [ 0 , 0x180D ], [ 0 , 0x2a37 ,( 0x00 , 0x40 ), 0x10 ], [ 0 , 0x2a38 , 3 , 0x02 ] ] # set cfg as active ble . gatt ( srv ) # set advertising parameters ble . gap_adv ([ 0x02 , 0x01 , 0x06 , 0x05 , 0x02 , 0x0d , 0x18 , 0x0a , 0x18 ]) while True : sleep ( 1000 ) # set a random heart rate # by using returned handle ble . gatt_set ( srv [ 1 ][ 0 ], random ( 40 , 150 )) # you can inspect the HRM value with the following app: # Android: https://play.google.com/store/apps/details?id=no.nordicsemi.android.nrftoolbox&hl=en # iOS: https://itunes.apple.com/us/app/nrf-toolbox/id820906058?mt=8 except Exception as e : print ( e )","title":"Examples"},{"location":"reference/libs/adafruit/bluefruit/docs/examples/#examples","text":"The following are a list of examples for lib.adafruit.bluefruit.","title":"Examples"},{"location":"reference/libs/adafruit/bluefruit/docs/examples/#serial-over-ble","text":"A simple example to establish a serial connection over BLE from your board to a smartphone. main.py ################################################################################ # bluefruit serial # # Created: 2016-01-07 14:11:04.262350 # ################################################################################ import streams # import the bluefruit driver from adafruit.bluefruit import bluefruit as ble streams . serial () try : print ( \"initializing...\" ) ble . init ( SPI0 , D8 , D7 ) # initialize BLE # pass the spi driver, the chip select pin and the irqpin # if you are using a Bluefruit shield, the following parameters should be correct. # If you are using a Bluefruit breakout, set them to your wiring # do a factory reset, to start fresh ble . hard_reset () # create a BLE stream instance blestream = ble . BLEStream () while True : # check if some client connected to using # otherwise the stream is not usable! if ble . gap_is_connected (): # print some connection info print ( \"Connection\" , ble . addr (), \" <-> \" , ble . peer_addr (), \"with RSSI\" , str ( ble . rssi ())) # send by BLE print ( \"Hello BLE! Tell me something...\" , stream = blestream ) # receive from BLE print ( \"answer:\" , blestream . readline ()) else : print ( \"waiting for connection\" ) sleep ( 1000 ) # you can test the serial over ble with the following app: # Android: https://play.google.com/store/apps/details?id=no.nordicsemi.android.nrftoolbox&hl=en # iOS: https://itunes.apple.com/us/app/nrf-toolbox/id820906058?mt=8 except Exception as e : print ( e )","title":"Serial over BLE"},{"location":"reference/libs/adafruit/bluefruit/docs/examples/#ble-heart-rate-monitor","text":"A simple example to set up the Bluefruit with custom services. The example is configured to work with a Bluefruit shield; change the chip select and irqpin if you are using a breakout. main.py ################################################################################ # bluefruit HRM # # Created: 2016-01-07 14:11:04.262350 # ################################################################################ import streams # import the bluefruit driver from adafruit.bluefruit import bluefruit as ble streams . serial () try : print ( \"initializing...\" ) # initialize BLE # pass the spi driver, the chip select pin and the irqpin # if you are using a Bluefruit shield, the following parameters should be correct. # If you are using a Bluefruit breakout, set them to your wiring ble . init ( SPI0 , D8 , D7 ) # do a factory reset, to start fresh ble . hard_reset () # set the advertised name ble . gap_name ( \"Zerynth HRM\" ) # prepare a configuration # by specifying the service(s) # and the corresponding characteristics srv = [ [ 0 , 0x180D ], [ 0 , 0x2a37 ,( 0x00 , 0x40 ), 0x10 ], [ 0 , 0x2a38 , 3 , 0x02 ] ] # set cfg as active ble . gatt ( srv ) # set advertising parameters ble . gap_adv ([ 0x02 , 0x01 , 0x06 , 0x05 , 0x02 , 0x0d , 0x18 , 0x0a , 0x18 ]) while True : sleep ( 1000 ) # set a random heart rate # by using returned handle ble . gatt_set ( srv [ 1 ][ 0 ], random ( 40 , 150 )) # you can inspect the HRM value with the following app: # Android: https://play.google.com/store/apps/details?id=no.nordicsemi.android.nrftoolbox&hl=en # iOS: https://itunes.apple.com/us/app/nrf-toolbox/id820906058?mt=8 except Exception as e : print ( e )","title":"BLE Heart Rate Monitor"},{"location":"reference/libs/amphenol/dlh/docs/","text":"DLH Module \u00b6 The DLH Series Mini Digital Output Sensor is based on All Sensors\u2019 CoBeam2 TM Technology. This reduces package stress susceptibility, resulting in improved overall long term stability and vastly improves the position sensitivity. The digital interface options ease integration of the sensors into a wide range of process control and measurement systems, allowing direct connection to serial communications channels. For battery-powered systems, the sensors can enter very low-power modes between readings to minimize load on the power supply.These calibrated and compensated sensors provide accurate, stable output over a wide temperature range. This series is intended for use with non-corrosive, non-ionic working fluids such as air, dry gases and the like. A protective parylene coating is optionally available for moisture/harsh media protection. Contents: DLH Module The driver implements SPI communication.","title":"DLH Module"},{"location":"reference/libs/amphenol/dlh/docs/#dlh-module","text":"The DLH Series Mini Digital Output Sensor is based on All Sensors\u2019 CoBeam2 TM Technology. This reduces package stress susceptibility, resulting in improved overall long term stability and vastly improves the position sensitivity. The digital interface options ease integration of the sensors into a wide range of process control and measurement systems, allowing direct connection to serial communications channels. For battery-powered systems, the sensors can enter very low-power modes between readings to minimize load on the power supply.These calibrated and compensated sensors provide accurate, stable output over a wide temperature range. This series is intended for use with non-corrosive, non-ionic working fluids such as air, dry gases and the like. A protective parylene coating is optionally available for moisture/harsh media protection. Contents: DLH Module The driver implements SPI communication.","title":"DLH Module"},{"location":"reference/libs/amphenol/dlh/docs/dlh/","text":"DLH Module \u00b6 This module contains the Zerynth driver for Amphenol DLH pressure sensors series. These calibrated and compensated sensors provide accurate, stable output over a wide temperature range. This series is intended for use with non-corrosive, non-ionic working fluids such as air, dry gases and the like. The driver implements SPI communication. \u00b6 class DLH \u00b6 class DLH ( spidrv , cs , d_or_g , clock = 2000000 ) Creates an instance of the DLH class. Arguments: spidrv \u2013 SPI Bus used \u2018( SPI0, \u2026 )\u2019 cs \u2013 GPIO to be used as Carrier Select d_or_g \u2013 specifies DLH type D (differential) or G (absolute) sensor. can be one of TYPE_D or TYPE_G constants clock \u2013 spi clock to be used Temperature and pressure values can be easily obtained from the sensor: from amphenol.dlh import dlh ... d = dlh . DLH ( SPI0 , D10 , dlh . TYPE_D ) press , temp = d . get_values ( unit = dlh . UNIT_PASCAL ) DLH.get_values \u00b6 get_values ( mode = MODE_SINGLE , unit = UNIT_INH20 ) Return a 2-element tuple containing current pressure and temperature values. The acquisition mode can be specified with one of: MODE_SINGLE MODE_AVG2 MODE_AVG4 MODE_AVG8 MODE_AVG16 The unit of measure of pressure can be specified in: UNIT_INH20 UNIT_CMH20 UNIT_PASCAL","title":"DLH Module"},{"location":"reference/libs/amphenol/dlh/docs/dlh/#dlh-module","text":"This module contains the Zerynth driver for Amphenol DLH pressure sensors series. These calibrated and compensated sensors provide accurate, stable output over a wide temperature range. This series is intended for use with non-corrosive, non-ionic working fluids such as air, dry gases and the like.","title":"DLH Module"},{"location":"reference/libs/amphenol/dlh/docs/dlh/#the-driver-implements-spi-communication","text":"","title":"The driver implements SPI communication."},{"location":"reference/libs/amphenol/dlh/docs/dlh/#class-dlh","text":"class DLH ( spidrv , cs , d_or_g , clock = 2000000 ) Creates an instance of the DLH class. Arguments: spidrv \u2013 SPI Bus used \u2018( SPI0, \u2026 )\u2019 cs \u2013 GPIO to be used as Carrier Select d_or_g \u2013 specifies DLH type D (differential) or G (absolute) sensor. can be one of TYPE_D or TYPE_G constants clock \u2013 spi clock to be used Temperature and pressure values can be easily obtained from the sensor: from amphenol.dlh import dlh ... d = dlh . DLH ( SPI0 , D10 , dlh . TYPE_D ) press , temp = d . get_values ( unit = dlh . UNIT_PASCAL )","title":"class DLH"},{"location":"reference/libs/amphenol/dlh/docs/dlh/#dlhget_values","text":"get_values ( mode = MODE_SINGLE , unit = UNIT_INH20 ) Return a 2-element tuple containing current pressure and temperature values. The acquisition mode can be specified with one of: MODE_SINGLE MODE_AVG2 MODE_AVG4 MODE_AVG8 MODE_AVG16 The unit of measure of pressure can be specified in: UNIT_INH20 UNIT_CMH20 UNIT_PASCAL","title":"DLH.get_values"},{"location":"reference/libs/ams/tsl2561/docs/","text":"AMS TSL2561 \u00b6 The TSL2561 is a light-to-digital converter that transforms light intensity to a digital signal output capable of direct I\u00b2C interface. This device combines one broadband photodiode (visible plus infrared) and one infrared-responding photodiode on a single CMOS integrated circuit capable of providing a near-photopic response over an effective 20-bit dynamic range (16-bit resolution). Two integrating ADCs convert the photodiode currents to a digital output that represents the irradiance measured on each channel. The TSL2561 is designed particularly for display panels (LCD, OLED, etc.) with the purpose of extending battery life and providing optimum viewing in several lighting conditions, but also for other applications. Some examples are street light control, security lighting, sunlight harvesting, machine vision, keyboard illumination control based upon ambient lighting conditions, and automotive instrumentation clusters. More information at AMS dedicated page . Technical Details \u00b6 Supply Voltage (Vdd): from 2.7 V to 3.6 V Operation Temperature (Top): from -30 \u00b0C to 70 \u00b0C Spectral Responsivity Channel0: Wavelength Range from ~300 nm to ~1100 nm Spectral Responsivity Channel1: Wavelength Range from ~600 nm to ~1000 nm Digital Output Current: from -1 mA to 20 mA Automatically Rejects 50/60-Hz Lighting Ripple Low Active Power (0.75 mW Typical) with Power Down Mode I\u00b2C interface Here below, the Zerynth driver for the AMS TSL2561. Contents: * TSL2561 Module * Examples * ambient light","title":"AMS TSL2561"},{"location":"reference/libs/ams/tsl2561/docs/#ams-tsl2561","text":"The TSL2561 is a light-to-digital converter that transforms light intensity to a digital signal output capable of direct I\u00b2C interface. This device combines one broadband photodiode (visible plus infrared) and one infrared-responding photodiode on a single CMOS integrated circuit capable of providing a near-photopic response over an effective 20-bit dynamic range (16-bit resolution). Two integrating ADCs convert the photodiode currents to a digital output that represents the irradiance measured on each channel. The TSL2561 is designed particularly for display panels (LCD, OLED, etc.) with the purpose of extending battery life and providing optimum viewing in several lighting conditions, but also for other applications. Some examples are street light control, security lighting, sunlight harvesting, machine vision, keyboard illumination control based upon ambient lighting conditions, and automotive instrumentation clusters. More information at AMS dedicated page .","title":"AMS TSL2561"},{"location":"reference/libs/ams/tsl2561/docs/#technical-details","text":"Supply Voltage (Vdd): from 2.7 V to 3.6 V Operation Temperature (Top): from -30 \u00b0C to 70 \u00b0C Spectral Responsivity Channel0: Wavelength Range from ~300 nm to ~1100 nm Spectral Responsivity Channel1: Wavelength Range from ~600 nm to ~1000 nm Digital Output Current: from -1 mA to 20 mA Automatically Rejects 50/60-Hz Lighting Ripple Low Active Power (0.75 mW Typical) with Power Down Mode I\u00b2C interface Here below, the Zerynth driver for the AMS TSL2561. Contents: * TSL2561 Module * Examples * ambient light","title":"Technical Details"},{"location":"reference/libs/ams/tsl2561/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.ams.tsl2561. Read Ambient Light from TSL2561 \u00b6 Basic example to read the illuminance from TSL2561 sensor. main.py ################################################################################ # Illuminance Example # # Created: 2017-03-16 17:03:14.563172 # ################################################################################ import streams from ams.tsl2561 import tsl2561 streams . serial () try : # Setup sensor # This setup is referred to tsl2561 mounted on on hexiwear device # Address pin of the sensor connected to gnd tsl = tsl2561 . TSL2561 ( I2C0 , addr = tsl2561 . TSL_I2C_ADDRESS [ \"LOW\" ]) print ( \"start...\" ) tsl . start () print ( \"init...\" ) tsl . init () print ( \"Ready!\" ) print ( \"--------------------------------------------------------\" ) except Exception as e : print ( \"Error: \" , e ) try : while True : raw_ir = tsl . get_raw_infrared () # Read raw infrared print ( \"Raw Infrared: \" , raw_ir ) raw_fs = tsl . get_raw_fullspectrum () # Read raw fullspectrum print ( \"Raw FullSpectrum: \" , raw_fs ) raw_vis = tsl . get_raw_visible () # Read raw visible print ( \"Raw Visible: \" , raw_vis ) lux = tsl . get_lux () # Read Lux print ( \"Illuminance: \" , lux , \"Lux\" ) print ( \"--------------------------------------------------------\" ) sleep ( 5000 ) except Exception as e : print ( \"Error2: \" , e )","title":"Examples"},{"location":"reference/libs/ams/tsl2561/docs/examples/#examples","text":"The following are a list of examples for lib.ams.tsl2561.","title":"Examples"},{"location":"reference/libs/ams/tsl2561/docs/examples/#read-ambient-light-from-tsl2561","text":"Basic example to read the illuminance from TSL2561 sensor. main.py ################################################################################ # Illuminance Example # # Created: 2017-03-16 17:03:14.563172 # ################################################################################ import streams from ams.tsl2561 import tsl2561 streams . serial () try : # Setup sensor # This setup is referred to tsl2561 mounted on on hexiwear device # Address pin of the sensor connected to gnd tsl = tsl2561 . TSL2561 ( I2C0 , addr = tsl2561 . TSL_I2C_ADDRESS [ \"LOW\" ]) print ( \"start...\" ) tsl . start () print ( \"init...\" ) tsl . init () print ( \"Ready!\" ) print ( \"--------------------------------------------------------\" ) except Exception as e : print ( \"Error: \" , e ) try : while True : raw_ir = tsl . get_raw_infrared () # Read raw infrared print ( \"Raw Infrared: \" , raw_ir ) raw_fs = tsl . get_raw_fullspectrum () # Read raw fullspectrum print ( \"Raw FullSpectrum: \" , raw_fs ) raw_vis = tsl . get_raw_visible () # Read raw visible print ( \"Raw Visible: \" , raw_vis ) lux = tsl . get_lux () # Read Lux print ( \"Illuminance: \" , lux , \"Lux\" ) print ( \"--------------------------------------------------------\" ) sleep ( 5000 ) except Exception as e : print ( \"Error2: \" , e )","title":"Read Ambient Light from TSL2561"},{"location":"reference/libs/ams/tsl2561/docs/tsl2561/","text":"TSL2561 Module \u00b6 This module contains the driver for AMS TSL2561 Luminosity sensor integrating both infrared and full-spectrum photodiodes. The TSL2561 is capable of direct I2C communication and is able to conduct specific light ranges from 0.1 - 40k+ Lux easily. Additionally, it contains two integrating analog-to-digital converters (ADC) that convert currents from the two photodiodes, simultaneously ( datasheet ). class TSL2561 \u00b6 class TSL2561 ( i2cdrv , addr = 0x49 , clk = 400000 ) Creates an instance of a new TSL2561. Arguments: i2cdrv \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x49 clk \u2013 Clock speed, default 400kHz Example: from ams.tsl2561 import tsl2561 ... tsl = tsl2561 . TSL2561 ( I2C0 , addr = tsl2561 . TSL_I2C_ADDRESS [ \"LOW\" ]) tsl . start () tsl . init () lux = tsl . get_lux () Note This sensor has a dedicated \u201cAddress\u201d pin that allows to select 1 of 3 available address as shown in the table below. ADDR SEL Terminal Level I2C Address Zerynth Define GND 0x29 addr = tsl2561.TSL_I2C_ADDRESS[\u201cLOW\u201d] Float 0x39 addr = tsl2561.TSL_I2C_ADDRESS[\u201cNORMAL\u201d] Vdd 0x49 addr = tsl2561.TSL_I2C_ADDRESS[\u201cHIGH\u201d] TSL2561.init \u00b6 init ( gain = 1 , timing = 0 , pack = 1 ) Initialize the TSL2561 setting the gain, timing and kind of package. Arguments: - gain \u2013 set the gain of the sensor (values allowed: 0 for gain=1x and 1 for gain=16x), default 1 - timing \u2013 set the integration time value (from 0 to 2 - 0 for 13 ms, 1 for 101 ms, 2 for 402 ms), default 0 - pack \u2013 set the kind of package for the correct lux calculation (values allowed: 0 for CS package and 1 for T,FN,CL package), default 1 get_raw_fullspectrum() Retrieves the current raw value read on channel0 (full-spectrum photodiode). Returns raw_fs. TSL2561.get_raw_infrared \u00b6 get_raw_infrared () Retrieves the current raw value read on channel1 (infrared photodiode). Returns raw_ir. TSL2561.get_raw_visible \u00b6 get_raw_visible () Retrieves the difference between the current raw value read on channel0 and raw value on channel1 (visible spectrum). Returns raw_vis = (raw_fs - raw_ir). TSL2561.get_lux \u00b6 get_lux () Converts the raw sensor values to the standard SI lux equivalent (according to the sensor settings - gain, timing and kind of package). Returns lux value or 0 if the sensor is saturated and the values are unreliable.","title":"TSL2561 Module"},{"location":"reference/libs/ams/tsl2561/docs/tsl2561/#tsl2561-module","text":"This module contains the driver for AMS TSL2561 Luminosity sensor integrating both infrared and full-spectrum photodiodes. The TSL2561 is capable of direct I2C communication and is able to conduct specific light ranges from 0.1 - 40k+ Lux easily. Additionally, it contains two integrating analog-to-digital converters (ADC) that convert currents from the two photodiodes, simultaneously ( datasheet ).","title":"TSL2561 Module"},{"location":"reference/libs/ams/tsl2561/docs/tsl2561/#class-tsl2561","text":"class TSL2561 ( i2cdrv , addr = 0x49 , clk = 400000 ) Creates an instance of a new TSL2561. Arguments: i2cdrv \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x49 clk \u2013 Clock speed, default 400kHz Example: from ams.tsl2561 import tsl2561 ... tsl = tsl2561 . TSL2561 ( I2C0 , addr = tsl2561 . TSL_I2C_ADDRESS [ \"LOW\" ]) tsl . start () tsl . init () lux = tsl . get_lux () Note This sensor has a dedicated \u201cAddress\u201d pin that allows to select 1 of 3 available address as shown in the table below. ADDR SEL Terminal Level I2C Address Zerynth Define GND 0x29 addr = tsl2561.TSL_I2C_ADDRESS[\u201cLOW\u201d] Float 0x39 addr = tsl2561.TSL_I2C_ADDRESS[\u201cNORMAL\u201d] Vdd 0x49 addr = tsl2561.TSL_I2C_ADDRESS[\u201cHIGH\u201d]","title":"class TSL2561"},{"location":"reference/libs/ams/tsl2561/docs/tsl2561/#tsl2561init","text":"init ( gain = 1 , timing = 0 , pack = 1 ) Initialize the TSL2561 setting the gain, timing and kind of package. Arguments: - gain \u2013 set the gain of the sensor (values allowed: 0 for gain=1x and 1 for gain=16x), default 1 - timing \u2013 set the integration time value (from 0 to 2 - 0 for 13 ms, 1 for 101 ms, 2 for 402 ms), default 0 - pack \u2013 set the kind of package for the correct lux calculation (values allowed: 0 for CS package and 1 for T,FN,CL package), default 1 get_raw_fullspectrum() Retrieves the current raw value read on channel0 (full-spectrum photodiode). Returns raw_fs.","title":"TSL2561.init"},{"location":"reference/libs/ams/tsl2561/docs/tsl2561/#tsl2561get_raw_infrared","text":"get_raw_infrared () Retrieves the current raw value read on channel1 (infrared photodiode). Returns raw_ir.","title":"TSL2561.get_raw_infrared"},{"location":"reference/libs/ams/tsl2561/docs/tsl2561/#tsl2561get_raw_visible","text":"get_raw_visible () Retrieves the difference between the current raw value read on channel0 and raw value on channel1 (visible spectrum). Returns raw_vis = (raw_fs - raw_ir).","title":"TSL2561.get_raw_visible"},{"location":"reference/libs/ams/tsl2561/docs/tsl2561/#tsl2561get_lux","text":"get_lux () Converts the raw sensor values to the standard SI lux equivalent (according to the sensor settings - gain, timing and kind of package). Returns lux value or 0 if the sensor is saturated and the values are unreliable.","title":"TSL2561.get_lux"},{"location":"reference/libs/aws/greengrass/docs/","text":"AWS Greengrass \u00b6 AWS Greengrass lets you build IoT solutions that connect different types of devices with the cloud and each other. Devices that run Linux and support ARM or x86 architectures can host the Greengrass Core. The Greengrass Core enables the local execution of AWS Lambda code, messaging, data caching, and security. Devices running AWS Greengrass Core act as a hub that can communicate with other devices able to connect to AWS IoT Core, such as microcontroller based devices or large appliances. AWS Greengrass Core devices and the AWS IoT Core devices can be configured to communicate with one another in a Greengrass Group. If the Greengrass Core device loses connectivity to the cloud, devices in the Greengrass Group can continue to communicate with each other over the local network. A Greengrass Group may represent one floor of a building, one truck, or an entire mining site. The Zerynth AWS Greengrass Library extends Zerynth AWS IoT Core Library with functions to retrieve info about an AWS Greengrass Core: Contents: Amazon Web Services Greengrass Library The DiscoveryInfo class Helper Functions Examples Discover and publish","title":"AWS Greengrass"},{"location":"reference/libs/aws/greengrass/docs/#aws-greengrass","text":"AWS Greengrass lets you build IoT solutions that connect different types of devices with the cloud and each other. Devices that run Linux and support ARM or x86 architectures can host the Greengrass Core. The Greengrass Core enables the local execution of AWS Lambda code, messaging, data caching, and security. Devices running AWS Greengrass Core act as a hub that can communicate with other devices able to connect to AWS IoT Core, such as microcontroller based devices or large appliances. AWS Greengrass Core devices and the AWS IoT Core devices can be configured to communicate with one another in a Greengrass Group. If the Greengrass Core device loses connectivity to the cloud, devices in the Greengrass Group can continue to communicate with each other over the local network. A Greengrass Group may represent one floor of a building, one truck, or an entire mining site. The Zerynth AWS Greengrass Library extends Zerynth AWS IoT Core Library with functions to retrieve info about an AWS Greengrass Core: Contents: Amazon Web Services Greengrass Library The DiscoveryInfo class Helper Functions Examples Discover and publish","title":"AWS Greengrass"},{"location":"reference/libs/aws/greengrass/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.aws.greengrass. Discover and Publish \u00b6 Discover Group AWS Greengrass Core, connect and start publishing. main.py # AWS Greengrass Discover and Publish # Created at 2017-10-03 08:49:48.182639 import streams import json from wireless import wifi # choose a wifi chip supporting secure sockets and client certificates from espressif.esp32net import esp32wifi as wifi_driver # import aws iot module from aws.iot import iot # import aws greengrass module from aws.greengrass import greengrass as gg # import helpers functions to easily load keys, certificates and thing configuration import helpers # THING KEY AND CERTIFICATE FILE MUST BE PLACED INSIDE PROJECT FOLDER new_resource ( 'private.pem.key' ) new_resource ( 'certificate.pem.crt' ) # SET THING CONFIGURATION INSIDE THE FOLLOWING JSON FILE new_resource ( 'thing.conf.json' ) streams . serial () wifi_driver . auto_init () print ( 'connecting to wifi...' ) # place here your wifi configuration wifi . link ( \"SSID\" , wifi . WIFI_WPA2 , \"PSW\" ) pkey , clicert = helpers . load_key_cert ( 'private.pem.key' , 'certificate.pem.crt' ) thing_conf = helpers . load_thing_conf () publish_period = 1000 # discover Greengrass core info info = gg . discover ( thing_conf [ 'endpoint' ], thing_conf [ 'thingname' ], clicert , pkey ) # N.B. for this example to work it is required that single element connectivity and CA lists are retrieved by discover! gg_endpoint = info . connectivity ()[ 0 ] print ( 'discovered:' , gg_endpoint ) # create aws iot thing instance and connect to discovered mqtt broker specifying retrieved CA certificate thing = iot . Thing ( gg_endpoint , thing_conf [ 'mqttid' ], clicert , pkey , thingname = thing_conf [ 'thingname' ], cacert = info . CA ()) print ( 'connecting to mqtt broker...' ) thing . mqtt . connect () thing . mqtt . loop () while True : print ( 'publish random sample...' ) thing . mqtt . publish ( \"dev/sample\" , json . dumps ({ 'asample' : random ( 0 , 10 ) })) sleep ( publish_period )","title":"Examples"},{"location":"reference/libs/aws/greengrass/docs/examples/#examples","text":"The following are a list of examples for lib.aws.greengrass.","title":"Examples"},{"location":"reference/libs/aws/greengrass/docs/examples/#discover-and-publish","text":"Discover Group AWS Greengrass Core, connect and start publishing. main.py # AWS Greengrass Discover and Publish # Created at 2017-10-03 08:49:48.182639 import streams import json from wireless import wifi # choose a wifi chip supporting secure sockets and client certificates from espressif.esp32net import esp32wifi as wifi_driver # import aws iot module from aws.iot import iot # import aws greengrass module from aws.greengrass import greengrass as gg # import helpers functions to easily load keys, certificates and thing configuration import helpers # THING KEY AND CERTIFICATE FILE MUST BE PLACED INSIDE PROJECT FOLDER new_resource ( 'private.pem.key' ) new_resource ( 'certificate.pem.crt' ) # SET THING CONFIGURATION INSIDE THE FOLLOWING JSON FILE new_resource ( 'thing.conf.json' ) streams . serial () wifi_driver . auto_init () print ( 'connecting to wifi...' ) # place here your wifi configuration wifi . link ( \"SSID\" , wifi . WIFI_WPA2 , \"PSW\" ) pkey , clicert = helpers . load_key_cert ( 'private.pem.key' , 'certificate.pem.crt' ) thing_conf = helpers . load_thing_conf () publish_period = 1000 # discover Greengrass core info info = gg . discover ( thing_conf [ 'endpoint' ], thing_conf [ 'thingname' ], clicert , pkey ) # N.B. for this example to work it is required that single element connectivity and CA lists are retrieved by discover! gg_endpoint = info . connectivity ()[ 0 ] print ( 'discovered:' , gg_endpoint ) # create aws iot thing instance and connect to discovered mqtt broker specifying retrieved CA certificate thing = iot . Thing ( gg_endpoint , thing_conf [ 'mqttid' ], clicert , pkey , thingname = thing_conf [ 'thingname' ], cacert = info . CA ()) print ( 'connecting to mqtt broker...' ) thing . mqtt . connect () thing . mqtt . loop () while True : print ( 'publish random sample...' ) thing . mqtt . publish ( \"dev/sample\" , json . dumps ({ 'asample' : random ( 0 , 10 ) })) sleep ( publish_period )","title":"Discover and Publish"},{"location":"reference/libs/aws/greengrass/docs/greengrass/","text":"Amazon Web Services Greengrass Library \u00b6 The Zerynth AWS Greengrass Library contains helper functions for IoT devices to retrieve info about an AWS Greengrass Core . Note dev-voja to connect to an AWS Greengrass Core after info retrieval use Zerynth AWS IoT Core Library The DiscoveryInfo class \u00b6 class DiscoveryInfo \u00b6 class DiscoveryInfo ( raw_info ) A DiscoveryInfo instance is returned by greengrass.discover() function. It exposes the following attributes and methods: DiscoveryInfo.raw dictionary containing raw discovery response . DiscoveryInfo.CA() DiscoveryInfo.connectivity() DiscoveryInfo.CA \u00b6 CA () Returns Greengrass Core CA Certificate if only one Server Certificate is returned by discover call. Raises GreengrassDiscoveryInfoException if more than one certificate is returned. DiscoveryInfo.connectivity \u00b6 connectivity () Returns a tuple (core_address, core_port) with Greengrass Core address and port if only one Core is returned by discover call. Raises GreengrassDiscoveryInfoException if more than one Core is returned. Helper Functions \u00b6 discover \u00b6 discover ( endpoint , thingname , clicert , pkey , cacert = None ) param endpoint: AWS server where to retrieve Greengrass core info param thingname: AWS IoT Core or AWS Greengrass Device name param clicert: client certificate param pkey: client private key Discover info about own group Greengrass Core. Returns a DiscoveryInfo() object.","title":"Amazon Web Services Greengrass Library"},{"location":"reference/libs/aws/greengrass/docs/greengrass/#amazon-web-services-greengrass-library","text":"The Zerynth AWS Greengrass Library contains helper functions for IoT devices to retrieve info about an AWS Greengrass Core . Note dev-voja to connect to an AWS Greengrass Core after info retrieval use Zerynth AWS IoT Core Library","title":"Amazon Web Services Greengrass Library"},{"location":"reference/libs/aws/greengrass/docs/greengrass/#the-discoveryinfo-class","text":"","title":"The DiscoveryInfo class"},{"location":"reference/libs/aws/greengrass/docs/greengrass/#class-discoveryinfo","text":"class DiscoveryInfo ( raw_info ) A DiscoveryInfo instance is returned by greengrass.discover() function. It exposes the following attributes and methods: DiscoveryInfo.raw dictionary containing raw discovery response . DiscoveryInfo.CA() DiscoveryInfo.connectivity()","title":"class DiscoveryInfo"},{"location":"reference/libs/aws/greengrass/docs/greengrass/#discoveryinfoca","text":"CA () Returns Greengrass Core CA Certificate if only one Server Certificate is returned by discover call. Raises GreengrassDiscoveryInfoException if more than one certificate is returned.","title":"DiscoveryInfo.CA"},{"location":"reference/libs/aws/greengrass/docs/greengrass/#discoveryinfoconnectivity","text":"connectivity () Returns a tuple (core_address, core_port) with Greengrass Core address and port if only one Core is returned by discover call. Raises GreengrassDiscoveryInfoException if more than one Core is returned.","title":"DiscoveryInfo.connectivity"},{"location":"reference/libs/aws/greengrass/docs/greengrass/#helper-functions","text":"","title":"Helper Functions"},{"location":"reference/libs/aws/greengrass/docs/greengrass/#discover","text":"discover ( endpoint , thingname , clicert , pkey , cacert = None ) param endpoint: AWS server where to retrieve Greengrass core info param thingname: AWS IoT Core or AWS Greengrass Device name param clicert: client certificate param pkey: client private key Discover info about own group Greengrass Core. Returns a DiscoveryInfo() object.","title":"discover"},{"location":"reference/libs/aws/iot/docs/","text":"AWS IoT \u00b6 AWS IoT is a managed cloud platform that lets connected devices easily and securely interact with cloud applications and other devices: AWS IoT platform . It is possible, for example, to connect to AWS IoT MQTT Broker to send device data and process/store those data with different AWS services linked to AWS IoT platform through custom Rules . Here below, the Zerynth Library to manage your devices thanks to AWS IoT platform: Contents: Amazon Web Services IoT Library The Thing class Amazon Web Services IoT Jobs Library Jobs class Job class Amazon Web Services IoT FOTA Library Amazon Web Services IoT Default Credentials Examples Controlled publish period HWCrypto Controller publish period Cloud15Lines FOTA aws","title":"AWS IoT"},{"location":"reference/libs/aws/iot/docs/#aws-iot","text":"AWS IoT is a managed cloud platform that lets connected devices easily and securely interact with cloud applications and other devices: AWS IoT platform . It is possible, for example, to connect to AWS IoT MQTT Broker to send device data and process/store those data with different AWS services linked to AWS IoT platform through custom Rules . Here below, the Zerynth Library to manage your devices thanks to AWS IoT platform: Contents: Amazon Web Services IoT Library The Thing class Amazon Web Services IoT Jobs Library Jobs class Job class Amazon Web Services IoT FOTA Library Amazon Web Services IoT Default Credentials Examples Controlled publish period HWCrypto Controller publish period Cloud15Lines FOTA aws","title":"AWS IoT"},{"location":"reference/libs/aws/iot/docs/default_credentials/","text":"Amazon Web Services IoT Default Credentials \u00b6 The Zerynth AWS IoT Default Credentials module is useful to achieve a zero-time startup for your AWS IoT project powered by Zerynth. It makes it really simple to load connection credentials, which could be stored on flash or in a secure element, by means of a single call to the load() function. load \u00b6 load () This function returns: AWS IoT endpoint for the device to connect to; device Mqtt ID; client certificate to be sent to AWS; device private key. Endpoint and Mqtt ID are retrieved from the thing.conf.json configuration file which has to be put in the project and filled like this: { \"endpoint\" : \"myendpoint.iot.my-region.amazonaws.com\" , \"mqttid\" : \"mymqttid\" } Client certificate is retrieved from certificate.pem.crt file which must be put in the project, too. On the other hand the private key can be retrieved from different sources depending on the presence of the ZERYNTH_HWCRYPTO_ATECCx08A define inside the Zerynth project project.yml file. without ZERYNTH_HWCRYPTO_ATECCx08A , the private key is taken from private.pem.key file put in the project and stored on flash (unsafe for production purposes) with ZERYNTH_HWCRYPTO_ATECCx08A , the private key is stored inside a secure element, returned private key is an empty string and the thing.conf.json needs extra configuration fields: { \"crypto_drv\" : 0 # I2C the secure element is connected to, 0 for I2C0 \"crypto_addr\" : 88 , # I2C address of the secure element \"crypto_clock\" : 100000 , # I2C clock (Hz) of the secure element \"crypto_slot\" : 2 # slot of the secure element where the private key is stored }","title":"Amazon Web Services IoT Default Credentials"},{"location":"reference/libs/aws/iot/docs/default_credentials/#amazon-web-services-iot-default-credentials","text":"The Zerynth AWS IoT Default Credentials module is useful to achieve a zero-time startup for your AWS IoT project powered by Zerynth. It makes it really simple to load connection credentials, which could be stored on flash or in a secure element, by means of a single call to the load() function.","title":"Amazon Web Services IoT Default Credentials"},{"location":"reference/libs/aws/iot/docs/default_credentials/#load","text":"load () This function returns: AWS IoT endpoint for the device to connect to; device Mqtt ID; client certificate to be sent to AWS; device private key. Endpoint and Mqtt ID are retrieved from the thing.conf.json configuration file which has to be put in the project and filled like this: { \"endpoint\" : \"myendpoint.iot.my-region.amazonaws.com\" , \"mqttid\" : \"mymqttid\" } Client certificate is retrieved from certificate.pem.crt file which must be put in the project, too. On the other hand the private key can be retrieved from different sources depending on the presence of the ZERYNTH_HWCRYPTO_ATECCx08A define inside the Zerynth project project.yml file. without ZERYNTH_HWCRYPTO_ATECCx08A , the private key is taken from private.pem.key file put in the project and stored on flash (unsafe for production purposes) with ZERYNTH_HWCRYPTO_ATECCx08A , the private key is stored inside a secure element, returned private key is an empty string and the thing.conf.json needs extra configuration fields: { \"crypto_drv\" : 0 # I2C the secure element is connected to, 0 for I2C0 \"crypto_addr\" : 88 , # I2C address of the secure element \"crypto_clock\" : 100000 , # I2C clock (Hz) of the secure element \"crypto_slot\" : 2 # slot of the secure element where the private key is stored }","title":"load"},{"location":"reference/libs/aws/iot/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.aws.iot. Controlled Publish Period \u00b6 Connect your device to AWS IoT platform and start publishing at a default period, waiting for period updates requested as changes to things' shadow. main.py # AWS IoT Controlled publish period # Created at 2017-10-03 08:49:48.182639 import streams import json from wireless import wifi # choose a wifi chip supporting secure sockets and client certificates from espressif.esp32net import esp32wifi as wifi_driver # import aws iot module from aws.iot import iot # import helpers functions to easily load keys, certificates and thing configuration import helpers # THING KEY AND CERTIFICATE FILE MUST BE PLACED INSIDE PROJECT FOLDER new_resource ( 'private.pem.key' ) new_resource ( 'certificate.pem.crt' ) # SET THING CONFIGURATION INSIDE THE FOLLOWING JSON FILE new_resource ( 'thing.conf.json' ) # define a callback for shadow updates def shadow_callback ( requested ): global publish_period print ( 'requested publish period:' , requested [ 'publish_period' ]) publish_period = requested [ 'publish_period' ] return { 'publish_period' : publish_period } streams . serial () wifi_driver . auto_init () print ( 'connecting to wifi...' ) # place here your wifi configuration wifi . link ( \"SSID\" , wifi . WIFI_WPA2 , \"PSW\" ) pkey , clicert = helpers . load_key_cert ( 'private.pem.key' , 'certificate.pem.crt' ) thing_conf = helpers . load_thing_conf () publish_period = 1000 # create aws iot thing instance, connect to mqtt broker, set shadow update callback and start mqtt reception loop thing = iot . Thing ( thing_conf [ 'endpoint' ], thing_conf [ 'mqttid' ], clicert , pkey , thingname = thing_conf [ 'thingname' ]) print ( 'connecting to mqtt broker...' ) thing . mqtt . connect () thing . on_shadow_request ( shadow_callback ) thing . mqtt . loop () thing . update_shadow ({ 'publish_period' : publish_period }) while True : print ( 'publish random sample...' ) thing . mqtt . publish ( \"dev/sample\" , json . dumps ({ 'asample' : random ( 0 , 10 ) })) sleep ( publish_period ) HWCrypto Controlled Publish Period \u00b6 Connect your device to AWS IoT platform and start publishing at a default period, waiting for period updates requested as changes to things' shadow. The connection is performed using a hardware private key stored in a ateccx08a crypto element. To register a hardware key to AWS IoT platform the following steps are needed: # derive a CSR from the hardware key ztc provisioning uplink - config - firmware esp32_device_alias ztc provisioning get - csr esp32_device_alias privatekey_slot 'C=IT,O=ZER,CN=MyDevice' - o hwkey0 . csr # get a certificate from AWS IoT and activate it aws iot create - certificate - from - csr --certificate-signing-request file://hwkey0.csr --certificate-pem-outfile certificate.pem.crt --set-as-active aws iot attach - thing - principal --thing-name my-thing --principal certificate-arn aws iot attach - principal - policy --policy-name my-policy --principal certificate-arn main.py # AWS IoT Controlled publish period # Created at 2017-10-03 08:49:48.182639 import streams import json from wireless import wifi # choose a wifi chip supporting secure sockets and client certificates from espressif.esp32net import esp32wifi as wifi_driver # import aws iot module from aws.iot import iot # import microchip ateccx08a module for its hw crypto element interface from microchip.ateccx08a import ateccx08a # import helpers functions to easily load keys, certificates and thing configuration import helpers # THING CERTIFICATE FILE MUST BE PLACED INSIDE PROJECT FOLDER new_resource ( 'certificate.pem.crt' ) # SET THING CONFIGURATION INSIDE THE FOLLOWING JSON FILE new_resource ( 'thing.conf.json' ) # define a callback for shadow updates def shadow_callback ( requested ): global publish_period print ( 'requested publish period:' , requested [ 'publish_period' ]) publish_period = requested [ 'publish_period' ] return { 'publish_period' : publish_period } streams . serial () wifi_driver . auto_init () print ( 'connecting to wifi...' ) # place here your wifi configuration wifi . link ( \"SSID\" , wifi . WIFI_WPA2 , \"PSW\" ) # start hardware crypto interface ateccx08a . hwcrypto_init ( I2C0 , 0 ) clicert = helpers . load_cert ( 'certificate.pem.crt' ) thing_conf = helpers . load_thing_conf () publish_period = 1000 # create aws iot thing instance, connect to mqtt broker, set shadow update callback and start mqtt reception loop # N.B. private key is passed as an empty string to use an hardware stored one thing = iot . Thing ( thing_conf [ 'endpoint' ], thing_conf [ 'mqttid' ], clicert , '' , thingname = thing_conf [ 'thingname' ]) print ( 'connecting to mqtt broker...' ) thing . mqtt . connect () thing . on_shadow_request ( shadow_callback ) thing . mqtt . loop () thing . update_shadow ({ 'publish_period' : publish_period }) while True : print ( 'publish random sample...' ) thing . mqtt . publish ( \"dev/sample\" , json . dumps ({ 'asample' : random ( 0 , 10 ) })) sleep ( publish_period ) Sensor to Cloud in 15 Lines \u00b6 Connect your device to AWS IoT and start sending data gathered from plugged sensor in 15 lines of Python code. main.py from wireless import wifi from espressif.esp32net import esp32wifi as wifi_driver from bosch.bme280 import bme280 from aws.iot import iot , default_credentials wifi_driver . auto_init () wifi . link ( \"SSID\" , wifi . WIFI_WPA2 , \"PSW\" ) endpoint , mqttid , clicert , pkey = default_credentials . load () thing = iot . Thing ( endpoint , mqttid , clicert , pkey ) thing . mqtt . connect () thing . mqtt . loop () sensor = bme280 . BME280 ( I2C0 ) while True : thing . mqtt . publish ( \"sensors\" , { 'temp' : sensor . get_temp ()}) sleep ( 1000 ) FOTA AWS \u00b6 Connect your device to AWS IoT platform and start updating the firmware seamlessly. main.py # AWS FOTA # Created at 2017-10-03 08:49:48.182639 import streams import json from wireless import wifi # choose a wifi chip supporting secure sockets and client certificates from espressif.esp32net import esp32wifi as wifi_driver # import aws iot module from aws.iot import iot from aws.iot import jobs from aws.iot import fota as awsfota # import helpers functions to easily load keys, certificates and thing configuration import helpers # THING KEY AND CERTIFICATE FILE MUST BE PLACED INSIDE PROJECT FOLDER new_resource ( 'private.pem.key' ) new_resource ( 'certificate.pem.crt' ) # SET THING CONFIGURATION INSIDE THE FOLLOWING JSON FILE new_resource ( 'thing.conf.json' ) # Init serial port for debug streams . serial () # FIRMWARE VERSION: change this to verify correct FOTA version = 0 try : wifi_driver . auto_init () print ( 'connecting to wifi...' ) # place here your wifi configuration wifi . link ( \"SSID\" , wifi . WIFI_WPA2 , \"password\" ) # load Thing configuration pkey , clicert = helpers . load_key_cert ( 'private.pem.key' , 'certificate.pem.crt' ) thing_conf = helpers . load_thing_conf () publish_period = 1000 # create aws iot thing instance and connect to mqtt broker thing = iot . Thing ( thing_conf [ 'endpoint' ], thing_conf [ 'mqttid' ], clicert , pkey , thingname = thing_conf [ 'thingname' ]) print ( 'connecting to mqtt broker...' ) thing . mqtt . connect () thing . mqtt . loop () #show current version firmware print ( \"Hello, I am firmware version:\" , version ) #create an IoT Jobs object myjobs = jobs . Jobs ( thing ) # check if there are FOTA jobs waiting to be performed # This function executes a FOTA update if possible # or confirms an already executed FOTA update awsfota . handle_fota_jobs ( myjobs , force = True ) while True : r = random ( 0 , 10 ) print ( 'publish random sample...' , r ) thing . mqtt . publish ( \"dev/sample\" , json . dumps ({ 'asample' : r })) sleep ( publish_period ) # check for new incoming jobs # again, FOTA is executed if a correct FOTA job is queued awsfota . handle_fota_jobs ( myjobs ) except Exception as e : print ( e ) #reset on error! awsfota . reset ()","title":"Examples"},{"location":"reference/libs/aws/iot/docs/examples/#examples","text":"The following are a list of examples for lib.aws.iot.","title":"Examples"},{"location":"reference/libs/aws/iot/docs/examples/#controlled-publish-period","text":"Connect your device to AWS IoT platform and start publishing at a default period, waiting for period updates requested as changes to things' shadow. main.py # AWS IoT Controlled publish period # Created at 2017-10-03 08:49:48.182639 import streams import json from wireless import wifi # choose a wifi chip supporting secure sockets and client certificates from espressif.esp32net import esp32wifi as wifi_driver # import aws iot module from aws.iot import iot # import helpers functions to easily load keys, certificates and thing configuration import helpers # THING KEY AND CERTIFICATE FILE MUST BE PLACED INSIDE PROJECT FOLDER new_resource ( 'private.pem.key' ) new_resource ( 'certificate.pem.crt' ) # SET THING CONFIGURATION INSIDE THE FOLLOWING JSON FILE new_resource ( 'thing.conf.json' ) # define a callback for shadow updates def shadow_callback ( requested ): global publish_period print ( 'requested publish period:' , requested [ 'publish_period' ]) publish_period = requested [ 'publish_period' ] return { 'publish_period' : publish_period } streams . serial () wifi_driver . auto_init () print ( 'connecting to wifi...' ) # place here your wifi configuration wifi . link ( \"SSID\" , wifi . WIFI_WPA2 , \"PSW\" ) pkey , clicert = helpers . load_key_cert ( 'private.pem.key' , 'certificate.pem.crt' ) thing_conf = helpers . load_thing_conf () publish_period = 1000 # create aws iot thing instance, connect to mqtt broker, set shadow update callback and start mqtt reception loop thing = iot . Thing ( thing_conf [ 'endpoint' ], thing_conf [ 'mqttid' ], clicert , pkey , thingname = thing_conf [ 'thingname' ]) print ( 'connecting to mqtt broker...' ) thing . mqtt . connect () thing . on_shadow_request ( shadow_callback ) thing . mqtt . loop () thing . update_shadow ({ 'publish_period' : publish_period }) while True : print ( 'publish random sample...' ) thing . mqtt . publish ( \"dev/sample\" , json . dumps ({ 'asample' : random ( 0 , 10 ) })) sleep ( publish_period )","title":"Controlled Publish Period"},{"location":"reference/libs/aws/iot/docs/examples/#hwcrypto-controlled-publish-period","text":"Connect your device to AWS IoT platform and start publishing at a default period, waiting for period updates requested as changes to things' shadow. The connection is performed using a hardware private key stored in a ateccx08a crypto element. To register a hardware key to AWS IoT platform the following steps are needed: # derive a CSR from the hardware key ztc provisioning uplink - config - firmware esp32_device_alias ztc provisioning get - csr esp32_device_alias privatekey_slot 'C=IT,O=ZER,CN=MyDevice' - o hwkey0 . csr # get a certificate from AWS IoT and activate it aws iot create - certificate - from - csr --certificate-signing-request file://hwkey0.csr --certificate-pem-outfile certificate.pem.crt --set-as-active aws iot attach - thing - principal --thing-name my-thing --principal certificate-arn aws iot attach - principal - policy --policy-name my-policy --principal certificate-arn main.py # AWS IoT Controlled publish period # Created at 2017-10-03 08:49:48.182639 import streams import json from wireless import wifi # choose a wifi chip supporting secure sockets and client certificates from espressif.esp32net import esp32wifi as wifi_driver # import aws iot module from aws.iot import iot # import microchip ateccx08a module for its hw crypto element interface from microchip.ateccx08a import ateccx08a # import helpers functions to easily load keys, certificates and thing configuration import helpers # THING CERTIFICATE FILE MUST BE PLACED INSIDE PROJECT FOLDER new_resource ( 'certificate.pem.crt' ) # SET THING CONFIGURATION INSIDE THE FOLLOWING JSON FILE new_resource ( 'thing.conf.json' ) # define a callback for shadow updates def shadow_callback ( requested ): global publish_period print ( 'requested publish period:' , requested [ 'publish_period' ]) publish_period = requested [ 'publish_period' ] return { 'publish_period' : publish_period } streams . serial () wifi_driver . auto_init () print ( 'connecting to wifi...' ) # place here your wifi configuration wifi . link ( \"SSID\" , wifi . WIFI_WPA2 , \"PSW\" ) # start hardware crypto interface ateccx08a . hwcrypto_init ( I2C0 , 0 ) clicert = helpers . load_cert ( 'certificate.pem.crt' ) thing_conf = helpers . load_thing_conf () publish_period = 1000 # create aws iot thing instance, connect to mqtt broker, set shadow update callback and start mqtt reception loop # N.B. private key is passed as an empty string to use an hardware stored one thing = iot . Thing ( thing_conf [ 'endpoint' ], thing_conf [ 'mqttid' ], clicert , '' , thingname = thing_conf [ 'thingname' ]) print ( 'connecting to mqtt broker...' ) thing . mqtt . connect () thing . on_shadow_request ( shadow_callback ) thing . mqtt . loop () thing . update_shadow ({ 'publish_period' : publish_period }) while True : print ( 'publish random sample...' ) thing . mqtt . publish ( \"dev/sample\" , json . dumps ({ 'asample' : random ( 0 , 10 ) })) sleep ( publish_period )","title":"HWCrypto Controlled Publish Period"},{"location":"reference/libs/aws/iot/docs/examples/#sensor-to-cloud-in-15-lines","text":"Connect your device to AWS IoT and start sending data gathered from plugged sensor in 15 lines of Python code. main.py from wireless import wifi from espressif.esp32net import esp32wifi as wifi_driver from bosch.bme280 import bme280 from aws.iot import iot , default_credentials wifi_driver . auto_init () wifi . link ( \"SSID\" , wifi . WIFI_WPA2 , \"PSW\" ) endpoint , mqttid , clicert , pkey = default_credentials . load () thing = iot . Thing ( endpoint , mqttid , clicert , pkey ) thing . mqtt . connect () thing . mqtt . loop () sensor = bme280 . BME280 ( I2C0 ) while True : thing . mqtt . publish ( \"sensors\" , { 'temp' : sensor . get_temp ()}) sleep ( 1000 )","title":"Sensor to Cloud in 15 Lines"},{"location":"reference/libs/aws/iot/docs/examples/#fota-aws","text":"Connect your device to AWS IoT platform and start updating the firmware seamlessly. main.py # AWS FOTA # Created at 2017-10-03 08:49:48.182639 import streams import json from wireless import wifi # choose a wifi chip supporting secure sockets and client certificates from espressif.esp32net import esp32wifi as wifi_driver # import aws iot module from aws.iot import iot from aws.iot import jobs from aws.iot import fota as awsfota # import helpers functions to easily load keys, certificates and thing configuration import helpers # THING KEY AND CERTIFICATE FILE MUST BE PLACED INSIDE PROJECT FOLDER new_resource ( 'private.pem.key' ) new_resource ( 'certificate.pem.crt' ) # SET THING CONFIGURATION INSIDE THE FOLLOWING JSON FILE new_resource ( 'thing.conf.json' ) # Init serial port for debug streams . serial () # FIRMWARE VERSION: change this to verify correct FOTA version = 0 try : wifi_driver . auto_init () print ( 'connecting to wifi...' ) # place here your wifi configuration wifi . link ( \"SSID\" , wifi . WIFI_WPA2 , \"password\" ) # load Thing configuration pkey , clicert = helpers . load_key_cert ( 'private.pem.key' , 'certificate.pem.crt' ) thing_conf = helpers . load_thing_conf () publish_period = 1000 # create aws iot thing instance and connect to mqtt broker thing = iot . Thing ( thing_conf [ 'endpoint' ], thing_conf [ 'mqttid' ], clicert , pkey , thingname = thing_conf [ 'thingname' ]) print ( 'connecting to mqtt broker...' ) thing . mqtt . connect () thing . mqtt . loop () #show current version firmware print ( \"Hello, I am firmware version:\" , version ) #create an IoT Jobs object myjobs = jobs . Jobs ( thing ) # check if there are FOTA jobs waiting to be performed # This function executes a FOTA update if possible # or confirms an already executed FOTA update awsfota . handle_fota_jobs ( myjobs , force = True ) while True : r = random ( 0 , 10 ) print ( 'publish random sample...' , r ) thing . mqtt . publish ( \"dev/sample\" , json . dumps ({ 'asample' : r })) sleep ( publish_period ) # check for new incoming jobs # again, FOTA is executed if a correct FOTA job is queued awsfota . handle_fota_jobs ( myjobs ) except Exception as e : print ( e ) #reset on error! awsfota . reset ()","title":"FOTA AWS"},{"location":"reference/libs/aws/iot/docs/fota/","text":"Amazon Web Services IoT FOTA Library \u00b6 The Zerynth AWS IoT FOTA Library can be used to implement Firmware Over The Air updates (FOTA) of AWS Things with ease. Devices connected to the AWS IoT MQTT Broker can receive jobs containing enough information for a firmware update. Such jobs can be easily generated by the ZTC. The FOTA flow is quite simple: A device is notified of a new job The job document must contain the following required fields: bc_idx , the index of the bytecode slot to save the new firmware to bc_crc , the MD5 crc of the new firmware bc_size , the length in bytes of the new firmware bc_url , a https url to a S3 file containing the new firmware If the job can be performed, it is placed in the IN_PROGRESS status. Otherwise it is mared as FAILED and the flow stops. The firmware is downloaded from bc_url , saved to the device and checked for errors against bc_crc The device is restarted If the new firmware is correct, the IN_PROGRESS job is retrieved and marked as SUCCEEDED. Otherwise the old working firmware will restart and will mark the job as FAILED. The entire flow can be managed as in the following example: from aws.iot import fota as awsfota from aws.iot import jobs ... do some initialization ( connect to the network and configure the Thing ) ... # create an IoT Jobs object myjobs = jobs . Jobs ( thing ) # check if there are FOTA jobs waiting to be performed # This function executes a FOTA update if possible # or confirms an already executed FOTA update awsfota . handle_fota_jobs ( myjobs , force = True ) # True, force while True : r = random ( 0 , 10 ) print ( 'publish random sample...' , r ) thing . mqtt . publish ( \"dev/sample\" , json . dumps ({ 'asample' : r })) sleep ( publish_period ) # check for new incoming jobs # again, FOTA is executed if a correct FOTA job is queued awsfota . handle_fota_jobs ( myjobs ) update \u00b6 update ( document ) Given a correct job document , performs the FOTA update by downloading the correct firmware from the signed S3 bucket url and checking if the download was correct against the firmware CRC. Return True if the process finishes correctly. test \u00b6 test ( document ) Must be called after a successful update to test the new firmware providing the job document . Once called, a device reset is necessary. confirm \u00b6 confirm () Makes the new firmware final. Must be called by the new firmware upon reset after the old firmware called test. Failing to confirm the new firmware will reboot the old firmware on reset. reset \u00b6 reset () Reset the device. handle_fota_jobs \u00b6 handle_fota_jobs ( jobs , force = False , disconnect_mqtt = True , auto_reset = True , job_cbk = None ) The entire FOTA flow can be implemented by adding this function to an AWS ready firmware. The function arguments: jobs , is an instance of the Jobs class (module aws.iot.jobs) properly initialized with the current Thing force , if True forces the retrieval of pending and queued jobs regardless of a mqtt notification of the new jobs event disconnect_mqtt , determines if th mqtt connection of the current Thing is closed before attempting a FOTA. By default it is set to True since keeping two TLS sockets open (one to the MQTT broker and the other to the S3 bucket) can be demanding for most devices. auto_reset , automatically resets the device when the FOTA flow requires it. By default is set to True, however it can be disabled and the needed reset can be performed manually. A reset is signaled by handle_fota_jobs returning True. job_cbk , is the job callback. Each non-FOTA job is passed to job_cbk for external handling if job_cbk is not None The function must be called at least twice: the first time, right after the connection to the mqtt broker with force=True in order to handle all pending jobs. The second call can be made periodically in the publish loop to catch new queued jobs.","title":"Amazon Web Services IoT FOTA Library"},{"location":"reference/libs/aws/iot/docs/fota/#amazon-web-services-iot-fota-library","text":"The Zerynth AWS IoT FOTA Library can be used to implement Firmware Over The Air updates (FOTA) of AWS Things with ease. Devices connected to the AWS IoT MQTT Broker can receive jobs containing enough information for a firmware update. Such jobs can be easily generated by the ZTC. The FOTA flow is quite simple: A device is notified of a new job The job document must contain the following required fields: bc_idx , the index of the bytecode slot to save the new firmware to bc_crc , the MD5 crc of the new firmware bc_size , the length in bytes of the new firmware bc_url , a https url to a S3 file containing the new firmware If the job can be performed, it is placed in the IN_PROGRESS status. Otherwise it is mared as FAILED and the flow stops. The firmware is downloaded from bc_url , saved to the device and checked for errors against bc_crc The device is restarted If the new firmware is correct, the IN_PROGRESS job is retrieved and marked as SUCCEEDED. Otherwise the old working firmware will restart and will mark the job as FAILED. The entire flow can be managed as in the following example: from aws.iot import fota as awsfota from aws.iot import jobs ... do some initialization ( connect to the network and configure the Thing ) ... # create an IoT Jobs object myjobs = jobs . Jobs ( thing ) # check if there are FOTA jobs waiting to be performed # This function executes a FOTA update if possible # or confirms an already executed FOTA update awsfota . handle_fota_jobs ( myjobs , force = True ) # True, force while True : r = random ( 0 , 10 ) print ( 'publish random sample...' , r ) thing . mqtt . publish ( \"dev/sample\" , json . dumps ({ 'asample' : r })) sleep ( publish_period ) # check for new incoming jobs # again, FOTA is executed if a correct FOTA job is queued awsfota . handle_fota_jobs ( myjobs )","title":"Amazon Web Services IoT FOTA Library"},{"location":"reference/libs/aws/iot/docs/fota/#update","text":"update ( document ) Given a correct job document , performs the FOTA update by downloading the correct firmware from the signed S3 bucket url and checking if the download was correct against the firmware CRC. Return True if the process finishes correctly.","title":"update"},{"location":"reference/libs/aws/iot/docs/fota/#test","text":"test ( document ) Must be called after a successful update to test the new firmware providing the job document . Once called, a device reset is necessary.","title":"test"},{"location":"reference/libs/aws/iot/docs/fota/#confirm","text":"confirm () Makes the new firmware final. Must be called by the new firmware upon reset after the old firmware called test. Failing to confirm the new firmware will reboot the old firmware on reset.","title":"confirm"},{"location":"reference/libs/aws/iot/docs/fota/#reset","text":"reset () Reset the device.","title":"reset"},{"location":"reference/libs/aws/iot/docs/fota/#handle_fota_jobs","text":"handle_fota_jobs ( jobs , force = False , disconnect_mqtt = True , auto_reset = True , job_cbk = None ) The entire FOTA flow can be implemented by adding this function to an AWS ready firmware. The function arguments: jobs , is an instance of the Jobs class (module aws.iot.jobs) properly initialized with the current Thing force , if True forces the retrieval of pending and queued jobs regardless of a mqtt notification of the new jobs event disconnect_mqtt , determines if th mqtt connection of the current Thing is closed before attempting a FOTA. By default it is set to True since keeping two TLS sockets open (one to the MQTT broker and the other to the S3 bucket) can be demanding for most devices. auto_reset , automatically resets the device when the FOTA flow requires it. By default is set to True, however it can be disabled and the needed reset can be performed manually. A reset is signaled by handle_fota_jobs returning True. job_cbk , is the job callback. Each non-FOTA job is passed to job_cbk for external handling if job_cbk is not None The function must be called at least twice: the first time, right after the connection to the mqtt broker with force=True in order to handle all pending jobs. The second call can be made periodically in the publish loop to catch new queued jobs.","title":"handle_fota_jobs"},{"location":"reference/libs/aws/iot/docs/iot/","text":"Amazon Web Services IoT Library \u00b6 The Zerynth AWS IoT Library can be used to ease the connection to the AWS IoT platform . It allows to make your device act as an AWS IoT Thing which can be registered through AWS tools or directly from the Zerynth Toolchain. Check this video for a live demo: ## The Thing class ##### class Thing ```#!py3 class Thing(endpoint, mqtt_id, clicert, pkey, thingname=None, cacert=None)``` Create a Thing instance representing an AWS IoT Thing. The Thing object will contain an mqtt client instance pointing to AWS IoT MQTT broker located at `endpoint` endpoint. The client is configured with `mqtt_id` as MQTT id and is able to connect securely through AWS authorized `pkey` private key and `clicert` certificate (an optional `cacert` CA Certificate can also be passed). Refer to Zerynth SSL Context creation for admitted `pkey` values. The client is accessible through `mqtt` instance attribute and exposes all Zerynth MQTT Client methods so that it is possible, for example, to setup custom callback on MQTT commands. The only difference concerns mqtt.connect method which does not require broker url and ssl context, taking them from Thing configuration: my_thing = iot . Thing ( 'my_ep_id.iot.my_region.amazonaws.com' , 'my_thing_id' , clicert , pkey ) my_thing . mqtt . connect () ... my_thing . mqtt . loop () A `thingname` different from chosen MQTT id can be specified, otherwise `mqtt_id` will be assumed also as Thing name. ###### Thing.update_shadow ```#!py3 update_shadow(state)``` Update thing shadow with reported `state` state. `state` must be a dictionary containing only custom state keys and values: my_thing . update_shadow ({ 'publish_period' : 1000 }) ###### Thing.on_shadow_request ```#!py3 on_shadow_request(shadow_cbk)``` Set a callback to be called on shadow update requests. `shadow_cbk` callback will be called with a dictionary containing requested state as the only parameter: def shadow_callback ( requested ): print ( 'requested publish period:' , requested [ 'publish_period' ]) my_thing . on_shadow_request ( shadow_callback ) If a dictionary is returned, it is automatically published as reported state.","title":"Amazon Web Services IoT Library"},{"location":"reference/libs/aws/iot/docs/iot/#amazon-web-services-iot-library","text":"The Zerynth AWS IoT Library can be used to ease the connection to the AWS IoT platform . It allows to make your device act as an AWS IoT Thing which can be registered through AWS tools or directly from the Zerynth Toolchain. Check this video for a live demo: ## The Thing class ##### class Thing ```#!py3 class Thing(endpoint, mqtt_id, clicert, pkey, thingname=None, cacert=None)``` Create a Thing instance representing an AWS IoT Thing. The Thing object will contain an mqtt client instance pointing to AWS IoT MQTT broker located at `endpoint` endpoint. The client is configured with `mqtt_id` as MQTT id and is able to connect securely through AWS authorized `pkey` private key and `clicert` certificate (an optional `cacert` CA Certificate can also be passed). Refer to Zerynth SSL Context creation for admitted `pkey` values. The client is accessible through `mqtt` instance attribute and exposes all Zerynth MQTT Client methods so that it is possible, for example, to setup custom callback on MQTT commands. The only difference concerns mqtt.connect method which does not require broker url and ssl context, taking them from Thing configuration: my_thing = iot . Thing ( 'my_ep_id.iot.my_region.amazonaws.com' , 'my_thing_id' , clicert , pkey ) my_thing . mqtt . connect () ... my_thing . mqtt . loop () A `thingname` different from chosen MQTT id can be specified, otherwise `mqtt_id` will be assumed also as Thing name. ###### Thing.update_shadow ```#!py3 update_shadow(state)``` Update thing shadow with reported `state` state. `state` must be a dictionary containing only custom state keys and values: my_thing . update_shadow ({ 'publish_period' : 1000 }) ###### Thing.on_shadow_request ```#!py3 on_shadow_request(shadow_cbk)``` Set a callback to be called on shadow update requests. `shadow_cbk` callback will be called with a dictionary containing requested state as the only parameter: def shadow_callback ( requested ): print ( 'requested publish period:' , requested [ 'publish_period' ]) my_thing . on_shadow_request ( shadow_callback ) If a dictionary is returned, it is automatically published as reported state.","title":"Amazon Web Services IoT Library"},{"location":"reference/libs/aws/iot/docs/jobs/","text":"Amazon Web Services IoT Jobs Library \u00b6 The Zerynth AWS IoT Jobs Library can be used to handle IoT Jobs with ease. Jobs class \u00b6 class Jobs \u00b6 class Jobs ( thing ) This class allows the retrieval of the thing job list. It requires the connection to thw MQTT broker to be already established: It subscribes to various topic to receive jobs notifications. Jobs.changed \u00b6 changed () Return True if there are new pending jobs. If called again, and in the meantime no new job notifications have been received, return False. Jobs.list \u00b6 list () Retrieve the list of jobs for the current Thing. The result value is a tuple with two items. The first item is the list of IN_PROGRESS jobs, while the second item is the list of QUEUED jobs (as Job() instances). This method is blocking . Control is not released until the list of jobs is retrieved. Moreover, it is not safe to call the method from different threads. Job class \u00b6 class Job \u00b6 class Job ( thing , jobid ) This class abstracts an IoT Job related to a particular thing and having jobId jobid . There is no need to manually create instances of this class, they are returned by methods of the Jobs() class. Job.describe \u00b6 describe () Retrieves data about the job. In particular the fields version , status and document are associated to the job instance after a successful describe . This method is blocking . Control is not released until the job description is retrieved. Moreover, it is not safe to call the method from different threads. Return True on success, False otherwise. Job.update \u00b6 update ( status , status_details = {}) Updates the status of the job. The status can be one of the following class constant: Job.IN_PROGRESS Job.FAILED Job.SUCCEEDED The optional field status_details can contain custom values that are associated to the job status. This method is blocking . Control is not released until the status change is signaled. Moreover, it is not safe to call the method from different threads. Return True on success, False otherwise.","title":"Amazon Web Services IoT Jobs Library"},{"location":"reference/libs/aws/iot/docs/jobs/#amazon-web-services-iot-jobs-library","text":"The Zerynth AWS IoT Jobs Library can be used to handle IoT Jobs with ease.","title":"Amazon Web Services IoT Jobs Library"},{"location":"reference/libs/aws/iot/docs/jobs/#jobs-class","text":"","title":"Jobs class"},{"location":"reference/libs/aws/iot/docs/jobs/#class-jobs","text":"class Jobs ( thing ) This class allows the retrieval of the thing job list. It requires the connection to thw MQTT broker to be already established: It subscribes to various topic to receive jobs notifications.","title":"class Jobs"},{"location":"reference/libs/aws/iot/docs/jobs/#jobschanged","text":"changed () Return True if there are new pending jobs. If called again, and in the meantime no new job notifications have been received, return False.","title":"Jobs.changed"},{"location":"reference/libs/aws/iot/docs/jobs/#jobslist","text":"list () Retrieve the list of jobs for the current Thing. The result value is a tuple with two items. The first item is the list of IN_PROGRESS jobs, while the second item is the list of QUEUED jobs (as Job() instances). This method is blocking . Control is not released until the list of jobs is retrieved. Moreover, it is not safe to call the method from different threads.","title":"Jobs.list"},{"location":"reference/libs/aws/iot/docs/jobs/#job-class","text":"","title":"Job class"},{"location":"reference/libs/aws/iot/docs/jobs/#class-job","text":"class Job ( thing , jobid ) This class abstracts an IoT Job related to a particular thing and having jobId jobid . There is no need to manually create instances of this class, they are returned by methods of the Jobs() class.","title":"class Job"},{"location":"reference/libs/aws/iot/docs/jobs/#jobdescribe","text":"describe () Retrieves data about the job. In particular the fields version , status and document are associated to the job instance after a successful describe . This method is blocking . Control is not released until the job description is retrieved. Moreover, it is not safe to call the method from different threads. Return True on success, False otherwise.","title":"Job.describe"},{"location":"reference/libs/aws/iot/docs/jobs/#jobupdate","text":"update ( status , status_details = {}) Updates the status of the job. The status can be one of the following class constant: Job.IN_PROGRESS Job.FAILED Job.SUCCEEDED The optional field status_details can contain custom values that are associated to the job status. This method is blocking . Control is not released until the status change is signaled. Moreover, it is not safe to call the method from different threads. Return True on success, False otherwise.","title":"Job.update"},{"location":"reference/libs/azure/iot/docs/","text":"Microsoft Azure IoT Hub \u00b6 Microsoft Azure IoT Hub is the Microsoft Azure IoT platform to connect, monitor, and control billions of Internet of Things assets: Microsoft Azure Iot Hub . It is possible, for example, to connect to Microsoft Azure IoT Hub MQTT Broker to send device data and process/store those data with different Microsoft Azure services. Here below, the Zerynth Library to manage your devices thanks to Microsoft Azure IoT Hub: Contents: Microsoft Azure Iot Hub Library The Device class Examples Controlled publish period Direct methods and messages","title":"Microsoft Azure IoT Hub"},{"location":"reference/libs/azure/iot/docs/#microsoft-azure-iot-hub","text":"Microsoft Azure IoT Hub is the Microsoft Azure IoT platform to connect, monitor, and control billions of Internet of Things assets: Microsoft Azure Iot Hub . It is possible, for example, to connect to Microsoft Azure IoT Hub MQTT Broker to send device data and process/store those data with different Microsoft Azure services. Here below, the Zerynth Library to manage your devices thanks to Microsoft Azure IoT Hub: Contents: Microsoft Azure Iot Hub Library The Device class Examples Controlled publish period Direct methods and messages","title":"Microsoft Azure IoT Hub"},{"location":"reference/libs/azure/iot/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.azure.iot. Controlled Publish Period \u00b6 Connect your device to Azure Iot Hub and start publishing events at a default period, waiting for period updates requested as changes to device twin. main.py # Azure IoT Controlled publish period # Created at 2017-10-03 08:49:48.182639 import streams import json from wireless import wifi # choose a wifi chip supporting secure sockets from espressif.esp32net import esp32wifi as wifi_driver import requests # import azure iot module from azure.iot import iot # import helpers functions to easily load keys and device configuration import helpers # DEVICE KEY FILE MUST BE PLACED INSIDE PROJECT FOLDER new_resource ( 'private.base64.key' ) # set device configuration inside this json file new_resource ( 'device.conf.json' ) # define a callback for twin updates def twin_callback ( twin , version ): global publish_period print ( 'new twin version:' , version ) print ( 'requested publish period:' , twin [ 'publish_period' ]) publish_period = twin [ 'publish_period' ] return { 'publish_period' : publish_period } streams . serial () wifi_driver . auto_init () # place here your wifi configuration wifi . link ( \"SSID\" , wifi . WIFI_WPA2 , \"PSW\" ) pkey = helpers . load_key ( 'private.base64.key' ) device_conf = helpers . load_device_conf () publish_period = 5000 sample_th = 5 # choose an appropriate way to get a valid timestamp (may be available through hardware RTC) def get_timestamp (): user_agent = { \"user-agent\" : \"curl/7.56.0\" } return json . loads ( requests . get ( \"http://now.zerynth.com/\" , headers = user_agent ) . content )[ 'now' ][ 'epoch' ] # create an azure iot device instance, connect to mqtt broker, set twin callback and start mqtt reception loop device = iot . Device ( device_conf [ 'hub_id' ], device_conf [ 'device_id' ], device_conf [ 'api_version' ], pkey , get_timestamp ) device . mqtt . connect () device . on_twin_update ( twin_callback ) device . mqtt . loop () while True : print ( 'publish random sample...' ) sample = random ( 0 , 10 ) device . publish_event ({ 'asample' : sample }, { 'above_th' : sample > sample_th }) sleep ( publish_period ) Direct methods and messages \u00b6 Connect your device to Azure Iot Hub and wait for direct method calls or cloud to device messages. main.py # Azure IoT Direct methods and messages # Created at 2017-10-03 08:49:48.182639 import streams import json from wireless import wifi # choose a wifi chip supporting secure sockets from espressif.esp32net import esp32wifi as wifi_driver import requests # import azure iot module from azure.iot import iot # import helpers functions to easily load keys and device configuration import helpers # DEVICE KEY FILE MUST BE PLACED INSIDE PROJECT FOLDER new_resource ( 'private.base64.key' ) # set device configuration inside this json file new_resource ( 'device.conf.json' ) # define a callback for cloud to device messages def bound_callback ( msg , properties ): print ( 'received msg:' , msg ) print ( 'with properties:' , properties ) # define a callback for a cloud direct method def send_something ( method_payload ): return ( 0 ,{ 'something' : random ( 0 , 10 )}) streams . serial () wifi_driver . auto_init () # place here your wifi configuration wifi . link ( \"SSID\" , wifi . WIFI_WPA2 , \"PSW\" ) pkey = helpers . load_key ( 'private.base64.key' ) device_conf = helpers . load_device_conf () publish_period = 5000 sample_th = 5 # choose an appropriate way to get a valid timestamp (may be available through hardware RTC) def get_timestamp (): user_agent = { \"user-agent\" : \"curl/7.56.0\" } return json . loads ( requests . get ( \"http://now.zerynth.com/\" , headers = user_agent ) . content )[ 'now' ][ 'epoch' ] # create an azure iot device instance, connect to mqtt broker, set bound and method callbacks and start mqtt reception loop device = iot . Device ( device_conf [ 'hub_id' ], device_conf [ 'device_id' ], device_conf [ 'api_version' ], pkey , get_timestamp ) device . mqtt . connect () device . on_bound ( bound_callback ) device . on_method ( 'get' , send_something ) device . mqtt . loop () while True : print ( 'wait for directives from the Cloud...' ) sleep ( 5000 )","title":"Examples"},{"location":"reference/libs/azure/iot/docs/examples/#examples","text":"The following are a list of examples for lib.azure.iot.","title":"Examples"},{"location":"reference/libs/azure/iot/docs/examples/#controlled-publish-period","text":"Connect your device to Azure Iot Hub and start publishing events at a default period, waiting for period updates requested as changes to device twin. main.py # Azure IoT Controlled publish period # Created at 2017-10-03 08:49:48.182639 import streams import json from wireless import wifi # choose a wifi chip supporting secure sockets from espressif.esp32net import esp32wifi as wifi_driver import requests # import azure iot module from azure.iot import iot # import helpers functions to easily load keys and device configuration import helpers # DEVICE KEY FILE MUST BE PLACED INSIDE PROJECT FOLDER new_resource ( 'private.base64.key' ) # set device configuration inside this json file new_resource ( 'device.conf.json' ) # define a callback for twin updates def twin_callback ( twin , version ): global publish_period print ( 'new twin version:' , version ) print ( 'requested publish period:' , twin [ 'publish_period' ]) publish_period = twin [ 'publish_period' ] return { 'publish_period' : publish_period } streams . serial () wifi_driver . auto_init () # place here your wifi configuration wifi . link ( \"SSID\" , wifi . WIFI_WPA2 , \"PSW\" ) pkey = helpers . load_key ( 'private.base64.key' ) device_conf = helpers . load_device_conf () publish_period = 5000 sample_th = 5 # choose an appropriate way to get a valid timestamp (may be available through hardware RTC) def get_timestamp (): user_agent = { \"user-agent\" : \"curl/7.56.0\" } return json . loads ( requests . get ( \"http://now.zerynth.com/\" , headers = user_agent ) . content )[ 'now' ][ 'epoch' ] # create an azure iot device instance, connect to mqtt broker, set twin callback and start mqtt reception loop device = iot . Device ( device_conf [ 'hub_id' ], device_conf [ 'device_id' ], device_conf [ 'api_version' ], pkey , get_timestamp ) device . mqtt . connect () device . on_twin_update ( twin_callback ) device . mqtt . loop () while True : print ( 'publish random sample...' ) sample = random ( 0 , 10 ) device . publish_event ({ 'asample' : sample }, { 'above_th' : sample > sample_th }) sleep ( publish_period )","title":"Controlled Publish Period"},{"location":"reference/libs/azure/iot/docs/examples/#direct-methods-and-messages","text":"Connect your device to Azure Iot Hub and wait for direct method calls or cloud to device messages. main.py # Azure IoT Direct methods and messages # Created at 2017-10-03 08:49:48.182639 import streams import json from wireless import wifi # choose a wifi chip supporting secure sockets from espressif.esp32net import esp32wifi as wifi_driver import requests # import azure iot module from azure.iot import iot # import helpers functions to easily load keys and device configuration import helpers # DEVICE KEY FILE MUST BE PLACED INSIDE PROJECT FOLDER new_resource ( 'private.base64.key' ) # set device configuration inside this json file new_resource ( 'device.conf.json' ) # define a callback for cloud to device messages def bound_callback ( msg , properties ): print ( 'received msg:' , msg ) print ( 'with properties:' , properties ) # define a callback for a cloud direct method def send_something ( method_payload ): return ( 0 ,{ 'something' : random ( 0 , 10 )}) streams . serial () wifi_driver . auto_init () # place here your wifi configuration wifi . link ( \"SSID\" , wifi . WIFI_WPA2 , \"PSW\" ) pkey = helpers . load_key ( 'private.base64.key' ) device_conf = helpers . load_device_conf () publish_period = 5000 sample_th = 5 # choose an appropriate way to get a valid timestamp (may be available through hardware RTC) def get_timestamp (): user_agent = { \"user-agent\" : \"curl/7.56.0\" } return json . loads ( requests . get ( \"http://now.zerynth.com/\" , headers = user_agent ) . content )[ 'now' ][ 'epoch' ] # create an azure iot device instance, connect to mqtt broker, set bound and method callbacks and start mqtt reception loop device = iot . Device ( device_conf [ 'hub_id' ], device_conf [ 'device_id' ], device_conf [ 'api_version' ], pkey , get_timestamp ) device . mqtt . connect () device . on_bound ( bound_callback ) device . on_method ( 'get' , send_something ) device . mqtt . loop () while True : print ( 'wait for directives from the Cloud...' ) sleep ( 5000 )","title":"Direct methods and messages"},{"location":"reference/libs/azure/iot/docs/iot/","text":"Microsoft Azure Iot Hub Library \u00b6 The Zerynth Microsoft Azure Iot Hub Library can be used to ease the connection to Microsoft Azure Iot Hub . It allows to make your device act as a Microsoft Azure Iot Hub Device which can be registered through Azure command line tools or Azure web dashboard. The Device class \u00b6 class Device \u00b6 class Device ( hub_id , device_id , api_version , key , timestamp_fn , token_lifetime = 60 ) Create a Device instance representing a Microsoft Azure Iot Hub Device. The Device object will contain an mqtt client instance pointing to Microsoft Azure Iot Hub MQTT broker located at hub_id.azure-devices.net . The client is configured with device_id as MQTT id and is able to connect securely through TLS and authenticate through a SAS token with a token_lifetime minutes lifespan. Valid tokens generation process needs current timestamp which will be obtained calling passed timestamp_fn . timestamp_fn has to be a Python function returning an integer timestamp. A valid base64-encoded primary or secondary key key is also needed. The api_version string is mandatory to enable some responses from Azure MQTT broker on specific topics. The client is accessible through mqtt instance attribute and exposes all Zerynth MQTT Client methods so that it is possible, for example, to setup custom callbacks on MQTT commands (though the Device class already exposes high-level methods to setup Azure specific callbacks). The only difference concerns mqtt.connect method which does not require broker url and ssl context, taking them from Device configuration: def timestamp_fn (): valid_timestamp = 1509001724 return valid_timestamp key = \"ZhmdoNjyBccLrTnku0JxxVTTg8e94kleWTz9M+FJ9dk=\" my_device = iot . Device ( 'my-hub-id' , 'my-device-id' , '2017-06-30' , key , timestamp_fn ) my_device . mqtt . connect () ... my_device . mqtt . loop () Device.on_bound \u00b6 on_bound ( bound_cbk ) Set a callback to be called on cloud to device messages. bound_cbk callback will be called passing a string containing sent message and a dictionary containing sent properties: def bound_callback ( msg , properties ): print ( 'c2d msg:' , msg ) print ( 'with properties:' , properties ) my_device . on_bound ( bound_callback ) Device.on_method \u00b6 on_method ( method_name , method_cbk ) Set a callback to respond to a direct method call. method_cbk callback will be called in response to method_name method, passing a dictionary containing method payload (should be a valid JSON): def send_something ( method_payload ): if method_payload [ 'type' ] == 'random' : return ( 0 , { 'something' : random ( 0 , 10 )}) deterministic = 5 return ( 0 , { 'something' : deterministic }) my_device . on_method ( 'get' , send_something ) method_cbk callback must return a tuple containing response status and a dictionary or None as response payload. Device.on_twin_update \u00b6 on_twin_update ( twin_cbk ) Set a callback to respond to cloud twin updates. twin_cbk callback will be called when a twin update is notified by the cloud, passing a dictionary containing desired twin and an integer representing current twin version: def twin_callback ( twin , version ): print ( 'new twin version:' , version ) print ( twin ) my_device . on_twin_update ( twin_callback ) It is possible for twin_cbk to return a dictionary which will be immediately sent as reported twin. Device.report_twin \u00b6 report_twin ( reported , wait_confirm = True , timeout = 1000 ) Report reported twin. reported twin must be a dictionary and will be sent as JSON string. It is possible to not wait for cloud confirmation setting wait_confirm to false or to set a custom timeout ( -1 to wait forever) for the confirmation process which could lead to TimeoutException . An integer status code is returned after cloud confirmation. Device.get_twin \u00b6 get_twin ( timeout = 1000 ) Get current twin containing desired and reported fields. It is possible set a custom timeout ( -1 to wait forever) for the process which could lead to TimeoutException . An integer status code is returned after cloud response along with received twin JSON-parsed dictionary. Device.publish_event \u00b6 publish_event ( event , properties ) Publish a new event event with custom properties . event must be a dictionary and will be sent as json string. properties must be a dictionary and will be sent as an url-encoded property bag.","title":"Microsoft Azure Iot Hub Library"},{"location":"reference/libs/azure/iot/docs/iot/#microsoft-azure-iot-hub-library","text":"The Zerynth Microsoft Azure Iot Hub Library can be used to ease the connection to Microsoft Azure Iot Hub . It allows to make your device act as a Microsoft Azure Iot Hub Device which can be registered through Azure command line tools or Azure web dashboard.","title":"Microsoft Azure Iot Hub Library"},{"location":"reference/libs/azure/iot/docs/iot/#the-device-class","text":"","title":"The Device class"},{"location":"reference/libs/azure/iot/docs/iot/#class-device","text":"class Device ( hub_id , device_id , api_version , key , timestamp_fn , token_lifetime = 60 ) Create a Device instance representing a Microsoft Azure Iot Hub Device. The Device object will contain an mqtt client instance pointing to Microsoft Azure Iot Hub MQTT broker located at hub_id.azure-devices.net . The client is configured with device_id as MQTT id and is able to connect securely through TLS and authenticate through a SAS token with a token_lifetime minutes lifespan. Valid tokens generation process needs current timestamp which will be obtained calling passed timestamp_fn . timestamp_fn has to be a Python function returning an integer timestamp. A valid base64-encoded primary or secondary key key is also needed. The api_version string is mandatory to enable some responses from Azure MQTT broker on specific topics. The client is accessible through mqtt instance attribute and exposes all Zerynth MQTT Client methods so that it is possible, for example, to setup custom callbacks on MQTT commands (though the Device class already exposes high-level methods to setup Azure specific callbacks). The only difference concerns mqtt.connect method which does not require broker url and ssl context, taking them from Device configuration: def timestamp_fn (): valid_timestamp = 1509001724 return valid_timestamp key = \"ZhmdoNjyBccLrTnku0JxxVTTg8e94kleWTz9M+FJ9dk=\" my_device = iot . Device ( 'my-hub-id' , 'my-device-id' , '2017-06-30' , key , timestamp_fn ) my_device . mqtt . connect () ... my_device . mqtt . loop ()","title":"class Device"},{"location":"reference/libs/azure/iot/docs/iot/#deviceon_bound","text":"on_bound ( bound_cbk ) Set a callback to be called on cloud to device messages. bound_cbk callback will be called passing a string containing sent message and a dictionary containing sent properties: def bound_callback ( msg , properties ): print ( 'c2d msg:' , msg ) print ( 'with properties:' , properties ) my_device . on_bound ( bound_callback )","title":"Device.on_bound"},{"location":"reference/libs/azure/iot/docs/iot/#deviceon_method","text":"on_method ( method_name , method_cbk ) Set a callback to respond to a direct method call. method_cbk callback will be called in response to method_name method, passing a dictionary containing method payload (should be a valid JSON): def send_something ( method_payload ): if method_payload [ 'type' ] == 'random' : return ( 0 , { 'something' : random ( 0 , 10 )}) deterministic = 5 return ( 0 , { 'something' : deterministic }) my_device . on_method ( 'get' , send_something ) method_cbk callback must return a tuple containing response status and a dictionary or None as response payload.","title":"Device.on_method"},{"location":"reference/libs/azure/iot/docs/iot/#deviceon_twin_update","text":"on_twin_update ( twin_cbk ) Set a callback to respond to cloud twin updates. twin_cbk callback will be called when a twin update is notified by the cloud, passing a dictionary containing desired twin and an integer representing current twin version: def twin_callback ( twin , version ): print ( 'new twin version:' , version ) print ( twin ) my_device . on_twin_update ( twin_callback ) It is possible for twin_cbk to return a dictionary which will be immediately sent as reported twin.","title":"Device.on_twin_update"},{"location":"reference/libs/azure/iot/docs/iot/#devicereport_twin","text":"report_twin ( reported , wait_confirm = True , timeout = 1000 ) Report reported twin. reported twin must be a dictionary and will be sent as JSON string. It is possible to not wait for cloud confirmation setting wait_confirm to false or to set a custom timeout ( -1 to wait forever) for the confirmation process which could lead to TimeoutException . An integer status code is returned after cloud confirmation.","title":"Device.report_twin"},{"location":"reference/libs/azure/iot/docs/iot/#deviceget_twin","text":"get_twin ( timeout = 1000 ) Get current twin containing desired and reported fields. It is possible set a custom timeout ( -1 to wait forever) for the process which could lead to TimeoutException . An integer status code is returned after cloud response along with received twin JSON-parsed dictionary.","title":"Device.get_twin"},{"location":"reference/libs/azure/iot/docs/iot/#devicepublish_event","text":"publish_event ( event , properties ) Publish a new event event with custom properties . event must be a dictionary and will be sent as json string. properties must be a dictionary and will be sent as an url-encoded property bag.","title":"Device.publish_event"},{"location":"reference/libs/azure/sas/docs/","text":"Microsoft Azure Shared Access Signatures \u00b6 Microsoft Azure Shared Access Signatures provide a way to grant limited access to Microsoft Azure objects in a storage account to other clients, without exposing account keys. Contents: Azure Shared Access Signatures","title":"Microsoft Azure Shared Access Signatures"},{"location":"reference/libs/azure/sas/docs/#microsoft-azure-shared-access-signatures","text":"Microsoft Azure Shared Access Signatures provide a way to grant limited access to Microsoft Azure objects in a storage account to other clients, without exposing account keys. Contents: Azure Shared Access Signatures","title":"Microsoft Azure Shared Access Signatures"},{"location":"reference/libs/azure/sas/docs/sas/","text":"Azure Shared Access Signatures \u00b6 This module allows handling Azure Shared Access Signatures from Zerynth programs. generate \u00b6 generate ( uri , key , ttl , policy_name = None ) Generate a SAS for target uri signed with key valid till ttl (passed as epoch) and with optional policy_name .","title":"Azure Shared Access Signatures"},{"location":"reference/libs/azure/sas/docs/sas/#azure-shared-access-signatures","text":"This module allows handling Azure Shared Access Signatures from Zerynth programs.","title":"Azure Shared Access Signatures"},{"location":"reference/libs/azure/sas/docs/sas/#generate","text":"generate ( uri , key , ttl , policy_name = None ) Generate a SAS for target uri signed with key valid till ttl (passed as epoch) and with optional policy_name .","title":"generate"},{"location":"reference/libs/blockchain/ethereum/docs/","text":"Ethereum \u00b6 The Ethereum modules implement basic functionalities for interacting with the Ethereum blockchain. In particular, they allow: Creation of signed transactions Interaction with geth JSON-RPC endpoints (via rpc module) Execution of contract calls Contents: Ethereum Transaction class Contract class RPC RPC class RLP Examples Simple Transaction DiceGame","title":"Ethereum"},{"location":"reference/libs/blockchain/ethereum/docs/#ethereum","text":"The Ethereum modules implement basic functionalities for interacting with the Ethereum blockchain. In particular, they allow: Creation of signed transactions Interaction with geth JSON-RPC endpoints (via rpc module) Execution of contract calls Contents: Ethereum Transaction class Contract class RPC RPC class RLP Examples Simple Transaction DiceGame","title":"Ethereum"},{"location":"reference/libs/blockchain/ethereum/docs/ethereum/","text":"Ethereum \u00b6 This module allows the creation of transactions and makes it easy to call contracts. The Ethereum module is very easy to use: import streams from blockchain.ethereum import ethereum # prepare a transaction object tx = ethereum . Transaction () tx . set_value ( 1 , ethereum . FINNEY ) tx . set_gas_price ( \"0x430e23411\" ) tx . set_gas_limit ( \"0x33450\" ) tx . set_nonce ( 0 ) tx . set_receiver ( \"0xde9F276DDff83727fB627D2C0728b5bAeA469373\" ) tx . set_chain ( ethereum . ROPSTEN ) # Test network # sign the transaction with a private key tx . sign ( \"0xa5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5\" ) # print hex RLP representation print ( tx . to_rlp ( True )) # print Hashes print ( tx . hash ( False ) . hexdigest ()) print ( tx . hash ( True ) . hexdigest ()) # print full info print ( tx ) The following constants are defined: WEI , minimum transactable unit KWEI , 1000 WEI MWEI , one million WEI GWEI , one billion WEI SZABO , 1000 GWEI FINNEY , one million GWEI ETHER , one billion GWEI MAIN , identifier of the main network ROPSTEN , identifier of the ropsten network RINKEBY , identifier of the rinkeby network KOVAN , identifier of the kovan network get_address \u00b6 get_address ( pv ) Given the private key pv, return the corresponding Ethereum address pv can be given in both binary or hex format (starting with 0x). get_checksum_address \u00b6 get_checksum_address ( addr ) Given the the Ethereum address addr , return the checksummed address according to EIP 55 . Transaction class \u00b6 class Transaction \u00b6 class Transaction ( chain = MAIN ) Creates an instance of a Transaction on the network id specified by chain . The resulting Transaction instance is empty and invalid. The following parameters must be at least specified by calling the appropriate setters: receiver address value to transfer gas price gas limit transaction nonce Optionally, transaction data and network id can be set. Transaction.set_receiver \u00b6 set_receiver ( address ) Parameters: address \u2013 the receiver address in hex format starting with 0x. Set the receiver address to address . Transaction.set_value \u00b6 set_value ( value , unit = WEI ) Parameters: value \u2013 value to transfer as an hexadecimal string, bytes or integer unit \u2013 a unit constant, default WEI Convert value to big number format according to unit and set the resulting big number as the transaction value. Transaction.set_gas_price \u00b6 set_gas_price ( value , unit = WEI ) Parameters: value \u2013 gas price in hexadecimal format unit \u2013 a unit constant, default WEI Convert value to big number format according to unit and set the resulting big number as the transaction gas price. Transaction.set_gas_limt \u00b6 set_gas_limt ( value , unit = WEI ) Parameters: value \u2013 gas limit in hexadecimal format unit \u2013 a unit constant, default WEI Convert value to big number format according to unit and set the resulting big number as the transaction gas limit. Transaction.set_nonce \u00b6 set_nonce ( value ) Parameters: value \u2013 transaction nonce as integer Set transaction nonce. Transaction.set_data \u00b6 set_data ( value ) Parameters: value \u2013 binary representation of transaction data. Can be hexadecimal or bytes. Set transaction data to value . Transaction.set_chain \u00b6 set_chain ( chain ) Parameters: chain \u2013 integer representing the network id of the Ethereum network. Set the network id for the transaction. Transaction.to_rlp \u00b6 to_rlp ( hex ) Parameters: hex \u2013 boolean Return the RLP representation of the transaction in biney form. If hex is True, the hexadecimal representation is returned. Transaction.hash \u00b6 hash ( full = True ) Parameters: full \u2013 boolean Return a hash instance (Keccak) of the transaction. To obtain the binary or string hash, call the methods digest/hexdigest on the result. If full is False, fields v,r,s of the transaction are set to default values as specified in EIP-155 . Transaction.sign \u00b6 sign ( pv ) Parameters: pv \u2013 private key in hexadecimal or binary format. Generate a signed transaction according to EIP-155. Once signed, the transaction can be converted to RLP and broadcasted to the Ethereum network. Contract class \u00b6 class Contract \u00b6 class Contract ( rpc , contract_address , key = None , address = None , chain = MAIN ) Prepare the device to interact with an Ethereum Smart Contract. Create an instance of the Contract class to: call contract functions through paid transactions (functions modifying the blockchain) call contract functions through simple, gas-free calls (functions not modifying the blockchain) A device can interact with an already created contract placed at address contract_address . rpc must be a valid RPC instance. chain is the optional network id. key and address represent device address and key needed only if paid transactions are executed. Contract.register_function \u00b6 register_function ( function , gas_price = None , gas_limit = None , args_type = ()) Parameters: function \u2013 function name gas_price \u2013 gas price for function execution, can be None, an tuple (value, unit) or a single integer value which will be considered in WEI unit gas_limit \u2013 gas limit for function execution, can be None, an tuple (value, unit) or a single integer value which will be considered in WEI unit args_type \u2013 a tuple specifying function arguments\u2019 type following Ethereum ABI , at the moment only a subset of possible types is supported: address , uint<M> where 0 < M < 256 and M % 8 == 0 Contract.tx \u00b6 tx ( function , nonce , value , args = ()) Register a contract function to be called. Parameters: function \u2013 function to call nonce \u2013 transaction nonce as integer (can be obtained calling rpc.getTransactionCount) value \u2013 transaction value as a tuple (value,unit) or None args \u2013 call arguments as a tuple Contract.call \u00b6 call ( function , args = (), rv = None ) Call a previously registered function modifying the blockchain. Parameters: function \u2013 function to call args \u2013 call arguments as a tuple rv \u2013 return value: a tuple containing the number of expected bits and str or int to have respectively an hex string as the call return value or an integer obtained converting returned hex to decimal (e.g. (160, str) for a call returning an address) Call a previously registered function not modifying the blockchain.","title":"Ethereum"},{"location":"reference/libs/blockchain/ethereum/docs/ethereum/#ethereum","text":"This module allows the creation of transactions and makes it easy to call contracts. The Ethereum module is very easy to use: import streams from blockchain.ethereum import ethereum # prepare a transaction object tx = ethereum . Transaction () tx . set_value ( 1 , ethereum . FINNEY ) tx . set_gas_price ( \"0x430e23411\" ) tx . set_gas_limit ( \"0x33450\" ) tx . set_nonce ( 0 ) tx . set_receiver ( \"0xde9F276DDff83727fB627D2C0728b5bAeA469373\" ) tx . set_chain ( ethereum . ROPSTEN ) # Test network # sign the transaction with a private key tx . sign ( \"0xa5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5a5\" ) # print hex RLP representation print ( tx . to_rlp ( True )) # print Hashes print ( tx . hash ( False ) . hexdigest ()) print ( tx . hash ( True ) . hexdigest ()) # print full info print ( tx ) The following constants are defined: WEI , minimum transactable unit KWEI , 1000 WEI MWEI , one million WEI GWEI , one billion WEI SZABO , 1000 GWEI FINNEY , one million GWEI ETHER , one billion GWEI MAIN , identifier of the main network ROPSTEN , identifier of the ropsten network RINKEBY , identifier of the rinkeby network KOVAN , identifier of the kovan network","title":"Ethereum"},{"location":"reference/libs/blockchain/ethereum/docs/ethereum/#get_address","text":"get_address ( pv ) Given the private key pv, return the corresponding Ethereum address pv can be given in both binary or hex format (starting with 0x).","title":"get_address"},{"location":"reference/libs/blockchain/ethereum/docs/ethereum/#get_checksum_address","text":"get_checksum_address ( addr ) Given the the Ethereum address addr , return the checksummed address according to EIP 55 .","title":"get_checksum_address"},{"location":"reference/libs/blockchain/ethereum/docs/ethereum/#transaction-class","text":"","title":"Transaction class"},{"location":"reference/libs/blockchain/ethereum/docs/ethereum/#class-transaction","text":"class Transaction ( chain = MAIN ) Creates an instance of a Transaction on the network id specified by chain . The resulting Transaction instance is empty and invalid. The following parameters must be at least specified by calling the appropriate setters: receiver address value to transfer gas price gas limit transaction nonce Optionally, transaction data and network id can be set.","title":"class Transaction"},{"location":"reference/libs/blockchain/ethereum/docs/ethereum/#transactionset_receiver","text":"set_receiver ( address ) Parameters: address \u2013 the receiver address in hex format starting with 0x. Set the receiver address to address .","title":"Transaction.set_receiver"},{"location":"reference/libs/blockchain/ethereum/docs/ethereum/#transactionset_value","text":"set_value ( value , unit = WEI ) Parameters: value \u2013 value to transfer as an hexadecimal string, bytes or integer unit \u2013 a unit constant, default WEI Convert value to big number format according to unit and set the resulting big number as the transaction value.","title":"Transaction.set_value"},{"location":"reference/libs/blockchain/ethereum/docs/ethereum/#transactionset_gas_price","text":"set_gas_price ( value , unit = WEI ) Parameters: value \u2013 gas price in hexadecimal format unit \u2013 a unit constant, default WEI Convert value to big number format according to unit and set the resulting big number as the transaction gas price.","title":"Transaction.set_gas_price"},{"location":"reference/libs/blockchain/ethereum/docs/ethereum/#transactionset_gas_limt","text":"set_gas_limt ( value , unit = WEI ) Parameters: value \u2013 gas limit in hexadecimal format unit \u2013 a unit constant, default WEI Convert value to big number format according to unit and set the resulting big number as the transaction gas limit.","title":"Transaction.set_gas_limt"},{"location":"reference/libs/blockchain/ethereum/docs/ethereum/#transactionset_nonce","text":"set_nonce ( value ) Parameters: value \u2013 transaction nonce as integer Set transaction nonce.","title":"Transaction.set_nonce"},{"location":"reference/libs/blockchain/ethereum/docs/ethereum/#transactionset_data","text":"set_data ( value ) Parameters: value \u2013 binary representation of transaction data. Can be hexadecimal or bytes. Set transaction data to value .","title":"Transaction.set_data"},{"location":"reference/libs/blockchain/ethereum/docs/ethereum/#transactionset_chain","text":"set_chain ( chain ) Parameters: chain \u2013 integer representing the network id of the Ethereum network. Set the network id for the transaction.","title":"Transaction.set_chain"},{"location":"reference/libs/blockchain/ethereum/docs/ethereum/#transactionto_rlp","text":"to_rlp ( hex ) Parameters: hex \u2013 boolean Return the RLP representation of the transaction in biney form. If hex is True, the hexadecimal representation is returned.","title":"Transaction.to_rlp"},{"location":"reference/libs/blockchain/ethereum/docs/ethereum/#transactionhash","text":"hash ( full = True ) Parameters: full \u2013 boolean Return a hash instance (Keccak) of the transaction. To obtain the binary or string hash, call the methods digest/hexdigest on the result. If full is False, fields v,r,s of the transaction are set to default values as specified in EIP-155 .","title":"Transaction.hash"},{"location":"reference/libs/blockchain/ethereum/docs/ethereum/#transactionsign","text":"sign ( pv ) Parameters: pv \u2013 private key in hexadecimal or binary format. Generate a signed transaction according to EIP-155. Once signed, the transaction can be converted to RLP and broadcasted to the Ethereum network.","title":"Transaction.sign"},{"location":"reference/libs/blockchain/ethereum/docs/ethereum/#contract-class","text":"","title":"Contract class"},{"location":"reference/libs/blockchain/ethereum/docs/ethereum/#class-contract","text":"class Contract ( rpc , contract_address , key = None , address = None , chain = MAIN ) Prepare the device to interact with an Ethereum Smart Contract. Create an instance of the Contract class to: call contract functions through paid transactions (functions modifying the blockchain) call contract functions through simple, gas-free calls (functions not modifying the blockchain) A device can interact with an already created contract placed at address contract_address . rpc must be a valid RPC instance. chain is the optional network id. key and address represent device address and key needed only if paid transactions are executed.","title":"class Contract"},{"location":"reference/libs/blockchain/ethereum/docs/ethereum/#contractregister_function","text":"register_function ( function , gas_price = None , gas_limit = None , args_type = ()) Parameters: function \u2013 function name gas_price \u2013 gas price for function execution, can be None, an tuple (value, unit) or a single integer value which will be considered in WEI unit gas_limit \u2013 gas limit for function execution, can be None, an tuple (value, unit) or a single integer value which will be considered in WEI unit args_type \u2013 a tuple specifying function arguments\u2019 type following Ethereum ABI , at the moment only a subset of possible types is supported: address , uint<M> where 0 < M < 256 and M % 8 == 0","title":"Contract.register_function"},{"location":"reference/libs/blockchain/ethereum/docs/ethereum/#contracttx","text":"tx ( function , nonce , value , args = ()) Register a contract function to be called. Parameters: function \u2013 function to call nonce \u2013 transaction nonce as integer (can be obtained calling rpc.getTransactionCount) value \u2013 transaction value as a tuple (value,unit) or None args \u2013 call arguments as a tuple","title":"Contract.tx"},{"location":"reference/libs/blockchain/ethereum/docs/ethereum/#contractcall","text":"call ( function , args = (), rv = None ) Call a previously registered function modifying the blockchain. Parameters: function \u2013 function to call args \u2013 call arguments as a tuple rv \u2013 return value: a tuple containing the number of expected bits and str or int to have respectively an hex string as the call return value or an integer obtained converting returned hex to decimal (e.g. (160, str) for a call returning an address) Call a previously registered function not modifying the blockchain.","title":"Contract.call"},{"location":"reference/libs/blockchain/ethereum/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.blockchain.ethereum. Simple Transaction \u00b6 Transfer value from an address to another through an Ethereum transaction. In this example the Ropsten test network is used, so no real value is actually being transferred, but it acts exactly the same way that it would be in the real Ethereum network. Preparation \u00b6 Creating an address and get some Ether in it (MetaMask) \u00b6 Install the MetaMask browser extension from https://metamask.io/ Choose the Ropsten test network from top-right corner (instead of the main network) Request your first Ether from https://faucet.metamask.io/ , since we are using the test network, they have no real money value. Export and note your Ethereum private key from MetaMask pressing the three lines menu button, Details, Export private key (you will be promped for the password you created when you installed MetaMask). Registering to a RPC node (Infura) \u00b6 In order to interact with the Ethereum blockchain, a RPC node exposing API is needed. In this example we'll be using https://infura.io that offer this service for free. Register to their website and note your API key (e.g. 607c53ff4845226fa6c4b060fd1db12d). Configuring the example \u00b6 Edit the config.py file and change your Wi-Fi informations. In the same file insert your Ethereum address and private key. This is the address that your microcontroller will be using to send some currency. You can also customize the receiver address (e.g. you can return some Ether to the faucet address that you can copy from https://faucet.metamask.io/ ) and the amount of Wei to be sent (note that 1e18 Wei = 1 Ether). Running the example \u00b6 After completing the previous part, you should be able to run the code and make your first transaction. You can use https://ropsten.etherscan.io to real time monitor your address or transactions status. main.py import streams # Ethereum modules from blockchain.ethereum import ethereum from blockchain.ethereum import rpc # WiFi drivers from espressif.esp32net import esp32wifi as net_driver # for ESP-32 # from broadcom.bcm43362 import bcm43362 as net_driver # for Particle Photon from wireless import wifi # SSL module for https import ssl # Configuration file import config # The SSL context is needed to validate https certificates SSL_CTX = ssl . create_ssl_context ( cacert = config . CA_CERT , options = ssl . CERT_REQUIRED | ssl . SERVER_AUTH ) try : streams . serial () # Connect to WiFi network net_driver . auto_init () print ( \"Connecting to wifi\" ) wifi . link ( config . WIFI_SSID , wifi . WIFI_WPA2 , config . WIFI_PASSWORD ) print ( \"Connected!\" ) print ( \"Asking ethereum...\" ) # Init the RPC node eth = rpc . RPC ( config . RPC_URL , ssl_ctx = SSL_CTX ) # Get our current balance balance = eth . getBalance ( config . ADDRESS ) print ( \"Balance:\" , balance ) if not balance : print ( eth . last_error ) raise Exception # Get network informations print ( \"Gas Price:\" , eth . getGasPrice ()) nt = eth . getTransactionCount ( config . ADDRESS ) print ( \"TCount:\" , nt ) print ( \"Chain:\" , eth . getChainId ()) # Prepare a transaction object tx = ethereum . Transaction () tx . set_value ( config . WEI_AMOUNT , ethereum . WEI ) tx . set_gas_price ( \"0x430e23411\" ) tx . set_gas_limit ( \"0x33450\" ) tx . set_nonce ( nt ) tx . set_receiver ( config . RECEIVER_ADDRESS ) tx . set_chain ( ethereum . ROPSTEN ) # Sign the transaction with the private key tx . sign ( config . PRIVATE_KEY ) # Print hex RLP representation print ( tx . to_rlp ( True )) # Print hashes print ( tx . hash ( False ) . hexdigest ()) print ( tx . hash ( True ) . hexdigest ()) # Print full info print ( tx ) # Send the transaction tx_hash = eth . sendTransaction ( tx . to_rlp ( True )) print ( \"SENT!\" ) print ( \"Monitor your transaction at: \\n https://ropsten.etherscan.io/tx/ %s \" % tx_hash ) except Exception as e : print ( e ) while True : print ( \".\" ) sleep ( 10000 ) # Smart contract example \u00b6 This example shows how to call some smart contract functions, get the return value, or transfer Ether to a payable function. In this example the Ropsten test network is used, so no real value is actually being transferred, but it acts exactly the same way that it would be in the real Ethereum network. Game rules \u00b6 This smart contract act as shooter for a virtual 20-faces dice. A player can ask the shooter to roll the dice paying any amount (with a minimum 5 Wei) using the bet function. After rolling the dice, if the sum of the number is greater or equal to 14, the player wins the jackpot. In any case his bet becomes part of the jackpot itself. Note: the smart contract source code it's included in this example folder. A live version of the contract can be found on the Ropsten network at this address: 0xf7a270b24d2859002c0f414b0a0c97e4c794f5cc . Preparation \u00b6 Creating an address and get some Ether in it (MetaMask) \u00b6 Install the MetaMask browser extension from https://metamask.io/ Choose the Ropsten test network from top-right corner (instead of the main network) Request your first Ether from https://faucet.metamask.io/ , since we are using the test network, they have no real money value. Export and note your Ethereum private key from MetaMask pressing the three lines menu button, Details, Export private key (you will be prompted for the password you created when you installed MetaMask). Registering to a RPC node (Infura) \u00b6 In order to interact with the Ethereum blockchain, a RPC node exposing API is needed. In this example we'll be using https://infura.io that offer this service for free. Register to their website and note your API key (e.g. 607c53ff4845226fa6c4b060fd1db12d). Configuring the example \u00b6 Edit the config.py file and change your Wi-Fi informations. In the same file insert your Ethereum address and private key. This is the address that your microcontroller will be using to call the smart contract. Running the example \u00b6 After completing the previous part, you should be able to run the code and make your first bet. You can use https://ropsten.etherscan.io to real time monitor your address or transactions status. After your bet has been mined, check your balance to see if you won or just lost some Ether. main.py import streams # Ethereum modules from blockchain.ethereum import ethereum from blockchain.ethereum import rpc # WiFi drivers from espressif.esp32net import esp32wifi as net_driver # for ESP-32 # from broadcom.bcm43362 import bcm43362 as net_driver # for Particle Photon from wireless import wifi # SSL module for https import ssl # Configuration file import config # The SSL context is needed to validate https certificates SSL_CTX = ssl . create_ssl_context ( cacert = config . CA_CERT , options = ssl . CERT_REQUIRED | ssl . SERVER_AUTH ) # Use serial monitor streams . serial () def init_wifi (): # Connect to WiFi network net_driver . auto_init () print ( \"Connecting to wifi\" ) wifi . link ( config . WIFI_SSID , wifi . WIFI_WPA2 , config . WIFI_PASSWORD ) print ( \"Connected!\" ) def send_bet (): nt = eth . getTransactionCount ( config . ADDRESS ) tx = ethereum . Transaction () tx . set_value ( config . BET_AMOUNT , ethereum . WEI ) tx . set_gas_price ( config . GAS_PRICE ) tx . set_gas_limit ( \"0x33450\" ) tx . set_nonce ( nt ) tx . set_receiver ( config . CONTRACT_ADDRESS ) tx . set_chain ( ethereum . ROPSTEN ) tx . sign ( config . PRIVATE_KEY ) tx_hash = eth . sendTransaction ( tx . to_rlp ( True )) return tx_hash def print_balance (): # Get our current balance from the net balance = eth . getBalance ( config . ADDRESS ) print ( \"Current balance: \" , balance ) if not balance : print ( eth . last_error ) raise Exception # Main try : init_wifi () # Init the RPC node eth = rpc . RPC ( config . RPC_URL , ssl_ctx = SSL_CTX ) # Init smart contract object game = ethereum . Contract ( eth , config . CONTRACT_ADDRESS , config . PRIVATE_KEY , config . ADDRESS , chain = ethereum . ROPSTEN ) for name in config . CONTRACT_METHODS : method = config . CONTRACT_METHODS [ name ] game . register_function ( name , config . GAS_PRICE , method [ \"gas_limit\" ], args_type = method [ \"args\" ] ) # Run the game print_balance () jackpot = game . call ( 'getJackpot' , rv = ( 256 , str )) print ( 'Current jackpot: %s ' % jackpot ) print ( 'Betting %s Wei...' % config . BET_AMOUNT ) nonce = eth . getTransactionCount ( config . ADDRESS ) tx_hash = game . tx ( 'bet' , nonce , value = ( config . BET_AMOUNT , ethereum . WEI )) print ( 'Your bet has been placed, and the transaction is now being mined.' ) print ( 'Monitor your balance at https://ropsten.etherscan.io/address/ %s #internaltx to see if you won!' % config . ADDRESS ) print ( 'Reset your device to play again.' ) except Exception as e : print ( e ) while True : print ( \".\" ) sleep ( 10000 )","title":"Examples"},{"location":"reference/libs/blockchain/ethereum/docs/examples/#examples","text":"The following are a list of examples for lib.blockchain.ethereum.","title":"Examples"},{"location":"reference/libs/blockchain/ethereum/docs/examples/#simple-transaction","text":"Transfer value from an address to another through an Ethereum transaction. In this example the Ropsten test network is used, so no real value is actually being transferred, but it acts exactly the same way that it would be in the real Ethereum network.","title":"Simple Transaction"},{"location":"reference/libs/blockchain/ethereum/docs/examples/#preparation","text":"","title":"Preparation"},{"location":"reference/libs/blockchain/ethereum/docs/examples/#creating-an-address-and-get-some-ether-in-it-metamask","text":"Install the MetaMask browser extension from https://metamask.io/ Choose the Ropsten test network from top-right corner (instead of the main network) Request your first Ether from https://faucet.metamask.io/ , since we are using the test network, they have no real money value. Export and note your Ethereum private key from MetaMask pressing the three lines menu button, Details, Export private key (you will be promped for the password you created when you installed MetaMask).","title":"Creating an address and get some Ether in it (MetaMask)"},{"location":"reference/libs/blockchain/ethereum/docs/examples/#registering-to-a-rpc-node-infura","text":"In order to interact with the Ethereum blockchain, a RPC node exposing API is needed. In this example we'll be using https://infura.io that offer this service for free. Register to their website and note your API key (e.g. 607c53ff4845226fa6c4b060fd1db12d).","title":"Registering to a RPC node (Infura)"},{"location":"reference/libs/blockchain/ethereum/docs/examples/#configuring-the-example","text":"Edit the config.py file and change your Wi-Fi informations. In the same file insert your Ethereum address and private key. This is the address that your microcontroller will be using to send some currency. You can also customize the receiver address (e.g. you can return some Ether to the faucet address that you can copy from https://faucet.metamask.io/ ) and the amount of Wei to be sent (note that 1e18 Wei = 1 Ether).","title":"Configuring the example"},{"location":"reference/libs/blockchain/ethereum/docs/examples/#running-the-example","text":"After completing the previous part, you should be able to run the code and make your first transaction. You can use https://ropsten.etherscan.io to real time monitor your address or transactions status. main.py import streams # Ethereum modules from blockchain.ethereum import ethereum from blockchain.ethereum import rpc # WiFi drivers from espressif.esp32net import esp32wifi as net_driver # for ESP-32 # from broadcom.bcm43362 import bcm43362 as net_driver # for Particle Photon from wireless import wifi # SSL module for https import ssl # Configuration file import config # The SSL context is needed to validate https certificates SSL_CTX = ssl . create_ssl_context ( cacert = config . CA_CERT , options = ssl . CERT_REQUIRED | ssl . SERVER_AUTH ) try : streams . serial () # Connect to WiFi network net_driver . auto_init () print ( \"Connecting to wifi\" ) wifi . link ( config . WIFI_SSID , wifi . WIFI_WPA2 , config . WIFI_PASSWORD ) print ( \"Connected!\" ) print ( \"Asking ethereum...\" ) # Init the RPC node eth = rpc . RPC ( config . RPC_URL , ssl_ctx = SSL_CTX ) # Get our current balance balance = eth . getBalance ( config . ADDRESS ) print ( \"Balance:\" , balance ) if not balance : print ( eth . last_error ) raise Exception # Get network informations print ( \"Gas Price:\" , eth . getGasPrice ()) nt = eth . getTransactionCount ( config . ADDRESS ) print ( \"TCount:\" , nt ) print ( \"Chain:\" , eth . getChainId ()) # Prepare a transaction object tx = ethereum . Transaction () tx . set_value ( config . WEI_AMOUNT , ethereum . WEI ) tx . set_gas_price ( \"0x430e23411\" ) tx . set_gas_limit ( \"0x33450\" ) tx . set_nonce ( nt ) tx . set_receiver ( config . RECEIVER_ADDRESS ) tx . set_chain ( ethereum . ROPSTEN ) # Sign the transaction with the private key tx . sign ( config . PRIVATE_KEY ) # Print hex RLP representation print ( tx . to_rlp ( True )) # Print hashes print ( tx . hash ( False ) . hexdigest ()) print ( tx . hash ( True ) . hexdigest ()) # Print full info print ( tx ) # Send the transaction tx_hash = eth . sendTransaction ( tx . to_rlp ( True )) print ( \"SENT!\" ) print ( \"Monitor your transaction at: \\n https://ropsten.etherscan.io/tx/ %s \" % tx_hash ) except Exception as e : print ( e ) while True : print ( \".\" ) sleep ( 10000 )","title":"Running the example"},{"location":"reference/libs/blockchain/ethereum/docs/examples/#smart-contract-example","text":"This example shows how to call some smart contract functions, get the return value, or transfer Ether to a payable function. In this example the Ropsten test network is used, so no real value is actually being transferred, but it acts exactly the same way that it would be in the real Ethereum network.","title":"# Smart contract example"},{"location":"reference/libs/blockchain/ethereum/docs/examples/#game-rules","text":"This smart contract act as shooter for a virtual 20-faces dice. A player can ask the shooter to roll the dice paying any amount (with a minimum 5 Wei) using the bet function. After rolling the dice, if the sum of the number is greater or equal to 14, the player wins the jackpot. In any case his bet becomes part of the jackpot itself. Note: the smart contract source code it's included in this example folder. A live version of the contract can be found on the Ropsten network at this address: 0xf7a270b24d2859002c0f414b0a0c97e4c794f5cc .","title":"Game rules"},{"location":"reference/libs/blockchain/ethereum/docs/examples/#preparation_1","text":"","title":"Preparation"},{"location":"reference/libs/blockchain/ethereum/docs/examples/#creating-an-address-and-get-some-ether-in-it-metamask_1","text":"Install the MetaMask browser extension from https://metamask.io/ Choose the Ropsten test network from top-right corner (instead of the main network) Request your first Ether from https://faucet.metamask.io/ , since we are using the test network, they have no real money value. Export and note your Ethereum private key from MetaMask pressing the three lines menu button, Details, Export private key (you will be prompted for the password you created when you installed MetaMask).","title":"Creating an address and get some Ether in it (MetaMask)"},{"location":"reference/libs/blockchain/ethereum/docs/examples/#registering-to-a-rpc-node-infura_1","text":"In order to interact with the Ethereum blockchain, a RPC node exposing API is needed. In this example we'll be using https://infura.io that offer this service for free. Register to their website and note your API key (e.g. 607c53ff4845226fa6c4b060fd1db12d).","title":"Registering to a RPC node (Infura)"},{"location":"reference/libs/blockchain/ethereum/docs/examples/#configuring-the-example_1","text":"Edit the config.py file and change your Wi-Fi informations. In the same file insert your Ethereum address and private key. This is the address that your microcontroller will be using to call the smart contract.","title":"Configuring the example"},{"location":"reference/libs/blockchain/ethereum/docs/examples/#running-the-example_1","text":"After completing the previous part, you should be able to run the code and make your first bet. You can use https://ropsten.etherscan.io to real time monitor your address or transactions status. After your bet has been mined, check your balance to see if you won or just lost some Ether. main.py import streams # Ethereum modules from blockchain.ethereum import ethereum from blockchain.ethereum import rpc # WiFi drivers from espressif.esp32net import esp32wifi as net_driver # for ESP-32 # from broadcom.bcm43362 import bcm43362 as net_driver # for Particle Photon from wireless import wifi # SSL module for https import ssl # Configuration file import config # The SSL context is needed to validate https certificates SSL_CTX = ssl . create_ssl_context ( cacert = config . CA_CERT , options = ssl . CERT_REQUIRED | ssl . SERVER_AUTH ) # Use serial monitor streams . serial () def init_wifi (): # Connect to WiFi network net_driver . auto_init () print ( \"Connecting to wifi\" ) wifi . link ( config . WIFI_SSID , wifi . WIFI_WPA2 , config . WIFI_PASSWORD ) print ( \"Connected!\" ) def send_bet (): nt = eth . getTransactionCount ( config . ADDRESS ) tx = ethereum . Transaction () tx . set_value ( config . BET_AMOUNT , ethereum . WEI ) tx . set_gas_price ( config . GAS_PRICE ) tx . set_gas_limit ( \"0x33450\" ) tx . set_nonce ( nt ) tx . set_receiver ( config . CONTRACT_ADDRESS ) tx . set_chain ( ethereum . ROPSTEN ) tx . sign ( config . PRIVATE_KEY ) tx_hash = eth . sendTransaction ( tx . to_rlp ( True )) return tx_hash def print_balance (): # Get our current balance from the net balance = eth . getBalance ( config . ADDRESS ) print ( \"Current balance: \" , balance ) if not balance : print ( eth . last_error ) raise Exception # Main try : init_wifi () # Init the RPC node eth = rpc . RPC ( config . RPC_URL , ssl_ctx = SSL_CTX ) # Init smart contract object game = ethereum . Contract ( eth , config . CONTRACT_ADDRESS , config . PRIVATE_KEY , config . ADDRESS , chain = ethereum . ROPSTEN ) for name in config . CONTRACT_METHODS : method = config . CONTRACT_METHODS [ name ] game . register_function ( name , config . GAS_PRICE , method [ \"gas_limit\" ], args_type = method [ \"args\" ] ) # Run the game print_balance () jackpot = game . call ( 'getJackpot' , rv = ( 256 , str )) print ( 'Current jackpot: %s ' % jackpot ) print ( 'Betting %s Wei...' % config . BET_AMOUNT ) nonce = eth . getTransactionCount ( config . ADDRESS ) tx_hash = game . tx ( 'bet' , nonce , value = ( config . BET_AMOUNT , ethereum . WEI )) print ( 'Your bet has been placed, and the transaction is now being mined.' ) print ( 'Monitor your balance at https://ropsten.etherscan.io/address/ %s #internaltx to see if you won!' % config . ADDRESS ) print ( 'Reset your device to play again.' ) except Exception as e : print ( e ) while True : print ( \".\" ) sleep ( 10000 )","title":"Running the example"},{"location":"reference/libs/blockchain/ethereum/docs/rlp/","text":"RLP \u00b6 This module implements the RLP encoding scheme for the Ethereum protocol. encode \u00b6 encode ( obj ) Parameters: obj \u2013 the object to encode Return the RLP representation of obj . Only lists, tuples, strings, bytes/bytearrays and integers are allowed as types for obj.","title":"RLP"},{"location":"reference/libs/blockchain/ethereum/docs/rlp/#rlp","text":"This module implements the RLP encoding scheme for the Ethereum protocol.","title":"RLP"},{"location":"reference/libs/blockchain/ethereum/docs/rlp/#encode","text":"encode ( obj ) Parameters: obj \u2013 the object to encode Return the RLP representation of obj . Only lists, tuples, strings, bytes/bytearrays and integers are allowed as types for obj.","title":"encode"},{"location":"reference/libs/blockchain/ethereum/docs/rpc/","text":"RPC \u00b6 This module allows calling the JSON-RPC endpoints of a geth node. from blockchain.ethereum import rpc ... address = \"0x84db76Ea20C2f55F94A87440fBE825fBE5476da1\" # setup node address eth = rpc . RPC ( \"ethereum.zerynth.com:8545\" ) # retrieve balance print ( \"Balance:\" , eth . getBalance ( address )) print ( \"Gas Price:\" , eth . getGasPrice ()) nonce = eth . getTransactionCount ( address ) print ( \"Transaction Count:\" , nonce ) print ( \"Chain:\" , eth . getChainId ()) RPC class \u00b6 class RPC \u00b6 class RPC ( host ) Initialize a RPC instance with the get node at host . host must also contain the port and the protocol (i.e. https://mynode.com:8545 ) RPC.call \u00b6 call ( method , params = (), retry = 10 ) Parameters: method \u2013 the endpoint to call params \u2013 the list of parameters for the endpoint retry \u2013 the number of call retries before failing Call endpoint method with params params . Return the result field of the endpoint json response or None in case of error. Error reason can be retrieved in self.last_error . RPC.getBalance \u00b6 getBalance ( address , block_number = \"latest\" ) Params address: Ethereum address Params block_number: the point in the blockchain up to which balance is calculated Return the current balance for address address . Previous balances can be retrieved by specifying a different block_number . RPC.getGasPrice \u00b6 getGasPrice () Return the current gas price estimated by the Ethereum node. Return 0 on error. RPC.getChainId \u00b6 getChainId () Return the Ethereum network id. RPC.getTransactionCount \u00b6 getTransactionCount ( address , block_number = \"latest\" ) Parameters: address \u2013 Ethereum address block_number \u2013 the point in the blockchain up to which the transaction count is calculated Return the current transaction count for address address . The returned value can be used as nonce for the next transaction. Transaction counts at specific points in time can be retrieved by specifying a different block_number . RPC.sendTransaction \u00b6 sendTransaction ( tx , retry = 10 ) Parameters: tx \u2013 the hexadecimal hash of a signed transaction retry \u2013 the number of retries Send the raw transaction to the get node in order to broadcast it to all nodes in the network. If correct, it will be eventually added to a mined block. RPC.simpleCall \u00b6 simpleCall ( tx , block_number , retry = 10 ) Parameters: tx \u2013 the hexadecimal hash of a signed transaction block_number \u2013 the point in the blockchain up to which make the call retry \u2013 the number of retries Executes a new message call immediately without creating a transaction on the block chain.","title":"RPC"},{"location":"reference/libs/blockchain/ethereum/docs/rpc/#rpc","text":"This module allows calling the JSON-RPC endpoints of a geth node. from blockchain.ethereum import rpc ... address = \"0x84db76Ea20C2f55F94A87440fBE825fBE5476da1\" # setup node address eth = rpc . RPC ( \"ethereum.zerynth.com:8545\" ) # retrieve balance print ( \"Balance:\" , eth . getBalance ( address )) print ( \"Gas Price:\" , eth . getGasPrice ()) nonce = eth . getTransactionCount ( address ) print ( \"Transaction Count:\" , nonce ) print ( \"Chain:\" , eth . getChainId ())","title":"RPC"},{"location":"reference/libs/blockchain/ethereum/docs/rpc/#rpc-class","text":"","title":"RPC class"},{"location":"reference/libs/blockchain/ethereum/docs/rpc/#class-rpc","text":"class RPC ( host ) Initialize a RPC instance with the get node at host . host must also contain the port and the protocol (i.e. https://mynode.com:8545 )","title":"class RPC"},{"location":"reference/libs/blockchain/ethereum/docs/rpc/#rpccall","text":"call ( method , params = (), retry = 10 ) Parameters: method \u2013 the endpoint to call params \u2013 the list of parameters for the endpoint retry \u2013 the number of call retries before failing Call endpoint method with params params . Return the result field of the endpoint json response or None in case of error. Error reason can be retrieved in self.last_error .","title":"RPC.call"},{"location":"reference/libs/blockchain/ethereum/docs/rpc/#rpcgetbalance","text":"getBalance ( address , block_number = \"latest\" ) Params address: Ethereum address Params block_number: the point in the blockchain up to which balance is calculated Return the current balance for address address . Previous balances can be retrieved by specifying a different block_number .","title":"RPC.getBalance"},{"location":"reference/libs/blockchain/ethereum/docs/rpc/#rpcgetgasprice","text":"getGasPrice () Return the current gas price estimated by the Ethereum node. Return 0 on error.","title":"RPC.getGasPrice"},{"location":"reference/libs/blockchain/ethereum/docs/rpc/#rpcgetchainid","text":"getChainId () Return the Ethereum network id.","title":"RPC.getChainId"},{"location":"reference/libs/blockchain/ethereum/docs/rpc/#rpcgettransactioncount","text":"getTransactionCount ( address , block_number = \"latest\" ) Parameters: address \u2013 Ethereum address block_number \u2013 the point in the blockchain up to which the transaction count is calculated Return the current transaction count for address address . The returned value can be used as nonce for the next transaction. Transaction counts at specific points in time can be retrieved by specifying a different block_number .","title":"RPC.getTransactionCount"},{"location":"reference/libs/blockchain/ethereum/docs/rpc/#rpcsendtransaction","text":"sendTransaction ( tx , retry = 10 ) Parameters: tx \u2013 the hexadecimal hash of a signed transaction retry \u2013 the number of retries Send the raw transaction to the get node in order to broadcast it to all nodes in the network. If correct, it will be eventually added to a mined block.","title":"RPC.sendTransaction"},{"location":"reference/libs/blockchain/ethereum/docs/rpc/#rpcsimplecall","text":"simpleCall ( tx , block_number , retry = 10 ) Parameters: tx \u2013 the hexadecimal hash of a signed transaction block_number \u2013 the point in the blockchain up to which make the call retry \u2013 the number of retries Executes a new message call immediately without creating a transaction on the block chain.","title":"RPC.simpleCall"},{"location":"reference/libs/bosch/bme280/docs/","text":"Bosch BME280 \u00b6 The BME280 is an integrated environmental sensor developed specifically for mobile applications where size and low power consumption are key design constraints. More information at Bosch dedicated page . Technical Details \u00b6 Pressure range: 300 - 1100 hPa Temperature range: -40 - +85 \u00b0C Supply Voltage (Vdd): from 1.7 V to 3.6 V I2C and SPI interfaces Current consumption < 4uA @ 1Hz data refresh rate Here below, the Zerynth driver for the Bosch BME280. Contents: BME280 Module BME280 class Examples get values","title":"Bosch BME280"},{"location":"reference/libs/bosch/bme280/docs/#bosch-bme280","text":"The BME280 is an integrated environmental sensor developed specifically for mobile applications where size and low power consumption are key design constraints. More information at Bosch dedicated page .","title":"Bosch BME280"},{"location":"reference/libs/bosch/bme280/docs/#technical-details","text":"Pressure range: 300 - 1100 hPa Temperature range: -40 - +85 \u00b0C Supply Voltage (Vdd): from 1.7 V to 3.6 V I2C and SPI interfaces Current consumption < 4uA @ 1Hz data refresh rate Here below, the Zerynth driver for the Bosch BME280. Contents: BME280 Module BME280 class Examples get values","title":"Technical Details"},{"location":"reference/libs/bosch/bme280/docs/bme280/","text":"BME280 Module \u00b6 This module contains the Zerynth driver for Bosch BME280 digital environmental sensor. The unit combine high linearity and accuracy sensors for pressure, humidity and temperature and is designed for low current consumption, long term sability and high EMC robustness. The BME280 features I2C and SPI digital interfaces, the present library enables I2C only ( datasheet ). BME280 class \u00b6 class BME280 \u00b6 class BME280 ( drvname , addr = 0x76 , clk = 400000 ) Creates an intance of the BME280 class. Parameters: drvname \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x76 clk \u2013 Clock speed, default 400kHz Sensor\u2019s calibration data are automatically read on object creation and setup method is called with default parameters. Temperature, humidity and pressure values can be easily obtained from the sensor: from bosch.bme280 import bme280 ... bme = bme280 . BME280 ( I2C0 ) temp , hum , pres = bme . get_values () BME280.setup \u00b6 setup ( mode = 3 , os_t = 1 , os_h = 1 , os_p = 1 , t_sb = 6 , filter = 1 ) This method sets the operating mode and the sampling parameters of the module. Parameters: mode : Control the operating mode. Sleep mode is entered by default after power on reset. In sleep mode, no measurement are performed and all registers are accessible. In normal mode the sensor cycles between an active measurement period and an inactive standby period. In forced mode a single measurement is performed in accordance to the selected measurement and filter options, after which the sensor enter in sleep mode. mode Operating mode 0 Sleep Mode 1 or 2 Forced Mode 3 Normal Mode Note See pages 12-13 of the datasheet for more details on operating mode and allowed sensor mode transitions. os_t: Oversampling setting for temperature sensor, see os_p for details on allowed values. os_h: Oversampling setting for humidity sensor, see os_p for details on allowed values. os_p: Oversampling setting for pressure sensor. os_p Oversampling setting 0 Skipped (output set to 0) 1 oversampling 1x 2 oversampling 2x 3 oversampling 4x 4 oversampling 8x 5 oversampling 16x t_sb: Control the inactive duration t_standby in normal mode. t_sb t_standby [ms] 0 0.5 1 62.5 2 125 3 250 4 500 5 1000 6 10 7 20 filter: Control the time constant of the internal IIR filter. It reduces the bandwidth of the temperature and pressure output signals and increases the resolution of the pressure and temperature output data to 20 bit. filter Filter coefficient 0 Filter off 1 2 2 4 3 8 4 16 BME280.get_temp \u00b6 get_temp () Return the current temperature value in Celsius degree. BME280.get_hum \u00b6 get_hum () Return the current humidity value in %rH. BME280.get_press \u00b6 get_press () Return the current pressure value in Pascal. BME280.get_values \u00b6 get_values () Return a 3-element tuple containing current temperature, humidity and pressure values. BME280.soft_reset \u00b6 soft_reset () Reset the device using the complete power-on-reset procedure. BME280.get_status \u00b6 get_status () Return a two element long tuple representing the status of the sensor. The first element is equal to 1 whenever a conversion is running; it is equal to 0 when the results have been transferred to the data register. The second and last element of the returned tuple is euqal to 1 when the non-volatile memory data (calibration parameters) are being copied to image registers; it is equal to 0 when the copying is done. The data are copied at power-on-reset and before every conversion. BME280.get_chip_id \u00b6 get_chip_id () Return the device chip id as a single byte integer.","title":"BME280 Module"},{"location":"reference/libs/bosch/bme280/docs/bme280/#bme280-module","text":"This module contains the Zerynth driver for Bosch BME280 digital environmental sensor. The unit combine high linearity and accuracy sensors for pressure, humidity and temperature and is designed for low current consumption, long term sability and high EMC robustness. The BME280 features I2C and SPI digital interfaces, the present library enables I2C only ( datasheet ).","title":"BME280 Module"},{"location":"reference/libs/bosch/bme280/docs/bme280/#bme280-class","text":"","title":"BME280 class"},{"location":"reference/libs/bosch/bme280/docs/bme280/#class-bme280","text":"class BME280 ( drvname , addr = 0x76 , clk = 400000 ) Creates an intance of the BME280 class. Parameters: drvname \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x76 clk \u2013 Clock speed, default 400kHz Sensor\u2019s calibration data are automatically read on object creation and setup method is called with default parameters. Temperature, humidity and pressure values can be easily obtained from the sensor: from bosch.bme280 import bme280 ... bme = bme280 . BME280 ( I2C0 ) temp , hum , pres = bme . get_values ()","title":"class BME280"},{"location":"reference/libs/bosch/bme280/docs/bme280/#bme280setup","text":"setup ( mode = 3 , os_t = 1 , os_h = 1 , os_p = 1 , t_sb = 6 , filter = 1 ) This method sets the operating mode and the sampling parameters of the module. Parameters: mode : Control the operating mode. Sleep mode is entered by default after power on reset. In sleep mode, no measurement are performed and all registers are accessible. In normal mode the sensor cycles between an active measurement period and an inactive standby period. In forced mode a single measurement is performed in accordance to the selected measurement and filter options, after which the sensor enter in sleep mode. mode Operating mode 0 Sleep Mode 1 or 2 Forced Mode 3 Normal Mode Note See pages 12-13 of the datasheet for more details on operating mode and allowed sensor mode transitions. os_t: Oversampling setting for temperature sensor, see os_p for details on allowed values. os_h: Oversampling setting for humidity sensor, see os_p for details on allowed values. os_p: Oversampling setting for pressure sensor. os_p Oversampling setting 0 Skipped (output set to 0) 1 oversampling 1x 2 oversampling 2x 3 oversampling 4x 4 oversampling 8x 5 oversampling 16x t_sb: Control the inactive duration t_standby in normal mode. t_sb t_standby [ms] 0 0.5 1 62.5 2 125 3 250 4 500 5 1000 6 10 7 20 filter: Control the time constant of the internal IIR filter. It reduces the bandwidth of the temperature and pressure output signals and increases the resolution of the pressure and temperature output data to 20 bit. filter Filter coefficient 0 Filter off 1 2 2 4 3 8 4 16","title":"BME280.setup"},{"location":"reference/libs/bosch/bme280/docs/bme280/#bme280get_temp","text":"get_temp () Return the current temperature value in Celsius degree.","title":"BME280.get_temp"},{"location":"reference/libs/bosch/bme280/docs/bme280/#bme280get_hum","text":"get_hum () Return the current humidity value in %rH.","title":"BME280.get_hum"},{"location":"reference/libs/bosch/bme280/docs/bme280/#bme280get_press","text":"get_press () Return the current pressure value in Pascal.","title":"BME280.get_press"},{"location":"reference/libs/bosch/bme280/docs/bme280/#bme280get_values","text":"get_values () Return a 3-element tuple containing current temperature, humidity and pressure values.","title":"BME280.get_values"},{"location":"reference/libs/bosch/bme280/docs/bme280/#bme280soft_reset","text":"soft_reset () Reset the device using the complete power-on-reset procedure.","title":"BME280.soft_reset"},{"location":"reference/libs/bosch/bme280/docs/bme280/#bme280get_status","text":"get_status () Return a two element long tuple representing the status of the sensor. The first element is equal to 1 whenever a conversion is running; it is equal to 0 when the results have been transferred to the data register. The second and last element of the returned tuple is euqal to 1 when the non-volatile memory data (calibration parameters) are being copied to image registers; it is equal to 0 when the copying is done. The data are copied at power-on-reset and before every conversion.","title":"BME280.get_status"},{"location":"reference/libs/bosch/bme280/docs/bme280/#bme280get_chip_id","text":"get_chip_id () Return the device chip id as a single byte integer.","title":"BME280.get_chip_id"},{"location":"reference/libs/bosch/bme280/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.bosch.bme280. Read humidity, temperature and pressure values from BME280 \u00b6 Basic example to read the current values of relative humidity, temperature and atmoshperic pressure from Bosch sensor BME280. main.py ################################################################################ # Temperature, Humidity and Pressure Example # # Created: 2019-01-18 08:47:18.498321 # ################################################################################ import streams from bosch.bme280 import bme280 streams . serial () try : # Setup sensor print ( \"start...\" ) bme = bme280 . BME280 ( I2C0 ) print ( \"Ready!\" ) print ( \"--------------------------------------------------------\" ) except Exception as e : print ( \"Error: \" , e ) try : while True : temp , hum , pres = bme . get_values () print ( \"Temperature:\" , temp , \"C\" ) print ( \"Humidity:\" , hum , \"%\" ) print ( \"Pressure:\" , pres , \"Pa\" ) print ( \"--------------------------------------------------------\" ) sleep ( 5000 ) except Exception as e : print ( \"Error2: \" , e )","title":"Examples"},{"location":"reference/libs/bosch/bme280/docs/examples/#examples","text":"The following are a list of examples for lib.bosch.bme280.","title":"Examples"},{"location":"reference/libs/bosch/bme280/docs/examples/#read-humidity-temperature-and-pressure-values-from-bme280","text":"Basic example to read the current values of relative humidity, temperature and atmoshperic pressure from Bosch sensor BME280. main.py ################################################################################ # Temperature, Humidity and Pressure Example # # Created: 2019-01-18 08:47:18.498321 # ################################################################################ import streams from bosch.bme280 import bme280 streams . serial () try : # Setup sensor print ( \"start...\" ) bme = bme280 . BME280 ( I2C0 ) print ( \"Ready!\" ) print ( \"--------------------------------------------------------\" ) except Exception as e : print ( \"Error: \" , e ) try : while True : temp , hum , pres = bme . get_values () print ( \"Temperature:\" , temp , \"C\" ) print ( \"Humidity:\" , hum , \"%\" ) print ( \"Pressure:\" , pres , \"Pa\" ) print ( \"--------------------------------------------------------\" ) sleep ( 5000 ) except Exception as e : print ( \"Error2: \" , e )","title":"Read humidity, temperature and pressure values from BME280"},{"location":"reference/libs/bosch/bmp180/docs/","text":"BOSCH BMP180 \u00b6 The BMP180 is a digital fully calibrated barometric pressure sensor of Bosch Sensortec, with a very high performance. This sensor enables applications in advanced mobile devices, such as smartphones, tablet PCs and sports devices. The ultra-low power consumption down to 3 \u03bcA makes the BMP180 one of the best sensor in terms of power saving for your mobile devices. For optimum system integration the BMP180 is equipped with digital bidirectional I2C interface; Typical applications can regard indoor navigation, GPS-enhancement (for dead-reckoning, slope detection, etc.), weather forecast, vertical velocity indication (rise/sink speed), and many more. More information at Bosch dedicated page . Technical Details \u00b6 Supply Voltage (Vdd): from 1.8 V to 3.6 V Operation Temperature (Top): from -40 \u00b0C to 85 \u00b0C Pressure Range: from 300 to 1100 hPa (from 9000 to -500 m relating to sea level) Pressure Accuracy (Vdd=3.3V, Pressure and temperature in range): from -4.0 to +2.0 hPa Pressure Resolution: 0.01 hPa Temperature Range: from 0 to 65 \u00b0C Temperature Accuracy (Vdd=3.3V, Pressure and temperature in range): \u00b1 1 \u00b0C Temperature Resolution: 0.1 \u00b0C Power Consumption (Vbat=3V): from 3 to 12 \u00b5A at 1 sample/sec and Top=25\u00b0C I\u00b2C interface Here below, the Zerynth driver for the BOSCH BMP180. Contents: BMP180 Module Examples get temp press alt","title":"BOSCH BMP180"},{"location":"reference/libs/bosch/bmp180/docs/#bosch-bmp180","text":"The BMP180 is a digital fully calibrated barometric pressure sensor of Bosch Sensortec, with a very high performance. This sensor enables applications in advanced mobile devices, such as smartphones, tablet PCs and sports devices. The ultra-low power consumption down to 3 \u03bcA makes the BMP180 one of the best sensor in terms of power saving for your mobile devices. For optimum system integration the BMP180 is equipped with digital bidirectional I2C interface; Typical applications can regard indoor navigation, GPS-enhancement (for dead-reckoning, slope detection, etc.), weather forecast, vertical velocity indication (rise/sink speed), and many more. More information at Bosch dedicated page .","title":"BOSCH BMP180"},{"location":"reference/libs/bosch/bmp180/docs/#technical-details","text":"Supply Voltage (Vdd): from 1.8 V to 3.6 V Operation Temperature (Top): from -40 \u00b0C to 85 \u00b0C Pressure Range: from 300 to 1100 hPa (from 9000 to -500 m relating to sea level) Pressure Accuracy (Vdd=3.3V, Pressure and temperature in range): from -4.0 to +2.0 hPa Pressure Resolution: 0.01 hPa Temperature Range: from 0 to 65 \u00b0C Temperature Accuracy (Vdd=3.3V, Pressure and temperature in range): \u00b1 1 \u00b0C Temperature Resolution: 0.1 \u00b0C Power Consumption (Vbat=3V): from 3 to 12 \u00b5A at 1 sample/sec and Top=25\u00b0C I\u00b2C interface Here below, the Zerynth driver for the BOSCH BMP180. Contents: BMP180 Module Examples get temp press alt","title":"Technical Details"},{"location":"reference/libs/bosch/bmp180/docs/bmp180/","text":"BMP180 Module \u00b6 This module contains the driver for BOSCH BMP180 Digital Barometric Pressure Sensor. The ultra-low power, low voltage electronics of the BMP180 is optimized for use in mobile devices and the I2C interface allows for easy system integration with a microcontroller. The BMP180 is based on piezo-resistive technology for EMC robustness, high accuracy and linearity as well as long term stability ( datasheet ). class BMP180 \u00b6 class BMP180 ( i2cdrv , addr = 0x77 , clk = 100000 ) Creates an instance of a new BMP180. Arguments: i2cdrv \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x77 clk \u2013 Clock speed, default 100kHz Example: from bosch.bmp180 import bmp180 ... bmp = bmp180 . BMP180 ( I2C0 ) bmp . start () bmp . init () temp , pres = bmp . get_temp_pres () BMP180.init \u00b6 init ( oss = 0 ) Initialize the BMP180 calibrating the sensor and setting the oss value. Arguments: oss \u2013 OverSampling Setting value (from 0 to 4), default 0 BMP180.set_over_sampling_setting \u00b6 set_over_sampling_setting ( oss ) Sets the OverSampling Setting value of the BMP180. Arguments: oss \u2013 OverSampling Setting value (from 0 to 4 allowed) Note The OverSampling Setting parameter selects different operating modes according to give the possibility for findind the optimum compromise between power consumption, speed, and resolution; in the table below allowed values are reported with related operating modes. OSS param Operating Mode N of samples Conversion time Avg Current 1 sample/s 0 Ultra Low Power 1 4.5 ms 3 uA 1 Standard 2 7.5 ms 5 uA 2 High Resolution 4 13.5 ms 7 uA 3 Ultra High Resolution 8 25.5 ms 12 uA BMP180.get_raw_temp \u00b6 get_raw_temp () Retrieves the current temperature data from the sensor as raw value. Returns raw_t. BMP180.get_raw_pres \u00b6 get_raw_pres () Retrieves the current pressure data from the sensor as raw value; according to the OverSampling Setting value this measure can be faster but less accurate or more precise but slower. (see set_over_sampling_setting() ) Returns raw_p. BMP180.get_temp \u00b6 get_temp () Retrieves the current temperature data from the sensor as calibrate value in \u00b0C. Returns temp. BMP180.get_pres \u00b6 get_pres () Retrieves the current pressure data from the sensor as calibrate value in Pa; according to the OverSampling Setting value this measure can be faster but less accurate or more precise but slower. (see set_over_sampling_setting() ) Returns pres. BMP180.get_temp_pres \u00b6 get_temp_pres () Retrieves the current temperature (in \u00b0C) and pressure (in Pa) data from the sensor as calibrate values in one call. Returns temp. BMP180.get_altitude \u00b6 get_altitude () Calculates, from measured pressure, the current altitude data as value in meters. Returns altitude. BMP180.get_sea_level_pres \u00b6 get_sea_level_pres () Calculates, from measured pressure, the pressure (in Pa) at sea level when given a known altitude in meters. Returns p0 (pressure at sea level).","title":"BMP180 Module"},{"location":"reference/libs/bosch/bmp180/docs/bmp180/#bmp180-module","text":"This module contains the driver for BOSCH BMP180 Digital Barometric Pressure Sensor. The ultra-low power, low voltage electronics of the BMP180 is optimized for use in mobile devices and the I2C interface allows for easy system integration with a microcontroller. The BMP180 is based on piezo-resistive technology for EMC robustness, high accuracy and linearity as well as long term stability ( datasheet ).","title":"BMP180 Module"},{"location":"reference/libs/bosch/bmp180/docs/bmp180/#class-bmp180","text":"class BMP180 ( i2cdrv , addr = 0x77 , clk = 100000 ) Creates an instance of a new BMP180. Arguments: i2cdrv \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x77 clk \u2013 Clock speed, default 100kHz Example: from bosch.bmp180 import bmp180 ... bmp = bmp180 . BMP180 ( I2C0 ) bmp . start () bmp . init () temp , pres = bmp . get_temp_pres ()","title":"class BMP180"},{"location":"reference/libs/bosch/bmp180/docs/bmp180/#bmp180init","text":"init ( oss = 0 ) Initialize the BMP180 calibrating the sensor and setting the oss value. Arguments: oss \u2013 OverSampling Setting value (from 0 to 4), default 0","title":"BMP180.init"},{"location":"reference/libs/bosch/bmp180/docs/bmp180/#bmp180set_over_sampling_setting","text":"set_over_sampling_setting ( oss ) Sets the OverSampling Setting value of the BMP180. Arguments: oss \u2013 OverSampling Setting value (from 0 to 4 allowed) Note The OverSampling Setting parameter selects different operating modes according to give the possibility for findind the optimum compromise between power consumption, speed, and resolution; in the table below allowed values are reported with related operating modes. OSS param Operating Mode N of samples Conversion time Avg Current 1 sample/s 0 Ultra Low Power 1 4.5 ms 3 uA 1 Standard 2 7.5 ms 5 uA 2 High Resolution 4 13.5 ms 7 uA 3 Ultra High Resolution 8 25.5 ms 12 uA","title":"BMP180.set_over_sampling_setting"},{"location":"reference/libs/bosch/bmp180/docs/bmp180/#bmp180get_raw_temp","text":"get_raw_temp () Retrieves the current temperature data from the sensor as raw value. Returns raw_t.","title":"BMP180.get_raw_temp"},{"location":"reference/libs/bosch/bmp180/docs/bmp180/#bmp180get_raw_pres","text":"get_raw_pres () Retrieves the current pressure data from the sensor as raw value; according to the OverSampling Setting value this measure can be faster but less accurate or more precise but slower. (see set_over_sampling_setting() ) Returns raw_p.","title":"BMP180.get_raw_pres"},{"location":"reference/libs/bosch/bmp180/docs/bmp180/#bmp180get_temp","text":"get_temp () Retrieves the current temperature data from the sensor as calibrate value in \u00b0C. Returns temp.","title":"BMP180.get_temp"},{"location":"reference/libs/bosch/bmp180/docs/bmp180/#bmp180get_pres","text":"get_pres () Retrieves the current pressure data from the sensor as calibrate value in Pa; according to the OverSampling Setting value this measure can be faster but less accurate or more precise but slower. (see set_over_sampling_setting() ) Returns pres.","title":"BMP180.get_pres"},{"location":"reference/libs/bosch/bmp180/docs/bmp180/#bmp180get_temp_pres","text":"get_temp_pres () Retrieves the current temperature (in \u00b0C) and pressure (in Pa) data from the sensor as calibrate values in one call. Returns temp.","title":"BMP180.get_temp_pres"},{"location":"reference/libs/bosch/bmp180/docs/bmp180/#bmp180get_altitude","text":"get_altitude () Calculates, from measured pressure, the current altitude data as value in meters. Returns altitude.","title":"BMP180.get_altitude"},{"location":"reference/libs/bosch/bmp180/docs/bmp180/#bmp180get_sea_level_pres","text":"get_sea_level_pres () Calculates, from measured pressure, the pressure (in Pa) at sea level when given a known altitude in meters. Returns p0 (pressure at sea level).","title":"BMP180.get_sea_level_pres"},{"location":"reference/libs/bosch/bmp180/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.bosch.bmp180. Temperature, Pressure, Altitude \u00b6 Get Temperature, Pressure, and Altitude throught the BMP180 sensor features. main.py ################################################################################ # Get Temperature, Pressure, and Altitude Example # # Created: 2017-02-28 16:44:15.135468 # ################################################################################ from bosch.bmp180 import bmp180 import streams streams . serial () # Setup sensor # This setup is referred to bmp180 mounted on 10DOF Click in slot A of a Flip n Click device bmp = bmp180 . BMP180 ( I2C0 ) print ( \"start...\" ) bmp . start () print ( \"init...\" ) bmp . init () print ( \"Ready!\" ) print ( \"--------------------------------------------------------\" ) while True : rt = bmp . get_raw_temp () # Read raw temperature print ( \"Raw Temperature: \" , rt ) rp = bmp . get_raw_pres () # Read raw pressure print ( \"Raw Pressure: \" , rp ) temp = bmp . get_temp () # Read temperature print ( \"Temperature: \" , temp , \"C\" ) pres = bmp . get_pres () # Read pressure print ( \"Pressure: \" , pres , \"Pa\" ) temp , pres = bmp . get_temp_pres () # Read both (temperature and pressure) print ( \"Temp: \" , temp , \"C and Pres:\" , pres , \"Pa\" ) altitude = bmp . get_altitude () # Read altitude print ( \"Altitude: \" , altitude , \"m\" ) slp = bmp . get_sea_level_pres ( altitude_m = altitude ) # Read pressure at level sea print ( \"Pressure at level sea: \" , slp , \"Pa\" ) print ( \"--------------------------------------------------------\" ) sleep ( 5000 )","title":"Examples"},{"location":"reference/libs/bosch/bmp180/docs/examples/#examples","text":"The following are a list of examples for lib.bosch.bmp180.","title":"Examples"},{"location":"reference/libs/bosch/bmp180/docs/examples/#temperature-pressure-altitude","text":"Get Temperature, Pressure, and Altitude throught the BMP180 sensor features. main.py ################################################################################ # Get Temperature, Pressure, and Altitude Example # # Created: 2017-02-28 16:44:15.135468 # ################################################################################ from bosch.bmp180 import bmp180 import streams streams . serial () # Setup sensor # This setup is referred to bmp180 mounted on 10DOF Click in slot A of a Flip n Click device bmp = bmp180 . BMP180 ( I2C0 ) print ( \"start...\" ) bmp . start () print ( \"init...\" ) bmp . init () print ( \"Ready!\" ) print ( \"--------------------------------------------------------\" ) while True : rt = bmp . get_raw_temp () # Read raw temperature print ( \"Raw Temperature: \" , rt ) rp = bmp . get_raw_pres () # Read raw pressure print ( \"Raw Pressure: \" , rp ) temp = bmp . get_temp () # Read temperature print ( \"Temperature: \" , temp , \"C\" ) pres = bmp . get_pres () # Read pressure print ( \"Pressure: \" , pres , \"Pa\" ) temp , pres = bmp . get_temp_pres () # Read both (temperature and pressure) print ( \"Temp: \" , temp , \"C and Pres:\" , pres , \"Pa\" ) altitude = bmp . get_altitude () # Read altitude print ( \"Altitude: \" , altitude , \"m\" ) slp = bmp . get_sea_level_pres ( altitude_m = altitude ) # Read pressure at level sea print ( \"Pressure at level sea: \" , slp , \"Pa\" ) print ( \"--------------------------------------------------------\" ) sleep ( 5000 )","title":"Temperature, Pressure, Altitude"},{"location":"reference/libs/bosch/bno055/docs/","text":"BOSCH BNO055 \u00b6 The BNO055 is an Application Specific Sensor Nodes (ASSN) implementing an intelligent 9-axis Absolute Orientation Sensor. It eases the integration process for customers, freeing them from the complexities of multivendor solutions so they can spend more time on product innovation, including novel applications such as wearable hardware. For optimum system integration the BNO055 is equipped with digital bidirectional I2C interface; Typical applications can regard Navigation, Robotics, Fitness and well-being, Augmented reality, Context awareness, Tablets and ultra-books. More information at Bosch dedicated page . Technical Details \u00b6 Supply Voltage (Vdd): from 2.4 V to 3.6 V Operation Temperature (Top): from -40 \u00b0C to 85 \u00b0C Triaxial 16bit gyroscope with ranges switchable from \u00b1125\u00b0/s to \u00b12000\u00b0/s Triaxial 14bit accelerometer with acceleration ranges \u00b12g/\u00b14g/\u00b18g/\u00b116g Geomagnetic sensor with magnetic field range typical \u00b11300\u00b5T (x-, y-axis) and \u00b12500\u00b5T (z-axis) Power Consumption (Vbat=3V): max 12.3 mA (Normal Mode @100Hz output data rate) I\u00b2C interface Here below, the Zerynth driver for the BOSCH BNO055. Contents: BNO055 Module Examples get acceleration inclination alarm","title":"BOSCH BNO055"},{"location":"reference/libs/bosch/bno055/docs/#bosch-bno055","text":"The BNO055 is an Application Specific Sensor Nodes (ASSN) implementing an intelligent 9-axis Absolute Orientation Sensor. It eases the integration process for customers, freeing them from the complexities of multivendor solutions so they can spend more time on product innovation, including novel applications such as wearable hardware. For optimum system integration the BNO055 is equipped with digital bidirectional I2C interface; Typical applications can regard Navigation, Robotics, Fitness and well-being, Augmented reality, Context awareness, Tablets and ultra-books. More information at Bosch dedicated page .","title":"BOSCH BNO055"},{"location":"reference/libs/bosch/bno055/docs/#technical-details","text":"Supply Voltage (Vdd): from 2.4 V to 3.6 V Operation Temperature (Top): from -40 \u00b0C to 85 \u00b0C Triaxial 16bit gyroscope with ranges switchable from \u00b1125\u00b0/s to \u00b12000\u00b0/s Triaxial 14bit accelerometer with acceleration ranges \u00b12g/\u00b14g/\u00b18g/\u00b116g Geomagnetic sensor with magnetic field range typical \u00b11300\u00b5T (x-, y-axis) and \u00b12500\u00b5T (z-axis) Power Consumption (Vbat=3V): max 12.3 mA (Normal Mode @100Hz output data rate) I\u00b2C interface Here below, the Zerynth driver for the BOSCH BNO055. Contents: BNO055 Module Examples get acceleration inclination alarm","title":"Technical Details"},{"location":"reference/libs/bosch/bno055/docs/bno055/","text":"BNO055 Module \u00b6 This module contains the driver for BOSCH BNO055 9-axis Absolute Orientation Sensor. The BNO055 is a System in Package (SiP), integrating a triaxial 14-bit accelerometer, a triaxial 16-bit gyroscope with a range of \u00b12000 degrees per second, a triaxial geomagnetic sensor ( datasheet ). class BNO055 \u00b6 class BNO055 ( i2cdrv , addr = 0x28 , clk = 100000 ) Creates an intance of a new BNO055. Arguments: i2cdrv \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x28 clk \u2013 Clock speed, default 100kHz Example: from bosch.bno055 import bno055 ... bno = bno055 . BNO055 ( I2C0 ) bno . start () bno . init () abs_orientation = bno . get_euler () BNO055.init \u00b6 init ( mode = None ) Initialize the BNO055 setting the mode value. Arguments: - mode \u2013 Mode value selectable from Mode table (refer to page 20 of the BNO055 datasheet), default None BNO055.set_mode \u00b6 set_mode ( mode ) Sets the Mode value of the BNO055. Arguments: mode \u2013 Mode value (refer to page 20 of the BNO055 datasheet) Note The BNO055 provides a variety of output signals, which can be chosen by selecting the appropriate operation mode. The table below lists the different modes and the available sensor signals. .tg {border-collapse:collapse;border-spacing:0;} .tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px; overflow:hidden;padding:10px 5px;word-break:normal;} .tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px; font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;} .tg .tg-htbt{background-color:#FFF;border-color:inherit;color:#404040;text-align:left;vertical-align:middle} .tg .tg-zatc{background-color:#FFF;border-color:inherit;color:#404040;font-weight:bold;text-align:left;vertical-align:bottom} .tg .tg-5ncm{background-color:#F3F6F6;border-color:inherit;color:#404040;text-align:left;vertical-align:middle} Mode Available Library Functions Value Name get_acc() get_magn() get_gyro() get_euler() acc ACCONLY Yes No No No magn MAGONLY No Yes No No gyro GYROONLY No No Yes No accmag ACCMAG Yes Yes No No accgyro ACCGYRO Yes No Yes No maggyro MAGGYRO No Yes Yes No amg AMG No Yes Yes No imu IMU Yes No Yes Yes comp COMPASS Yes Yes No Yes m4g M4G Yes Yes Yes Yes ndof_off NDOF_FMC_OFF No Yes Yes Yes ndof NDOF Yes Yes Yes Yes BNO055.get_calibration_status \u00b6 get_calibration_status () Retrieves the current calibration status of the BNO055 main components: System Accelerometer Gyroscope Magnetometer Note Read: 3 indicates fully calibrated; 0 indicates not calibrated. Returns [sys_cal_sts, acc_cal_sts, gyro_cal_sts, magn_cal_sts]. BNO055get_calibration \u00b6 get_calibration ( raw = False ) Retrieves the calibration values of the BNO055 main components (list of 11 elements): Accelerometer Offset for X, Y, Z axes (values in m/s\u00b2) - list elements 0,1,2; Magnetometer Offset for X, Y, Z axes (values in uT) - list elements 3,4,5; Gyroscope Offset for X, Y, Z axes (values in Dps) - list elements 6,7,8; Accelerometer Radius - list element 9; Magnetometer Radius - list element 10. Note If raw parameter is set to True, returns a list of 22 raw bytes. Returns [list of calibration values] set_calibration \u00b6 set_calibration ( data , raw = False ) Sets the calibration values of the BNO055 main components. Arguments: data \u2013 List of values (11 elements) representing the sensors offsets and radius. Data list must follow this order: Accelerometer Offset for X, Y, Z axes (values in m/s\u00b2) - list elements 0,1,2; Magnetometer Offset for X, Y, Z axes (values in uT) - list elements 3,4,5; Gyroscope Offset for X, Y, Z axes (values in Dps) - list elements 6,7,8; Accelerometer Radius - list element 9; Magnetometer Radius - list element 10. Note If raw parameter is set to True, following rules are required: data list must have 22 elements; each element must be a byte (value 0 to 255); data list must be a sequence of [lsb1, msb1, lsb2, msb2, \u2026, \u2026]; data list order is the same described above (elem0 and elem1 of data list are respectively lsb and msb of accelerometer offset in x axis). BNO055.get_acc \u00b6 get_acc () Retrieves the current absolute acceleration as a list of X, Y, Z values in m/s\u00b2. Returns [acc_x, acc_y, acc_z]. BNO055.get_gyro \u00b6 get_gyro () Retrieves the current gyroscope data reading as a list of X, Y, Z values in degrees per second. Returns [gyro_x, gyro_y, gyro_z]. BNO055.get_magn \u00b6 get_magn () Retrieves the current magnetometer reading as a list of X, Y, Z values in micro-Teslas. Returns [value_magn_x, value_magn_y, value_magn_z]. BNO055.get_euler \u00b6 get_euler () Retrieves the current orientation as a list of heading, roll, and pitch euler angles in degrees. Returns [abs_or_h, abs_or_r, abs_or_p]. BNO055.get_lin_acc \u00b6 get_lin_acc () Retrieves the current linear acceleration (acceleration from movement, not from gravity) as a list of X, Y, Z values in m/s\u00b2. Returns [lin_acc_x, lin_acc_y, lin_acc_z]. BNO055.get_grav \u00b6 get_grav () Retrieves the current gravity acceleration as a list of X, Y, Z values in m/s\u00b2. Returns [grav_x, grav_y, grav_z]. BNO055.get_quaternion \u00b6 get_quaternion () Retrieves the current orientation as a list of X, Y, Z, W quaternion values. Returns [w, x, y, z]. BNO055.get_temp \u00b6 get_temp () Retrieves the current temperature in Celtius. Returns temp.","title":"BNO055 Module"},{"location":"reference/libs/bosch/bno055/docs/bno055/#bno055-module","text":"This module contains the driver for BOSCH BNO055 9-axis Absolute Orientation Sensor. The BNO055 is a System in Package (SiP), integrating a triaxial 14-bit accelerometer, a triaxial 16-bit gyroscope with a range of \u00b12000 degrees per second, a triaxial geomagnetic sensor ( datasheet ).","title":"BNO055 Module"},{"location":"reference/libs/bosch/bno055/docs/bno055/#class-bno055","text":"class BNO055 ( i2cdrv , addr = 0x28 , clk = 100000 ) Creates an intance of a new BNO055. Arguments: i2cdrv \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x28 clk \u2013 Clock speed, default 100kHz Example: from bosch.bno055 import bno055 ... bno = bno055 . BNO055 ( I2C0 ) bno . start () bno . init () abs_orientation = bno . get_euler ()","title":"class BNO055"},{"location":"reference/libs/bosch/bno055/docs/bno055/#bno055init","text":"init ( mode = None ) Initialize the BNO055 setting the mode value. Arguments: - mode \u2013 Mode value selectable from Mode table (refer to page 20 of the BNO055 datasheet), default None","title":"BNO055.init"},{"location":"reference/libs/bosch/bno055/docs/bno055/#bno055set_mode","text":"set_mode ( mode ) Sets the Mode value of the BNO055. Arguments: mode \u2013 Mode value (refer to page 20 of the BNO055 datasheet) Note The BNO055 provides a variety of output signals, which can be chosen by selecting the appropriate operation mode. The table below lists the different modes and the available sensor signals. .tg {border-collapse:collapse;border-spacing:0;} .tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px; overflow:hidden;padding:10px 5px;word-break:normal;} .tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px; font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;} .tg .tg-htbt{background-color:#FFF;border-color:inherit;color:#404040;text-align:left;vertical-align:middle} .tg .tg-zatc{background-color:#FFF;border-color:inherit;color:#404040;font-weight:bold;text-align:left;vertical-align:bottom} .tg .tg-5ncm{background-color:#F3F6F6;border-color:inherit;color:#404040;text-align:left;vertical-align:middle} Mode Available Library Functions Value Name get_acc() get_magn() get_gyro() get_euler() acc ACCONLY Yes No No No magn MAGONLY No Yes No No gyro GYROONLY No No Yes No accmag ACCMAG Yes Yes No No accgyro ACCGYRO Yes No Yes No maggyro MAGGYRO No Yes Yes No amg AMG No Yes Yes No imu IMU Yes No Yes Yes comp COMPASS Yes Yes No Yes m4g M4G Yes Yes Yes Yes ndof_off NDOF_FMC_OFF No Yes Yes Yes ndof NDOF Yes Yes Yes Yes","title":"BNO055.set_mode"},{"location":"reference/libs/bosch/bno055/docs/bno055/#bno055get_calibration_status","text":"get_calibration_status () Retrieves the current calibration status of the BNO055 main components: System Accelerometer Gyroscope Magnetometer Note Read: 3 indicates fully calibrated; 0 indicates not calibrated. Returns [sys_cal_sts, acc_cal_sts, gyro_cal_sts, magn_cal_sts].","title":"BNO055.get_calibration_status"},{"location":"reference/libs/bosch/bno055/docs/bno055/#bno055get_calibration","text":"get_calibration ( raw = False ) Retrieves the calibration values of the BNO055 main components (list of 11 elements): Accelerometer Offset for X, Y, Z axes (values in m/s\u00b2) - list elements 0,1,2; Magnetometer Offset for X, Y, Z axes (values in uT) - list elements 3,4,5; Gyroscope Offset for X, Y, Z axes (values in Dps) - list elements 6,7,8; Accelerometer Radius - list element 9; Magnetometer Radius - list element 10. Note If raw parameter is set to True, returns a list of 22 raw bytes. Returns [list of calibration values]","title":"BNO055get_calibration"},{"location":"reference/libs/bosch/bno055/docs/bno055/#set_calibration","text":"set_calibration ( data , raw = False ) Sets the calibration values of the BNO055 main components. Arguments: data \u2013 List of values (11 elements) representing the sensors offsets and radius. Data list must follow this order: Accelerometer Offset for X, Y, Z axes (values in m/s\u00b2) - list elements 0,1,2; Magnetometer Offset for X, Y, Z axes (values in uT) - list elements 3,4,5; Gyroscope Offset for X, Y, Z axes (values in Dps) - list elements 6,7,8; Accelerometer Radius - list element 9; Magnetometer Radius - list element 10. Note If raw parameter is set to True, following rules are required: data list must have 22 elements; each element must be a byte (value 0 to 255); data list must be a sequence of [lsb1, msb1, lsb2, msb2, \u2026, \u2026]; data list order is the same described above (elem0 and elem1 of data list are respectively lsb and msb of accelerometer offset in x axis).","title":"set_calibration"},{"location":"reference/libs/bosch/bno055/docs/bno055/#bno055get_acc","text":"get_acc () Retrieves the current absolute acceleration as a list of X, Y, Z values in m/s\u00b2. Returns [acc_x, acc_y, acc_z].","title":"BNO055.get_acc"},{"location":"reference/libs/bosch/bno055/docs/bno055/#bno055get_gyro","text":"get_gyro () Retrieves the current gyroscope data reading as a list of X, Y, Z values in degrees per second. Returns [gyro_x, gyro_y, gyro_z].","title":"BNO055.get_gyro"},{"location":"reference/libs/bosch/bno055/docs/bno055/#bno055get_magn","text":"get_magn () Retrieves the current magnetometer reading as a list of X, Y, Z values in micro-Teslas. Returns [value_magn_x, value_magn_y, value_magn_z].","title":"BNO055.get_magn"},{"location":"reference/libs/bosch/bno055/docs/bno055/#bno055get_euler","text":"get_euler () Retrieves the current orientation as a list of heading, roll, and pitch euler angles in degrees. Returns [abs_or_h, abs_or_r, abs_or_p].","title":"BNO055.get_euler"},{"location":"reference/libs/bosch/bno055/docs/bno055/#bno055get_lin_acc","text":"get_lin_acc () Retrieves the current linear acceleration (acceleration from movement, not from gravity) as a list of X, Y, Z values in m/s\u00b2. Returns [lin_acc_x, lin_acc_y, lin_acc_z].","title":"BNO055.get_lin_acc"},{"location":"reference/libs/bosch/bno055/docs/bno055/#bno055get_grav","text":"get_grav () Retrieves the current gravity acceleration as a list of X, Y, Z values in m/s\u00b2. Returns [grav_x, grav_y, grav_z].","title":"BNO055.get_grav"},{"location":"reference/libs/bosch/bno055/docs/bno055/#bno055get_quaternion","text":"get_quaternion () Retrieves the current orientation as a list of X, Y, Z, W quaternion values. Returns [w, x, y, z].","title":"BNO055.get_quaternion"},{"location":"reference/libs/bosch/bno055/docs/bno055/#bno055get_temp","text":"get_temp () Retrieves the current temperature in Celtius. Returns temp.","title":"BNO055.get_temp"},{"location":"reference/libs/bosch/bno055/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.bosch.bno055. Acceleration \u00b6 Get Acceleration as tuple value in 3-axis x,y,z from BNO055. main.py ################################################################################ # Get Acceleration Example # # Created: 2017-02-24 12:48:43.342375 # ################################################################################ from bosch.bno055 import bno055 import streams streams . serial () # Setup sensor # This setup is referred to bno055 mounted on 10DOF Click in slot A of a Flip n Click device print ( \"Start...\" ) bno = bno055 . BNO055 ( I2C0 ) bno . start () print ( \"Init...\" ) # Enabled Accelerometer bno . init ( \"acc\" ) # Operating Mode ACCONLY (only raw accelerometer data) print ( \"Ready!\" ) print ( \"--------------------------------------------------------\" ) while True : data = bno . get_acc () # Read Data on 3 axis print ( \"Acceleration on XYZ\" , data ) print ( \"--------------------------------------------------------\" ) sleep ( 5000 ) Inclination Alarm \u00b6 Basic Example of BNO055 usage for overcoming tilt threshold alarm. main.py ################################################################################ # Inclination Alarm # # Created: 2017-02-24 14:30:21.325536 # ################################################################################ from bosch.bno055 import bno055 import streams streams . serial () # Setup sensor # This setup is referred to bno055 mounted on 10DOF Click in slot A of a Flip n Click device print ( \"Start...\" ) bno = bno055 . BNO055 ( I2C0 ) bno . start () print ( \"Init...\" ) # Eenabled Accelerometer, Magnetometer, and Gyroscope bno . init ( \"comp\" ) # Operating Mode COMPASS (measure the magnetic earth field and calculate the geographic direction) print ( \"Ready!\" ) print ( \"--------------------------------------------------------\" ) while True : data = bno . get_euler () # Read Data print ( 'heading: ' , data [ 0 ], ' roll: ' , data [ 1 ], ' pitch: ' , data [ 2 ]) angle = int ( max ( abs ( data [ 1 ]), abs ( data [ 2 ]))) # max angle between roll and pitch if angle >= 0 and angle <= 30 : # angle check print ( \"OK! inclination pack: \" + str ( angle ) + \" degrees!\" ) else : print ( \"WARNING! inclination pack: \" + str ( angle ) + \" degrees!\" ) sleep ( 1000 )","title":"Examples"},{"location":"reference/libs/bosch/bno055/docs/examples/#examples","text":"The following are a list of examples for lib.bosch.bno055.","title":"Examples"},{"location":"reference/libs/bosch/bno055/docs/examples/#acceleration","text":"Get Acceleration as tuple value in 3-axis x,y,z from BNO055. main.py ################################################################################ # Get Acceleration Example # # Created: 2017-02-24 12:48:43.342375 # ################################################################################ from bosch.bno055 import bno055 import streams streams . serial () # Setup sensor # This setup is referred to bno055 mounted on 10DOF Click in slot A of a Flip n Click device print ( \"Start...\" ) bno = bno055 . BNO055 ( I2C0 ) bno . start () print ( \"Init...\" ) # Enabled Accelerometer bno . init ( \"acc\" ) # Operating Mode ACCONLY (only raw accelerometer data) print ( \"Ready!\" ) print ( \"--------------------------------------------------------\" ) while True : data = bno . get_acc () # Read Data on 3 axis print ( \"Acceleration on XYZ\" , data ) print ( \"--------------------------------------------------------\" ) sleep ( 5000 )","title":"Acceleration"},{"location":"reference/libs/bosch/bno055/docs/examples/#inclination-alarm","text":"Basic Example of BNO055 usage for overcoming tilt threshold alarm. main.py ################################################################################ # Inclination Alarm # # Created: 2017-02-24 14:30:21.325536 # ################################################################################ from bosch.bno055 import bno055 import streams streams . serial () # Setup sensor # This setup is referred to bno055 mounted on 10DOF Click in slot A of a Flip n Click device print ( \"Start...\" ) bno = bno055 . BNO055 ( I2C0 ) bno . start () print ( \"Init...\" ) # Eenabled Accelerometer, Magnetometer, and Gyroscope bno . init ( \"comp\" ) # Operating Mode COMPASS (measure the magnetic earth field and calculate the geographic direction) print ( \"Ready!\" ) print ( \"--------------------------------------------------------\" ) while True : data = bno . get_euler () # Read Data print ( 'heading: ' , data [ 0 ], ' roll: ' , data [ 1 ], ' pitch: ' , data [ 2 ]) angle = int ( max ( abs ( data [ 1 ]), abs ( data [ 2 ]))) # max angle between roll and pitch if angle >= 0 and angle <= 30 : # angle check print ( \"OK! inclination pack: \" + str ( angle ) + \" degrees!\" ) else : print ( \"WARNING! inclination pack: \" + str ( angle ) + \" degrees!\" ) sleep ( 1000 )","title":"Inclination Alarm"},{"location":"reference/libs/bridgetek/bt81x/docs/","text":"BT81x \u00b6 Bridgetek BT81x series of Embedded Video Engines (EVE) utilizes an object oriented methodology for creating hi-quality human machine interfaces (HMIs). With support for display, audio, and touch, this new technology allows engineers to quickly and efficiently design HMIs and deliver robust solutions, hi-resolution displays with lower bill of material costs. Product page: BT81x Technical Details \u00b6 BT81x functionality includes graphic control, audio control, and touch control interface Support multiple widgets for simplified design implementation Support Adaptive Scalable Texture Compression (ASTC) format to save considerable memory space for larger fonts and graphics images Support external QSPI NOR flash to fetch graphic elements (image, font, widget etc) Support 4-wire resistive touch screen (BT816) Support capacitive touch screen with up to 5 touches detection (BT815) Hardware engine can recognize touch tags and track touch movement. Provides notification for up to 255 touch tags. Programmable interrupt controller provides interrupts to host MCU Built-in 12MHz crystal oscillator with PLL providing programmable system clock up to 72MHz Video RGB parallel output; configurable to support PCLK up to 60MHz and R/G/B output of 1 to 8 bits Programmable timing to adjust HSYNC and VSYNC timing, enabling interface to numerous displays Support for LCD display with resolution up to SVGA (800\u00d7600) and formats with data enable (DE) mode or VSYNC/HSYNC mode Support landscape and portrait orientations Display enable control output to LCD panel Integrated 1MByte graphics RAM, no frame buffer RAM required Support playback of motion-JPEG encoded AVI videos Built-in sound synthesizer Audio wave playback for mono 8-bit linear PCM, 4-bit ADPCM and \u00b5-Law coding format at sampling frequencies from 8 kHz to 48 kHz. Built-in digital filter reduces the system design complexity of external filtering PWM output for display backlight dimming control Supports I/O voltage from 1.8V to 3.3V Built-in Power-on-reset circuit -40\u00b0C to 85\u00b0C extended operating temperature range Available in a compact Pb-free, VQFN-package, RoHS compliant Below, Zerynth driver documentation for Bridgetek BT81x Embedded Video Engines. Contents: BT81x library Co-Processor Commands Examples DisplayZerynthLogo DisplayNetworks DisplayWidgets","title":"BT81x"},{"location":"reference/libs/bridgetek/bt81x/docs/#bt81x","text":"Bridgetek BT81x series of Embedded Video Engines (EVE) utilizes an object oriented methodology for creating hi-quality human machine interfaces (HMIs). With support for display, audio, and touch, this new technology allows engineers to quickly and efficiently design HMIs and deliver robust solutions, hi-resolution displays with lower bill of material costs. Product page: BT81x","title":"BT81x"},{"location":"reference/libs/bridgetek/bt81x/docs/#technical-details","text":"BT81x functionality includes graphic control, audio control, and touch control interface Support multiple widgets for simplified design implementation Support Adaptive Scalable Texture Compression (ASTC) format to save considerable memory space for larger fonts and graphics images Support external QSPI NOR flash to fetch graphic elements (image, font, widget etc) Support 4-wire resistive touch screen (BT816) Support capacitive touch screen with up to 5 touches detection (BT815) Hardware engine can recognize touch tags and track touch movement. Provides notification for up to 255 touch tags. Programmable interrupt controller provides interrupts to host MCU Built-in 12MHz crystal oscillator with PLL providing programmable system clock up to 72MHz Video RGB parallel output; configurable to support PCLK up to 60MHz and R/G/B output of 1 to 8 bits Programmable timing to adjust HSYNC and VSYNC timing, enabling interface to numerous displays Support for LCD display with resolution up to SVGA (800\u00d7600) and formats with data enable (DE) mode or VSYNC/HSYNC mode Support landscape and portrait orientations Display enable control output to LCD panel Integrated 1MByte graphics RAM, no frame buffer RAM required Support playback of motion-JPEG encoded AVI videos Built-in sound synthesizer Audio wave playback for mono 8-bit linear PCM, 4-bit ADPCM and \u00b5-Law coding format at sampling frequencies from 8 kHz to 48 kHz. Built-in digital filter reduces the system design complexity of external filtering PWM output for display backlight dimming control Supports I/O voltage from 1.8V to 3.3V Built-in Power-on-reset circuit -40\u00b0C to 85\u00b0C extended operating temperature range Available in a compact Pb-free, VQFN-package, RoHS compliant Below, Zerynth driver documentation for Bridgetek BT81x Embedded Video Engines. Contents: BT81x library Co-Processor Commands Examples DisplayZerynthLogo DisplayNetworks DisplayWidgets","title":"Technical Details"},{"location":"reference/libs/bridgetek/bt81x/docs/bt81x/","text":"BT81x library \u00b6 This module exports classes and functions to handle Bridgetek BT81x family of Embedded Video Engines. class DisplayConf \u00b6 class DisplayConf ( width , height , hcycle , hoffset , hsync0 , hsync1 , vcycle , voffset , vsync0 , vsync1 , pclk , swizzle , pclkpol , cspread , dither , description ) Class to store a display configuration. List of attributes: DisplayConf.width display width in pixels DisplayConf.height display height in pixels DisplayConf.hcycle number of total PCLK cycles per horizontal line scan DisplayConf.hoffset number of PCLK cycle before pixels are scanned out DisplayConf.hsync0 how many PCLK cycles for HSYNC0 during start of line DisplayConf.hsync1 how many PCLK cycles for HSYNC1 during start of line DisplayConf.vcycle how many lines in one frame DisplayConf.voffset how many lines taken after the start of a new frame DisplayConf.vsync0 how many lines of signal VSYNC0 takes at start of a new frame DisplayConf.vsync1 how many lines of signal VSYNC1 takes at start of a new frame DisplayConf.pclk main clock divider for PCLK, if 0 there is no PCLK output DisplayConf.swizzle controls the arrangement of output RGB pins to support different LCD panels DisplayConf.pclkpol 0 for PCLK polarity on the rising edge, 1 for falling edge DisplayConf.cspread controls the transition of RGB signals with PCLK active clock edge DisplayConf.dither 1 or 0 to respectively enable or disable dither DisplayConf.description a string describing the display display_conf module global variable is automatically set with a DisplayConf() instance when importing a display module from a display vendor: from riverdi.displays.bt81x import ctp50 from bridgetek.bt81x import bt81x DisplayConf.init \u00b6 init ( spi , cs , pd , int , dc = None , spi_speed = 3000000 ) Parameters: spi \u2013 spi driver ( SPI0 , SPI1 , ... ) cs \u2013 chip select pin pd \u2013 pd pin int \u2013 interrupt pin dc \u2013 display configuration as a DisplayConf() instance spi_speed \u2013 spi speed in Hertz Initializes the chip. When dc parameter is not specified display_conf global variable is used. class Palette \u00b6 class Palette ( font , foreground , background ) Class to store a color palette for font, foreground and background. List of attributes: font tuple of rgb values (r,g,b) foreground tuple of rgb values (r,g,b) background tuple of rgb values (r,g,b) class Text \u00b6 class Text ( x , y , font , options , text , palette = None ) Class to store a text element configuration. List of attributes: x - coordinate top-left, in pixels y - coordinate top-left, in pixels font to use 0-31 options one of OPT_CENTERX , OPT_CENTERY , OPT_CENTER , OPT_RIGHTX , OPT_FORMAT , OPT_FILL text string palette Palette() object instance to set colors class Button \u00b6 class Button ( x , y , width , height , font , options , text , palette = None ) Class to store a text element configuration. Inherits all Text() attributes and adds: width button width in pixels height button height in pixels Co-Processor Commands \u00b6 List of available options for the options command parameter: OPT_3D 3D effect OPT_CENTER horizontally and vertically centered style OPT_CENTERX horizontally-centered style OPT_CENTERY vertically-centered style OPT_FILL breaks the text at spaces into multiple lines OPT_FLASH fetch the data from flash memory OPT_FLAT no 3D effect OPT_FORMAT flag of string formatting OPT_FULLSCREEN zoom the media to fill as much of the screen as possible OPT_MEDIAFIFO source data from the defined media FIFO OPT_MONO decodes the source JPEG image to L8 format, i.e., monochrome OPT_NOBACK no background drawn OPT_NODL no display list commands generated OPT_NOHANDS no hands OPT_NOHM no hour and minute hands OPT_NOPOINTER no pointer OPT_NOSECS no second hands OPT_NOTEAR sync video updates to the display blanking interval, avoiding horizontal tearing artifacts OPT_NOTICKS no ticks OPT_OVERLAY append the video bitmap to an existing display list OPT_RGB565 decodes the source image to RGB565 format OPT_RIGHTX right justified style OPT_SIGNED the number is treated as a 32 bit signed integer OPT_SOUND decode the audio data Options can be combined using a bitwise OR. dl_start \u00b6 dl_start () Starts a new display list. set_font_color \u00b6 set_font_color ( r , g , b ) Arguments: r \u2013 red 0-255 g \u2013 green 0-255 b \u2013 blue 0-255 Sets current font color. set_foreground(r, g, b) Arguments: r \u2013 red 0-255 g \u2013 green 0-255 b \u2013 blue 0-255 Sets current foreground color. set_background \u00b6 set_background ( r , g , b ) Arguments: r \u2013 red 0-255 g \u2013 green 0-255 b \u2013 blue 0-255 Sets current background color. Parameters: txt \u2013 Text object instance Adds a text element to the screen. A call to set_font_color() is performed if the Text.palette attribute is set. add_button \u00b6 add_button ( btn ) Arguments: btn \u2013 Button object instance Adds a button element to the screen. Calls to set_background() , set_foreground() and set_font_color() are performed if the Text.palette.font attribute is set. add_keys \u00b6 add_keys ( x , y , w , h , font , options , s ) Arguments: x \u2013 x-coordinate top-left, in pixels y \u2013 y-coordinate top-left, in pixels w \u2013 width of the keys h \u2013 height of the keys font \u2013 font used in key label 0-31 options \u2013 one of OPT_3D (default), OPT_FLAT , OPT_CENTER or an ASCII code s \u2013 key labels, one character per key. Adds a row of keys to the screen. If an ASCII code is specified as option, that key is drawn as pressed (in background color with any 3D effect removed). The TAG value is set to the ASCII value of each key, so that key presses can be detected with a callback on that value. add_clock \u00b6 add_clock ( x , y , r , options , h , m , s , ms ) Arguments: x \u2013 x-coordinate top-left, in pixels y \u2013 y-coordinate top-left, in pixels r \u2013 clock radius options \u2013 one of OPT_3D (default), OPT_FLAT , OPT_NOBACK , OPT_NOTICKS , OPT_NOSECS , OPT_NOHANDS , OPT_NOHM h \u2013 hour m \u2013 minutes s \u2013 seconds ms \u2013 milliseconds Adds a clock to the screen. clear \u00b6 clear ( color , stencil , tag ) Arguments: color \u2013 clear color 0-1 stencil \u2013 clear stencil 0-1 tag \u2013 clear tag 0-1 Clears buffers to default values. clear_color \u00b6 clear_color ( rgb = None , a = None ) Arguments: rgb \u2013 tuple for red, green and blue values ( 0-255 , 0-255 , 0-255 ) a \u2013 alpha 0-255 Sets the default color when colors are cleared. The initial value is ((0, 0, 0), 0) . clear_tag \u00b6 clear_tag ( default_tag ) Arguments: default_tag \u2013 default tag Sets the default tag when tag buffer is cleared. The initial value is 0 . spinner \u00b6 spinner ( x , y , style , scale ) Arguments: x \u2013 x-coordinate top-left, in pixels y \u2013 y-coordinate top-left, in pixels style \u2013 spinner style, one of SPINNER_CIRCLE , SPINNER_LINE , SPINNER_CLOCK , SPINNER_ORBITING Draws a spinner with a chosen style. calibrate \u00b6 calibrate () Starts the calibration procedure (needed by Resistive Displays). inflate \u00b6 inflate ( ram_ptr , resource ) Arguments: ram_ptr \u2013 address in RAM_G to inflate the resource to resource \u2013 name of the resource to inflate Inflates a Zerynth resource to RAM_G (General purpose graphics RAM, bt81x main memory) for later use. The resource should be a valid bt81x image (zlib-compressed). Raises: PeripheralError \u2013 if an error occurs while loading TimeoutError \u2013 if the process takes longer than set timeout ( set_timeout() ) load_image \u00b6 load_image ( ram_ptr , options , resource ) Arguments: ram_ptr \u2013 address in RAM_G to load the resource to options \u2013 load options resource \u2013 name of the resource to inflate Inflates a Zerynth resource consisting of a PNG image to RAM_G (General purpose graphics RAM, bt81x main memory) for later use. Raises: PeripheralError \u2013 if an error occurs while loading TimeoutError \u2013 if the process takes longer than set timeout ( set_timeout() ) vertex_format \u00b6 vertex_format ( fmt ) Arguments: fmt \u2013 format frac value, one of 0 , 1 , 2 , 3 , 4 Selects a vertex format for subsequent draw operations. Vertex format are useful to specify pixel coordinates beyond the 0-511 range. Bitmap \u00b6 Bitmap ( handle , source , layout , size ) Arguments: handle \u2013 a user-defined handle to refer to the bitmap source \u2013 bitmap source in RAM_G layout \u2013 a tuple of (bitmap_format, linestride) size \u2013 a tuple of (filtering_mode, x_wrap_mode, y_wrap_mode, bitmap_width, bitmap_height) Class to store a bitmap element and to allow subsequent bitmap draw operations. linestride value represents the amount of memory used for each line of bitmap pixels. It depends on selected format and can be usually calculated with the following formula: linestride = width * byte/pixel Allowed values for bitmap_format and number of bits/pixel for that format: L1 1 L2 2 L4 4 L8 8 ARGB2 8 RGB332 8 ARGB4 16 ARGB1555 16 RGB565 16 PALETTED8 8 PALETTED4444 8 PALETTED565 8 BARGRAPH TEXT8X8 Allowed values for filtering_mode are: NEAREST BILINEAR Allowed values for x_wrap_mode and y_wrap_mode are: BORDER REPEAT prepare_draw \u00b6 prepare_draw () To be called before draw() . draw \u00b6 draw ( vertex , vertex_fmt = None ) Draws prepared image on screen. Can be called multiple times after a single prepare_draw() . If vertex tuple has 2 elements the vertex format is set according to vertex_fmt parameter ( vertex_format() ) and vertex elements are assumed to be the image x and y top-left coordinates. If vertex tuple has 4 elements vertex_fmt parameter is ignored and vertex elements are assumed to be the image x and y top-left coordinates, image handle and cell. end \u00b6 end () Ends drawing a graphics primitive. display \u00b6 display () Ends a display list. swap_and_empty \u00b6 swap_and_empty () Swaps current display list and waits until all commands are executed. Raises: PeripheralError \u2013 if an error occurs while loading TimeoutError \u2013 if the process takes longer than set timeout ( set_timeout() ) set_timeout \u00b6 set_timeout ( timeout_millis ) Arguments: timeout_millis \u2013 timeout in milliseconds Sets a timeout for Co-Processor commands. Default timeout value is 4000 . tag \u00b6 tag ( n ) Arguments: n \u2013 tag value 1-255 Attaches the tag value to all the following graphics objects drawn on the screen, unless tag_mask() is used to disable it. When the graphics objects attached with the tag value are touched, if calls to track() and touch_loop() have been previously issued, a callback function is called. The initial tag value is specified by function clear_tag() and takes effect calling function clear() . tag_mask \u00b6 tag_mask ( mask ) Arguments: mask \u2013 mask value 0-1 If called with value 0 the default value of the tag buffer is used for current display list. tag_mask \u00b6 tag_mask ( mask ) Arguments: mask \u2013 mask value 0-1 If called with value 0 the default value of the tag buffer is used for current display list. touch_loop \u00b6 touch_loop ( cbks ) Arguments: cbks \u2013 tuple of tuples of callback and tag value for the callback to be activated on ((tag_value1, cbk1), (tag_value2, cbk2), ...) touch_points \u2013 number of multiple touch points (to be supported by used display) Starts the touch loop to call set callbacks when touches are detected. Each callback function is called passing tag value, tracked value and touch point. If a tag value of -1 is specified for a certain callback, that callback is called for every detected tag value.","title":"BT81x library"},{"location":"reference/libs/bridgetek/bt81x/docs/bt81x/#bt81x-library","text":"This module exports classes and functions to handle Bridgetek BT81x family of Embedded Video Engines.","title":"BT81x library"},{"location":"reference/libs/bridgetek/bt81x/docs/bt81x/#class-displayconf","text":"class DisplayConf ( width , height , hcycle , hoffset , hsync0 , hsync1 , vcycle , voffset , vsync0 , vsync1 , pclk , swizzle , pclkpol , cspread , dither , description ) Class to store a display configuration. List of attributes: DisplayConf.width display width in pixels DisplayConf.height display height in pixels DisplayConf.hcycle number of total PCLK cycles per horizontal line scan DisplayConf.hoffset number of PCLK cycle before pixels are scanned out DisplayConf.hsync0 how many PCLK cycles for HSYNC0 during start of line DisplayConf.hsync1 how many PCLK cycles for HSYNC1 during start of line DisplayConf.vcycle how many lines in one frame DisplayConf.voffset how many lines taken after the start of a new frame DisplayConf.vsync0 how many lines of signal VSYNC0 takes at start of a new frame DisplayConf.vsync1 how many lines of signal VSYNC1 takes at start of a new frame DisplayConf.pclk main clock divider for PCLK, if 0 there is no PCLK output DisplayConf.swizzle controls the arrangement of output RGB pins to support different LCD panels DisplayConf.pclkpol 0 for PCLK polarity on the rising edge, 1 for falling edge DisplayConf.cspread controls the transition of RGB signals with PCLK active clock edge DisplayConf.dither 1 or 0 to respectively enable or disable dither DisplayConf.description a string describing the display display_conf module global variable is automatically set with a DisplayConf() instance when importing a display module from a display vendor: from riverdi.displays.bt81x import ctp50 from bridgetek.bt81x import bt81x","title":"class DisplayConf"},{"location":"reference/libs/bridgetek/bt81x/docs/bt81x/#displayconfinit","text":"init ( spi , cs , pd , int , dc = None , spi_speed = 3000000 ) Parameters: spi \u2013 spi driver ( SPI0 , SPI1 , ... ) cs \u2013 chip select pin pd \u2013 pd pin int \u2013 interrupt pin dc \u2013 display configuration as a DisplayConf() instance spi_speed \u2013 spi speed in Hertz Initializes the chip. When dc parameter is not specified display_conf global variable is used.","title":"DisplayConf.init"},{"location":"reference/libs/bridgetek/bt81x/docs/bt81x/#class-palette","text":"class Palette ( font , foreground , background ) Class to store a color palette for font, foreground and background. List of attributes: font tuple of rgb values (r,g,b) foreground tuple of rgb values (r,g,b) background tuple of rgb values (r,g,b)","title":"class Palette"},{"location":"reference/libs/bridgetek/bt81x/docs/bt81x/#class-text","text":"class Text ( x , y , font , options , text , palette = None ) Class to store a text element configuration. List of attributes: x - coordinate top-left, in pixels y - coordinate top-left, in pixels font to use 0-31 options one of OPT_CENTERX , OPT_CENTERY , OPT_CENTER , OPT_RIGHTX , OPT_FORMAT , OPT_FILL text string palette Palette() object instance to set colors","title":"class Text"},{"location":"reference/libs/bridgetek/bt81x/docs/bt81x/#class-button","text":"class Button ( x , y , width , height , font , options , text , palette = None ) Class to store a text element configuration. Inherits all Text() attributes and adds: width button width in pixels height button height in pixels","title":"class Button"},{"location":"reference/libs/bridgetek/bt81x/docs/bt81x/#co-processor-commands","text":"List of available options for the options command parameter: OPT_3D 3D effect OPT_CENTER horizontally and vertically centered style OPT_CENTERX horizontally-centered style OPT_CENTERY vertically-centered style OPT_FILL breaks the text at spaces into multiple lines OPT_FLASH fetch the data from flash memory OPT_FLAT no 3D effect OPT_FORMAT flag of string formatting OPT_FULLSCREEN zoom the media to fill as much of the screen as possible OPT_MEDIAFIFO source data from the defined media FIFO OPT_MONO decodes the source JPEG image to L8 format, i.e., monochrome OPT_NOBACK no background drawn OPT_NODL no display list commands generated OPT_NOHANDS no hands OPT_NOHM no hour and minute hands OPT_NOPOINTER no pointer OPT_NOSECS no second hands OPT_NOTEAR sync video updates to the display blanking interval, avoiding horizontal tearing artifacts OPT_NOTICKS no ticks OPT_OVERLAY append the video bitmap to an existing display list OPT_RGB565 decodes the source image to RGB565 format OPT_RIGHTX right justified style OPT_SIGNED the number is treated as a 32 bit signed integer OPT_SOUND decode the audio data Options can be combined using a bitwise OR.","title":"Co-Processor Commands"},{"location":"reference/libs/bridgetek/bt81x/docs/bt81x/#dl_start","text":"dl_start () Starts a new display list.","title":"dl_start"},{"location":"reference/libs/bridgetek/bt81x/docs/bt81x/#set_font_color","text":"set_font_color ( r , g , b ) Arguments: r \u2013 red 0-255 g \u2013 green 0-255 b \u2013 blue 0-255 Sets current font color. set_foreground(r, g, b) Arguments: r \u2013 red 0-255 g \u2013 green 0-255 b \u2013 blue 0-255 Sets current foreground color.","title":"set_font_color"},{"location":"reference/libs/bridgetek/bt81x/docs/bt81x/#set_background","text":"set_background ( r , g , b ) Arguments: r \u2013 red 0-255 g \u2013 green 0-255 b \u2013 blue 0-255 Sets current background color. Parameters: txt \u2013 Text object instance Adds a text element to the screen. A call to set_font_color() is performed if the Text.palette attribute is set.","title":"set_background"},{"location":"reference/libs/bridgetek/bt81x/docs/bt81x/#add_button","text":"add_button ( btn ) Arguments: btn \u2013 Button object instance Adds a button element to the screen. Calls to set_background() , set_foreground() and set_font_color() are performed if the Text.palette.font attribute is set.","title":"add_button"},{"location":"reference/libs/bridgetek/bt81x/docs/bt81x/#add_keys","text":"add_keys ( x , y , w , h , font , options , s ) Arguments: x \u2013 x-coordinate top-left, in pixels y \u2013 y-coordinate top-left, in pixels w \u2013 width of the keys h \u2013 height of the keys font \u2013 font used in key label 0-31 options \u2013 one of OPT_3D (default), OPT_FLAT , OPT_CENTER or an ASCII code s \u2013 key labels, one character per key. Adds a row of keys to the screen. If an ASCII code is specified as option, that key is drawn as pressed (in background color with any 3D effect removed). The TAG value is set to the ASCII value of each key, so that key presses can be detected with a callback on that value.","title":"add_keys"},{"location":"reference/libs/bridgetek/bt81x/docs/bt81x/#add_clock","text":"add_clock ( x , y , r , options , h , m , s , ms ) Arguments: x \u2013 x-coordinate top-left, in pixels y \u2013 y-coordinate top-left, in pixels r \u2013 clock radius options \u2013 one of OPT_3D (default), OPT_FLAT , OPT_NOBACK , OPT_NOTICKS , OPT_NOSECS , OPT_NOHANDS , OPT_NOHM h \u2013 hour m \u2013 minutes s \u2013 seconds ms \u2013 milliseconds Adds a clock to the screen.","title":"add_clock"},{"location":"reference/libs/bridgetek/bt81x/docs/bt81x/#clear","text":"clear ( color , stencil , tag ) Arguments: color \u2013 clear color 0-1 stencil \u2013 clear stencil 0-1 tag \u2013 clear tag 0-1 Clears buffers to default values.","title":"clear"},{"location":"reference/libs/bridgetek/bt81x/docs/bt81x/#clear_color","text":"clear_color ( rgb = None , a = None ) Arguments: rgb \u2013 tuple for red, green and blue values ( 0-255 , 0-255 , 0-255 ) a \u2013 alpha 0-255 Sets the default color when colors are cleared. The initial value is ((0, 0, 0), 0) .","title":"clear_color"},{"location":"reference/libs/bridgetek/bt81x/docs/bt81x/#clear_tag","text":"clear_tag ( default_tag ) Arguments: default_tag \u2013 default tag Sets the default tag when tag buffer is cleared. The initial value is 0 .","title":"clear_tag"},{"location":"reference/libs/bridgetek/bt81x/docs/bt81x/#spinner","text":"spinner ( x , y , style , scale ) Arguments: x \u2013 x-coordinate top-left, in pixels y \u2013 y-coordinate top-left, in pixels style \u2013 spinner style, one of SPINNER_CIRCLE , SPINNER_LINE , SPINNER_CLOCK , SPINNER_ORBITING Draws a spinner with a chosen style.","title":"spinner"},{"location":"reference/libs/bridgetek/bt81x/docs/bt81x/#calibrate","text":"calibrate () Starts the calibration procedure (needed by Resistive Displays).","title":"calibrate"},{"location":"reference/libs/bridgetek/bt81x/docs/bt81x/#inflate","text":"inflate ( ram_ptr , resource ) Arguments: ram_ptr \u2013 address in RAM_G to inflate the resource to resource \u2013 name of the resource to inflate Inflates a Zerynth resource to RAM_G (General purpose graphics RAM, bt81x main memory) for later use. The resource should be a valid bt81x image (zlib-compressed). Raises: PeripheralError \u2013 if an error occurs while loading TimeoutError \u2013 if the process takes longer than set timeout ( set_timeout() )","title":"inflate"},{"location":"reference/libs/bridgetek/bt81x/docs/bt81x/#load_image","text":"load_image ( ram_ptr , options , resource ) Arguments: ram_ptr \u2013 address in RAM_G to load the resource to options \u2013 load options resource \u2013 name of the resource to inflate Inflates a Zerynth resource consisting of a PNG image to RAM_G (General purpose graphics RAM, bt81x main memory) for later use. Raises: PeripheralError \u2013 if an error occurs while loading TimeoutError \u2013 if the process takes longer than set timeout ( set_timeout() )","title":"load_image"},{"location":"reference/libs/bridgetek/bt81x/docs/bt81x/#vertex_format","text":"vertex_format ( fmt ) Arguments: fmt \u2013 format frac value, one of 0 , 1 , 2 , 3 , 4 Selects a vertex format for subsequent draw operations. Vertex format are useful to specify pixel coordinates beyond the 0-511 range.","title":"vertex_format"},{"location":"reference/libs/bridgetek/bt81x/docs/bt81x/#bitmap","text":"Bitmap ( handle , source , layout , size ) Arguments: handle \u2013 a user-defined handle to refer to the bitmap source \u2013 bitmap source in RAM_G layout \u2013 a tuple of (bitmap_format, linestride) size \u2013 a tuple of (filtering_mode, x_wrap_mode, y_wrap_mode, bitmap_width, bitmap_height) Class to store a bitmap element and to allow subsequent bitmap draw operations. linestride value represents the amount of memory used for each line of bitmap pixels. It depends on selected format and can be usually calculated with the following formula: linestride = width * byte/pixel Allowed values for bitmap_format and number of bits/pixel for that format: L1 1 L2 2 L4 4 L8 8 ARGB2 8 RGB332 8 ARGB4 16 ARGB1555 16 RGB565 16 PALETTED8 8 PALETTED4444 8 PALETTED565 8 BARGRAPH TEXT8X8 Allowed values for filtering_mode are: NEAREST BILINEAR Allowed values for x_wrap_mode and y_wrap_mode are: BORDER REPEAT","title":"Bitmap"},{"location":"reference/libs/bridgetek/bt81x/docs/bt81x/#prepare_draw","text":"prepare_draw () To be called before draw() .","title":"prepare_draw"},{"location":"reference/libs/bridgetek/bt81x/docs/bt81x/#draw","text":"draw ( vertex , vertex_fmt = None ) Draws prepared image on screen. Can be called multiple times after a single prepare_draw() . If vertex tuple has 2 elements the vertex format is set according to vertex_fmt parameter ( vertex_format() ) and vertex elements are assumed to be the image x and y top-left coordinates. If vertex tuple has 4 elements vertex_fmt parameter is ignored and vertex elements are assumed to be the image x and y top-left coordinates, image handle and cell.","title":"draw"},{"location":"reference/libs/bridgetek/bt81x/docs/bt81x/#end","text":"end () Ends drawing a graphics primitive.","title":"end"},{"location":"reference/libs/bridgetek/bt81x/docs/bt81x/#display","text":"display () Ends a display list.","title":"display"},{"location":"reference/libs/bridgetek/bt81x/docs/bt81x/#swap_and_empty","text":"swap_and_empty () Swaps current display list and waits until all commands are executed. Raises: PeripheralError \u2013 if an error occurs while loading TimeoutError \u2013 if the process takes longer than set timeout ( set_timeout() )","title":"swap_and_empty"},{"location":"reference/libs/bridgetek/bt81x/docs/bt81x/#set_timeout","text":"set_timeout ( timeout_millis ) Arguments: timeout_millis \u2013 timeout in milliseconds Sets a timeout for Co-Processor commands. Default timeout value is 4000 .","title":"set_timeout"},{"location":"reference/libs/bridgetek/bt81x/docs/bt81x/#tag","text":"tag ( n ) Arguments: n \u2013 tag value 1-255 Attaches the tag value to all the following graphics objects drawn on the screen, unless tag_mask() is used to disable it. When the graphics objects attached with the tag value are touched, if calls to track() and touch_loop() have been previously issued, a callback function is called. The initial tag value is specified by function clear_tag() and takes effect calling function clear() .","title":"tag"},{"location":"reference/libs/bridgetek/bt81x/docs/bt81x/#tag_mask","text":"tag_mask ( mask ) Arguments: mask \u2013 mask value 0-1 If called with value 0 the default value of the tag buffer is used for current display list.","title":"tag_mask"},{"location":"reference/libs/bridgetek/bt81x/docs/bt81x/#tag_mask_1","text":"tag_mask ( mask ) Arguments: mask \u2013 mask value 0-1 If called with value 0 the default value of the tag buffer is used for current display list.","title":"tag_mask"},{"location":"reference/libs/bridgetek/bt81x/docs/bt81x/#touch_loop","text":"touch_loop ( cbks ) Arguments: cbks \u2013 tuple of tuples of callback and tag value for the callback to be activated on ((tag_value1, cbk1), (tag_value2, cbk2), ...) touch_points \u2013 number of multiple touch points (to be supported by used display) Starts the touch loop to call set callbacks when touches are detected. Each callback function is called passing tag value, tracked value and touch point. If a tag value of -1 is specified for a certain callback, that callback is called for every detected tag value.","title":"touch_loop"},{"location":"reference/libs/bridgetek/bt81x/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.bridgetek.bt81x. Display Zerynth Logo \u00b6 Display Zerynth Logo. main.py import streams from riverdi.displays.bt81x import ctp50 from bridgetek.bt81x import bt81x streams . serial () # choose one logo to be loaded on flash new_resource ( 'zerynth_logo.bin' ) # new_resource('zerynth_logo.png') LOGO_W = 642 LOGO_H = 144 linestride = LOGO_W * 2 # with ARGB1555 and ARGB4 formats, 2 bytes per pixel layout = ( bt81x . ARGB1555 , linestride ) # choose this layout for zerynth_logo.bin # layout = (bt81x.ARGB4, linestride) # choose this layout for zerynth_logo.png zerynth_logo = bt81x . Bitmap ( 1 , 0 , layout , ( bt81x . BILINEAR , bt81x . BORDER , bt81x . BORDER , LOGO_W , LOGO_H )) bt81x . init ( SPI0 , D4 , D33 , D34 ) bt81x . inflate ( 0 , 'zerynth_logo.bin' ) # bt81x.load_image(0, 0, 'zerynth_logo.png') bt81x . dl_start () bt81x . clear_color ( rgb = ( 0xff , 0xff , 0xff )) bt81x . clear ( 1 , 1 , 0 ) zerynth_logo . prepare_draw () zerynth_logo . draw ((( bt81x . display_conf . width - LOGO_W ) // 2 , ( bt81x . display_conf . height - LOGO_H ) // 2 ), vertex_fmt = 0 ) bt81x . display () bt81x . swap_and_empty () Display Networks \u00b6 Scan for networks and display them on the LCD as clickable buttons. main.py # display networks import streams from wireless import wifi from espressif.esp32net import esp32wifi as wifi_driver from riverdi.displays.bt81x import ctp50 from bridgetek.bt81x import bt81x streams . serial () wifi_driver . auto_init () TAG_BASE = 1 BTN_WIDTH = bt81x . display_conf . width BTN_HEIGHT = bt81x . display_conf . height // 8 MAX_NET = 7 # different colors for pressed and non-pressed buttons palette_default = bt81x . Palette (( 0xff , 0xff , 0xff ), ( 0 , 0 , 0xff )) palette_pressed = bt81x . Palette (( 0xff , 0xff , 0xff ), ( 0xff , 0 , 0 )) btn = bt81x . Button ( 0 , 0 , BTN_WIDTH , BTN_HEIGHT , 31 , 0 , \"\" , palette = palette_default ) def draw_networks ( networks , pressed = None ): bt81x . dl_start () bt81x . clear ( 1 , 1 , 1 ) for i , ssid_sec in enumerate ( networks ): if i == MAX_NET : # do not display more networks than MAX_NET break btn . palette = palette_pressed if i == pressed else palette_default btn . text = ( \" %s :: %s \" ) % ( ssid_sec [ 0 ], ssid_sec [ 1 ]) btn . y = i * BTN_HEIGHT bt81x . track ( 0 , btn . y , BTN_WIDTH , BTN_HEIGHT , TAG_BASE + i ) bt81x . tag ( TAG_BASE + i ) bt81x . add_button ( btn ) bt81x . display () bt81x . swap_and_empty () def pressed ( tag , tracked , tp ): print ( \"PRESSED!\" , tag ) draw_networks ( networks , pressed = tag - 1 ) bt81x . init ( SPI0 , D4 , D33 , D34 ) # uncomment these lines to calibrate resistive displays # bt81x.dl_start() # bt81x.calibrate() # bt81x.swap_and_empty() wifi_sec = ( \"Open\" , \"WEP\" , \"WPA\" , \"WPA2\" ) print ( \"> scanning\" ) # scan and keep network name and security networks = [( scanned [ 0 ], wifi_sec [ scanned [ 1 ]]) for scanned in wifi . scan ( 15000 )] print ( \"> scan results...\" ) draw_networks ( networks ) # register 'pressed' callback for touch events on every tagged object bt81x . touch_loop ((( - 1 , pressed ), )) Display Widgets \u00b6 Select a widget to display, pressing on a key. 1. spinner clock 2. spinner orbiting 3. spinner circle 4. spinner line 5. auto-updating clock main.py import streams import threading import rtc from riverdi.displays.bt81x import ctp50 from bridgetek.bt81x import bt81x def updating_clock (): tt = rtc . get_utc () bt81x . add_clock ( bt81x . display_conf . width // 2 , ( bt81x . display_conf . height * 5 ) // 7 , bt81x . display_conf . height // 6 , 0 , tt . tm_hour , tt . tm_min , tt . tm_sec , 0 ) # simulate a touch event to refresh the clock widget, sleep is needed to not let other threads starve sleep ( 400 ) widget_choice_evt . set () def demo_spinner ( style ): bt81x . spinner ( bt81x . display_conf . width // 2 , ( bt81x . display_conf . height * 5 ) // 7 , style , 0 ) # the widgets tuple contains tuples with: # - widget description # - widget draw function # - widget draw function arguments widgets = ( ( \"spinner clock\" , demo_spinner , bt81x . SPINNER_CLOCK ), ( \"spinner orbiting\" , demo_spinner , bt81x . SPINNER_ORBITING ), ( \"spinner circle\" , demo_spinner , bt81x . SPINNER_CIRCLE ), ( \"spinner line\" , demo_spinner , bt81x . SPINNER_LINE ), ( \"auto-updating clock\" , updating_clock , ), ) widget_choice = None widget_choice_evt = threading . Event () widget_selection_keys = \"123456789\" widget_selection_keys = widget_selection_keys [: len ( widgets )] def widget_choice_cbk ( _widget_choice , _ ): global widget_choice widget_choice = _widget_choice - __ORD ( '0' ) widget_choice_evt . set () palette_default = bt81x . Palette (( 0xff , 0xff , 0xff ), foreground = ( 0x3c , 0x82 , 0x82 )) txt = bt81x . Text ( 0 , 0 , 31 , bt81x . OPT_CENTERX | bt81x . OPT_CENTERY , \"\" , palette = palette_default ) streams . serial () # open serial channel to display debug messages print ( '> Init chip' ) bt81x . init ( SPI0 , D4 , D33 , D34 ) bt81x . touch_loop ((( - 1 , widget_choice_cbk ), )) # listen to touch events and make widget_choice_cbk process them def widget_selection (): bt81x . dl_start () bt81x . clear ( 1 , 1 , 1 ) txt . font = 31 txt . text = \"Choose a widget\" txt . x = bt81x . display_conf . width // 2 txt . y = ( bt81x . display_conf . height * 2 ) // 11 bt81x . add_text ( txt ) bt81x . track ( bt81x . display_conf . width // 5 , ( bt81x . display_conf . height * 3 ) // 11 , 500 , 100 , 0 ) bt81x . add_keys ( bt81x . display_conf . width // 5 , ( bt81x . display_conf . height * 3 ) // 11 , 500 , 100 , 31 , 0 , widget_selection_keys ) if widget_choice : print ( '> displaying' , widgets [ widget_choice - 1 ][ 0 ]) widgets [ widget_choice - 1 ][ 1 ]( * widgets [ widget_choice - 1 ][ 2 :]) bt81x . display () bt81x . swap_and_empty () widget_choice_evt . wait () widget_choice_evt . clear () # uncomment these lines to calibrate resistive displays # bt81x.dl_start() # bt81x.calibrate() # bt81x.swap_and_empty() while True : widget_selection ()","title":"Examples"},{"location":"reference/libs/bridgetek/bt81x/docs/examples/#examples","text":"The following are a list of examples for lib.bridgetek.bt81x.","title":"Examples"},{"location":"reference/libs/bridgetek/bt81x/docs/examples/#display-zerynth-logo","text":"Display Zerynth Logo. main.py import streams from riverdi.displays.bt81x import ctp50 from bridgetek.bt81x import bt81x streams . serial () # choose one logo to be loaded on flash new_resource ( 'zerynth_logo.bin' ) # new_resource('zerynth_logo.png') LOGO_W = 642 LOGO_H = 144 linestride = LOGO_W * 2 # with ARGB1555 and ARGB4 formats, 2 bytes per pixel layout = ( bt81x . ARGB1555 , linestride ) # choose this layout for zerynth_logo.bin # layout = (bt81x.ARGB4, linestride) # choose this layout for zerynth_logo.png zerynth_logo = bt81x . Bitmap ( 1 , 0 , layout , ( bt81x . BILINEAR , bt81x . BORDER , bt81x . BORDER , LOGO_W , LOGO_H )) bt81x . init ( SPI0 , D4 , D33 , D34 ) bt81x . inflate ( 0 , 'zerynth_logo.bin' ) # bt81x.load_image(0, 0, 'zerynth_logo.png') bt81x . dl_start () bt81x . clear_color ( rgb = ( 0xff , 0xff , 0xff )) bt81x . clear ( 1 , 1 , 0 ) zerynth_logo . prepare_draw () zerynth_logo . draw ((( bt81x . display_conf . width - LOGO_W ) // 2 , ( bt81x . display_conf . height - LOGO_H ) // 2 ), vertex_fmt = 0 ) bt81x . display () bt81x . swap_and_empty ()","title":"Display Zerynth Logo"},{"location":"reference/libs/bridgetek/bt81x/docs/examples/#display-networks","text":"Scan for networks and display them on the LCD as clickable buttons. main.py # display networks import streams from wireless import wifi from espressif.esp32net import esp32wifi as wifi_driver from riverdi.displays.bt81x import ctp50 from bridgetek.bt81x import bt81x streams . serial () wifi_driver . auto_init () TAG_BASE = 1 BTN_WIDTH = bt81x . display_conf . width BTN_HEIGHT = bt81x . display_conf . height // 8 MAX_NET = 7 # different colors for pressed and non-pressed buttons palette_default = bt81x . Palette (( 0xff , 0xff , 0xff ), ( 0 , 0 , 0xff )) palette_pressed = bt81x . Palette (( 0xff , 0xff , 0xff ), ( 0xff , 0 , 0 )) btn = bt81x . Button ( 0 , 0 , BTN_WIDTH , BTN_HEIGHT , 31 , 0 , \"\" , palette = palette_default ) def draw_networks ( networks , pressed = None ): bt81x . dl_start () bt81x . clear ( 1 , 1 , 1 ) for i , ssid_sec in enumerate ( networks ): if i == MAX_NET : # do not display more networks than MAX_NET break btn . palette = palette_pressed if i == pressed else palette_default btn . text = ( \" %s :: %s \" ) % ( ssid_sec [ 0 ], ssid_sec [ 1 ]) btn . y = i * BTN_HEIGHT bt81x . track ( 0 , btn . y , BTN_WIDTH , BTN_HEIGHT , TAG_BASE + i ) bt81x . tag ( TAG_BASE + i ) bt81x . add_button ( btn ) bt81x . display () bt81x . swap_and_empty () def pressed ( tag , tracked , tp ): print ( \"PRESSED!\" , tag ) draw_networks ( networks , pressed = tag - 1 ) bt81x . init ( SPI0 , D4 , D33 , D34 ) # uncomment these lines to calibrate resistive displays # bt81x.dl_start() # bt81x.calibrate() # bt81x.swap_and_empty() wifi_sec = ( \"Open\" , \"WEP\" , \"WPA\" , \"WPA2\" ) print ( \"> scanning\" ) # scan and keep network name and security networks = [( scanned [ 0 ], wifi_sec [ scanned [ 1 ]]) for scanned in wifi . scan ( 15000 )] print ( \"> scan results...\" ) draw_networks ( networks ) # register 'pressed' callback for touch events on every tagged object bt81x . touch_loop ((( - 1 , pressed ), ))","title":"Display Networks"},{"location":"reference/libs/bridgetek/bt81x/docs/examples/#display-widgets","text":"Select a widget to display, pressing on a key. 1. spinner clock 2. spinner orbiting 3. spinner circle 4. spinner line 5. auto-updating clock main.py import streams import threading import rtc from riverdi.displays.bt81x import ctp50 from bridgetek.bt81x import bt81x def updating_clock (): tt = rtc . get_utc () bt81x . add_clock ( bt81x . display_conf . width // 2 , ( bt81x . display_conf . height * 5 ) // 7 , bt81x . display_conf . height // 6 , 0 , tt . tm_hour , tt . tm_min , tt . tm_sec , 0 ) # simulate a touch event to refresh the clock widget, sleep is needed to not let other threads starve sleep ( 400 ) widget_choice_evt . set () def demo_spinner ( style ): bt81x . spinner ( bt81x . display_conf . width // 2 , ( bt81x . display_conf . height * 5 ) // 7 , style , 0 ) # the widgets tuple contains tuples with: # - widget description # - widget draw function # - widget draw function arguments widgets = ( ( \"spinner clock\" , demo_spinner , bt81x . SPINNER_CLOCK ), ( \"spinner orbiting\" , demo_spinner , bt81x . SPINNER_ORBITING ), ( \"spinner circle\" , demo_spinner , bt81x . SPINNER_CIRCLE ), ( \"spinner line\" , demo_spinner , bt81x . SPINNER_LINE ), ( \"auto-updating clock\" , updating_clock , ), ) widget_choice = None widget_choice_evt = threading . Event () widget_selection_keys = \"123456789\" widget_selection_keys = widget_selection_keys [: len ( widgets )] def widget_choice_cbk ( _widget_choice , _ ): global widget_choice widget_choice = _widget_choice - __ORD ( '0' ) widget_choice_evt . set () palette_default = bt81x . Palette (( 0xff , 0xff , 0xff ), foreground = ( 0x3c , 0x82 , 0x82 )) txt = bt81x . Text ( 0 , 0 , 31 , bt81x . OPT_CENTERX | bt81x . OPT_CENTERY , \"\" , palette = palette_default ) streams . serial () # open serial channel to display debug messages print ( '> Init chip' ) bt81x . init ( SPI0 , D4 , D33 , D34 ) bt81x . touch_loop ((( - 1 , widget_choice_cbk ), )) # listen to touch events and make widget_choice_cbk process them def widget_selection (): bt81x . dl_start () bt81x . clear ( 1 , 1 , 1 ) txt . font = 31 txt . text = \"Choose a widget\" txt . x = bt81x . display_conf . width // 2 txt . y = ( bt81x . display_conf . height * 2 ) // 11 bt81x . add_text ( txt ) bt81x . track ( bt81x . display_conf . width // 5 , ( bt81x . display_conf . height * 3 ) // 11 , 500 , 100 , 0 ) bt81x . add_keys ( bt81x . display_conf . width // 5 , ( bt81x . display_conf . height * 3 ) // 11 , 500 , 100 , 31 , 0 , widget_selection_keys ) if widget_choice : print ( '> displaying' , widgets [ widget_choice - 1 ][ 0 ]) widgets [ widget_choice - 1 ][ 1 ]( * widgets [ widget_choice - 1 ][ 2 :]) bt81x . display () bt81x . swap_and_empty () widget_choice_evt . wait () widget_choice_evt . clear () # uncomment these lines to calibrate resistive displays # bt81x.dl_start() # bt81x.calibrate() # bt81x.swap_and_empty() while True : widget_selection ()","title":"Display Widgets"},{"location":"reference/libs/broadcom/bcm43362/docs/","text":"Broadcom BCM43362 \u00b6 The Broadcom BCM43362 single-chip device provides the highest level of integration for mobile and handheld wireless systems, featuring integrated IEEE 802.11 b/g and handheld device class IEEE 802.11n. It includes a 2.4 GHz WLAN CMOS power amplifier (PA) that meets the output power requirements of most handheld systems. Along with the integrated power amplifier, the BCM43362 also includes integrated transmit and receive baluns, further reducing the overall solution cost. Host interface options include SDIO v2.0 that can operate in 4b or 1b modes, and a generic SPI mode; more information on Broadcom Community . Technical Details \u00b6 Power Supply Voltage (Vbat): from 2.3 V to 4.8 V Operation Temperature (Top): from -30 \u00b0C to 85 \u00b0C Frequency Range: from 2400 MHz to 2500 MHz Power Consumption (Vbat=3.6V, Top=20\u00b0C): from 40 uA (OFF Mode) to 320 mA (Transmission Mode) Here below, the Zerynth driver for the Broadcom BCM43362 wifi chip. Contents: Broadcom BCM43362 Technical Details BCM43362 Module","title":"Broadcom BCM43362"},{"location":"reference/libs/broadcom/bcm43362/docs/#broadcom-bcm43362","text":"The Broadcom BCM43362 single-chip device provides the highest level of integration for mobile and handheld wireless systems, featuring integrated IEEE 802.11 b/g and handheld device class IEEE 802.11n. It includes a 2.4 GHz WLAN CMOS power amplifier (PA) that meets the output power requirements of most handheld systems. Along with the integrated power amplifier, the BCM43362 also includes integrated transmit and receive baluns, further reducing the overall solution cost. Host interface options include SDIO v2.0 that can operate in 4b or 1b modes, and a generic SPI mode; more information on Broadcom Community .","title":"Broadcom BCM43362"},{"location":"reference/libs/broadcom/bcm43362/docs/#technical-details","text":"Power Supply Voltage (Vbat): from 2.3 V to 4.8 V Operation Temperature (Top): from -30 \u00b0C to 85 \u00b0C Frequency Range: from 2400 MHz to 2500 MHz Power Consumption (Vbat=3.6V, Top=20\u00b0C): from 40 uA (OFF Mode) to 320 mA (Transmission Mode) Here below, the Zerynth driver for the Broadcom BCM43362 wifi chip. Contents: Broadcom BCM43362 Technical Details BCM43362 Module","title":"Technical Details"},{"location":"reference/libs/broadcom/bcm43362/docs/bcm43362/","text":"BCM43362 Module \u00b6 This module implements the bcm43362 wifi driver. At the moment some functionalities are missing: * soft ap * wifi direct It can be used for every kind of bcm43362 based device, going from the Particle Photon to Broadcom Evaluation Boards (not integrated in the IDE). It is important to remark that Broadcom drivers for Zerynth are distributed as binary only, since the Broadcom license for source code is very restrictive. The bcm43362 is based on the SDIO standard and also needs some additional pins to function; one which is called WEN (Wireless Enable) used as turn on/shutdown; one which is called RST and is used internally to reset the Wifi chip; more info on Broadcom Community: https://community.broadcom.com To use the module expand on the following example: from broadcom.bcm43362 import bcm43362 as bcm from wireless import wifi bcm . auto_init () for retry in range ( 10 ): try : wifi . link ( \"Network-SSID\" , wifi . WIFI_WPA2 , \"password\" ) break except Exception as e : print ( e ) if not wifi . is_linked (): raise IOError auto_init \u00b6 auto_init ( country = \"US\" ) Tries to automatically init the bcm43362 driver by looking at the device type. The automatic configuration is possible for Broadcom Evaluation devices and Particle Photon (both USI9 and USI14 modules). The country argument initializes the driver to use only country available channels. PeripheralError is raised in case of failed initialization. init \u00b6 init ( boots0 , boots1 , wen , rst , country ) Tries to init the bcm43362 driver: boots0 and boots1 are the pins used to configure the chip transfer (SPI vs SDIO). Pass 0xffff if not needed. wen is the pin used as wifi power switch rst is the pin used as wifi reset country is the two letter code of the country. It is used to identify available channels. set_antenna \u00b6 set_antenna ( antenna ) Selects the antenna to be used: 0: antenna 0 1: antenna 1 3: automatic antenna selection get_rssi \u00b6 get_rssi () Returns the current RSSI in dBm get_error \u00b6 get_error () Returns the last connection error as an internal code.","title":"BCM43362 Module"},{"location":"reference/libs/broadcom/bcm43362/docs/bcm43362/#bcm43362-module","text":"This module implements the bcm43362 wifi driver. At the moment some functionalities are missing: * soft ap * wifi direct It can be used for every kind of bcm43362 based device, going from the Particle Photon to Broadcom Evaluation Boards (not integrated in the IDE). It is important to remark that Broadcom drivers for Zerynth are distributed as binary only, since the Broadcom license for source code is very restrictive. The bcm43362 is based on the SDIO standard and also needs some additional pins to function; one which is called WEN (Wireless Enable) used as turn on/shutdown; one which is called RST and is used internally to reset the Wifi chip; more info on Broadcom Community: https://community.broadcom.com To use the module expand on the following example: from broadcom.bcm43362 import bcm43362 as bcm from wireless import wifi bcm . auto_init () for retry in range ( 10 ): try : wifi . link ( \"Network-SSID\" , wifi . WIFI_WPA2 , \"password\" ) break except Exception as e : print ( e ) if not wifi . is_linked (): raise IOError","title":"BCM43362 Module"},{"location":"reference/libs/broadcom/bcm43362/docs/bcm43362/#auto_init","text":"auto_init ( country = \"US\" ) Tries to automatically init the bcm43362 driver by looking at the device type. The automatic configuration is possible for Broadcom Evaluation devices and Particle Photon (both USI9 and USI14 modules). The country argument initializes the driver to use only country available channels. PeripheralError is raised in case of failed initialization.","title":"auto_init"},{"location":"reference/libs/broadcom/bcm43362/docs/bcm43362/#init","text":"init ( boots0 , boots1 , wen , rst , country ) Tries to init the bcm43362 driver: boots0 and boots1 are the pins used to configure the chip transfer (SPI vs SDIO). Pass 0xffff if not needed. wen is the pin used as wifi power switch rst is the pin used as wifi reset country is the two letter code of the country. It is used to identify available channels.","title":"init"},{"location":"reference/libs/broadcom/bcm43362/docs/bcm43362/#set_antenna","text":"set_antenna ( antenna ) Selects the antenna to be used: 0: antenna 0 1: antenna 1 3: automatic antenna selection","title":"set_antenna"},{"location":"reference/libs/broadcom/bcm43362/docs/bcm43362/#get_rssi","text":"get_rssi () Returns the current RSSI in dBm","title":"get_rssi"},{"location":"reference/libs/broadcom/bcm43362/docs/bcm43362/#get_error","text":"get_error () Returns the last connection error as an internal code.","title":"get_error"},{"location":"reference/libs/cypress/capsense/docs/","text":"Cypress CapSense \u00b6 CapSense is a Cypress capacitive sensing solution. Capacitive sensing can be used in a variety of applications and products where conventional mechanical buttons can be replaced with sleek human interfaces to transform the way users interact with electronic systems. These include home appliances, automotive, IoT, and industrial applications. CapSense supports multiple interfaces (widgets) using both CSX and CSD sensing methods, with robust performance. Technical Details \u00b6 supports Self-Capacitance (CSD) and Mutual-Capacitance (CSX) sensing methods; supports various Widgets, such as Buttons, Matrix Buttons, Sliders, Touchpads, and Proximity Sensors; provides ultra-low power consumption and liquid-tolerant capacitive sensing technology. Below, Zerynth driver documentation for Cypress CapSense. Contents: Cypress CapSense Library Examples CapsenseEvents","title":"Cypress CapSense"},{"location":"reference/libs/cypress/capsense/docs/#cypress-capsense","text":"CapSense is a Cypress capacitive sensing solution. Capacitive sensing can be used in a variety of applications and products where conventional mechanical buttons can be replaced with sleek human interfaces to transform the way users interact with electronic systems. These include home appliances, automotive, IoT, and industrial applications. CapSense supports multiple interfaces (widgets) using both CSX and CSD sensing methods, with robust performance.","title":"Cypress CapSense"},{"location":"reference/libs/cypress/capsense/docs/#technical-details","text":"supports Self-Capacitance (CSD) and Mutual-Capacitance (CSX) sensing methods; supports various Widgets, such as Buttons, Matrix Buttons, Sliders, Touchpads, and Proximity Sensors; provides ultra-low power consumption and liquid-tolerant capacitive sensing technology. Below, Zerynth driver documentation for Cypress CapSense. Contents: Cypress CapSense Library Examples CapsenseEvents","title":"Technical Details"},{"location":"reference/libs/cypress/capsense/docs/capsense/","text":"Cypress CapSense Library \u00b6 This module exposes easy to use functions to handle Cypress CapSense widgets. Note At the moment the library is tailored for use with CapSense widgets mounted on the PSoC6 WiFi-BT Pioneer Kit (i.e., two buttons and a slider). Tuning and custom configurations are not supported. init \u00b6 init () Initializes available CapSense widgets. on_btn \u00b6 on_btn ( callback , event = BTN0_RISE ) Arguments: callback \u2013 callback function event \u2013 event type Sets a callback to be called in response to a button event. Available events are: BTN0_RISE : triggered on button 0 touch BTN0_FALL : triggered when button 0 press finishes BTN1_RISE : triggered on button 1 touch BTN1_FALL : triggered when button 0 press finishes Callbacks are called without additional parameters. on_slider \u00b6 on_slider ( callback , event = SLIDER_LEAVE ) Arguments: callback \u2013 callback function event \u2013 event type Sets a callback to be called in response to a slider event. Available events are: SLIDER_ENTER : triggered on slider touch SLIDER_LEAVE : triggered when slider press event finishes SLIDER_LVLCHNG : triggered while the slider is pressed, when the slider centroid value changes Slider callbacks are called with different parameters, as described below: # SLIDER_ENTER def enter_callback ( start_pos ): print ( \"centroid value:\" , start_pos ) # SLIDER_LEAVE def leave_callback ( start_pos , end_pos ): print ( \"centroid value on enter and leave:\" , start_pos , end_pos ) # SLIDER_LVLCHNG def level_callback ( cur_pos ): print ( \"centroid value:\" , cur_pos ) get_centroid \u00b6 get_centroid () Gets current slider centroid value. Returns None if the slider is currently not touched.","title":"Cypress CapSense Library"},{"location":"reference/libs/cypress/capsense/docs/capsense/#cypress-capsense-library","text":"This module exposes easy to use functions to handle Cypress CapSense widgets. Note At the moment the library is tailored for use with CapSense widgets mounted on the PSoC6 WiFi-BT Pioneer Kit (i.e., two buttons and a slider). Tuning and custom configurations are not supported.","title":"Cypress CapSense Library"},{"location":"reference/libs/cypress/capsense/docs/capsense/#init","text":"init () Initializes available CapSense widgets.","title":"init"},{"location":"reference/libs/cypress/capsense/docs/capsense/#on_btn","text":"on_btn ( callback , event = BTN0_RISE ) Arguments: callback \u2013 callback function event \u2013 event type Sets a callback to be called in response to a button event. Available events are: BTN0_RISE : triggered on button 0 touch BTN0_FALL : triggered when button 0 press finishes BTN1_RISE : triggered on button 1 touch BTN1_FALL : triggered when button 0 press finishes Callbacks are called without additional parameters.","title":"on_btn"},{"location":"reference/libs/cypress/capsense/docs/capsense/#on_slider","text":"on_slider ( callback , event = SLIDER_LEAVE ) Arguments: callback \u2013 callback function event \u2013 event type Sets a callback to be called in response to a slider event. Available events are: SLIDER_ENTER : triggered on slider touch SLIDER_LEAVE : triggered when slider press event finishes SLIDER_LVLCHNG : triggered while the slider is pressed, when the slider centroid value changes Slider callbacks are called with different parameters, as described below: # SLIDER_ENTER def enter_callback ( start_pos ): print ( \"centroid value:\" , start_pos ) # SLIDER_LEAVE def leave_callback ( start_pos , end_pos ): print ( \"centroid value on enter and leave:\" , start_pos , end_pos ) # SLIDER_LVLCHNG def level_callback ( cur_pos ): print ( \"centroid value:\" , cur_pos )","title":"on_slider"},{"location":"reference/libs/cypress/capsense/docs/capsense/#get_centroid","text":"get_centroid () Gets current slider centroid value. Returns None if the slider is currently not touched.","title":"get_centroid"},{"location":"reference/libs/cypress/capsense/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.cypress.capsense. Capsense Events \u00b6 Touch any button or the slider on your PSOC6 board and get notified. main.py ################################################################################ # Capsense Events # # Created by Zerynth Team 2019 CC # Authors: L.Rizzello, G. Baldi ################################################################################ import streams from cypress.capsense import capsense def hello (): print ( \"hello!!!\" ) def bye (): print ( \"bye...\" ) def notify_leave ( start_pos , end_pos ): print ( \"slider leave!\" , start_pos , end_pos ) def notify_enter ( start_pos ): print ( \"slider enter:\" , start_pos ) def led_toggle ( cur_pos ): pinToggle ( LED0 ) streams . serial () print ( '> init capsense' ) capsense . init () capsense . on_btn ( hello ) capsense . on_btn ( bye , event = capsense . BTN0_FALL ) capsense . on_btn ( hello , event = capsense . BTN1_RISE ) capsense . on_btn ( bye , event = capsense . BTN1_FALL ) capsense . on_slider ( notify_leave , event = capsense . SLIDER_LEAVE ) capsense . on_slider ( notify_enter , event = capsense . SLIDER_ENTER ) capsense . on_slider ( led_toggle , event = capsense . SLIDER_LVLCHNG )","title":"Examples"},{"location":"reference/libs/cypress/capsense/docs/examples/#examples","text":"The following are a list of examples for lib.cypress.capsense.","title":"Examples"},{"location":"reference/libs/cypress/capsense/docs/examples/#capsense-events","text":"Touch any button or the slider on your PSOC6 board and get notified. main.py ################################################################################ # Capsense Events # # Created by Zerynth Team 2019 CC # Authors: L.Rizzello, G. Baldi ################################################################################ import streams from cypress.capsense import capsense def hello (): print ( \"hello!!!\" ) def bye (): print ( \"bye...\" ) def notify_leave ( start_pos , end_pos ): print ( \"slider leave!\" , start_pos , end_pos ) def notify_enter ( start_pos ): print ( \"slider enter:\" , start_pos ) def led_toggle ( cur_pos ): pinToggle ( LED0 ) streams . serial () print ( '> init capsense' ) capsense . init () capsense . on_btn ( hello ) capsense . on_btn ( bye , event = capsense . BTN0_FALL ) capsense . on_btn ( hello , event = capsense . BTN1_RISE ) capsense . on_btn ( bye , event = capsense . BTN1_FALL ) capsense . on_slider ( notify_leave , event = capsense . SLIDER_LEAVE ) capsense . on_slider ( notify_enter , event = capsense . SLIDER_ENTER ) capsense . on_slider ( led_toggle , event = capsense . SLIDER_LVLCHNG )","title":"Capsense Events"},{"location":"reference/libs/eseye/anynetaws/docs/","text":"Eseye AnyNet AWS \u00b6 Eseye is a leading global provider of M2M cellular connectivity for the Internet of Things (IoT) specialized in simplifying complex global device deployments for enterprises. Their AnyNet Secure SIM identifies, catalogues and connects IoT devices to AWS IoT cloud, while reducing costs and risks of IoT deployments. To easily interact with AnyNet Secure SIM exploiting its AWS IoT readiness, an MCU-based AT modem has been developed. The AWS AT modem exposes an MQTT client, connected to AWS IoT, controllable through simple AT custom commands over a serial interface. The modem can be found on the AnyNet 2G Click Board as a result of the partnership between MikroElektronica and Eseye . Note When using AnyNet 2G Click Board be sure to have sufficient power supply and a sufficiently good antenna according to 2G network signal strength for the zone of usage. Here below, the Zerynth Library to communicate to the modem through an intuitive Python interface. Contents: Eseye AnyNet AWS Eseye AnyNet AWS Library Examples Get info Publish and subscribe","title":"Eseye AnyNet AWS"},{"location":"reference/libs/eseye/anynetaws/docs/#eseye-anynet-aws","text":"Eseye is a leading global provider of M2M cellular connectivity for the Internet of Things (IoT) specialized in simplifying complex global device deployments for enterprises. Their AnyNet Secure SIM identifies, catalogues and connects IoT devices to AWS IoT cloud, while reducing costs and risks of IoT deployments. To easily interact with AnyNet Secure SIM exploiting its AWS IoT readiness, an MCU-based AT modem has been developed. The AWS AT modem exposes an MQTT client, connected to AWS IoT, controllable through simple AT custom commands over a serial interface. The modem can be found on the AnyNet 2G Click Board as a result of the partnership between MikroElektronica and Eseye . Note When using AnyNet 2G Click Board be sure to have sufficient power supply and a sufficiently good antenna according to 2G network signal strength for the zone of usage. Here below, the Zerynth Library to communicate to the modem through an intuitive Python interface. Contents: Eseye AnyNet AWS Eseye AnyNet AWS Library Examples Get info Publish and subscribe","title":"Eseye AnyNet AWS"},{"location":"reference/libs/eseye/anynetaws/docs/anynetaws/","text":"Eseye AnyNet AWS Library \u00b6 The Zerynth Eseye AnyNet AWS Library allows to easily connect to AWS IoT platform thanks to Eseye AnyNet AWS AT modem. init \u00b6 init ( serdrv , serbaud = 9600 ) Arguments: serdrv \u2013 serial communication driver (e.g., SERIAL0 , SERIAL1 , \u2026) serbaud \u2013 serial communication baudrate Initialize serial communication with the Eseye AWS AT modem. state \u00b6 state ( string_format = True ) Arguments: string_format \u2013 True or False to select string or integer output format respectively Retrieve modem state, returned as an integer in the range 0 , :samp:8 or a string in the list: [ 'Idle' , 'Waiting Keys' , 'Connecting to Network' , 'Establishing SSL' , 'SSL Connected' , 'Connecting MQTT' , 'Ready: MQTT Connected' , 'Ready: Subscribed' , 'Error' ] qccid \u00b6 qccid () Retrieve the ICCD of AnyNet Secure SIM. version \u00b6 version () Retrieve the version of the Eseye AWS AT modem firmware. reset() Force a reload of parameters from the SIM card, forcing the modem to reset. pubopen \u00b6 pubopen ( topic , sock_index ) Arguments: topic \u2013 a string representing a valid mqtt topic (note that the modem firmware automatically appends AWS IoT Thing name to chosen topic) sock_index \u2013 an integer representing a valid modem socket index (0,1) Open a publish channel to topic topic through socket index sock_index . Eseye AWS AT modem needs a publish channel to be open before starting publishing on a selected topic. A publish channel is open on top of an available socket represented by a socket index. Only one channel can be open on a single socket index, when trying to open a channel on an already used socket a SocketUsageError exception is raised. pubopen_index \u00b6 pubopen_index ( topic ) Arguments: topic \u2013 a string representing a valid mqtt topic (note that the modem firmware automatically appends AWS IoT Thing name to chosen topic) Check if a publish channel for topic topic is already open on any of the available modem sockets, returning None if none is found, socket index otherwise. publish \u00b6 publish ( topic , payload , sock_index = 0 , qos = 1 , mode = 2 ) Arguments: topic \u2013 a string representing a valid mqtt topic (note that the modem firmware automatically appends AWS IoT Thing name to chosen topic) payload \u2013 a string, bytes or bytearray object to be sent sock_index \u2013 an integer representing a valid modem socket index (0,1) qos \u2013 an integer representing the qos level to send the mqtt message with (1,2,3) mode \u2013 an integer representing a valid publish mode (0,1,2) Publish a message on a chosen topic in one of the following modes: publish the message without opening a publish channel , which must be already open when calling this function, open ( pubopen() ) a publish channel and publish the message without checking if a publish channel is already open on that topic, open ( pubopen() ) a publish channel and publish the message checking if a channel is already open on chosen topic, if so the socket index on which the channel is already open overwrites passed one. pubclose \u00b6 pubclose ( sock_index ) Arguments: sock_index \u2013 an integer representing a valid modem socket index (0,1) Close a publish channel open on socket sock_index . subopen \u00b6 subopen ( topic , sock_index ) Arguments: topic \u2013 a string representing a valid mqtt topic (note that the modem firmware automatically appends AWS IoT Thing name to chosen topic) sock_index \u2013 an integer representing a valid modem socket index (0,1) Open a subscription channel for topic topic through socket index sock_index . A subscription channel is open on top of an available socket represented by a socket index. Only one channel can be open on a single socket index, when trying to open a channel on an already used socket a SocketUsageError exception is raised. Refer to subscribe() function to associate a callback function to chosen subscription. subopen_index \u00b6 subopen_index ( topic ) Arguments: topic \u2013 a string representing a valid mqtt topic (note that the modem firmware automatically appends AWS IoT Thing name to chosen topic) Check if a subscription channel for topic topic is already open on any of the available modem sockets, returning None if none is found, socket index otherwise. subclose \u00b6 subclose ( sock_index ) Arguments: sock_index \u2013 an integer representing a valid modem socket index (0,1) Close a subscription open on socket sock_index . subscribe \u00b6 subscribe ( topic , callback , sock_index = 0 , mode = 1 ) Arguments: topic \u2013 a string representing a valid mqtt topic (note that the modem firmware automatically appends AWS IoT Thing name to chosen topic) callback \u2013 a function to be called when a message arrives on chosen topic sock_index \u2013 an integer representing a valid modem socket index (0,1) mode \u2013 an integer representing a valid subscription mode (0,1) Subscribe to topic topic calling callback function whenever a new message arrives on chosen topic. Example callback function: def my_callback ( sock_index , topic , data ): print ( '> callback from' , topic ) print ( '> on socket ' , sock_index ) print ( '> with content:' , data ) As reported, a callback function must accept three arguments. Depending on selected mode, the following actions are executed calling the subscribe() function: 1. open ( subopen() ) a subscription channel , setting a callback, without checking if a channel is already open on chosen topic, 2. open ( subopen() ) a subscription channel , setting a callback, checking if a channel is already open on chosen topic, if so the socket index on which the channel is already open overwrites passed one.","title":"Eseye AnyNet AWS Library"},{"location":"reference/libs/eseye/anynetaws/docs/anynetaws/#eseye-anynet-aws-library","text":"The Zerynth Eseye AnyNet AWS Library allows to easily connect to AWS IoT platform thanks to Eseye AnyNet AWS AT modem.","title":"Eseye AnyNet AWS Library"},{"location":"reference/libs/eseye/anynetaws/docs/anynetaws/#init","text":"init ( serdrv , serbaud = 9600 ) Arguments: serdrv \u2013 serial communication driver (e.g., SERIAL0 , SERIAL1 , \u2026) serbaud \u2013 serial communication baudrate Initialize serial communication with the Eseye AWS AT modem.","title":"init"},{"location":"reference/libs/eseye/anynetaws/docs/anynetaws/#state","text":"state ( string_format = True ) Arguments: string_format \u2013 True or False to select string or integer output format respectively Retrieve modem state, returned as an integer in the range 0 , :samp:8 or a string in the list: [ 'Idle' , 'Waiting Keys' , 'Connecting to Network' , 'Establishing SSL' , 'SSL Connected' , 'Connecting MQTT' , 'Ready: MQTT Connected' , 'Ready: Subscribed' , 'Error' ]","title":"state"},{"location":"reference/libs/eseye/anynetaws/docs/anynetaws/#qccid","text":"qccid () Retrieve the ICCD of AnyNet Secure SIM.","title":"qccid"},{"location":"reference/libs/eseye/anynetaws/docs/anynetaws/#version","text":"version () Retrieve the version of the Eseye AWS AT modem firmware. reset() Force a reload of parameters from the SIM card, forcing the modem to reset.","title":"version"},{"location":"reference/libs/eseye/anynetaws/docs/anynetaws/#pubopen","text":"pubopen ( topic , sock_index ) Arguments: topic \u2013 a string representing a valid mqtt topic (note that the modem firmware automatically appends AWS IoT Thing name to chosen topic) sock_index \u2013 an integer representing a valid modem socket index (0,1) Open a publish channel to topic topic through socket index sock_index . Eseye AWS AT modem needs a publish channel to be open before starting publishing on a selected topic. A publish channel is open on top of an available socket represented by a socket index. Only one channel can be open on a single socket index, when trying to open a channel on an already used socket a SocketUsageError exception is raised.","title":"pubopen"},{"location":"reference/libs/eseye/anynetaws/docs/anynetaws/#pubopen_index","text":"pubopen_index ( topic ) Arguments: topic \u2013 a string representing a valid mqtt topic (note that the modem firmware automatically appends AWS IoT Thing name to chosen topic) Check if a publish channel for topic topic is already open on any of the available modem sockets, returning None if none is found, socket index otherwise.","title":"pubopen_index"},{"location":"reference/libs/eseye/anynetaws/docs/anynetaws/#publish","text":"publish ( topic , payload , sock_index = 0 , qos = 1 , mode = 2 ) Arguments: topic \u2013 a string representing a valid mqtt topic (note that the modem firmware automatically appends AWS IoT Thing name to chosen topic) payload \u2013 a string, bytes or bytearray object to be sent sock_index \u2013 an integer representing a valid modem socket index (0,1) qos \u2013 an integer representing the qos level to send the mqtt message with (1,2,3) mode \u2013 an integer representing a valid publish mode (0,1,2) Publish a message on a chosen topic in one of the following modes: publish the message without opening a publish channel , which must be already open when calling this function, open ( pubopen() ) a publish channel and publish the message without checking if a publish channel is already open on that topic, open ( pubopen() ) a publish channel and publish the message checking if a channel is already open on chosen topic, if so the socket index on which the channel is already open overwrites passed one.","title":"publish"},{"location":"reference/libs/eseye/anynetaws/docs/anynetaws/#pubclose","text":"pubclose ( sock_index ) Arguments: sock_index \u2013 an integer representing a valid modem socket index (0,1) Close a publish channel open on socket sock_index .","title":"pubclose"},{"location":"reference/libs/eseye/anynetaws/docs/anynetaws/#subopen","text":"subopen ( topic , sock_index ) Arguments: topic \u2013 a string representing a valid mqtt topic (note that the modem firmware automatically appends AWS IoT Thing name to chosen topic) sock_index \u2013 an integer representing a valid modem socket index (0,1) Open a subscription channel for topic topic through socket index sock_index . A subscription channel is open on top of an available socket represented by a socket index. Only one channel can be open on a single socket index, when trying to open a channel on an already used socket a SocketUsageError exception is raised. Refer to subscribe() function to associate a callback function to chosen subscription.","title":"subopen"},{"location":"reference/libs/eseye/anynetaws/docs/anynetaws/#subopen_index","text":"subopen_index ( topic ) Arguments: topic \u2013 a string representing a valid mqtt topic (note that the modem firmware automatically appends AWS IoT Thing name to chosen topic) Check if a subscription channel for topic topic is already open on any of the available modem sockets, returning None if none is found, socket index otherwise.","title":"subopen_index"},{"location":"reference/libs/eseye/anynetaws/docs/anynetaws/#subclose","text":"subclose ( sock_index ) Arguments: sock_index \u2013 an integer representing a valid modem socket index (0,1) Close a subscription open on socket sock_index .","title":"subclose"},{"location":"reference/libs/eseye/anynetaws/docs/anynetaws/#subscribe","text":"subscribe ( topic , callback , sock_index = 0 , mode = 1 ) Arguments: topic \u2013 a string representing a valid mqtt topic (note that the modem firmware automatically appends AWS IoT Thing name to chosen topic) callback \u2013 a function to be called when a message arrives on chosen topic sock_index \u2013 an integer representing a valid modem socket index (0,1) mode \u2013 an integer representing a valid subscription mode (0,1) Subscribe to topic topic calling callback function whenever a new message arrives on chosen topic. Example callback function: def my_callback ( sock_index , topic , data ): print ( '> callback from' , topic ) print ( '> on socket ' , sock_index ) print ( '> with content:' , data ) As reported, a callback function must accept three arguments. Depending on selected mode, the following actions are executed calling the subscribe() function: 1. open ( subopen() ) a subscription channel , setting a callback, without checking if a channel is already open on chosen topic, 2. open ( subopen() ) a subscription channel , setting a callback, checking if a channel is already open on chosen topic, if so the socket index on which the channel is already open overwrites passed one.","title":"subscribe"},{"location":"reference/libs/eseye/anynetaws/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.eseye.anynetaws. Get Info \u00b6 Print Eseye AWS AT modem info. main.py # Eseye Anynet AWS Get info example # Created at 2018-04-11 14:41:54.157523 import streams from eseye.anynetaws import anynetaws as aws streams . serial () aws . init ( SERIAL2 ) # select the serial driver the modem is connected to while True : print ( '> aws state:' , aws . state ()) print ( '> firmware version:' , aws . version ()) print ( '> qccid:' , aws . qccid ()) sleep ( 5000 ) Publish and Subscribe \u00b6 Set two callbacks for two different AWS IoT MQTT topics and publish on another topic when a newline character is received on the serial monitor. main.py # Eseye Anynet AWS Publish and Subscribe example # Created at 2018-04-11 09:09:21.039592 import streams from eseye.anynetaws import anynetaws as aws def my_callback ( index , topic , data ): print ( '> callback from' , topic ) print ( '> content:' , data ) main_ser = streams . serial () aws . init ( SERIAL2 ) # select the serial driver the modem is connected to print ( '> subscribe...' ) # subscribe to mychannel/commands/thingname and mychannel/cloudmessages/thingname topics aws . subscribe ( 'mychannel/commands' , my_callback , sock_index = 0 ) aws . subscribe ( 'mychannel/cloudmessages' , my_callback , sock_index = 1 ) print ( '> subscriptions completed!' ) while True : print ( '> [ENTER] to publish' ) main_ser . readline () print ( '> publish...' ) # publish a message on topic mychannel/devices/thingname aws . publish ( 'mychannel/devices' , 'hello!' ) print ( '> publish completed!' )","title":"Examples"},{"location":"reference/libs/eseye/anynetaws/docs/examples/#examples","text":"The following are a list of examples for lib.eseye.anynetaws.","title":"Examples"},{"location":"reference/libs/eseye/anynetaws/docs/examples/#get-info","text":"Print Eseye AWS AT modem info. main.py # Eseye Anynet AWS Get info example # Created at 2018-04-11 14:41:54.157523 import streams from eseye.anynetaws import anynetaws as aws streams . serial () aws . init ( SERIAL2 ) # select the serial driver the modem is connected to while True : print ( '> aws state:' , aws . state ()) print ( '> firmware version:' , aws . version ()) print ( '> qccid:' , aws . qccid ()) sleep ( 5000 )","title":"Get Info"},{"location":"reference/libs/eseye/anynetaws/docs/examples/#publish-and-subscribe","text":"Set two callbacks for two different AWS IoT MQTT topics and publish on another topic when a newline character is received on the serial monitor. main.py # Eseye Anynet AWS Publish and Subscribe example # Created at 2018-04-11 09:09:21.039592 import streams from eseye.anynetaws import anynetaws as aws def my_callback ( index , topic , data ): print ( '> callback from' , topic ) print ( '> content:' , data ) main_ser = streams . serial () aws . init ( SERIAL2 ) # select the serial driver the modem is connected to print ( '> subscribe...' ) # subscribe to mychannel/commands/thingname and mychannel/cloudmessages/thingname topics aws . subscribe ( 'mychannel/commands' , my_callback , sock_index = 0 ) aws . subscribe ( 'mychannel/cloudmessages' , my_callback , sock_index = 1 ) print ( '> subscriptions completed!' ) while True : print ( '> [ENTER] to publish' ) main_ser . readline () print ( '> publish...' ) # publish a message on topic mychannel/devices/thingname aws . publish ( 'mychannel/devices' , 'hello!' ) print ( '> publish completed!' )","title":"Publish and Subscribe"},{"location":"reference/libs/espressif/esp32ble/docs/","text":"Espressif ESP32 BLE \u00b6 This module implements the BLE driver for ESP32. It includes support for secure pairing and scanning. The module implements only the peripheral role functionalities, while the central role ones are not included. The module is also compatible with the Wifi and Ethernet drivers and the radio coexistence is entirely managed by the VM in a balanced mode. Many examples are available going from a simple scanner, to beacons to a more advanced GATT server. To test the examples it is suggested to use a BLE app like the nRF Connect and a Beacon scanner like Beacon Scanner . Some screenshots related to the examples: Contents: ESP32 BLE Examples BLE Alerts BLE Scanner Eddystone Beacon iBeacon Beacon Eddystone Reader iBeacon Reader BLE Alerts Secure 1 BLE Alerts Secure 2 BLE Wifi","title":"Espressif ESP32 BLE"},{"location":"reference/libs/espressif/esp32ble/docs/#espressif-esp32-ble","text":"This module implements the BLE driver for ESP32. It includes support for secure pairing and scanning. The module implements only the peripheral role functionalities, while the central role ones are not included. The module is also compatible with the Wifi and Ethernet drivers and the radio coexistence is entirely managed by the VM in a balanced mode. Many examples are available going from a simple scanner, to beacons to a more advanced GATT server. To test the examples it is suggested to use a BLE app like the nRF Connect and a Beacon scanner like Beacon Scanner . Some screenshots related to the examples: Contents: ESP32 BLE Examples BLE Alerts BLE Scanner Eddystone Beacon iBeacon Beacon Eddystone Reader iBeacon Reader BLE Alerts Secure 1 BLE Alerts Secure 2 BLE Wifi","title":"Espressif ESP32 BLE"},{"location":"reference/libs/espressif/esp32ble/docs/esp32ble/","text":"ESP32 BLE \u00b6 This module implements the ESP32 ble driver for peripheral roles. The driver is based on ESP32 IDF 3.2 and can work on Virtual Machines compiled with support for ESP32 BLE. To use the module expand on the following example: from espressif.esp32ble import esp32ble as bledrv from wireless import ble bledrv . init () ble . gap ( \"Zerynth\" ) ble . start () while True : sleep ( 1000 ) # do things here","title":"ESP32 BLE"},{"location":"reference/libs/espressif/esp32ble/docs/esp32ble/#esp32-ble","text":"This module implements the ESP32 ble driver for peripheral roles. The driver is based on ESP32 IDF 3.2 and can work on Virtual Machines compiled with support for ESP32 BLE. To use the module expand on the following example: from espressif.esp32ble import esp32ble as bledrv from wireless import ble bledrv . init () ble . gap ( \"Zerynth\" ) ble . start () while True : sleep ( 1000 ) # do things here","title":"ESP32 BLE"},{"location":"reference/libs/espressif/esp32ble/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.espressif.esp32ble. BLE Alerts \u00b6 An implementationof an Alert Notification device to show how services and characteristics can be easily created. main.py ################################################################################ # BLE Alerts # # Created by Zerynth Team 2019 CC # Author: G. Baldi ############################################################################### import streams #import the ESP32 BLE driver: a BLE capable VM is also needed! from espressif.esp32ble import esp32ble as bledrv # then import the BLE modue from wireless import ble streams . serial () notifications_enabled = True connected = False # Let's define some callbacks def value_cb ( status , val ): # check incoming commands and enable/disable notifications global notifications_enabled print ( \"Value changed to\" , val [ 0 ], val [ 1 ]) if val [ 0 ] == 0 : print ( \"Notifications enabled\" ) notifications_enabled = True elif val [ 0 ] == 2 : notifications_enabled = False print ( \"Notifications disabled\" ) else : print ( \"Notifications unchanged\" ) def connection_cb ( address ): global connected print ( \"Connected to\" , ble . btos ( address )) connected = True def disconnection_cb ( address ): global connected print ( \"Disconnected from\" , ble . btos ( address )) # let's start advertising again ble . start_advertising () connected = False try : # initialize BLE driver bledrv . init () # Set GAP name and no security ble . gap ( \"ZNotifier\" , security = ( ble . SECURITY_MODE_1 , ble . SECURITY_LEVEL_1 )) # add some GAP callbacks ble . add_callback ( ble . EVT_CONNECTED , connection_cb ) ble . add_callback ( ble . EVT_DISCONNECTED , disconnection_cb ) # Create a GATT Service: let's try an Alert Notification Service # (here are the specs: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.service.alert_notification.xml) s = ble . Service ( 0x1811 ) # The Alert Notification service has multiple characteristics. Let's add them one by one # Create a GATT Characteristic for counting new alerts. # specs: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.characteristic.supported_new_alert_category.xml cn = ble . Characteristic ( 0x2A47 , ble . NOTIFY | ble . READ , 16 , \"New Alerts\" , ble . BYTES ) # Add the GATT Characteristic to the Service s . add_characteristic ( cn ) # Create anothr GATT Characteristic for enabling/disabling alerts # specs: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.characteristic.alert_notification_control_point.xml cc = ble . Characteristic ( 0x2A44 , ble . WRITE , 2 , \"Alerts control\" , ble . BYTES ) # Add the GATT Characteristic to the Service s . add_characteristic ( cc ) # Add a callback to be notified of changes cc . set_callback ( value_cb ) # Add the Service. You can create additional services and add them one by one ble . add_service ( s ) # Setup advertising to 50ms ble . advertising ( 50 ) # Start the BLE stack ble . start () # Now start advertising ble . start_advertising () except Exception as e : print ( e ) # loop forever while True : print ( \".\" ) if random ( 0 , 100 ) < 50 and notifications_enabled and connected : value = bytearray ( cn . get_value ()) value [ 0 ] = 0 # simple alert type if value [ 1 ] < 255 : value [ 1 ] = value [ 1 ] + 1 # add a notification print ( \"Adding a new notification, total of\" , value [ 1 ]) # the remaining 14 bytes can be some text value [ 2 : 10 ] = \"Zerynth!\" # set the new value. If ble notifications are enabled, the connected device will receive the change cn . set_value ( value ) sleep ( 5000 ) BLE Scanner \u00b6 A simple example implementing a BLE packet scanner. main.py ################################################################################ # BLE Scanner # # Created by Zerynth Team 2019 CC # Author: G. Baldi ############################################################################### import streams #import the ESP32 BLE driver: a BLE capable VM is also needed! from espressif.esp32ble import esp32ble as bledrv # then import the BLE modue from wireless import ble streams . serial () # Let's define some callbacks and constants # How long to scan for in milliseconds scan_time = 30000 def scan_report_cb ( data ): print ( \"Detected packet from\" , ble . btos ( data [ 4 ]), \"containing\" , ble . btos ( data [ 3 ])) print ( \" packet is of type\" , data [ 0 ], \"while address is of type\" , data [ 1 ]) print ( \" remote device has RSSI of\" , data [ 2 ]) def scan_start_cb ( data ): print ( \"Scan started\" ) def scan_stop_cb ( data ): print ( \"Scan stopped\" ) #let's start it up again ble . start_scanning ( scan_time ) try : # initialize BLE driver bledrv . init () # Set GAP name and no security ble . gap ( \"Zerynth\" , security = ( ble . SECURITY_MODE_1 , ble . SECURITY_LEVEL_1 )) ble . add_callback ( ble . EVT_SCAN_REPORT , scan_report_cb ) ble . add_callback ( ble . EVT_SCAN_STARTED , scan_start_cb ) ble . add_callback ( ble . EVT_SCAN_STOPPED , scan_stop_cb ) #set scanning parameters: every 100ms for 50ms and no duplicates ble . scanning ( 100 , 50 , duplicates = 0 ) # Start the BLE stack ble . start () # Now start scanning for 30 seconds ble . start_scanning ( scan_time ) except Exception as e : print ( e ) # loop forever while True : print ( \".\" ) sleep ( 10000 ) Eddystone Beacon \u00b6 An implementation of a simple Eddystone Beacon advertising some predefined packets. main.py ################################################################################ # Eddystone Beacon # # Created by Zerynth Team 2019 CC # Author: G. Baldi ############################################################################### import streams import timers #import the ESP32 BLE driver: a BLE capable VM is also needed! from espressif.esp32ble import esp32ble as bledrv # then import the BLE module and beacons from wireless import ble from wireless import ble_beacons as bb streams . serial () adv_content = 0 battery_level = 40 temperature = 23.2 pdu_count = 0 uptime = timers . timer () uptime . start () # create payloads to cycle through payloads = [ bb . eddy_encode_uid ( \"Zerynth\" , \"Python\" , - 69 ), # UID Eddystone payload bb . eddy_encode_url ( \"https://www.zerynth.com\" , - 69 ), # URL Eddystone payload bb . eddy_encode_tlm ( battery_level , temperature , pdu_count , uptime . get () / 1000 ) # TLM Eddystone payload ] # this callback will be called at the end of an advertising cycle. # it is used to switch to the next content def adv_stop_cb ( data ): global pdu_count , adv_content print ( \"Advertising stopped\" ) adv_content = ( adv_content + 1 ) % 3 if adv_content == 0 : # advertise UID interval = 100 timeout = 10000 elif adv_content == 1 : # advertise URL interval = 100 timeout = 15000 else : # advertise TLM interval = 100 timeout = 150 pdu_count += 1 payloads [ 2 ] = bb . eddy_encode_tlm ( battery_level , temperature , pdu_count , uptime . get () / 1000 ) # TLM Eddystone payload payload = payloads [ adv_content ] ble . advertising ( interval , timeout = timeout , payload = payload , mode = ble . ADV_UNCN_UND ) ble . start_advertising () print ( \"Advertising restarted with\" , ble . btos ( payload )) try : # initialize BLE driver bledrv . init () # Set GAP name and no security ble . gap ( \"Zerynth\" , security = ( ble . SECURITY_MODE_1 , ble . SECURITY_LEVEL_1 )) ble . add_callback ( ble . EVT_ADV_STOPPED , adv_stop_cb ) # set advertising options: advertise every second with custom payload in non connectable undirected mode # after 10 seconds, stop and change payload ble . advertising ( 100 , timeout = 10000 , payload = payloads [ adv_content ], mode = ble . ADV_UNCN_UND ) # Start the BLE stack ble . start () # Now start scanning for 30 seconds ble . start_advertising () except Exception as e : print ( e ) # loop forever while True : print ( \".\" ) sleep ( 10000 ) iBeacon \u00b6 An Apple beacon advertising its own uuid. main.py ################################################################################ # iBeacon # # Created by Zerynth Team 2019 CC # Author: G. Baldi ############################################################################### import streams import timers #import the ESP32 BLE driver: a BLE capable VM is also needed! from espressif.esp32ble import esp32ble as bledrv # then import the BLE module and beacons from wireless import ble from wireless import ble_beacons as bb streams . serial () try : # initialize BLE driver bledrv . init () # Set GAP name and no security ble . gap ( \"Zerynth\" , security = ( ble . SECURITY_MODE_1 , ble . SECURITY_LEVEL_1 )) # set advertising options: advertise every second with custom payload in non connectable undirected mode ble . advertising ( 20 , payload = bb . ibeacon_encode ( \"fb0b57a2-8228-44cd-913a-94a122ba1206\" , 10 , 3 , - 69 ), mode = ble . ADV_UNCN_UND ) # Start the BLE stack ble . start () # Now start advertising ble . start_advertising () except Exception as e : print ( e ) # loop forever while True : print ( \".\" ) sleep ( 10000 ) main.py ################################################################################ # Eddystone Reader # # Created by Zerynth Team 2019 CC # Author: G. Baldi ############################################################################### import streams #import the ESP32 BLE driver: a BLE capable VM is also needed! from espressif.esp32ble import esp32ble as bledrv # then import the BLE modue from wireless import ble from wireless import ble_beacons as bb streams . serial () # Let's define some callbacks def scan_report_cb ( data ): pdata = data [ 3 ] rssi = data [ 2 ] try : etype = bb . eddy_decode_type ( pdata ) if etype == bb . EDDY_URL : url , tx = bb . eddy_decode ( pdata ) print ( \"Eddy URL found with\" , url , tx , rssi ) elif etype == bb . EDDY_UID : namespace , instance , tx = bb . eddy_decode ( pdata ) print ( \"Eddy UID found with\" ,[ hex ( x ) for x in namespace ],[ hex ( x ) for x in instance ], tx , rssi ) elif etype == bb . EDDY_LTM : battery , temperature , count , uptime = bb . eddy_decode ( pdata ) print ( \"Eddy LTM found with\" , battery , temperature , count , uptime , rssi ) # print(\"iBeacon found with\",[hex(x) for x in uuid],major,minor,tx,rssi) except Exception as e : print ( \"::\" ) def scan_stop_cb ( data ): print ( \"Scan stopped\" ) #let's start it up again ble . start_scanning ( 3000 ) try : # initialize BLE driver bledrv . init () # Set GAP name and no security ble . gap ( \"Zerynth\" , security = ( ble . SECURITY_MODE_1 , ble . SECURITY_LEVEL_1 )) ble . add_callback ( ble . EVT_SCAN_REPORT , scan_report_cb ) ble . add_callback ( ble . EVT_SCAN_STOPPED , scan_stop_cb ) #set scanning parameters: every 100ms for 100ms and no duplicates ble . scanning ( 100 , 100 , duplicates = 0 ) # Start the BLE stack ble . start () # Now start scanning for 3 seconds ble . start_scanning ( 3000 ) except Exception as e : print ( e ) # loop forever while True : print ( \".\" ) sleep ( 10000 ) iBeacon Reader \u00b6 A simple firmware to scan for iBeacons. main.py ################################################################################ # iBeacon Reader # # Created by Zerynth Team 2019 CC # Author: G. Baldi ############################################################################### import streams #import the ESP32 BLE driver: a BLE capable VM is also needed! from espressif.esp32ble import esp32ble as bledrv # then import the BLE modue from wireless import ble from wireless import ble_beacons as bb streams . serial () # Let's define some callbacks def scan_report_cb ( data ): pdata = data [ 3 ] rssi = data [ 2 ] try : uuid , major , minor , tx = bb . ibeacon_decode ( pdata ) print ( \"iBeacon found with\" ,[ hex ( x ) for x in uuid ], major , minor , tx , rssi ) except Exception as e : print ( \"::\" ) def scan_stop_cb ( data ): print ( \"Scan stopped\" ) #let's start it up again ble . start_scanning ( 3000 ) try : # initialize BLE driver bledrv . init () # Set GAP name and no security ble . gap ( \"Zerynth\" , security = ( ble . SECURITY_MODE_1 , ble . SECURITY_LEVEL_1 )) ble . add_callback ( ble . EVT_SCAN_REPORT , scan_report_cb ) ble . add_callback ( ble . EVT_SCAN_STOPPED , scan_stop_cb ) #set scanning parameters: every 100ms for 100ms and no duplicates ble . scanning ( 100 , 100 , duplicates = 0 ) # Start the BLE stack ble . start () # Now start scanning for 3 seconds ble . start_scanning ( 3000 ) except Exception as e : print ( e ) # loop forever while True : print ( \".\" ) sleep ( 10000 ) BLE Alerts with Security 1 \u00b6 An implementationof an Alert Notification device to show how services and characteristics can be easily created. It also features secure connections with bonding. main.py ################################################################################ # BLE Alerts with security # # Created by Zerynth Team 2019 CC # Author: G. Baldi ############################################################################### import streams #import the ESP32 BLE driver: a BLE capable VM is also needed! from espressif.esp32ble import esp32ble as bledrv # then import the BLE modue from wireless import ble streams . serial () notifications_enabled = True connected = False # Let's define some callbacks def value_cb ( status , val ): # check incoming commands and enable/disable notifications global notifications_enabled print ( \"Value changed to\" , val [ 0 ], val [ 1 ]) if val [ 0 ] == 0 : print ( \"Notifications enabled\" ) notifications_enabled = True elif val [ 0 ] == 2 : notifications_enabled = False print ( \"Notifications disabled\" ) else : print ( \"Notifications unchanged\" ) def connection_cb ( address ): global connected print ( \"Connected to\" , ble . btos ( address )) connected = True def disconnection_cb ( address ): global connected print ( \"Disconnected from\" , ble . btos ( address )) # let's start advertising again ble . start_advertising () connected = False # Let's define some security callbacks def show_key_cb ( passkey ): print ( \"ENTER THIS PIN ON THE MASTER:\" , passkey ) try : # initialize BLE driver bledrv . init () # Set GAP name and LEVEL 2 security # !!! If security is not set, no secure connection will be possible ble . gap ( \"ZNotifier\" , security = ( ble . SECURITY_MODE_1 , ble . SECURITY_LEVEL_2 )) # add some GAP callbacks ble . add_callback ( ble . EVT_CONNECTED , connection_cb ) ble . add_callback ( ble . EVT_DISCONNECTED , disconnection_cb ) # Create a GATT Service: let's try an Alert Notification Service # (here are the specs: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.service.alert_notification.xml) s = ble . Service ( 0x1811 ) # The Alert Notification service has multiple characteristics. Let's add them one by one # Create a GATT Characteristic for counting new alerts. # specs: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.characteristic.supported_new_alert_category.xml cn = ble . Characteristic ( 0x2A47 , ble . NOTIFY | ble . READ , 16 , \"New Alerts\" , ble . BYTES ) # Add the GATT Characteristic to the Service s . add_characteristic ( cn ) # Create anothr GATT Characteristic for enabling/disabling alerts # specs: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.characteristic.alert_notification_control_point.xml cc = ble . Characteristic ( 0x2A44 , ble . WRITE , 2 , \"Alerts control\" , ble . BYTES ) # Add the GATT Characteristic to the Service s . add_characteristic ( cc ) # Add a callback to be notified of changes cc . set_callback ( value_cb ) # Add the Service. You can create additional services and add them one by one ble . add_service ( s ) # Configure security. BLE security is very flexible. # In this case we declare that the device has only an output capability (CAP_DISPLAY_ONLY), # that we require a bonding (storage of the keys after pairing) # and that we want both secure connection and main in the middle protection. # Since we have CAP_DISPLAY_ONLY, we also declare a passkey that will be shown to the user # to be entered on the master (i.e. the smartphone) to finalize the bonding. ble . security ( capabilities = ble . CAP_DISPLAY_ONLY , bonding = ble . AUTH_BOND , scheme = ble . AUTH_SC | ble . AUTH_MITM , key_size = 16 , passkey = 225575 ) # To do so, we need a callback to display the passkey when needed ble . add_callback ( ble . EVT_SHOW_PASSKEY , show_key_cb ) # Setup advertising to 50ms ble . advertising ( 50 ) # Start the BLE stack ble . start () # Now start advertising ble . start_advertising () except Exception as e : print ( e ) # loop forever while True : print ( \".\" ) if random ( 0 , 100 ) < 50 and notifications_enabled and connected : value = bytearray ( cn . get_value ()) value [ 0 ] = 0 # simple alert type if value [ 1 ] < 255 : value [ 1 ] = value [ 1 ] + 1 # add a notification print ( \"Adding a new notification, total of\" , value [ 1 ]) # the remaining 14 bytes can be some text value [ 2 : 10 ] = \"Zerynth!\" # set the new value. If ble notifications are enabled, the connected device will receive the change cn . set_value ( value ) sleep ( 5000 ) BLE Alerts with Security 2 \u00b6 An implementationof an Alert Notification device to show how services and characteristics can be easily created. It also features secure connections with bonding using confirmation capabilities of the device. main.py ################################################################################ # BLE Alerts with Security 2 # # Created by Zerynth Team 2019 CC # Author: G. Baldi ############################################################################### import streams #import the ESP32 BLE driver: a BLE capable VM is also needed! from espressif.esp32ble import esp32ble as bledrv # then import the BLE modue from wireless import ble streams . serial () notifications_enabled = True connected = False # Let's define some callbacks def value_cb ( status , val ): # check incoming commands and enable/disable notifications global notifications_enabled print ( \"Value changed to\" , val [ 0 ], val [ 1 ]) if val [ 0 ] == 0 : print ( \"Notifications enabled\" ) notifications_enabled = True elif val [ 0 ] == 2 : notifications_enabled = False print ( \"Notifications disabled\" ) else : print ( \"Notifications unchanged\" ) def connection_cb ( address ): global connected print ( \"Connected to\" , ble . btos ( address )) connected = True def disconnection_cb ( address ): global connected print ( \"Disconnected from\" , ble . btos ( address )) # let's start advertising again ble . start_advertising () connected = False # Let's define some security callbacks def match_key_cb ( passkey ): print ( \"MASTER KEY IS:\" , passkey , \"CAN WE PROCEED? PRESS BUTTON FOR YES\" ) pinMode ( BTN0 , INPUT ) for i in range ( 5 ): if digitalRead ( BTN0 ) != 0 : ble . confirm_passkey ( 1 ) print ( \"Confirmed!\" ) return sleep ( 1000 ) ble . confirm_passkey ( 0 ) print ( \"Not confirmed!\" ) try : # initialize BLE driver bledrv . init () # Set GAP name and LEVEL 2 security # !!! If security is not set, no secure connection will be possible ble . gap ( \"ZNotifier\" , security = ( ble . SECURITY_MODE_1 , ble . SECURITY_LEVEL_2 )) # add some GAP callbacks ble . add_callback ( ble . EVT_CONNECTED , connection_cb ) ble . add_callback ( ble . EVT_DISCONNECTED , disconnection_cb ) # Create a GATT Service: let's try an Alert Notification Service # (here are the specs: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.service.alert_notification.xml) s = ble . Service ( 0x1811 ) # The Alert Notification service has multiple characteristics. Let's add them one by one # Create a GATT Characteristic for counting new alerts. # specs: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.characteristic.supported_new_alert_category.xml cn = ble . Characteristic ( 0x2A47 , ble . NOTIFY | ble . READ , 16 , \"New Alerts\" , ble . BYTES ) # Add the GATT Characteristic to the Service s . add_characteristic ( cn ) # Create anothr GATT Characteristic for enabling/disabling alerts # specs: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.characteristic.alert_notification_control_point.xml cc = ble . Characteristic ( 0x2A44 , ble . WRITE , 2 , \"Alerts control\" , ble . BYTES ) # Add the GATT Characteristic to the Service s . add_characteristic ( cc ) # Add a callback to be notified of changes cc . set_callback ( value_cb ) # Add the Service. You can create additional services and add them one by one ble . add_service ( s ) # Configure security. BLE security is very flexible. # In this case we declare that the device has only an output capability with yes o or no input (CAP_DISPLAY_YES_NO), # that we require a bonding (storage of the keys after pairing) # and that we want both secure connection and main in the middle protection. ble . security ( capabilities = ble . CAP_DISPLAY_YES_NO , bonding = ble . AUTH_BOND , scheme = ble . AUTH_SC | ble . AUTH_MITM , key_size = 16 ) # To do so, we need a callback to accept the passkey when needed ble . add_callback ( ble . EVT_MATCH_PASSKEY , match_key_cb ) # Setup advertising to 50ms ble . advertising ( 50 ) # Start the BLE stack ble . start () # Now start advertising ble . start_advertising () except Exception as e : print ( e ) # Uncomment the following lines to delte bonded devices! for bond in ble . bonded (): print ( \"Removing bonded:\" , ble . btos ( bond )) ble . remove_bonded ( bond ) # loop forever while True : print ( \".\" ) if random ( 0 , 100 ) < 50 and notifications_enabled and connected : value = bytearray ( cn . get_value ()) value [ 0 ] = 0 # simple alert type if value [ 1 ] < 255 : value [ 1 ] = value [ 1 ] + 1 # add a notification print ( \"Adding a new notification, total of\" , value [ 1 ]) # the remaining 14 bytes can be some text value [ 2 : 10 ] = \"Zerynth!\" # set the new value. If ble notifications are enabled, the connected device will receive the change cn . set_value ( value ) sleep ( 5000 ) BLE Wifi \u00b6 A BLE scanner sending packet data to a tcp socket ovr a Wifi connection. main.py ################################################################################ # BLE Wifi # # Created by Zerynth Team 2019 CC # Author: G. Baldi ############################################################################### import streams #import the ESP32 BLE driver: a BLE capable VM is also needed! from espressif.esp32ble import esp32ble as bledrv # then import the BLE modue from wireless import ble # import wifi modules from espressif.esp32net import esp32wifi as wifi_driver from wireless import wifi import socket import gc streams . serial () # Let's define some callbacks and constants # How long to scan for in milliseconds scan_time = 30000 # tcp socket ss = None def scan_report_cb ( data ): try : print ( \"Detected packet from\" , ble . btos ( data [ 4 ]), \"containing\" , ble . btos ( data [ 3 ])) print ( \" packet is of type\" , data [ 0 ], \"while address is of type\" , data [ 1 ]) print ( \" remote device has RSSI of\" , data [ 2 ]) # send to socket ss . sendall ( ble . btos ( data [ 3 ])) ss . sendall ( \" \\n \" ) except Exception as e : print ( \"send\" , e ) def scan_start_cb ( data ): print ( \"Scan started\" ) def scan_stop_cb ( data ): print ( \"Scan stopped\" ) #let's start it up again ble . start_scanning ( scan_time ) try : # initialize wifi wifi_driver . auto_init () for i in range ( 10 ): try : print ( 'connecting to wifi...' ) # place here your wifi configuration wifi . link ( \"SSID\" , wifi . WIFI_WPA2 , \"password\" ) break except Exception as e : print ( e ) # let's open a socket to forward the BLE packets print ( \"Opening socket...\" ) ss = socket . socket () # you can run \"nc -l -p 8082\" on your machine # and change the ip below ss . connect (( \"192.168.71.52\" , 8082 )) print ( \"Starting BLE...\" ) # initialize BLE driver bledrv . init () # Set GAP name and no security ble . gap ( \"Zerynth\" , security = ( ble . SECURITY_MODE_1 , ble . SECURITY_LEVEL_1 )) ble . add_callback ( ble . EVT_SCAN_REPORT , scan_report_cb ) ble . add_callback ( ble . EVT_SCAN_STARTED , scan_start_cb ) ble . add_callback ( ble . EVT_SCAN_STOPPED , scan_stop_cb ) #set scanning parameters: every 100ms for 50ms and no duplicates ble . scanning ( 100 , 50 , duplicates = 0 ) # Start the BLE stack ble . start () # Now start scanning for 30 seconds ble . start_scanning ( scan_time ) except Exception as e : print ( e ) # loop forever while True : print ( \".\" , gc . info ()) sleep ( 10000 ) ss . sendall ( \":: \\n \" )","title":"Examples"},{"location":"reference/libs/espressif/esp32ble/docs/examples/#examples","text":"The following are a list of examples for lib.espressif.esp32ble.","title":"Examples"},{"location":"reference/libs/espressif/esp32ble/docs/examples/#ble-alerts","text":"An implementationof an Alert Notification device to show how services and characteristics can be easily created. main.py ################################################################################ # BLE Alerts # # Created by Zerynth Team 2019 CC # Author: G. Baldi ############################################################################### import streams #import the ESP32 BLE driver: a BLE capable VM is also needed! from espressif.esp32ble import esp32ble as bledrv # then import the BLE modue from wireless import ble streams . serial () notifications_enabled = True connected = False # Let's define some callbacks def value_cb ( status , val ): # check incoming commands and enable/disable notifications global notifications_enabled print ( \"Value changed to\" , val [ 0 ], val [ 1 ]) if val [ 0 ] == 0 : print ( \"Notifications enabled\" ) notifications_enabled = True elif val [ 0 ] == 2 : notifications_enabled = False print ( \"Notifications disabled\" ) else : print ( \"Notifications unchanged\" ) def connection_cb ( address ): global connected print ( \"Connected to\" , ble . btos ( address )) connected = True def disconnection_cb ( address ): global connected print ( \"Disconnected from\" , ble . btos ( address )) # let's start advertising again ble . start_advertising () connected = False try : # initialize BLE driver bledrv . init () # Set GAP name and no security ble . gap ( \"ZNotifier\" , security = ( ble . SECURITY_MODE_1 , ble . SECURITY_LEVEL_1 )) # add some GAP callbacks ble . add_callback ( ble . EVT_CONNECTED , connection_cb ) ble . add_callback ( ble . EVT_DISCONNECTED , disconnection_cb ) # Create a GATT Service: let's try an Alert Notification Service # (here are the specs: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.service.alert_notification.xml) s = ble . Service ( 0x1811 ) # The Alert Notification service has multiple characteristics. Let's add them one by one # Create a GATT Characteristic for counting new alerts. # specs: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.characteristic.supported_new_alert_category.xml cn = ble . Characteristic ( 0x2A47 , ble . NOTIFY | ble . READ , 16 , \"New Alerts\" , ble . BYTES ) # Add the GATT Characteristic to the Service s . add_characteristic ( cn ) # Create anothr GATT Characteristic for enabling/disabling alerts # specs: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.characteristic.alert_notification_control_point.xml cc = ble . Characteristic ( 0x2A44 , ble . WRITE , 2 , \"Alerts control\" , ble . BYTES ) # Add the GATT Characteristic to the Service s . add_characteristic ( cc ) # Add a callback to be notified of changes cc . set_callback ( value_cb ) # Add the Service. You can create additional services and add them one by one ble . add_service ( s ) # Setup advertising to 50ms ble . advertising ( 50 ) # Start the BLE stack ble . start () # Now start advertising ble . start_advertising () except Exception as e : print ( e ) # loop forever while True : print ( \".\" ) if random ( 0 , 100 ) < 50 and notifications_enabled and connected : value = bytearray ( cn . get_value ()) value [ 0 ] = 0 # simple alert type if value [ 1 ] < 255 : value [ 1 ] = value [ 1 ] + 1 # add a notification print ( \"Adding a new notification, total of\" , value [ 1 ]) # the remaining 14 bytes can be some text value [ 2 : 10 ] = \"Zerynth!\" # set the new value. If ble notifications are enabled, the connected device will receive the change cn . set_value ( value ) sleep ( 5000 )","title":"BLE Alerts"},{"location":"reference/libs/espressif/esp32ble/docs/examples/#ble-scanner","text":"A simple example implementing a BLE packet scanner. main.py ################################################################################ # BLE Scanner # # Created by Zerynth Team 2019 CC # Author: G. Baldi ############################################################################### import streams #import the ESP32 BLE driver: a BLE capable VM is also needed! from espressif.esp32ble import esp32ble as bledrv # then import the BLE modue from wireless import ble streams . serial () # Let's define some callbacks and constants # How long to scan for in milliseconds scan_time = 30000 def scan_report_cb ( data ): print ( \"Detected packet from\" , ble . btos ( data [ 4 ]), \"containing\" , ble . btos ( data [ 3 ])) print ( \" packet is of type\" , data [ 0 ], \"while address is of type\" , data [ 1 ]) print ( \" remote device has RSSI of\" , data [ 2 ]) def scan_start_cb ( data ): print ( \"Scan started\" ) def scan_stop_cb ( data ): print ( \"Scan stopped\" ) #let's start it up again ble . start_scanning ( scan_time ) try : # initialize BLE driver bledrv . init () # Set GAP name and no security ble . gap ( \"Zerynth\" , security = ( ble . SECURITY_MODE_1 , ble . SECURITY_LEVEL_1 )) ble . add_callback ( ble . EVT_SCAN_REPORT , scan_report_cb ) ble . add_callback ( ble . EVT_SCAN_STARTED , scan_start_cb ) ble . add_callback ( ble . EVT_SCAN_STOPPED , scan_stop_cb ) #set scanning parameters: every 100ms for 50ms and no duplicates ble . scanning ( 100 , 50 , duplicates = 0 ) # Start the BLE stack ble . start () # Now start scanning for 30 seconds ble . start_scanning ( scan_time ) except Exception as e : print ( e ) # loop forever while True : print ( \".\" ) sleep ( 10000 )","title":"BLE Scanner"},{"location":"reference/libs/espressif/esp32ble/docs/examples/#eddystone-beacon","text":"An implementation of a simple Eddystone Beacon advertising some predefined packets. main.py ################################################################################ # Eddystone Beacon # # Created by Zerynth Team 2019 CC # Author: G. Baldi ############################################################################### import streams import timers #import the ESP32 BLE driver: a BLE capable VM is also needed! from espressif.esp32ble import esp32ble as bledrv # then import the BLE module and beacons from wireless import ble from wireless import ble_beacons as bb streams . serial () adv_content = 0 battery_level = 40 temperature = 23.2 pdu_count = 0 uptime = timers . timer () uptime . start () # create payloads to cycle through payloads = [ bb . eddy_encode_uid ( \"Zerynth\" , \"Python\" , - 69 ), # UID Eddystone payload bb . eddy_encode_url ( \"https://www.zerynth.com\" , - 69 ), # URL Eddystone payload bb . eddy_encode_tlm ( battery_level , temperature , pdu_count , uptime . get () / 1000 ) # TLM Eddystone payload ] # this callback will be called at the end of an advertising cycle. # it is used to switch to the next content def adv_stop_cb ( data ): global pdu_count , adv_content print ( \"Advertising stopped\" ) adv_content = ( adv_content + 1 ) % 3 if adv_content == 0 : # advertise UID interval = 100 timeout = 10000 elif adv_content == 1 : # advertise URL interval = 100 timeout = 15000 else : # advertise TLM interval = 100 timeout = 150 pdu_count += 1 payloads [ 2 ] = bb . eddy_encode_tlm ( battery_level , temperature , pdu_count , uptime . get () / 1000 ) # TLM Eddystone payload payload = payloads [ adv_content ] ble . advertising ( interval , timeout = timeout , payload = payload , mode = ble . ADV_UNCN_UND ) ble . start_advertising () print ( \"Advertising restarted with\" , ble . btos ( payload )) try : # initialize BLE driver bledrv . init () # Set GAP name and no security ble . gap ( \"Zerynth\" , security = ( ble . SECURITY_MODE_1 , ble . SECURITY_LEVEL_1 )) ble . add_callback ( ble . EVT_ADV_STOPPED , adv_stop_cb ) # set advertising options: advertise every second with custom payload in non connectable undirected mode # after 10 seconds, stop and change payload ble . advertising ( 100 , timeout = 10000 , payload = payloads [ adv_content ], mode = ble . ADV_UNCN_UND ) # Start the BLE stack ble . start () # Now start scanning for 30 seconds ble . start_advertising () except Exception as e : print ( e ) # loop forever while True : print ( \".\" ) sleep ( 10000 )","title":"Eddystone Beacon"},{"location":"reference/libs/espressif/esp32ble/docs/examples/#ibeacon","text":"An Apple beacon advertising its own uuid. main.py ################################################################################ # iBeacon # # Created by Zerynth Team 2019 CC # Author: G. Baldi ############################################################################### import streams import timers #import the ESP32 BLE driver: a BLE capable VM is also needed! from espressif.esp32ble import esp32ble as bledrv # then import the BLE module and beacons from wireless import ble from wireless import ble_beacons as bb streams . serial () try : # initialize BLE driver bledrv . init () # Set GAP name and no security ble . gap ( \"Zerynth\" , security = ( ble . SECURITY_MODE_1 , ble . SECURITY_LEVEL_1 )) # set advertising options: advertise every second with custom payload in non connectable undirected mode ble . advertising ( 20 , payload = bb . ibeacon_encode ( \"fb0b57a2-8228-44cd-913a-94a122ba1206\" , 10 , 3 , - 69 ), mode = ble . ADV_UNCN_UND ) # Start the BLE stack ble . start () # Now start advertising ble . start_advertising () except Exception as e : print ( e ) # loop forever while True : print ( \".\" ) sleep ( 10000 ) main.py ################################################################################ # Eddystone Reader # # Created by Zerynth Team 2019 CC # Author: G. Baldi ############################################################################### import streams #import the ESP32 BLE driver: a BLE capable VM is also needed! from espressif.esp32ble import esp32ble as bledrv # then import the BLE modue from wireless import ble from wireless import ble_beacons as bb streams . serial () # Let's define some callbacks def scan_report_cb ( data ): pdata = data [ 3 ] rssi = data [ 2 ] try : etype = bb . eddy_decode_type ( pdata ) if etype == bb . EDDY_URL : url , tx = bb . eddy_decode ( pdata ) print ( \"Eddy URL found with\" , url , tx , rssi ) elif etype == bb . EDDY_UID : namespace , instance , tx = bb . eddy_decode ( pdata ) print ( \"Eddy UID found with\" ,[ hex ( x ) for x in namespace ],[ hex ( x ) for x in instance ], tx , rssi ) elif etype == bb . EDDY_LTM : battery , temperature , count , uptime = bb . eddy_decode ( pdata ) print ( \"Eddy LTM found with\" , battery , temperature , count , uptime , rssi ) # print(\"iBeacon found with\",[hex(x) for x in uuid],major,minor,tx,rssi) except Exception as e : print ( \"::\" ) def scan_stop_cb ( data ): print ( \"Scan stopped\" ) #let's start it up again ble . start_scanning ( 3000 ) try : # initialize BLE driver bledrv . init () # Set GAP name and no security ble . gap ( \"Zerynth\" , security = ( ble . SECURITY_MODE_1 , ble . SECURITY_LEVEL_1 )) ble . add_callback ( ble . EVT_SCAN_REPORT , scan_report_cb ) ble . add_callback ( ble . EVT_SCAN_STOPPED , scan_stop_cb ) #set scanning parameters: every 100ms for 100ms and no duplicates ble . scanning ( 100 , 100 , duplicates = 0 ) # Start the BLE stack ble . start () # Now start scanning for 3 seconds ble . start_scanning ( 3000 ) except Exception as e : print ( e ) # loop forever while True : print ( \".\" ) sleep ( 10000 )","title":"iBeacon"},{"location":"reference/libs/espressif/esp32ble/docs/examples/#ibeacon-reader","text":"A simple firmware to scan for iBeacons. main.py ################################################################################ # iBeacon Reader # # Created by Zerynth Team 2019 CC # Author: G. Baldi ############################################################################### import streams #import the ESP32 BLE driver: a BLE capable VM is also needed! from espressif.esp32ble import esp32ble as bledrv # then import the BLE modue from wireless import ble from wireless import ble_beacons as bb streams . serial () # Let's define some callbacks def scan_report_cb ( data ): pdata = data [ 3 ] rssi = data [ 2 ] try : uuid , major , minor , tx = bb . ibeacon_decode ( pdata ) print ( \"iBeacon found with\" ,[ hex ( x ) for x in uuid ], major , minor , tx , rssi ) except Exception as e : print ( \"::\" ) def scan_stop_cb ( data ): print ( \"Scan stopped\" ) #let's start it up again ble . start_scanning ( 3000 ) try : # initialize BLE driver bledrv . init () # Set GAP name and no security ble . gap ( \"Zerynth\" , security = ( ble . SECURITY_MODE_1 , ble . SECURITY_LEVEL_1 )) ble . add_callback ( ble . EVT_SCAN_REPORT , scan_report_cb ) ble . add_callback ( ble . EVT_SCAN_STOPPED , scan_stop_cb ) #set scanning parameters: every 100ms for 100ms and no duplicates ble . scanning ( 100 , 100 , duplicates = 0 ) # Start the BLE stack ble . start () # Now start scanning for 3 seconds ble . start_scanning ( 3000 ) except Exception as e : print ( e ) # loop forever while True : print ( \".\" ) sleep ( 10000 )","title":"iBeacon Reader"},{"location":"reference/libs/espressif/esp32ble/docs/examples/#ble-alerts-with-security-1","text":"An implementationof an Alert Notification device to show how services and characteristics can be easily created. It also features secure connections with bonding. main.py ################################################################################ # BLE Alerts with security # # Created by Zerynth Team 2019 CC # Author: G. Baldi ############################################################################### import streams #import the ESP32 BLE driver: a BLE capable VM is also needed! from espressif.esp32ble import esp32ble as bledrv # then import the BLE modue from wireless import ble streams . serial () notifications_enabled = True connected = False # Let's define some callbacks def value_cb ( status , val ): # check incoming commands and enable/disable notifications global notifications_enabled print ( \"Value changed to\" , val [ 0 ], val [ 1 ]) if val [ 0 ] == 0 : print ( \"Notifications enabled\" ) notifications_enabled = True elif val [ 0 ] == 2 : notifications_enabled = False print ( \"Notifications disabled\" ) else : print ( \"Notifications unchanged\" ) def connection_cb ( address ): global connected print ( \"Connected to\" , ble . btos ( address )) connected = True def disconnection_cb ( address ): global connected print ( \"Disconnected from\" , ble . btos ( address )) # let's start advertising again ble . start_advertising () connected = False # Let's define some security callbacks def show_key_cb ( passkey ): print ( \"ENTER THIS PIN ON THE MASTER:\" , passkey ) try : # initialize BLE driver bledrv . init () # Set GAP name and LEVEL 2 security # !!! If security is not set, no secure connection will be possible ble . gap ( \"ZNotifier\" , security = ( ble . SECURITY_MODE_1 , ble . SECURITY_LEVEL_2 )) # add some GAP callbacks ble . add_callback ( ble . EVT_CONNECTED , connection_cb ) ble . add_callback ( ble . EVT_DISCONNECTED , disconnection_cb ) # Create a GATT Service: let's try an Alert Notification Service # (here are the specs: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.service.alert_notification.xml) s = ble . Service ( 0x1811 ) # The Alert Notification service has multiple characteristics. Let's add them one by one # Create a GATT Characteristic for counting new alerts. # specs: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.characteristic.supported_new_alert_category.xml cn = ble . Characteristic ( 0x2A47 , ble . NOTIFY | ble . READ , 16 , \"New Alerts\" , ble . BYTES ) # Add the GATT Characteristic to the Service s . add_characteristic ( cn ) # Create anothr GATT Characteristic for enabling/disabling alerts # specs: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.characteristic.alert_notification_control_point.xml cc = ble . Characteristic ( 0x2A44 , ble . WRITE , 2 , \"Alerts control\" , ble . BYTES ) # Add the GATT Characteristic to the Service s . add_characteristic ( cc ) # Add a callback to be notified of changes cc . set_callback ( value_cb ) # Add the Service. You can create additional services and add them one by one ble . add_service ( s ) # Configure security. BLE security is very flexible. # In this case we declare that the device has only an output capability (CAP_DISPLAY_ONLY), # that we require a bonding (storage of the keys after pairing) # and that we want both secure connection and main in the middle protection. # Since we have CAP_DISPLAY_ONLY, we also declare a passkey that will be shown to the user # to be entered on the master (i.e. the smartphone) to finalize the bonding. ble . security ( capabilities = ble . CAP_DISPLAY_ONLY , bonding = ble . AUTH_BOND , scheme = ble . AUTH_SC | ble . AUTH_MITM , key_size = 16 , passkey = 225575 ) # To do so, we need a callback to display the passkey when needed ble . add_callback ( ble . EVT_SHOW_PASSKEY , show_key_cb ) # Setup advertising to 50ms ble . advertising ( 50 ) # Start the BLE stack ble . start () # Now start advertising ble . start_advertising () except Exception as e : print ( e ) # loop forever while True : print ( \".\" ) if random ( 0 , 100 ) < 50 and notifications_enabled and connected : value = bytearray ( cn . get_value ()) value [ 0 ] = 0 # simple alert type if value [ 1 ] < 255 : value [ 1 ] = value [ 1 ] + 1 # add a notification print ( \"Adding a new notification, total of\" , value [ 1 ]) # the remaining 14 bytes can be some text value [ 2 : 10 ] = \"Zerynth!\" # set the new value. If ble notifications are enabled, the connected device will receive the change cn . set_value ( value ) sleep ( 5000 )","title":"BLE Alerts with Security 1"},{"location":"reference/libs/espressif/esp32ble/docs/examples/#ble-alerts-with-security-2","text":"An implementationof an Alert Notification device to show how services and characteristics can be easily created. It also features secure connections with bonding using confirmation capabilities of the device. main.py ################################################################################ # BLE Alerts with Security 2 # # Created by Zerynth Team 2019 CC # Author: G. Baldi ############################################################################### import streams #import the ESP32 BLE driver: a BLE capable VM is also needed! from espressif.esp32ble import esp32ble as bledrv # then import the BLE modue from wireless import ble streams . serial () notifications_enabled = True connected = False # Let's define some callbacks def value_cb ( status , val ): # check incoming commands and enable/disable notifications global notifications_enabled print ( \"Value changed to\" , val [ 0 ], val [ 1 ]) if val [ 0 ] == 0 : print ( \"Notifications enabled\" ) notifications_enabled = True elif val [ 0 ] == 2 : notifications_enabled = False print ( \"Notifications disabled\" ) else : print ( \"Notifications unchanged\" ) def connection_cb ( address ): global connected print ( \"Connected to\" , ble . btos ( address )) connected = True def disconnection_cb ( address ): global connected print ( \"Disconnected from\" , ble . btos ( address )) # let's start advertising again ble . start_advertising () connected = False # Let's define some security callbacks def match_key_cb ( passkey ): print ( \"MASTER KEY IS:\" , passkey , \"CAN WE PROCEED? PRESS BUTTON FOR YES\" ) pinMode ( BTN0 , INPUT ) for i in range ( 5 ): if digitalRead ( BTN0 ) != 0 : ble . confirm_passkey ( 1 ) print ( \"Confirmed!\" ) return sleep ( 1000 ) ble . confirm_passkey ( 0 ) print ( \"Not confirmed!\" ) try : # initialize BLE driver bledrv . init () # Set GAP name and LEVEL 2 security # !!! If security is not set, no secure connection will be possible ble . gap ( \"ZNotifier\" , security = ( ble . SECURITY_MODE_1 , ble . SECURITY_LEVEL_2 )) # add some GAP callbacks ble . add_callback ( ble . EVT_CONNECTED , connection_cb ) ble . add_callback ( ble . EVT_DISCONNECTED , disconnection_cb ) # Create a GATT Service: let's try an Alert Notification Service # (here are the specs: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.service.alert_notification.xml) s = ble . Service ( 0x1811 ) # The Alert Notification service has multiple characteristics. Let's add them one by one # Create a GATT Characteristic for counting new alerts. # specs: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.characteristic.supported_new_alert_category.xml cn = ble . Characteristic ( 0x2A47 , ble . NOTIFY | ble . READ , 16 , \"New Alerts\" , ble . BYTES ) # Add the GATT Characteristic to the Service s . add_characteristic ( cn ) # Create anothr GATT Characteristic for enabling/disabling alerts # specs: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.characteristic.alert_notification_control_point.xml cc = ble . Characteristic ( 0x2A44 , ble . WRITE , 2 , \"Alerts control\" , ble . BYTES ) # Add the GATT Characteristic to the Service s . add_characteristic ( cc ) # Add a callback to be notified of changes cc . set_callback ( value_cb ) # Add the Service. You can create additional services and add them one by one ble . add_service ( s ) # Configure security. BLE security is very flexible. # In this case we declare that the device has only an output capability with yes o or no input (CAP_DISPLAY_YES_NO), # that we require a bonding (storage of the keys after pairing) # and that we want both secure connection and main in the middle protection. ble . security ( capabilities = ble . CAP_DISPLAY_YES_NO , bonding = ble . AUTH_BOND , scheme = ble . AUTH_SC | ble . AUTH_MITM , key_size = 16 ) # To do so, we need a callback to accept the passkey when needed ble . add_callback ( ble . EVT_MATCH_PASSKEY , match_key_cb ) # Setup advertising to 50ms ble . advertising ( 50 ) # Start the BLE stack ble . start () # Now start advertising ble . start_advertising () except Exception as e : print ( e ) # Uncomment the following lines to delte bonded devices! for bond in ble . bonded (): print ( \"Removing bonded:\" , ble . btos ( bond )) ble . remove_bonded ( bond ) # loop forever while True : print ( \".\" ) if random ( 0 , 100 ) < 50 and notifications_enabled and connected : value = bytearray ( cn . get_value ()) value [ 0 ] = 0 # simple alert type if value [ 1 ] < 255 : value [ 1 ] = value [ 1 ] + 1 # add a notification print ( \"Adding a new notification, total of\" , value [ 1 ]) # the remaining 14 bytes can be some text value [ 2 : 10 ] = \"Zerynth!\" # set the new value. If ble notifications are enabled, the connected device will receive the change cn . set_value ( value ) sleep ( 5000 )","title":"BLE Alerts with Security 2"},{"location":"reference/libs/espressif/esp32ble/docs/examples/#ble-wifi","text":"A BLE scanner sending packet data to a tcp socket ovr a Wifi connection. main.py ################################################################################ # BLE Wifi # # Created by Zerynth Team 2019 CC # Author: G. Baldi ############################################################################### import streams #import the ESP32 BLE driver: a BLE capable VM is also needed! from espressif.esp32ble import esp32ble as bledrv # then import the BLE modue from wireless import ble # import wifi modules from espressif.esp32net import esp32wifi as wifi_driver from wireless import wifi import socket import gc streams . serial () # Let's define some callbacks and constants # How long to scan for in milliseconds scan_time = 30000 # tcp socket ss = None def scan_report_cb ( data ): try : print ( \"Detected packet from\" , ble . btos ( data [ 4 ]), \"containing\" , ble . btos ( data [ 3 ])) print ( \" packet is of type\" , data [ 0 ], \"while address is of type\" , data [ 1 ]) print ( \" remote device has RSSI of\" , data [ 2 ]) # send to socket ss . sendall ( ble . btos ( data [ 3 ])) ss . sendall ( \" \\n \" ) except Exception as e : print ( \"send\" , e ) def scan_start_cb ( data ): print ( \"Scan started\" ) def scan_stop_cb ( data ): print ( \"Scan stopped\" ) #let's start it up again ble . start_scanning ( scan_time ) try : # initialize wifi wifi_driver . auto_init () for i in range ( 10 ): try : print ( 'connecting to wifi...' ) # place here your wifi configuration wifi . link ( \"SSID\" , wifi . WIFI_WPA2 , \"password\" ) break except Exception as e : print ( e ) # let's open a socket to forward the BLE packets print ( \"Opening socket...\" ) ss = socket . socket () # you can run \"nc -l -p 8082\" on your machine # and change the ip below ss . connect (( \"192.168.71.52\" , 8082 )) print ( \"Starting BLE...\" ) # initialize BLE driver bledrv . init () # Set GAP name and no security ble . gap ( \"Zerynth\" , security = ( ble . SECURITY_MODE_1 , ble . SECURITY_LEVEL_1 )) ble . add_callback ( ble . EVT_SCAN_REPORT , scan_report_cb ) ble . add_callback ( ble . EVT_SCAN_STARTED , scan_start_cb ) ble . add_callback ( ble . EVT_SCAN_STOPPED , scan_stop_cb ) #set scanning parameters: every 100ms for 50ms and no duplicates ble . scanning ( 100 , 50 , duplicates = 0 ) # Start the BLE stack ble . start () # Now start scanning for 30 seconds ble . start_scanning ( scan_time ) except Exception as e : print ( e ) # loop forever while True : print ( \".\" , gc . info ()) sleep ( 10000 ) ss . sendall ( \":: \\n \" )","title":"BLE Wifi"},{"location":"reference/libs/espressif/esp32net/docs/","text":"Espressif ESP32 Wifi \u00b6 This module implements the wifi driver for ESP32. It includes support for softAP mode, SSL/TLS and packet sniffing. To use the module expand on the following example: from espressif.esp32wifi import esp32wifi as wifi_driver from wireless import wifi wifi_driver . auto_init () for retry in range ( 10 ): try : wifi . link ( \"Network-SSID\" , wifi . WIFI_WPA2 , \"password\" ) break except Exception as e : print ( e ) if not wifi . is_linked (): raise IOError Here below, the Zerynth driver for the Espressif ESP32 and some examples to better understand how to use it. Contents: ESP32 Ethernet Module ESP32 Wifi Module Examples Wifi SoftAP Sniffer Advanced Sniffer","title":"Espressif ESP32 Wifi"},{"location":"reference/libs/espressif/esp32net/docs/#espressif-esp32-wifi","text":"This module implements the wifi driver for ESP32. It includes support for softAP mode, SSL/TLS and packet sniffing. To use the module expand on the following example: from espressif.esp32wifi import esp32wifi as wifi_driver from wireless import wifi wifi_driver . auto_init () for retry in range ( 10 ): try : wifi . link ( \"Network-SSID\" , wifi . WIFI_WPA2 , \"password\" ) break except Exception as e : print ( e ) if not wifi . is_linked (): raise IOError Here below, the Zerynth driver for the Espressif ESP32 and some examples to better understand how to use it. Contents: ESP32 Ethernet Module ESP32 Wifi Module Examples Wifi SoftAP Sniffer Advanced Sniffer","title":"Espressif ESP32 Wifi"},{"location":"reference/libs/espressif/esp32net/docs/esp32eth/","text":"ESP32 Ethernet Module \u00b6 This module implements the Zerynth driver for the Espressif ESP32 Ethernet ( Resources and Documentation ). This module supports SSL/TLS. init \u00b6 init () Initializes the Ethernet chip connected to the device. The Ethernet chip is setup and can be managed using the Ethernet Module of the Zerynth Standard Library.","title":"ESP32 Ethernet Module"},{"location":"reference/libs/espressif/esp32net/docs/esp32eth/#esp32-ethernet-module","text":"This module implements the Zerynth driver for the Espressif ESP32 Ethernet ( Resources and Documentation ). This module supports SSL/TLS.","title":"ESP32 Ethernet Module"},{"location":"reference/libs/espressif/esp32net/docs/esp32eth/#init","text":"init () Initializes the Ethernet chip connected to the device. The Ethernet chip is setup and can be managed using the Ethernet Module of the Zerynth Standard Library.","title":"init"},{"location":"reference/libs/espressif/esp32net/docs/esp32wifi/","text":"ESP32 Wifi Module \u00b6 This module implements the Zerynth driver for the Espressif ESP32 Wi-Fi chip ( Resources and Documentation ). This module supports SoftAP mode and SSL/TLS. It also support promiscuous mode for wifi packet sniffing. init \u00b6 init () initializes the Wi-Fi chip connected to the device. The WiFi chip is setup and can be managed using the Wi-Fi Module of the Zerynth Standard Library. get_rssi \u00b6 get_rssi () Returns the current RSSI in dBm. start_sniffer \u00b6 start_sniffer ( packet_types = [], direction = 0xf , channels = [], mgmt_subtypes = [], ctrl_subtypes = [], data_subtypes = [], hop_time = 5000 , pkt_buffer = 32 , max_payloads = 4096 ) Start the wifi sniffer or change its configuration if already started. The sniffer itself is very flexible and configurable by means of type, subtype and direction filters. Wifi packets from IEEE 802.11 specification can be of management, control or data types, each type implementing a different functionality of the standard. The argument packet_types is a list of types represented by the constants WIFI_PKT_MGMT , WIFI_PKT_CTRL and WIFI_PKT_DATA . If packet_types is empty, the sniffer is configured by default with WIFI_PKT_MGMT considering only management packets. For each packet type, many different subtypes are possible according to the specification. The sniffer can be configured to only collect a subset of the allowed subtypes. To do so, three different argument can be specified to control the subsets: mgmt_subtypes , a list of management packet subtypes (if empty sniffs probe requests and response) ctrl_subtypes , a list of control packet subtypes (if empty sniffs control ack) data_subtypes , a list of data packet subtypes Subtypes are specified with the integer value of the subtypes in the packet frame . A number of constants is provided to specify packet subtypes, reported below. Wifi packets also have two bits indicating the \u201cdirection\u201d of the packet, either from or to the distribution system (DS). The distribution system is generally the Access Point that behaves as the physical bridge between the wireless network and another network, usually ethernet based. The two direction bits are usually called \u201cfrom_ds\u201d and \u201cto_ds\u201d meaning that the packet is coming from the DS and going to the DS respectively. Since management and control packets never leave the wireless network, the two bits are always 00. For data packets they usually are either 10 or 01 for packets entering or leaving the network. The case 11 is also possible for WDS systems where multiple wifi networks are organized together for packet routing. More details here . The sniffer can be configured to selectively filter only packets with a certain direction by providing the direction argument. It is a bitmask of the following constants: WIFI_DIR_TO_NULL_FROM_NULL , for 00 direction WIFI_DIR_TO_DS_FROM_NULL , for 10 direction, packets leaving the network WIFI_DIR_TO_NULL_FROM_DS , for 01 direction, packets entering the network WIFI_DIR_TO_DS_FROM_DS , for 11 direction, packets entering/leaving the network in a WDS system The sniffer can only sniff one channel at a time. To work around this limitation is possible to specify a list of channels in the range [1..13] and a hop_time in milliseconds. The sniffer will listen on each channel in channels for hop_time before jumping to the next. Sniffing packets can be a memory intensive task because both the high rate of packet traffic and the size of each packet that can reach 2Kb. It is possible to configure the sniffer memorywise by specifying the number of packets headers to retain in memory ( pkt_buffer ) and how much memory reserve to packet payloads (the actual data contained in the packet) max_payloads . The sniffer will keep collecting headers until pkt_buffer packets are buffered, discarding all the incoming packets if the buffer is full. The packet payload is buffered only if there is enough memory in the payload memory pool. It is therefore possible to sniff packet with complete headers but missing payloads if the memory pool is full but the packet buffer is not. To remove packet from the buffer and free up memory it is necessary to read them with :function: sniff() or :function: sniff_raw() . By calling this function again it is possible to reconfigure the sniffer. At each reconfiguration, the packet buffer and payload memory pool are emptied and the channel index restarted. Here below the list of constants for specifying packet subtypes: WIFI_PKT_MGMT_ASSOC_REQ , association request WIFI_PKT_MGMT_ASSOC_RES , association response WIFI_PKT_MGMT_REASSOC_REQ , reassociation request WIFI_PKT_MGMT_REASSOC_RES , reassociation response WIFI_PKT_MGMT_PROBE_REQ , probe request WIFI_PKT_MGMT_PROBE_RES , probe response WIFI_PKT_MGMT_TIMING_ADV , timing advertisment WIFI_PKT_MGMT_BEACON , AP beacon WIFI_PKT_MGMT_ATIM , announcement traffic indication WIFI_PKT_MGMT_DISASSOC , disassociation event WIFI_PKT_MGMT_AUTH , authentication event WIFI_PKT_MGMT_DEAUTH , deauthentication event WIFI_PKT_MGMT_ACTION , action WIFI_PKT_MGMT_ACTION_NACK , action no ack WIFI_PKT_CTRL_PSPOLL , power saving poll WIFI_PKT_CTRL_RTS , request to send WIFI_PKT_CTRL_CTS , clear to send WIFI_PKT_CTRL_ACK , ack WIFI_PKT_CTRL_CFEND , cfp end frame WIFI_PKT_CTRL_CFEND_ACK , cfp end frame ack WIFI_PKT_DATA_DATA , data packet WIFI_PKT_DATA_DATA_CFACK , data packet with cf ack WIFI_PKT_DATA_DATA_CFPOLL , data packet with cf poll WIFI_PKT_DATA_DATA_CFPOLL_ACK , data packet with cf poll ack WIFI_PKT_DATA_NULLDATA , data packet with no data (usually keepalives) WIFI_PKT_DATA_NULLDATA_CFACK , data packet with no data with cf ack WIFI_PKT_DATA_NULLDATA_CFPOLL , data packet with no data with cf poll WIFI_PKT_DATA_NULLDATA_CFPOLL_ACK , data packet with no data with cf poll ack WIFI_PKT_DATA_QOS , data packet for qos WIFI_PKT_DATA_QOS_CFACK , data packet for qos with cf ack WIFI_PKT_DATA_QOS_CFPOLL , data packet for qos with cf poll WIFI_PKT_DATA_QOS_CFPOLL_ACK , data packet for qos with cf poll ack WIFI_PKT_DATA_NULLQOS , data packet with no data for qos WIFI_PKT_DATA_NULLQOS_CFPOLL , data packet with no data for qos with cf poll WIFI_PKT_DATA_QOS_CFPOLL_ACK , data packet with no data for qos with cf poll ack get_sniffer_stats \u00b6 get_sniffer_stats () Return a tuple with sniffer statistics: number of sniffed packets since last start number of management packets that did not match a management subtype filter number of control packets that did not match a control subtype filter number of data packets that did not match a data subtype filter number of packets that did not match the direction filter number of packets missed due to buffer full number of packets in the buffer number of bytes used up in the payload memory pool current sniffer channel Filters are applied in a specific order: direction filter first and then subtype filter. sniff_raw \u00b6 sniff_raw () Return a list of sniffed packets from the underlying packet buffer. Each packet is itself a list with the following items: an integer representing the packet type an integer representing the packet subtype an integer representing the to_ds bit an integer representing the from_ds bit an integer representing the remaining packet flags an integer representing the duration_id field of the packet an integer representing the sequence control field of the packet a bytes of 6 elements representing the mac address 1 a bytes of 6 elements representing the mac address 2 a bytes of 6 elements representing the mac address 3 a bytes of 6 elements representing the mac address 4 an integer representing the RSSI an integer representing the channel an integer representing the payload size a bytes of either payload size elements or zero elements (if not enough space in memory pool was available) The values of packet type and subtype match the WIFI_PKT_ constants described above. The semantic of addresses changes based on samp:to_ds and from_ds bits and message type/subtype. In general one it can be assumed that: for to_ds 0 and from_ds 0: address 1 is the destination MAC address 2 is the source MAC address 3 is the BSSID (the MAC of the AP) for to_ds 1 and from_ds 0: address 1 is the BSSID address 2 is the source MAC address 3 is the destination MAC (outside the wifi network) for to_ds 0 and from_ds 1: address 1 is the destination MAC address 2 is the BSSID address 3 is the source MAC (outside the wifi network) for to_ds 1 and from_ds 1: address 1 is the receiver MAC (inside the wifi WDS network) address 2 is the transmitter MAC (inside the wifi WDS network) address 3 is the destination MAC (outside the wifi WDS network) address 4 is the source MAC (outside the wifi WDS network) Payload size is always specified in the packet tuple. However it is possible, if the memory pool for payload is exhausted, that the actual payload is not present. The returned list of packets is usually as big as the number of packets in the buffer and never exceeds that amount. sniff() The same as sniff_raw, except that the addresses are returned as hexadecimal strings in the format AA:BB:CC:DD:EE:FF. stop_sniffer() Stops the sniffer and free buffer and pool memory.","title":"ESP32 Wifi Module"},{"location":"reference/libs/espressif/esp32net/docs/esp32wifi/#esp32-wifi-module","text":"This module implements the Zerynth driver for the Espressif ESP32 Wi-Fi chip ( Resources and Documentation ). This module supports SoftAP mode and SSL/TLS. It also support promiscuous mode for wifi packet sniffing.","title":"ESP32 Wifi Module"},{"location":"reference/libs/espressif/esp32net/docs/esp32wifi/#init","text":"init () initializes the Wi-Fi chip connected to the device. The WiFi chip is setup and can be managed using the Wi-Fi Module of the Zerynth Standard Library.","title":"init"},{"location":"reference/libs/espressif/esp32net/docs/esp32wifi/#get_rssi","text":"get_rssi () Returns the current RSSI in dBm.","title":"get_rssi"},{"location":"reference/libs/espressif/esp32net/docs/esp32wifi/#start_sniffer","text":"start_sniffer ( packet_types = [], direction = 0xf , channels = [], mgmt_subtypes = [], ctrl_subtypes = [], data_subtypes = [], hop_time = 5000 , pkt_buffer = 32 , max_payloads = 4096 ) Start the wifi sniffer or change its configuration if already started. The sniffer itself is very flexible and configurable by means of type, subtype and direction filters. Wifi packets from IEEE 802.11 specification can be of management, control or data types, each type implementing a different functionality of the standard. The argument packet_types is a list of types represented by the constants WIFI_PKT_MGMT , WIFI_PKT_CTRL and WIFI_PKT_DATA . If packet_types is empty, the sniffer is configured by default with WIFI_PKT_MGMT considering only management packets. For each packet type, many different subtypes are possible according to the specification. The sniffer can be configured to only collect a subset of the allowed subtypes. To do so, three different argument can be specified to control the subsets: mgmt_subtypes , a list of management packet subtypes (if empty sniffs probe requests and response) ctrl_subtypes , a list of control packet subtypes (if empty sniffs control ack) data_subtypes , a list of data packet subtypes Subtypes are specified with the integer value of the subtypes in the packet frame . A number of constants is provided to specify packet subtypes, reported below. Wifi packets also have two bits indicating the \u201cdirection\u201d of the packet, either from or to the distribution system (DS). The distribution system is generally the Access Point that behaves as the physical bridge between the wireless network and another network, usually ethernet based. The two direction bits are usually called \u201cfrom_ds\u201d and \u201cto_ds\u201d meaning that the packet is coming from the DS and going to the DS respectively. Since management and control packets never leave the wireless network, the two bits are always 00. For data packets they usually are either 10 or 01 for packets entering or leaving the network. The case 11 is also possible for WDS systems where multiple wifi networks are organized together for packet routing. More details here . The sniffer can be configured to selectively filter only packets with a certain direction by providing the direction argument. It is a bitmask of the following constants: WIFI_DIR_TO_NULL_FROM_NULL , for 00 direction WIFI_DIR_TO_DS_FROM_NULL , for 10 direction, packets leaving the network WIFI_DIR_TO_NULL_FROM_DS , for 01 direction, packets entering the network WIFI_DIR_TO_DS_FROM_DS , for 11 direction, packets entering/leaving the network in a WDS system The sniffer can only sniff one channel at a time. To work around this limitation is possible to specify a list of channels in the range [1..13] and a hop_time in milliseconds. The sniffer will listen on each channel in channels for hop_time before jumping to the next. Sniffing packets can be a memory intensive task because both the high rate of packet traffic and the size of each packet that can reach 2Kb. It is possible to configure the sniffer memorywise by specifying the number of packets headers to retain in memory ( pkt_buffer ) and how much memory reserve to packet payloads (the actual data contained in the packet) max_payloads . The sniffer will keep collecting headers until pkt_buffer packets are buffered, discarding all the incoming packets if the buffer is full. The packet payload is buffered only if there is enough memory in the payload memory pool. It is therefore possible to sniff packet with complete headers but missing payloads if the memory pool is full but the packet buffer is not. To remove packet from the buffer and free up memory it is necessary to read them with :function: sniff() or :function: sniff_raw() . By calling this function again it is possible to reconfigure the sniffer. At each reconfiguration, the packet buffer and payload memory pool are emptied and the channel index restarted. Here below the list of constants for specifying packet subtypes: WIFI_PKT_MGMT_ASSOC_REQ , association request WIFI_PKT_MGMT_ASSOC_RES , association response WIFI_PKT_MGMT_REASSOC_REQ , reassociation request WIFI_PKT_MGMT_REASSOC_RES , reassociation response WIFI_PKT_MGMT_PROBE_REQ , probe request WIFI_PKT_MGMT_PROBE_RES , probe response WIFI_PKT_MGMT_TIMING_ADV , timing advertisment WIFI_PKT_MGMT_BEACON , AP beacon WIFI_PKT_MGMT_ATIM , announcement traffic indication WIFI_PKT_MGMT_DISASSOC , disassociation event WIFI_PKT_MGMT_AUTH , authentication event WIFI_PKT_MGMT_DEAUTH , deauthentication event WIFI_PKT_MGMT_ACTION , action WIFI_PKT_MGMT_ACTION_NACK , action no ack WIFI_PKT_CTRL_PSPOLL , power saving poll WIFI_PKT_CTRL_RTS , request to send WIFI_PKT_CTRL_CTS , clear to send WIFI_PKT_CTRL_ACK , ack WIFI_PKT_CTRL_CFEND , cfp end frame WIFI_PKT_CTRL_CFEND_ACK , cfp end frame ack WIFI_PKT_DATA_DATA , data packet WIFI_PKT_DATA_DATA_CFACK , data packet with cf ack WIFI_PKT_DATA_DATA_CFPOLL , data packet with cf poll WIFI_PKT_DATA_DATA_CFPOLL_ACK , data packet with cf poll ack WIFI_PKT_DATA_NULLDATA , data packet with no data (usually keepalives) WIFI_PKT_DATA_NULLDATA_CFACK , data packet with no data with cf ack WIFI_PKT_DATA_NULLDATA_CFPOLL , data packet with no data with cf poll WIFI_PKT_DATA_NULLDATA_CFPOLL_ACK , data packet with no data with cf poll ack WIFI_PKT_DATA_QOS , data packet for qos WIFI_PKT_DATA_QOS_CFACK , data packet for qos with cf ack WIFI_PKT_DATA_QOS_CFPOLL , data packet for qos with cf poll WIFI_PKT_DATA_QOS_CFPOLL_ACK , data packet for qos with cf poll ack WIFI_PKT_DATA_NULLQOS , data packet with no data for qos WIFI_PKT_DATA_NULLQOS_CFPOLL , data packet with no data for qos with cf poll WIFI_PKT_DATA_QOS_CFPOLL_ACK , data packet with no data for qos with cf poll ack","title":"start_sniffer"},{"location":"reference/libs/espressif/esp32net/docs/esp32wifi/#get_sniffer_stats","text":"get_sniffer_stats () Return a tuple with sniffer statistics: number of sniffed packets since last start number of management packets that did not match a management subtype filter number of control packets that did not match a control subtype filter number of data packets that did not match a data subtype filter number of packets that did not match the direction filter number of packets missed due to buffer full number of packets in the buffer number of bytes used up in the payload memory pool current sniffer channel Filters are applied in a specific order: direction filter first and then subtype filter.","title":"get_sniffer_stats"},{"location":"reference/libs/espressif/esp32net/docs/esp32wifi/#sniff_raw","text":"sniff_raw () Return a list of sniffed packets from the underlying packet buffer. Each packet is itself a list with the following items: an integer representing the packet type an integer representing the packet subtype an integer representing the to_ds bit an integer representing the from_ds bit an integer representing the remaining packet flags an integer representing the duration_id field of the packet an integer representing the sequence control field of the packet a bytes of 6 elements representing the mac address 1 a bytes of 6 elements representing the mac address 2 a bytes of 6 elements representing the mac address 3 a bytes of 6 elements representing the mac address 4 an integer representing the RSSI an integer representing the channel an integer representing the payload size a bytes of either payload size elements or zero elements (if not enough space in memory pool was available) The values of packet type and subtype match the WIFI_PKT_ constants described above. The semantic of addresses changes based on samp:to_ds and from_ds bits and message type/subtype. In general one it can be assumed that: for to_ds 0 and from_ds 0: address 1 is the destination MAC address 2 is the source MAC address 3 is the BSSID (the MAC of the AP) for to_ds 1 and from_ds 0: address 1 is the BSSID address 2 is the source MAC address 3 is the destination MAC (outside the wifi network) for to_ds 0 and from_ds 1: address 1 is the destination MAC address 2 is the BSSID address 3 is the source MAC (outside the wifi network) for to_ds 1 and from_ds 1: address 1 is the receiver MAC (inside the wifi WDS network) address 2 is the transmitter MAC (inside the wifi WDS network) address 3 is the destination MAC (outside the wifi WDS network) address 4 is the source MAC (outside the wifi WDS network) Payload size is always specified in the packet tuple. However it is possible, if the memory pool for payload is exhausted, that the actual payload is not present. The returned list of packets is usually as big as the number of packets in the buffer and never exceeds that amount. sniff() The same as sniff_raw, except that the addresses are returned as hexadecimal strings in the format AA:BB:CC:DD:EE:FF. stop_sniffer() Stops the sniffer and free buffer and pool memory.","title":"sniff_raw"},{"location":"reference/libs/espressif/esp32net/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.espressif.esp32net. Wifi Connect \u00b6 Simple wifi driver initialization and connection to a wifi network main.py ################################################################################ # Wifi Network Connection Example # # Created: 2016-07-27 11:00:55.020628 # ################################################################################ import streams # import the wifi interface from wireless import wifi # import wifi support from espressif.esp32net import esp32wifi as wifi_driver streams . serial () # init the wifi driver! # The driver automatically registers itself to the wifi interface # with the correct configuration for the selected device wifi_driver . auto_init () # use the wifi interface to link to the Access Point # change network name, security and password as needed print ( \"Establishing Link...\" ) try : # FOR THIS EXAMPLE TO WORK, \"Network-Name\" AND \"Wifi-Password\" MUST BE SET # TO MATCH YOUR ACTUAL NETWORK CONFIGURATION wifi . link ( \"Network-name\" , wifi . WIFI_WPA2 , \"password\" ) print ( \"Link Established\" ) except Exception as e : print ( \"ooops, something wrong while linking :(\" , e ) while True : sleep ( 1000 ) Soft AP Mode \u00b6 Simple wifi driver initialization in Access Point Mode. main.py ################################################################################ # Wifi SoftAP Example # # Created: 2016-07-27 11:00:55.020628 # ################################################################################ import streams # import the wifi interface from wireless import wifi # import wifi support from espressif.esp32net import esp32wifi as wifi_driver streams . serial () # init the wifi driver! # The driver automatically registers itself to the wifi interface # with the correct configuration for the selected device wifi_driver . auto_init () # use the wifi interface to link to the Access Point # change network name, security and password as needed print ( \"Creating Access Point...\" ) try : wifi . softap_init ( \"ESP32\" , wifi . WIFI_WPA2 , \"ZerynthEsp32\" ) print ( \"Access Point started!\" ) while True : info = wifi . softap_get_info () mac = \":\" . join ([ hex ( x , \"\" ) for x in info [ 3 ]]) print ( info [ 0 ], info [ 1 ], info [ 2 ], mac ) sleep ( 3000 ) except Exception as e : print ( \"ooops, something :(\" , e ) while True : sleep ( 1000 ) Sniffer \u00b6 A simple example showing the capabilities of the wifi sniffer. main.py ################################################################################ # Wifi Sniffer # # Created at 2019-05-08 15:19:21.114503 # ################################################################################ import streams from espressif.esp32net import esp32wifi as wifi_driver try : streams . serial () #let's init the driver wifi_driver . auto_init () except Exception as e : print ( \"ooops, something wrong with the driver\" , e ) while True : sleep ( 1000 ) try : while True : # loop over all channels for channel in [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 ]: print ( \"Sniffing channel\" , channel ) print ( \"================\" ) # start the sniffer for management and data packets # on the current channel # filtering packets going in and out of DS, and also packets with no direction # keep a buffer of 128 packets # but don't store the payloads (max_payloads=0) wifi_driver . start_sniffer ( packet_types = [ wifi_driver . WIFI_PKT_DATA , wifi_driver . WIFI_PKT_MGMT ], channels = [ channel ], direction = wifi_driver . WIFI_DIR_TO_DS_FROM_NULL | wifi_driver . WIFI_DIR_TO_NULL_FROM_DS | wifi_driver . WIFI_DIR_TO_NULL_FROM_NULL , pkt_buffer = 128 , max_payloads = 0 ) # The sniffer is sniffing :) # let's loop for 10 seconds on each channel seconds = 0 while seconds < 10 : sleep ( 1000 ) seconds += 1 pkts = wifi_driver . sniff () for pkt in pkts : print ( pkt [: - 1 ]) # print everything except the payload # let's also check some sniffing stats print ( \"Stats\" , wifi_driver . get_sniffer_stats ()) # This is not necessary, we can go back to the loop and call start_sniffer again # but let's call stop nonetheless wifi_driver . stop_sniffer () except Exception as e : print ( e ) Advanced Sniffer \u00b6 An advanced example that shows how to sniff probe requests to identify stations in the room and their position. main.py ################################################################################ # Advanced Wifi Sniffer # # Created at 2019-05-08 15:19:21.114503 # ################################################################################ import streams from espressif.esp32net import esp32wifi as wifi_driver try : streams . serial () wifi_driver . auto_init () except Exception as e : print ( \"ooops, something wrong while linking :(\" , e ) while True : sleep ( 1000 ) try : # configure the sniffer for probe requests # on all channels # stay on each channel for 4 seconds # 32 probes buffer # also save payloads (up to a total of 8Kb) # they can be analyzed to gather more information on identities wifi_driver . start_sniffer ( packet_types = [ wifi_driver . WIFI_PKT_MGMT ], channels = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 ], mgmt_subtypes = [ wifi_driver . WIFI_PKT_MGMT_PROBE_REQ ], direction = wifi_driver . WIFI_DIR_TO_NULL_FROM_NULL , pkt_buffer = 32 , max_payloads = 8192 , hop_time = 4000 ) identities = {} while True : seconds = 0 # gather probe request packet for 60 seconds while seconds < 60 : sleep ( 1000 ) seconds += 1 pkts = wifi_driver . sniff () for pkt in pkts : payload = pkt [ - 1 ] # being a to_ds 0, from_ds 0 packet, address 2 is the source mac # identifying the wifi station source = pkt [ 8 ] # source mac of the station probing the network # get also the rssi value rssi = pkt [ 11 ] # print the packet without payload print ( pkt [: - 1 ]) if source not in identities : # add the current rssi to the new source identities [ source ] = rssi else : # average the previous rssi with the new one # Note: don't do this if you have moving stations, like smartphones on people :) identities [ source ] = ( identities [ source ] + rssi ) // 2 # 60 seconds finished, display a summary print ( \"Identities summary\" ) print ( \"=========================================\" ) print ( \"Mac | rssi | distance | \" ) print ( \"=========================================\" ) for mac , rssis in identities . items (): # calculate distance using rssi: http://tdmts.net/2017/02/04/using-wifi-rssi-to-estimate-distance-to-an-access-point/ d = 10 ** (( - 84 - rssis ) / ( 10 * 4 )) print ( mac , \" \" , rssis , \" %2.2f \" % d ) print ( \"=========================================\" ) except Exception as e : print ( e )","title":"Examples"},{"location":"reference/libs/espressif/esp32net/docs/examples/#examples","text":"The following are a list of examples for lib.espressif.esp32net.","title":"Examples"},{"location":"reference/libs/espressif/esp32net/docs/examples/#wifi-connect","text":"Simple wifi driver initialization and connection to a wifi network main.py ################################################################################ # Wifi Network Connection Example # # Created: 2016-07-27 11:00:55.020628 # ################################################################################ import streams # import the wifi interface from wireless import wifi # import wifi support from espressif.esp32net import esp32wifi as wifi_driver streams . serial () # init the wifi driver! # The driver automatically registers itself to the wifi interface # with the correct configuration for the selected device wifi_driver . auto_init () # use the wifi interface to link to the Access Point # change network name, security and password as needed print ( \"Establishing Link...\" ) try : # FOR THIS EXAMPLE TO WORK, \"Network-Name\" AND \"Wifi-Password\" MUST BE SET # TO MATCH YOUR ACTUAL NETWORK CONFIGURATION wifi . link ( \"Network-name\" , wifi . WIFI_WPA2 , \"password\" ) print ( \"Link Established\" ) except Exception as e : print ( \"ooops, something wrong while linking :(\" , e ) while True : sleep ( 1000 )","title":"Wifi Connect"},{"location":"reference/libs/espressif/esp32net/docs/examples/#soft-ap-mode","text":"Simple wifi driver initialization in Access Point Mode. main.py ################################################################################ # Wifi SoftAP Example # # Created: 2016-07-27 11:00:55.020628 # ################################################################################ import streams # import the wifi interface from wireless import wifi # import wifi support from espressif.esp32net import esp32wifi as wifi_driver streams . serial () # init the wifi driver! # The driver automatically registers itself to the wifi interface # with the correct configuration for the selected device wifi_driver . auto_init () # use the wifi interface to link to the Access Point # change network name, security and password as needed print ( \"Creating Access Point...\" ) try : wifi . softap_init ( \"ESP32\" , wifi . WIFI_WPA2 , \"ZerynthEsp32\" ) print ( \"Access Point started!\" ) while True : info = wifi . softap_get_info () mac = \":\" . join ([ hex ( x , \"\" ) for x in info [ 3 ]]) print ( info [ 0 ], info [ 1 ], info [ 2 ], mac ) sleep ( 3000 ) except Exception as e : print ( \"ooops, something :(\" , e ) while True : sleep ( 1000 )","title":"Soft AP Mode"},{"location":"reference/libs/espressif/esp32net/docs/examples/#sniffer","text":"A simple example showing the capabilities of the wifi sniffer. main.py ################################################################################ # Wifi Sniffer # # Created at 2019-05-08 15:19:21.114503 # ################################################################################ import streams from espressif.esp32net import esp32wifi as wifi_driver try : streams . serial () #let's init the driver wifi_driver . auto_init () except Exception as e : print ( \"ooops, something wrong with the driver\" , e ) while True : sleep ( 1000 ) try : while True : # loop over all channels for channel in [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 ]: print ( \"Sniffing channel\" , channel ) print ( \"================\" ) # start the sniffer for management and data packets # on the current channel # filtering packets going in and out of DS, and also packets with no direction # keep a buffer of 128 packets # but don't store the payloads (max_payloads=0) wifi_driver . start_sniffer ( packet_types = [ wifi_driver . WIFI_PKT_DATA , wifi_driver . WIFI_PKT_MGMT ], channels = [ channel ], direction = wifi_driver . WIFI_DIR_TO_DS_FROM_NULL | wifi_driver . WIFI_DIR_TO_NULL_FROM_DS | wifi_driver . WIFI_DIR_TO_NULL_FROM_NULL , pkt_buffer = 128 , max_payloads = 0 ) # The sniffer is sniffing :) # let's loop for 10 seconds on each channel seconds = 0 while seconds < 10 : sleep ( 1000 ) seconds += 1 pkts = wifi_driver . sniff () for pkt in pkts : print ( pkt [: - 1 ]) # print everything except the payload # let's also check some sniffing stats print ( \"Stats\" , wifi_driver . get_sniffer_stats ()) # This is not necessary, we can go back to the loop and call start_sniffer again # but let's call stop nonetheless wifi_driver . stop_sniffer () except Exception as e : print ( e )","title":"Sniffer"},{"location":"reference/libs/espressif/esp32net/docs/examples/#advanced-sniffer","text":"An advanced example that shows how to sniff probe requests to identify stations in the room and their position. main.py ################################################################################ # Advanced Wifi Sniffer # # Created at 2019-05-08 15:19:21.114503 # ################################################################################ import streams from espressif.esp32net import esp32wifi as wifi_driver try : streams . serial () wifi_driver . auto_init () except Exception as e : print ( \"ooops, something wrong while linking :(\" , e ) while True : sleep ( 1000 ) try : # configure the sniffer for probe requests # on all channels # stay on each channel for 4 seconds # 32 probes buffer # also save payloads (up to a total of 8Kb) # they can be analyzed to gather more information on identities wifi_driver . start_sniffer ( packet_types = [ wifi_driver . WIFI_PKT_MGMT ], channels = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 ], mgmt_subtypes = [ wifi_driver . WIFI_PKT_MGMT_PROBE_REQ ], direction = wifi_driver . WIFI_DIR_TO_NULL_FROM_NULL , pkt_buffer = 32 , max_payloads = 8192 , hop_time = 4000 ) identities = {} while True : seconds = 0 # gather probe request packet for 60 seconds while seconds < 60 : sleep ( 1000 ) seconds += 1 pkts = wifi_driver . sniff () for pkt in pkts : payload = pkt [ - 1 ] # being a to_ds 0, from_ds 0 packet, address 2 is the source mac # identifying the wifi station source = pkt [ 8 ] # source mac of the station probing the network # get also the rssi value rssi = pkt [ 11 ] # print the packet without payload print ( pkt [: - 1 ]) if source not in identities : # add the current rssi to the new source identities [ source ] = rssi else : # average the previous rssi with the new one # Note: don't do this if you have moving stations, like smartphones on people :) identities [ source ] = ( identities [ source ] + rssi ) // 2 # 60 seconds finished, display a summary print ( \"Identities summary\" ) print ( \"=========================================\" ) print ( \"Mac | rssi | distance | \" ) print ( \"=========================================\" ) for mac , rssis in identities . items (): # calculate distance using rssi: http://tdmts.net/2017/02/04/using-wifi-rssi-to-estimate-distance-to-an-access-point/ d = 10 ** (( - 84 - rssis ) / ( 10 * 4 )) print ( mac , \" \" , rssis , \" %2.2f \" % d ) print ( \"=========================================\" ) except Exception as e : print ( e )","title":"Advanced Sniffer"},{"location":"reference/libs/espressif/esp8266wifi/docs/","text":"Espressif ESP8266 Wifi \u00b6 Espressif ESP8266 delivers highly integrated Wi-Fi SoC solution for efficient power usage, compact design and reliable performance in the Internet of Things industry. With the complete and self-contained Wi-Fi networking capabilities, ESP8266EX can perform either as a standalone application or as the slave to a host MCU. The integrated highspeed cache helps to increase the system performance and optimize the system memory. Also, ESP8266EX can be applied to any micro-controller design as a Wi-Fi adaptor through SPI/SDIO or I2C/UART interfaces. ESP8266EX integrates antenna switches, RF balun, power amplifier, low noise receive amplifier, filters and power management modules. The compact design minimizes the PCB size and requires minimal external circuitries. Besides the Wi-Fi functionalities, ESP8266EX also integrates an enhanced version of Tensilica L106 Diamond series 32-bit processor and on-chip SRAM. It can be interfaced with external sensors and other devices through the GPIOs; more information at Espressif dedicated page . Technical Details \u00b6 Supply Voltage (Vcc): from 2.5 V to 3.6 V Operation Temperature (Top): from -40 \u00b0C to 125 \u00b0C Active Current: 170 mA (max) Sleep mode Current:15 mA (max) Wifi Protocols: 802.11 b/n/e/i (2.4 GHz) Here below, the Zerynth driver for the Espressif ESP8266 and some examples to better understand how to use it. Contents: ESP8266 Wifi Module Examples WIFI CONNECT","title":"Espressif ESP8266 Wifi"},{"location":"reference/libs/espressif/esp8266wifi/docs/#espressif-esp8266-wifi","text":"Espressif ESP8266 delivers highly integrated Wi-Fi SoC solution for efficient power usage, compact design and reliable performance in the Internet of Things industry. With the complete and self-contained Wi-Fi networking capabilities, ESP8266EX can perform either as a standalone application or as the slave to a host MCU. The integrated highspeed cache helps to increase the system performance and optimize the system memory. Also, ESP8266EX can be applied to any micro-controller design as a Wi-Fi adaptor through SPI/SDIO or I2C/UART interfaces. ESP8266EX integrates antenna switches, RF balun, power amplifier, low noise receive amplifier, filters and power management modules. The compact design minimizes the PCB size and requires minimal external circuitries. Besides the Wi-Fi functionalities, ESP8266EX also integrates an enhanced version of Tensilica L106 Diamond series 32-bit processor and on-chip SRAM. It can be interfaced with external sensors and other devices through the GPIOs; more information at Espressif dedicated page .","title":"Espressif ESP8266 Wifi"},{"location":"reference/libs/espressif/esp8266wifi/docs/#technical-details","text":"Supply Voltage (Vcc): from 2.5 V to 3.6 V Operation Temperature (Top): from -40 \u00b0C to 125 \u00b0C Active Current: 170 mA (max) Sleep mode Current:15 mA (max) Wifi Protocols: 802.11 b/n/e/i (2.4 GHz) Here below, the Zerynth driver for the Espressif ESP8266 and some examples to better understand how to use it. Contents: ESP8266 Wifi Module Examples WIFI CONNECT","title":"Technical Details"},{"location":"reference/libs/espressif/esp8266wifi/docs/esp8266wifi/","text":"ESP8266 Wifi Module \u00b6 This module implements the Zerynth driver for the Espressif ESP8266 Wi-Fi chip ( Resources and Documentation ). NOTE: To avail the Wi-Fi functionalities, the end user had to follow this steps: * inizialize the Espressif ESP8266 chip using the init() of this driver * exploit the Wi-Fi features using the Wi-Fi Module of the Zerynth Standard Library init \u00b6 init () initializes the Wi-Fi chip connected to the device. Once ended this operation without errors, the Wi-Fi chip is ready to work and it can be handled using the Wi-Fi Module of the Zerynth Standard Library. get_rssi \u00b6 get_rssi () Returns the current RSSI in dBm.","title":"ESP8266 Wifi Module"},{"location":"reference/libs/espressif/esp8266wifi/docs/esp8266wifi/#esp8266-wifi-module","text":"This module implements the Zerynth driver for the Espressif ESP8266 Wi-Fi chip ( Resources and Documentation ). NOTE: To avail the Wi-Fi functionalities, the end user had to follow this steps: * inizialize the Espressif ESP8266 chip using the init() of this driver * exploit the Wi-Fi features using the Wi-Fi Module of the Zerynth Standard Library","title":"ESP8266 Wifi Module"},{"location":"reference/libs/espressif/esp8266wifi/docs/esp8266wifi/#init","text":"init () initializes the Wi-Fi chip connected to the device. Once ended this operation without errors, the Wi-Fi chip is ready to work and it can be handled using the Wi-Fi Module of the Zerynth Standard Library.","title":"init"},{"location":"reference/libs/espressif/esp8266wifi/docs/esp8266wifi/#get_rssi","text":"get_rssi () Returns the current RSSI in dBm.","title":"get_rssi"},{"location":"reference/libs/espressif/esp8266wifi/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.espressif.esp8266wifi. WIFI CONNECT \u00b6 Simple wifi driver initialization and connection to a wifi network (based on NodeMCU v2). main.py ################################################################################ # Wifi Network Connection Example # # Created: 2016-07-27 11:00:55.020628 # ################################################################################ import streams # import the wifi interface from wireless import wifi # import wifi support from espressif.esp8266wifi import esp8266wifi as wifi_driver streams . serial () # init the wifi driver! # The driver automatically registers itself to the wifi interface # with the correct configuration for the selected device wifi_driver . auto_init () # use the wifi interface to link to the Access Point # change network name, security and password as needed print ( \"Establishing Link...\" ) try : # FOR THIS EXAMPLE TO WORK, \"Network-Name\" AND \"Wifi-Password\" MUST BE SET # TO MATCH YOUR ACTUAL NETWORK CONFIGURATION wifi . link ( \"Network-name\" , wifi . WIFI_WPA2 , \"password\" ) print ( \"Link Established\" ) except Exception as e : print ( \"ooops, something wrong while linking :(\" , e ) while True : sleep ( 1000 )","title":"Examples"},{"location":"reference/libs/espressif/esp8266wifi/docs/examples/#examples","text":"The following are a list of examples for lib.espressif.esp8266wifi.","title":"Examples"},{"location":"reference/libs/espressif/esp8266wifi/docs/examples/#wifi-connect","text":"Simple wifi driver initialization and connection to a wifi network (based on NodeMCU v2). main.py ################################################################################ # Wifi Network Connection Example # # Created: 2016-07-27 11:00:55.020628 # ################################################################################ import streams # import the wifi interface from wireless import wifi # import wifi support from espressif.esp8266wifi import esp8266wifi as wifi_driver streams . serial () # init the wifi driver! # The driver automatically registers itself to the wifi interface # with the correct configuration for the selected device wifi_driver . auto_init () # use the wifi interface to link to the Access Point # change network name, security and password as needed print ( \"Establishing Link...\" ) try : # FOR THIS EXAMPLE TO WORK, \"Network-Name\" AND \"Wifi-Password\" MUST BE SET # TO MATCH YOUR ACTUAL NETWORK CONFIGURATION wifi . link ( \"Network-name\" , wifi . WIFI_WPA2 , \"password\" ) print ( \"Link Established\" ) except Exception as e : print ( \"ooops, something wrong while linking :(\" , e ) while True : sleep ( 1000 )","title":"WIFI CONNECT"},{"location":"reference/libs/fortebit/iot/docs/","text":"Index \u00b6 Contents: Fortebit IoT Library The Device class Examples Mqtt Http","title":"Index"},{"location":"reference/libs/fortebit/iot/docs/#index","text":"Contents: Fortebit IoT Library The Device class Examples Mqtt Http","title":"Index"},{"location":"reference/libs/fortebit/iot/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.fortebit.iot. MQTT \u00b6 MQTT ==== A simple example connecting a device to the OKDO IoT cloud using the MQTT protocol . ################################################################################ # MQTT at OKDO Cloud IoT # # Created at 2019-05-06 08:40:34.990336 # ################################################################################ import streams from wireless import wifi # choose a wifi chip (esp32) from espressif.esp32net import esp32wifi as wifi_driver # let's import the OKDO cloud modules; first the IoT module... from okdo.iot import iot # ...then the mqtt client from okdo.iot import mqtt_client # Let's define a global variable to store the publishing rate (in ms) rate = 3000 # Customize the following variables ssid = \"SSID\" # this is the SSID of the WiFi network wifipwd = \"\" # this is the Password for WiFi device_id = \"device_id\" # this is the device identifier. Can be obtained from the OKDO cloud dashboard device_token = \"device_token\" # this is the device token. Can be obtained from the OKDO cloud dashboard # Remember to add a device to your okdo cloud and define some assets: # - a \"rate\" actuator, with type integer # - a \"random\" sensor of type integer def rate_cb ( asset , value , previous_value ): global rate value = int ( value ) if value < 1000 : value = 1000 rate = value print ( \"Rate changed to\" , rate , \"ms\" ) streams . serial () try : # Let's initialize the WiFi wifi_driver . auto_init () for _ in range ( 0 , 5 ): # put your SSID and password here try : wifi . link ( ssid , wifi . WIFI_WPA2 , wifipwd ) break except : print ( \"Trying to connect...\" ) sleep ( 2000 ) else : print ( \"oops, can't attach to wifi!\" ) raise IOError print ( \"Connecting to OKDO IoT Cloud...\" ) # let's create a device passing the id, the token and the type of client device = iot . Device ( device_id , device_token , mqtt_client . MqttClient ) device . connect () print ( \"Device is connected\" ) # define the callbacks to call when an asset command is received device . watch_command ( \"rate\" , rate_cb ) # start the device device . run () print ( \"Device is up and running\" ) while True : # sleep as indicated by rate sleep ( rate ) x = random ( 0 , 100 ) msg = device . publish_asset ( \"random\" , x ) print ( \"Published asset\" , msg ) # alternatively, you can publish more than one asset state at a time # by providing them as a dictionary to the following function (uncomment to test) # msg = device.publish_state({\"random\":x}) # print(\"Published state\",msg) except Exception as e : print ( e ) HTTP \u00b6 A simple example connecting a device to the OKDO IoT cloud using the HTTP protocol. main.py ################################################################################ # HTTP at Fortebit Cloud IoT # # Created at 2019-05-06 08:40:34.990336 # ################################################################################ from fortebit.polaris import polaris import mcu import vm from wireless import gsm import ssl sleep ( 1000 ) print ( \"Test Polaris I/O\" ) polaris . init () #print(\"create IO exp...\") #iox = polaris.IO_EXP() print ( \"MCU UID:\" , [ hex ( b ) for b in mcu . uid ()]) print ( \"VM info:\" , vm . info ()) # let's import the OKDO cloud modules; first the IoT module... from fortebit.iot import iot # ...then the http client from fortebit.iot import http_client try : modem = polaris . GSM () minfo = gsm . mobile_info () print ( \"Modem:\" , minfo ) device_token = polaris . getAccessToken ( minfo [ 0 ], mcu . uid ()) print ( \"Access Token:\" , device_token ) for _ in range ( 0 , 5 ): # put your SSID and password here try : #gsm.attach(\"wap.vodafone.co.uk\",\"wap\",\"wap\") gsm . attach ( \"mobile.vodafone.it\" ) #gsm.attach(\"internet.wind\") #gsm.attach(\"tre.it\") break except Exception as e : print ( \"Retrying...\" , e ) try : gsm . detach () sleep ( 2000 ) except : pass else : print ( \"oops, can't attach to wifi!\" ) raise IOError ninfo = gsm . network_info () linfo = gsm . link_info () print ( \"Attached to network:\" , ninfo , linfo ) # retrieve the CA certificate used to sign the howsmyssl.com certificate cacert = __lookup ( SSL_CACERT_DST_ROOT_CA_X3 ) # create a SSL context to require server certificate verification ctx = ssl . create_ssl_context ( cacert = cacert , options = ssl . CERT_NONE ) #ssl.CERT_REQUIRED | ssl.SERVER_AUTH) # NOTE: if the underlying SSL driver does not support certificate validation # uncomment the following line! # ctx = None print ( \"Connecting to Fortebit IoT Cloud...\" ) # let's create a device passing the id, the token and the type of client device = iot . Device ( device_token , http_client . HttpClient , ctx ) device . connect () print ( \"Device is connected\" ) # start the device device . run () print ( \"Device is up and running\" ) x = 0 while True : # sleep as indicated by rate polaris . ledRedOn () sleep ( 3000 ) polaris . ledRedOff () x = x + 1 #random(0,100) msg = device . publish_telemetry ({ \"random\" : x }) print ( \"Published telemetry\" , msg ) # alternatively, you can publish more than one asset state at a time # by providing them as a dictionary to the following function (uncomment to test) # msg = device.publish_state({\"random\":x}) # print(\"Published state\",msg) except Exception as e : print ( e )","title":"Examples"},{"location":"reference/libs/fortebit/iot/docs/examples/#examples","text":"The following are a list of examples for lib.fortebit.iot.","title":"Examples"},{"location":"reference/libs/fortebit/iot/docs/examples/#mqtt","text":"MQTT ==== A simple example connecting a device to the OKDO IoT cloud using the MQTT protocol . ################################################################################ # MQTT at OKDO Cloud IoT # # Created at 2019-05-06 08:40:34.990336 # ################################################################################ import streams from wireless import wifi # choose a wifi chip (esp32) from espressif.esp32net import esp32wifi as wifi_driver # let's import the OKDO cloud modules; first the IoT module... from okdo.iot import iot # ...then the mqtt client from okdo.iot import mqtt_client # Let's define a global variable to store the publishing rate (in ms) rate = 3000 # Customize the following variables ssid = \"SSID\" # this is the SSID of the WiFi network wifipwd = \"\" # this is the Password for WiFi device_id = \"device_id\" # this is the device identifier. Can be obtained from the OKDO cloud dashboard device_token = \"device_token\" # this is the device token. Can be obtained from the OKDO cloud dashboard # Remember to add a device to your okdo cloud and define some assets: # - a \"rate\" actuator, with type integer # - a \"random\" sensor of type integer def rate_cb ( asset , value , previous_value ): global rate value = int ( value ) if value < 1000 : value = 1000 rate = value print ( \"Rate changed to\" , rate , \"ms\" ) streams . serial () try : # Let's initialize the WiFi wifi_driver . auto_init () for _ in range ( 0 , 5 ): # put your SSID and password here try : wifi . link ( ssid , wifi . WIFI_WPA2 , wifipwd ) break except : print ( \"Trying to connect...\" ) sleep ( 2000 ) else : print ( \"oops, can't attach to wifi!\" ) raise IOError print ( \"Connecting to OKDO IoT Cloud...\" ) # let's create a device passing the id, the token and the type of client device = iot . Device ( device_id , device_token , mqtt_client . MqttClient ) device . connect () print ( \"Device is connected\" ) # define the callbacks to call when an asset command is received device . watch_command ( \"rate\" , rate_cb ) # start the device device . run () print ( \"Device is up and running\" ) while True : # sleep as indicated by rate sleep ( rate ) x = random ( 0 , 100 ) msg = device . publish_asset ( \"random\" , x ) print ( \"Published asset\" , msg ) # alternatively, you can publish more than one asset state at a time # by providing them as a dictionary to the following function (uncomment to test) # msg = device.publish_state({\"random\":x}) # print(\"Published state\",msg) except Exception as e : print ( e )","title":"MQTT"},{"location":"reference/libs/fortebit/iot/docs/examples/#http","text":"A simple example connecting a device to the OKDO IoT cloud using the HTTP protocol. main.py ################################################################################ # HTTP at Fortebit Cloud IoT # # Created at 2019-05-06 08:40:34.990336 # ################################################################################ from fortebit.polaris import polaris import mcu import vm from wireless import gsm import ssl sleep ( 1000 ) print ( \"Test Polaris I/O\" ) polaris . init () #print(\"create IO exp...\") #iox = polaris.IO_EXP() print ( \"MCU UID:\" , [ hex ( b ) for b in mcu . uid ()]) print ( \"VM info:\" , vm . info ()) # let's import the OKDO cloud modules; first the IoT module... from fortebit.iot import iot # ...then the http client from fortebit.iot import http_client try : modem = polaris . GSM () minfo = gsm . mobile_info () print ( \"Modem:\" , minfo ) device_token = polaris . getAccessToken ( minfo [ 0 ], mcu . uid ()) print ( \"Access Token:\" , device_token ) for _ in range ( 0 , 5 ): # put your SSID and password here try : #gsm.attach(\"wap.vodafone.co.uk\",\"wap\",\"wap\") gsm . attach ( \"mobile.vodafone.it\" ) #gsm.attach(\"internet.wind\") #gsm.attach(\"tre.it\") break except Exception as e : print ( \"Retrying...\" , e ) try : gsm . detach () sleep ( 2000 ) except : pass else : print ( \"oops, can't attach to wifi!\" ) raise IOError ninfo = gsm . network_info () linfo = gsm . link_info () print ( \"Attached to network:\" , ninfo , linfo ) # retrieve the CA certificate used to sign the howsmyssl.com certificate cacert = __lookup ( SSL_CACERT_DST_ROOT_CA_X3 ) # create a SSL context to require server certificate verification ctx = ssl . create_ssl_context ( cacert = cacert , options = ssl . CERT_NONE ) #ssl.CERT_REQUIRED | ssl.SERVER_AUTH) # NOTE: if the underlying SSL driver does not support certificate validation # uncomment the following line! # ctx = None print ( \"Connecting to Fortebit IoT Cloud...\" ) # let's create a device passing the id, the token and the type of client device = iot . Device ( device_token , http_client . HttpClient , ctx ) device . connect () print ( \"Device is connected\" ) # start the device device . run () print ( \"Device is up and running\" ) x = 0 while True : # sleep as indicated by rate polaris . ledRedOn () sleep ( 3000 ) polaris . ledRedOff () x = x + 1 #random(0,100) msg = device . publish_telemetry ({ \"random\" : x }) print ( \"Published telemetry\" , msg ) # alternatively, you can publish more than one asset state at a time # by providing them as a dictionary to the following function (uncomment to test) # msg = device.publish_state({\"random\":x}) # print(\"Published state\",msg) except Exception as e : print ( e )","title":"HTTP"},{"location":"reference/libs/fortebit/iot/docs/http_client/","text":"","title":"Http client"},{"location":"reference/libs/fortebit/iot/docs/iot/","text":"Fortebit IoT Library \u00b6 The Zerynth Fortebit IoT Library can be used to ease the connection to the Fortebit IoT Cloud . It makes your device act as a Fortebit IoT Device that can be monitored and controlled on the Fortebit IoT Cloud dashboard. The device always send and receive data in the JSON format. The Device class \u00b6 class Device \u00b6 class Device ( device_token , client , ctx = None ) Create a Device instance representing a Fortebit IoT device. The device is provisioned by the device_token , obtained from the Fortebit dashboard upon the creation of a new device. The client parameter is a class that provides the implementation of the low level details for the connection. It can be one of MqttClient in the mqtt_client module, or HttpClient in the http_client module. The optional ctx parameter is an initialized secure socket context. Device.listen_rpc \u00b6 listen_rpc ( callback ) Listen to incoming RPC requests that get reported to the specified callback function, called as callback(id, method, params) : id is the request identifier (number) method is the method identifier of the RPC (Remote Procedure Call) params is a dictionary containing the RPC method arguments (or parameters) Call send_rpc_reply() to provide the result of the RPC request. Device.connect \u00b6 connect () Setup a connection to the Fortebit Cloud. Return True if successful. Device.is_connected \u00b6 is_connected () Returns the status of the connection to the Fortebit Cloud (reconnections are automatic). Device.run \u00b6 run () Starts the device by executing the underlying client loop. Device.publish_telemetry \u00b6 publish_telemetry ( values , ts ) Publish values (dictionary) to the device telemetry, with optional timestamp ts (epoch in milliseconds). Return a boolean, False if the message cannot be sent. Device.publish_attributes \u00b6 publish_attributes ( attributes ) Publish attributes (dictionary) to the device client attributes. Return a boolean, False if the message cannot be sent. Device.get_attributes \u00b6 get_attributes ( client , shared , timeout ) Obtain the specified client and/or shared attributes from the device. Return a dictionary, None if the data could not be received. Device.send_rpc_reply \u00b6 send_rpc_reply ( id , result ) Publish result (dictionary) as a reply to the RPC request with identifier id . Return a boolean, False if the message cannot be sent. Device.do_rpc_request \u00b6 do_rpc_request ( method , params , timeout ) Perform an RPC request with name method and arguments params , waiting for a reply maximum timeout milliseconds (only with MqttClient). Return the result of the RPC (dictionary), None in case of errors.","title":"Fortebit IoT Library"},{"location":"reference/libs/fortebit/iot/docs/iot/#fortebit-iot-library","text":"The Zerynth Fortebit IoT Library can be used to ease the connection to the Fortebit IoT Cloud . It makes your device act as a Fortebit IoT Device that can be monitored and controlled on the Fortebit IoT Cloud dashboard. The device always send and receive data in the JSON format.","title":"Fortebit IoT Library"},{"location":"reference/libs/fortebit/iot/docs/iot/#the-device-class","text":"","title":"The Device class"},{"location":"reference/libs/fortebit/iot/docs/iot/#class-device","text":"class Device ( device_token , client , ctx = None ) Create a Device instance representing a Fortebit IoT device. The device is provisioned by the device_token , obtained from the Fortebit dashboard upon the creation of a new device. The client parameter is a class that provides the implementation of the low level details for the connection. It can be one of MqttClient in the mqtt_client module, or HttpClient in the http_client module. The optional ctx parameter is an initialized secure socket context.","title":"class  Device"},{"location":"reference/libs/fortebit/iot/docs/iot/#devicelisten_rpc","text":"listen_rpc ( callback ) Listen to incoming RPC requests that get reported to the specified callback function, called as callback(id, method, params) : id is the request identifier (number) method is the method identifier of the RPC (Remote Procedure Call) params is a dictionary containing the RPC method arguments (or parameters) Call send_rpc_reply() to provide the result of the RPC request.","title":"Device.listen_rpc"},{"location":"reference/libs/fortebit/iot/docs/iot/#deviceconnect","text":"connect () Setup a connection to the Fortebit Cloud. Return True if successful.","title":"Device.connect"},{"location":"reference/libs/fortebit/iot/docs/iot/#deviceis_connected","text":"is_connected () Returns the status of the connection to the Fortebit Cloud (reconnections are automatic).","title":"Device.is_connected"},{"location":"reference/libs/fortebit/iot/docs/iot/#devicerun","text":"run () Starts the device by executing the underlying client loop.","title":"Device.run"},{"location":"reference/libs/fortebit/iot/docs/iot/#devicepublish_telemetry","text":"publish_telemetry ( values , ts ) Publish values (dictionary) to the device telemetry, with optional timestamp ts (epoch in milliseconds). Return a boolean, False if the message cannot be sent.","title":"Device.publish_telemetry"},{"location":"reference/libs/fortebit/iot/docs/iot/#devicepublish_attributes","text":"publish_attributes ( attributes ) Publish attributes (dictionary) to the device client attributes. Return a boolean, False if the message cannot be sent.","title":"Device.publish_attributes"},{"location":"reference/libs/fortebit/iot/docs/iot/#deviceget_attributes","text":"get_attributes ( client , shared , timeout ) Obtain the specified client and/or shared attributes from the device. Return a dictionary, None if the data could not be received.","title":"Device.get_attributes"},{"location":"reference/libs/fortebit/iot/docs/iot/#devicesend_rpc_reply","text":"send_rpc_reply ( id , result ) Publish result (dictionary) as a reply to the RPC request with identifier id . Return a boolean, False if the message cannot be sent.","title":"Device.send_rpc_reply"},{"location":"reference/libs/fortebit/iot/docs/iot/#devicedo_rpc_request","text":"do_rpc_request ( method , params , timeout ) Perform an RPC request with name method and arguments params , waiting for a reply maximum timeout milliseconds (only with MqttClient). Return the result of the RPC (dictionary), None in case of errors.","title":"Device.do_rpc_request"},{"location":"reference/libs/fortebit/iot/docs/mqtt_client/","text":"","title":"Mqtt client"},{"location":"reference/libs/fortebit/polaris/docs/","text":"Polaris \u00b6 This library has been written to be used with the Polaris boards provided by Fortebit, allowing the user to easily access all the features available on the board, with a uniform programming interface for all hardware variants (2G, 3G and NB-IoT). Below, Zerynth documentation for the Polaris library. Contents: Polaris Board GNSS Modem Cloud Service Accelerometer I/O Expander QSPI Flash","title":"Polaris"},{"location":"reference/libs/fortebit/polaris/docs/#polaris","text":"This library has been written to be used with the Polaris boards provided by Fortebit, allowing the user to easily access all the features available on the board, with a uniform programming interface for all hardware variants (2G, 3G and NB-IoT). Below, Zerynth documentation for the Polaris library. Contents: Polaris Board GNSS Modem Cloud Service Accelerometer I/O Expander QSPI Flash","title":"Polaris"},{"location":"reference/libs/fortebit/polaris/docs/accelerometer/","text":"Accelerometer \u00b6 This module provides easy access to Polaris on-board accelerometer. Accelerometer \u00b6 Accelerometer () Creates an instance of the on-board accelerometer device class ( stm.lis2hh12.LIS2HH12 ). Returns: LIS2HH12 object configured for Polaris hardware.","title":"Accelerometer"},{"location":"reference/libs/fortebit/polaris/docs/accelerometer/#accelerometer","text":"This module provides easy access to Polaris on-board accelerometer.","title":"Accelerometer"},{"location":"reference/libs/fortebit/polaris/docs/accelerometer/#accelerometer_1","text":"Accelerometer () Creates an instance of the on-board accelerometer device class ( stm.lis2hh12.LIS2HH12 ). Returns: LIS2HH12 object configured for Polaris hardware.","title":"Accelerometer"},{"location":"reference/libs/fortebit/polaris/docs/cloud/","text":"Cloud Service \u00b6 This module provides easy access to the Fortebit Cloud features. getAccessToken \u00b6 getAccessToken ( imei , uid ) Generates the board\u2019s own access token for Fortebit IoT cloud services. Arguments: imei \u2013 The modem IMEI number (as a 15 characters string) uid \u2013 The MCU unique identifier (as a 3 integers sequence) isRegistered \u00b6 isRegistered ( device , email ) Check if the specified IoT device is registered to the Polaris Cloud services. Arguments: device \u2013 a connected instance of fortebit.iot.Device email \u2013 the device owner\u2019s email address register \u00b6 register ( device , email ) Perform device registration to Polaris Cloud services. Arguments: device \u2013 a connected instance of fortebit.iot.Device email \u2013 the device owner\u2019s email address","title":"Cloud Service"},{"location":"reference/libs/fortebit/polaris/docs/cloud/#cloud-service","text":"This module provides easy access to the Fortebit Cloud features.","title":"Cloud Service"},{"location":"reference/libs/fortebit/polaris/docs/cloud/#getaccesstoken","text":"getAccessToken ( imei , uid ) Generates the board\u2019s own access token for Fortebit IoT cloud services. Arguments: imei \u2013 The modem IMEI number (as a 15 characters string) uid \u2013 The MCU unique identifier (as a 3 integers sequence)","title":"getAccessToken"},{"location":"reference/libs/fortebit/polaris/docs/cloud/#isregistered","text":"isRegistered ( device , email ) Check if the specified IoT device is registered to the Polaris Cloud services. Arguments: device \u2013 a connected instance of fortebit.iot.Device email \u2013 the device owner\u2019s email address","title":"isRegistered"},{"location":"reference/libs/fortebit/polaris/docs/cloud/#register","text":"register ( device , email ) Perform device registration to Polaris Cloud services. Arguments: device \u2013 a connected instance of fortebit.iot.Device email \u2013 the device owner\u2019s email address","title":"register"},{"location":"reference/libs/fortebit/polaris/docs/gnss/","text":"GNSS \u00b6 This module provides uniform access to Polaris on-board GNSS receiver, which may vary on different board variants. GNSS \u00b6 GNSS () Creates an instance of the correct GNSS receiver class for the current Polaris target board variant. Returns: quectel.l76.L76 for Polaris 3G and Polaris 2G , quectel.bg96.BG96_GNSS for Polaris NB-IoT .","title":"GNSS"},{"location":"reference/libs/fortebit/polaris/docs/gnss/#gnss","text":"This module provides uniform access to Polaris on-board GNSS receiver, which may vary on different board variants.","title":"GNSS"},{"location":"reference/libs/fortebit/polaris/docs/gnss/#gnss_1","text":"GNSS () Creates an instance of the correct GNSS receiver class for the current Polaris target board variant. Returns: quectel.l76.L76 for Polaris 3G and Polaris 2G , quectel.bg96.BG96_GNSS for Polaris NB-IoT .","title":"GNSS"},{"location":"reference/libs/fortebit/polaris/docs/ioexpander/","text":"I/O Expander \u00b6 This module provides easy access to Polaris on-board I/O Expander. IOExpander \u00b6 IOExpander () Creates an instance of the on-board I/O Expander device class ( onsemi.ncv7240.NCV7240 ). Returns: NCV7240 object configured for Polaris hardware.","title":"I/O Expander"},{"location":"reference/libs/fortebit/polaris/docs/ioexpander/#io-expander","text":"This module provides easy access to Polaris on-board I/O Expander.","title":"I/O Expander"},{"location":"reference/libs/fortebit/polaris/docs/ioexpander/#ioexpander","text":"IOExpander () Creates an instance of the on-board I/O Expander device class ( onsemi.ncv7240.NCV7240 ). Returns: NCV7240 object configured for Polaris hardware.","title":"IOExpander"},{"location":"reference/libs/fortebit/polaris/docs/main/","text":"","title":"Main"},{"location":"reference/libs/fortebit/polaris/docs/modem/","text":"Modem \u00b6 This module provides uniform access to Polaris on-board modem, which may vary on different board variants. init \u00b6 init () Initializes the correct Modem library for the current Polaris target board variant and returns the module object. Returns: quectel.m95.M95 for Polaris 2G , quectel.ug96.UG96 for Polaris 3G , quectel.bg96.BG96 for Polaris NB-IoT .","title":"Modem"},{"location":"reference/libs/fortebit/polaris/docs/modem/#modem","text":"This module provides uniform access to Polaris on-board modem, which may vary on different board variants.","title":"Modem"},{"location":"reference/libs/fortebit/polaris/docs/modem/#init","text":"init () Initializes the correct Modem library for the current Polaris target board variant and returns the module object. Returns: quectel.m95.M95 for Polaris 2G , quectel.ug96.UG96 for Polaris 3G , quectel.bg96.BG96 for Polaris NB-IoT .","title":"init"},{"location":"reference/libs/fortebit/polaris/docs/pinmap/","text":"class extbus \u00b6 class extbus Namespace for Ext interface signals and peripherals: PIN_GPIO1","title":"Pinmap"},{"location":"reference/libs/fortebit/polaris/docs/pinmap/#class-extbus","text":"class extbus Namespace for Ext interface signals and peripherals: PIN_GPIO1","title":"class extbus"},{"location":"reference/libs/fortebit/polaris/docs/polaris/","text":"Polaris Board \u00b6 This module provides easy access to the Polaris board features and meaningful names for MCU pins and peripherals. class main \u00b6 class main () Namespace for the Main connector signals and related peripherals: PIN_VIN - analog input for main supply voltage PIN_IGNITION - digital input for ignition detection (active high) PIN_SOS - digital input for emergency button (active low) PIN_AIN1 , PIN_RANGE_IN1 - analog input 1 and range selection pin PIN_AIN2 , PIN_RANGE_IN2 - analog input 2 and range selection pin PIN_AIN3 , PIN_RANGE_IN3 - analog input 3 and range selection pin PIN_AIN4 , PIN_RANGE_IN4 - analog input 4 and range selection pin PIN_IOEXP_IN1 - control input 1 for I/O Expander PIN_IOEXP_IN2 - control input 2 for I/O Expander ADC_VIN - ADC channel (using PIN_VIN ) ADC_IN1 - ADC channel (using PIN_AIN1 ) ADC_IN2 - ADC channel (using PIN_AIN2 ) ADC_IN3 - ADC channel (using PIN_AIN3 ) ADC_IN4 - ADC channel (using PIN_AIN4 ) PWM_IOEXP_IN1 - PWM control input 1 for I/O Expander PWM_IOEXP_IN2 - PWM control input 2 for I/O Expander class mikrobus \u00b6 class mikrobus () Namespace for the mikroBUS expansion interface signals and related peripherals: PIN_MISO , PIN_MOSI , PIN_SCK , PIN_CS - expansion SPI interface PIN_SDA , PIN_SCL - expansion I2C interface PIN_TX , PIN_RX - expansion UART pins PIN_RST , PIN_INT - general purpose I/O pins (usually reset and interrupt) PIN_PWM - PWM capable pin PIN_AN - analog input pin SERIAL - serial driver (using PIN_RX ,``PIN_TX``) SPI - SPI driver (using PIN_MISO , PIN_MOSI , PIN_SCK ) I2C - I2C driver (using PIN_SDA , PIN_SCL ) PWM - PWM channel (using PIN_PWM ) ADC - ADC channel (using PIN_AN ) class extbus \u00b6 class extbus () Namespace for the Ext-A expansion interface signals and related peripherals: PIN_GPIO1 , PIN_GPIO2 - general purpose I/O pins PIN_TX , PIN_RX - expansion UART pins PIN_PWM - PWM capable pin PIN_AN1 - analog input pin PIN_DAC1 , PIN_DAC1 - analog pins SERIAL - serial driver (using PIN_RX ,``PIN_TX``) PWM - PWM channel (using PIN_PWM ) ADC - ADC channel (using PIN_AN1 ) class internal Namespace for on-board devices signals and peripherals: PIN_LED_RED , PIN_LED_GREEN - LED control pins (active low) PIN_POWER_DIS - main power control pin (shutdown) PIN_5V_EN - control pin for 5V regulator PIN_BATT_EN - backup battery status pin PIN_IOEXP_CS - I/O Expander chip-select pin PIN_CAN_STANDBY - control pin for CAN transceiver stand-by mode (low for normal operation) PIN_ACCEL_CS , PIN_ACCEL_INT - accelerometer chip-select and interrupt pins PIN_CHARGE_PROG , PIN_CHARGE_STAT - backup battery charger control and status pins PIN_BATT_ADC - analog input for backup battery voltage SPI - on-board SPI driver (for accelerometer and I/O Expander) ADC_BATT - ADC channel (using PIN_BATT_ADC ) class gnss \u00b6 class gnss () Namespace for GNSS module signals and related peripherals: PIN_STANDBY , PIN_RESET - module control pins PIN_TX , PIN_RX - module UART pins PIN_ANTON - control pin (used only in the NB-IoT variant with BG96) SERIAL - serial driver (using PIN_RX ,``PIN_TX``) class gsm \u00b6 class gsm () Namespace for Modem signals and related peripherals: PIN_TX , PIN_RX - modem UART pins PIN_POWER , PIN_KILL , PIN_WAKE - modem control pins PIN_STATUS , PIN_RING - modem status pins SERIAL - serial driver (using PIN_RX ,``PIN_TX``) init \u00b6 init () Performs required initialization of Polaris pins and common functionalities. It should be called at the start of your application. sBatteryBackup \u00b6 sBatteryBackup () Returns a boolean value to indicate whether the board is powered from the backup battery source. setBatteryCharger \u00b6 setBatteryCharger ( enable ) Enables or disables the backup battery charger (5V required). Note: Do not enable the charger when the main power supply is not present. getChargerStatus \u00b6 getChargerStatus () Returns the battery charger status (not charging, charging or fully charged). Returns: One of these values: CHARGE_NONE = 0, CHARGE_BUSY = 1, CHARGE_COMPLETE = 2. getIgnitionStatus \u00b6 getIgnitionStatus () Reads the ignition status from digital input pin IGN/DIO5 (active high). Returns: An integer value to indicate whether the ignition switch is on/off: IGNITION_ON = 1 or IGNITION_OFF = 0. getEmergencyStatus \u00b6 getEmergencyStatus () Reads the emergency button status from digital input pin SOS/DIO6 (active low). Returns: An integer value to indicate whether the emergency button is switched on/off: SOS_ON = 1 or SOS_OFF = 0. shutdown \u00b6 shutdown () Disables the main regulator or backup battery source, effectively power-cycling the board. readMainVoltage \u00b6 readMainVoltage () Returns the analog measure of the main supply voltage. readMainVoltage \u00b6 readMainVoltage () Returns the analog measure of the backup battery voltage. readAnalogInputVoltage \u00b6 readAnalogInputVoltage ( pin_num , range = HIGH ) Returns the voltage measure of an analog input pin on the Main connector. Arguments: pin_num \u2013 Index of the analog pin (0-3 = corresponds to AIO1-4) range \u2013 Full-scale range: HIGH (0-36V) or LOW (0-5V) ledRedOff \u00b6 ledRedOff () Switch the red LED off. ledRedOn \u00b6 ledRedOn () Switch the red LED on. ledGreenOff \u00b6 ledGreenOff () Switch the green LED off. ledGreenOn \u00b6 ledGreenOn () Switch the green LED on.","title":"Polaris Board"},{"location":"reference/libs/fortebit/polaris/docs/polaris/#polaris-board","text":"This module provides easy access to the Polaris board features and meaningful names for MCU pins and peripherals.","title":"Polaris Board"},{"location":"reference/libs/fortebit/polaris/docs/polaris/#class-main","text":"class main () Namespace for the Main connector signals and related peripherals: PIN_VIN - analog input for main supply voltage PIN_IGNITION - digital input for ignition detection (active high) PIN_SOS - digital input for emergency button (active low) PIN_AIN1 , PIN_RANGE_IN1 - analog input 1 and range selection pin PIN_AIN2 , PIN_RANGE_IN2 - analog input 2 and range selection pin PIN_AIN3 , PIN_RANGE_IN3 - analog input 3 and range selection pin PIN_AIN4 , PIN_RANGE_IN4 - analog input 4 and range selection pin PIN_IOEXP_IN1 - control input 1 for I/O Expander PIN_IOEXP_IN2 - control input 2 for I/O Expander ADC_VIN - ADC channel (using PIN_VIN ) ADC_IN1 - ADC channel (using PIN_AIN1 ) ADC_IN2 - ADC channel (using PIN_AIN2 ) ADC_IN3 - ADC channel (using PIN_AIN3 ) ADC_IN4 - ADC channel (using PIN_AIN4 ) PWM_IOEXP_IN1 - PWM control input 1 for I/O Expander PWM_IOEXP_IN2 - PWM control input 2 for I/O Expander","title":"class main"},{"location":"reference/libs/fortebit/polaris/docs/polaris/#class-mikrobus","text":"class mikrobus () Namespace for the mikroBUS expansion interface signals and related peripherals: PIN_MISO , PIN_MOSI , PIN_SCK , PIN_CS - expansion SPI interface PIN_SDA , PIN_SCL - expansion I2C interface PIN_TX , PIN_RX - expansion UART pins PIN_RST , PIN_INT - general purpose I/O pins (usually reset and interrupt) PIN_PWM - PWM capable pin PIN_AN - analog input pin SERIAL - serial driver (using PIN_RX ,``PIN_TX``) SPI - SPI driver (using PIN_MISO , PIN_MOSI , PIN_SCK ) I2C - I2C driver (using PIN_SDA , PIN_SCL ) PWM - PWM channel (using PIN_PWM ) ADC - ADC channel (using PIN_AN )","title":"class mikrobus"},{"location":"reference/libs/fortebit/polaris/docs/polaris/#class-extbus","text":"class extbus () Namespace for the Ext-A expansion interface signals and related peripherals: PIN_GPIO1 , PIN_GPIO2 - general purpose I/O pins PIN_TX , PIN_RX - expansion UART pins PIN_PWM - PWM capable pin PIN_AN1 - analog input pin PIN_DAC1 , PIN_DAC1 - analog pins SERIAL - serial driver (using PIN_RX ,``PIN_TX``) PWM - PWM channel (using PIN_PWM ) ADC - ADC channel (using PIN_AN1 ) class internal Namespace for on-board devices signals and peripherals: PIN_LED_RED , PIN_LED_GREEN - LED control pins (active low) PIN_POWER_DIS - main power control pin (shutdown) PIN_5V_EN - control pin for 5V regulator PIN_BATT_EN - backup battery status pin PIN_IOEXP_CS - I/O Expander chip-select pin PIN_CAN_STANDBY - control pin for CAN transceiver stand-by mode (low for normal operation) PIN_ACCEL_CS , PIN_ACCEL_INT - accelerometer chip-select and interrupt pins PIN_CHARGE_PROG , PIN_CHARGE_STAT - backup battery charger control and status pins PIN_BATT_ADC - analog input for backup battery voltage SPI - on-board SPI driver (for accelerometer and I/O Expander) ADC_BATT - ADC channel (using PIN_BATT_ADC )","title":"class extbus"},{"location":"reference/libs/fortebit/polaris/docs/polaris/#class-gnss","text":"class gnss () Namespace for GNSS module signals and related peripherals: PIN_STANDBY , PIN_RESET - module control pins PIN_TX , PIN_RX - module UART pins PIN_ANTON - control pin (used only in the NB-IoT variant with BG96) SERIAL - serial driver (using PIN_RX ,``PIN_TX``)","title":"class gnss"},{"location":"reference/libs/fortebit/polaris/docs/polaris/#class-gsm","text":"class gsm () Namespace for Modem signals and related peripherals: PIN_TX , PIN_RX - modem UART pins PIN_POWER , PIN_KILL , PIN_WAKE - modem control pins PIN_STATUS , PIN_RING - modem status pins SERIAL - serial driver (using PIN_RX ,``PIN_TX``)","title":"class gsm"},{"location":"reference/libs/fortebit/polaris/docs/polaris/#init","text":"init () Performs required initialization of Polaris pins and common functionalities. It should be called at the start of your application.","title":"init"},{"location":"reference/libs/fortebit/polaris/docs/polaris/#sbatterybackup","text":"sBatteryBackup () Returns a boolean value to indicate whether the board is powered from the backup battery source.","title":"sBatteryBackup"},{"location":"reference/libs/fortebit/polaris/docs/polaris/#setbatterycharger","text":"setBatteryCharger ( enable ) Enables or disables the backup battery charger (5V required). Note: Do not enable the charger when the main power supply is not present.","title":"setBatteryCharger"},{"location":"reference/libs/fortebit/polaris/docs/polaris/#getchargerstatus","text":"getChargerStatus () Returns the battery charger status (not charging, charging or fully charged). Returns: One of these values: CHARGE_NONE = 0, CHARGE_BUSY = 1, CHARGE_COMPLETE = 2.","title":"getChargerStatus"},{"location":"reference/libs/fortebit/polaris/docs/polaris/#getignitionstatus","text":"getIgnitionStatus () Reads the ignition status from digital input pin IGN/DIO5 (active high). Returns: An integer value to indicate whether the ignition switch is on/off: IGNITION_ON = 1 or IGNITION_OFF = 0.","title":"getIgnitionStatus"},{"location":"reference/libs/fortebit/polaris/docs/polaris/#getemergencystatus","text":"getEmergencyStatus () Reads the emergency button status from digital input pin SOS/DIO6 (active low). Returns: An integer value to indicate whether the emergency button is switched on/off: SOS_ON = 1 or SOS_OFF = 0.","title":"getEmergencyStatus"},{"location":"reference/libs/fortebit/polaris/docs/polaris/#shutdown","text":"shutdown () Disables the main regulator or backup battery source, effectively power-cycling the board.","title":"shutdown"},{"location":"reference/libs/fortebit/polaris/docs/polaris/#readmainvoltage","text":"readMainVoltage () Returns the analog measure of the main supply voltage.","title":"readMainVoltage"},{"location":"reference/libs/fortebit/polaris/docs/polaris/#readmainvoltage_1","text":"readMainVoltage () Returns the analog measure of the backup battery voltage.","title":"readMainVoltage"},{"location":"reference/libs/fortebit/polaris/docs/polaris/#readanaloginputvoltage","text":"readAnalogInputVoltage ( pin_num , range = HIGH ) Returns the voltage measure of an analog input pin on the Main connector. Arguments: pin_num \u2013 Index of the analog pin (0-3 = corresponds to AIO1-4) range \u2013 Full-scale range: HIGH (0-36V) or LOW (0-5V)","title":"readAnalogInputVoltage"},{"location":"reference/libs/fortebit/polaris/docs/polaris/#ledredoff","text":"ledRedOff () Switch the red LED off.","title":"ledRedOff"},{"location":"reference/libs/fortebit/polaris/docs/polaris/#ledredon","text":"ledRedOn () Switch the red LED on.","title":"ledRedOn"},{"location":"reference/libs/fortebit/polaris/docs/polaris/#ledgreenoff","text":"ledGreenOff () Switch the green LED off.","title":"ledGreenOff"},{"location":"reference/libs/fortebit/polaris/docs/polaris/#ledgreenon","text":"ledGreenOn () Switch the green LED on.","title":"ledGreenOn"},{"location":"reference/libs/fortebit/polaris/docs/qspiflash/","text":"QSPI Flash \u00b6 This module provides easy access to Polaris on-board serial Flash memory. QSpiFlash \u00b6 QSpiFlash () Creates an instance of the Quad-SPI Flash device class. Returns : stdlib.QSpiFlash object configured for Polaris hardware.","title":"QSPI Flash"},{"location":"reference/libs/fortebit/polaris/docs/qspiflash/#qspi-flash","text":"This module provides easy access to Polaris on-board serial Flash memory.","title":"QSPI Flash"},{"location":"reference/libs/fortebit/polaris/docs/qspiflash/#qspiflash","text":"QSpiFlash () Creates an instance of the Quad-SPI Flash device class. Returns : stdlib.QSpiFlash object configured for Polaris hardware.","title":"QSpiFlash"},{"location":"reference/libs/googlecloud/iot/docs/","text":"Google Cloud IoT Core \u00b6 Cloud IoT Core is a fully managed service that allows you to easily and securely connect, manage, and ingest data from millions of globally dispersed devices: Google Cloud IoT Core . It is possible, for example, to connect to Google Cloud IoT Core MQTT Broker to send device data and process/store those data with different Google Cloud services linked to Google Cloud IoT Core through Google Cloud Pub/Sub . Here below, the Zerynth Library to manage your devices thanks to Google Cloud IoT Core: Contents: Google Cloud IoT Core Google Cloud IoT Core Library The Device class Examples Controlled publish period","title":"Google Cloud IoT Core"},{"location":"reference/libs/googlecloud/iot/docs/#google-cloud-iot-core","text":"Cloud IoT Core is a fully managed service that allows you to easily and securely connect, manage, and ingest data from millions of globally dispersed devices: Google Cloud IoT Core . It is possible, for example, to connect to Google Cloud IoT Core MQTT Broker to send device data and process/store those data with different Google Cloud services linked to Google Cloud IoT Core through Google Cloud Pub/Sub . Here below, the Zerynth Library to manage your devices thanks to Google Cloud IoT Core: Contents: Google Cloud IoT Core Google Cloud IoT Core Library The Device class Examples Controlled publish period","title":"Google Cloud IoT Core"},{"location":"reference/libs/googlecloud/iot/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.googlecloud.iot. Controlled Publish Period \u00b6 Connect your device to Google Cloud IoT Core and start publishing at a default period, waiting for period updates requested as changes to device config. main.py # Google Cloud IoT Controlled publish period # Created at 2017-10-03 08:49:48.182639 import streams import json from wireless import wifi # choose a wifi chip supporting secure sockets from espressif.esp32net import esp32wifi as wifi_driver import requests # import google cloud iot module from googlecloud.iot import iot # import helpers functions to easily load keys and device configuration import helpers # DEVICE KEY FILE MUST BE PLACED INSIDE PROJECT FOLDER new_resource ( 'private.hex.key' ) # set device configuration inside this json file new_resource ( 'device.conf.json' ) # define a callback for config updates def config_callback ( config ): global publish_period print ( 'requested publish period:' , config [ 'publish_period' ]) publish_period = config [ 'publish_period' ] return { 'publish_period' : publish_period } streams . serial () wifi_driver . auto_init () # place here your wifi configuration wifi . link ( \"SSID\" , wifi . WIFI_WPA2 , \"PSW\" ) pkey = helpers . load_key ( 'private.hex.key' ) device_conf = helpers . load_device_conf () publish_period = 5000 # choose an appropriate way to get a valid timestamp (may be available through hardware RTC) def get_timestamp (): user_agent = { \"user-agent\" : \"curl/7.56.0\" } return json . loads ( requests . get ( \"http://now.zerynth.com/\" , headers = user_agent ) . content )[ 'now' ][ 'epoch' ] # create a google cloud device instance, connect to mqtt broker, set config callback and start mqtt reception loop device = iot . Device ( device_conf [ 'project_id' ], device_conf [ 'cloud_region' ], device_conf [ 'registry_id' ], device_conf [ 'device_id' ], pkey , get_timestamp ) device . mqtt . connect () device . on_config ( config_callback ) device . mqtt . loop () while True : print ( 'publish random sample...' ) device . publish_event ( json . dumps ({ 'asample' : random ( 0 , 10 ) })) sleep ( publish_period )","title":"Examples"},{"location":"reference/libs/googlecloud/iot/docs/examples/#examples","text":"The following are a list of examples for lib.googlecloud.iot.","title":"Examples"},{"location":"reference/libs/googlecloud/iot/docs/examples/#controlled-publish-period","text":"Connect your device to Google Cloud IoT Core and start publishing at a default period, waiting for period updates requested as changes to device config. main.py # Google Cloud IoT Controlled publish period # Created at 2017-10-03 08:49:48.182639 import streams import json from wireless import wifi # choose a wifi chip supporting secure sockets from espressif.esp32net import esp32wifi as wifi_driver import requests # import google cloud iot module from googlecloud.iot import iot # import helpers functions to easily load keys and device configuration import helpers # DEVICE KEY FILE MUST BE PLACED INSIDE PROJECT FOLDER new_resource ( 'private.hex.key' ) # set device configuration inside this json file new_resource ( 'device.conf.json' ) # define a callback for config updates def config_callback ( config ): global publish_period print ( 'requested publish period:' , config [ 'publish_period' ]) publish_period = config [ 'publish_period' ] return { 'publish_period' : publish_period } streams . serial () wifi_driver . auto_init () # place here your wifi configuration wifi . link ( \"SSID\" , wifi . WIFI_WPA2 , \"PSW\" ) pkey = helpers . load_key ( 'private.hex.key' ) device_conf = helpers . load_device_conf () publish_period = 5000 # choose an appropriate way to get a valid timestamp (may be available through hardware RTC) def get_timestamp (): user_agent = { \"user-agent\" : \"curl/7.56.0\" } return json . loads ( requests . get ( \"http://now.zerynth.com/\" , headers = user_agent ) . content )[ 'now' ][ 'epoch' ] # create a google cloud device instance, connect to mqtt broker, set config callback and start mqtt reception loop device = iot . Device ( device_conf [ 'project_id' ], device_conf [ 'cloud_region' ], device_conf [ 'registry_id' ], device_conf [ 'device_id' ], pkey , get_timestamp ) device . mqtt . connect () device . on_config ( config_callback ) device . mqtt . loop () while True : print ( 'publish random sample...' ) device . publish_event ( json . dumps ({ 'asample' : random ( 0 , 10 ) })) sleep ( publish_period )","title":"Controlled Publish Period"},{"location":"reference/libs/googlecloud/iot/docs/iot/","text":"Google Cloud IoT Core Library \u00b6 The Zerynth Google Cloud IoT Core Library can be used to ease the connection to Google Cloud IoT Core . It allows to make your device act as a Google Cloud IoT Core Device which can be registered through Google Cloud tools or Google Cloud web dashboard. The Device class \u00b6 class Device \u00b6 class Device ( project_id , cloud_region , registry_id , device_id , pkey , timestamp_fn , token_lifetime = 60 ) . Create a Device instance representing a Google Cloud IoT Core Device. The Device object will contain an mqtt client instance pointing to Google Cloud IoT Core MQTT broker located at mqtt.googleapis.com . The client is configured with an MQTT id composed following Google Cloud IoT Core MQTT id standards projects / $ project_id / locations / $ cloud_region / registries / $ registry_id / devices / $ device_id and is able to connect securely through TLS and authenticate through a JWT with a token_lifetime minutes lifespan. Valid tokens generation process needs current timestamp which will be obtained calling passed timestamp_fn . timestamp_fn has to be a Python function returning an integer timestamp. A valid private key pkey is also needed. pkey must be an ECDSA private key in hex format. If a private key has been generated following Google Cloud IoT guidelines and is consequently stored as a pem file, the needed hex string can be extracted from the OCTET STRING field associated value obtained from openssl asn1parse - in my_private . pem command (since pem is a base64 encoded, plus header, DER ). The client is accessible through mqtt instance attribute and exposes all Zerynth MQTT Client methods so that it is possible, for example, to setup custom callbacks on MQTT commands. The only difference concerns mqtt.connect method which does not require broker url and ssl context, taking them from Device configuration: def timestamp_fn (): valid_timestamp = 1509001724 return valid_timestamp pkey = \"73801C733697C81604A4A4F7BF36FB84227DA506194A26A864A55B6DE8FF98E0\" my_device = iot . Device ( 'my-project' , 'my-cloud-region' , 'my-registry-id' , 'my-device-id' , pkey , timestamp_fn ) my_device . mqtt . connect () ... my_device . mqtt . loop () Device.publish_event \u00b6 publish_event ( event ) Publish a new event event . event must be a dictionary and will be sent as json string. Device.publish_state \u00b6 publish_state ( state ) Publish a new state state . state must be a dictionary and will be sent as json string. Device.on_config \u00b6 on_config ( config_cbk ) Set a callback to be called on config updates. config_cbk callback will be called passing a dictionary containing requested config as the only parameter: def config_cbk ( config ): print ( 'requested publish period:' , config [ 'publish_period' ]) return { 'publish_period' : config [ 'publish_period' ]} my_device . on_config ( config_cbk ) If the callback returns a dictionary, it will be immediately sent as updated device state. Device.on_command \u00b6 on_command ( command_cbk ) Set a callback to be called on command. command_cbk callback will be called passing the command payload and subfolder: def command_cbk ( command , subfolder ): print ( 'requested command payload:' , command ) print ( 'requested command subfolder:' , subfolder ) my_device . on_command ( command_cbk )","title":"Google Cloud IoT Core Library"},{"location":"reference/libs/googlecloud/iot/docs/iot/#google-cloud-iot-core-library","text":"The Zerynth Google Cloud IoT Core Library can be used to ease the connection to Google Cloud IoT Core . It allows to make your device act as a Google Cloud IoT Core Device which can be registered through Google Cloud tools or Google Cloud web dashboard.","title":"Google Cloud IoT Core Library"},{"location":"reference/libs/googlecloud/iot/docs/iot/#the-device-class","text":"","title":"The Device class"},{"location":"reference/libs/googlecloud/iot/docs/iot/#class-device","text":"class Device ( project_id , cloud_region , registry_id , device_id , pkey , timestamp_fn , token_lifetime = 60 ) . Create a Device instance representing a Google Cloud IoT Core Device. The Device object will contain an mqtt client instance pointing to Google Cloud IoT Core MQTT broker located at mqtt.googleapis.com . The client is configured with an MQTT id composed following Google Cloud IoT Core MQTT id standards projects / $ project_id / locations / $ cloud_region / registries / $ registry_id / devices / $ device_id and is able to connect securely through TLS and authenticate through a JWT with a token_lifetime minutes lifespan. Valid tokens generation process needs current timestamp which will be obtained calling passed timestamp_fn . timestamp_fn has to be a Python function returning an integer timestamp. A valid private key pkey is also needed. pkey must be an ECDSA private key in hex format. If a private key has been generated following Google Cloud IoT guidelines and is consequently stored as a pem file, the needed hex string can be extracted from the OCTET STRING field associated value obtained from openssl asn1parse - in my_private . pem command (since pem is a base64 encoded, plus header, DER ). The client is accessible through mqtt instance attribute and exposes all Zerynth MQTT Client methods so that it is possible, for example, to setup custom callbacks on MQTT commands. The only difference concerns mqtt.connect method which does not require broker url and ssl context, taking them from Device configuration: def timestamp_fn (): valid_timestamp = 1509001724 return valid_timestamp pkey = \"73801C733697C81604A4A4F7BF36FB84227DA506194A26A864A55B6DE8FF98E0\" my_device = iot . Device ( 'my-project' , 'my-cloud-region' , 'my-registry-id' , 'my-device-id' , pkey , timestamp_fn ) my_device . mqtt . connect () ... my_device . mqtt . loop ()","title":"class Device"},{"location":"reference/libs/googlecloud/iot/docs/iot/#devicepublish_event","text":"publish_event ( event ) Publish a new event event . event must be a dictionary and will be sent as json string.","title":"Device.publish_event"},{"location":"reference/libs/googlecloud/iot/docs/iot/#devicepublish_state","text":"publish_state ( state ) Publish a new state state . state must be a dictionary and will be sent as json string.","title":"Device.publish_state"},{"location":"reference/libs/googlecloud/iot/docs/iot/#deviceon_config","text":"on_config ( config_cbk ) Set a callback to be called on config updates. config_cbk callback will be called passing a dictionary containing requested config as the only parameter: def config_cbk ( config ): print ( 'requested publish period:' , config [ 'publish_period' ]) return { 'publish_period' : config [ 'publish_period' ]} my_device . on_config ( config_cbk ) If the callback returns a dictionary, it will be immediately sent as updated device state.","title":"Device.on_config"},{"location":"reference/libs/googlecloud/iot/docs/iot/#deviceon_command","text":"on_command ( command_cbk ) Set a callback to be called on command. command_cbk callback will be called passing the command payload and subfolder: def command_cbk ( command , subfolder ): print ( 'requested command payload:' , command ) print ( 'requested command subfolder:' , subfolder ) my_device . on_command ( command_cbk )","title":"Device.on_command"},{"location":"reference/libs/ibmcloud/iot/docs/","text":"IBM Cloud Watson IoT Library \u00b6 IBM Watson IoT Platform is a fully-managed, multi-tenant, cloud-hosted service. Capabilities include: Connection of a wide spectrum of IoT devices IoT device registration and management Ability for devices and applications to produce and consume events in near-real-time Dashboard/console for each service Integration at the application level Use of the industry standard MQTT and HTTP protocols for device connectivity Device-Cloud authentication, and application authentication The Cloud Service also enables analytics on the data from connected devices. It uses a simple rules-based composition model and an extensible framework to help organizations access IoT data, combine it with master asset data, analyze events and data in context, and automate responses to help improve operations and service levels ( Service Description ). Here below, the Zerynth Library to manage your devices thanks to IBM Watson IoT: Contents: IBM Cloud Watson IoT Library The Device class Examples Controlled publish period","title":"Index"},{"location":"reference/libs/ibmcloud/iot/docs/#ibm-cloud-watson-iot-library","text":"IBM Watson IoT Platform is a fully-managed, multi-tenant, cloud-hosted service. Capabilities include: Connection of a wide spectrum of IoT devices IoT device registration and management Ability for devices and applications to produce and consume events in near-real-time Dashboard/console for each service Integration at the application level Use of the industry standard MQTT and HTTP protocols for device connectivity Device-Cloud authentication, and application authentication The Cloud Service also enables analytics on the data from connected devices. It uses a simple rules-based composition model and an extensible framework to help organizations access IoT data, combine it with master asset data, analyze events and data in context, and automate responses to help improve operations and service levels ( Service Description ). Here below, the Zerynth Library to manage your devices thanks to IBM Watson IoT: Contents: IBM Cloud Watson IoT Library The Device class Examples Controlled publish period","title":"IBM Cloud Watson IoT Library"},{"location":"reference/libs/ibmcloud/iot/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.ibmcloud.iot. Controlled Publish Period \u00b6 Connect your device to IBM Watson IoT platform and start publishing at a default period, waiting for period updates requested through update period command. main.py # IBM Cloud Watson IoT Controlled publish period # Created at 2017-10-03 08:49:48.182639 import streams import json from wireless import wifi # choose a wifi chip supporting secure sockets from espressif.esp32net import esp32wifi as wifi_driver # import ibmcloud iot module from ibmcloud.iot import iot # import helpers functions to easily load device configuration import helpers # SET DEVICE CONFIGURATION INSIDE THE FOLLOWING JSON FILE new_resource ( 'device.conf.json' ) # define a callback for period updates def period_callback ( cmd ): global publish_period print ( 'requested publish period:' , cmd [ 'publish_period' ]) publish_period = cmd [ 'publish_period' ] streams . serial () wifi_driver . auto_init () print ( 'connecting to wifi...' ) # place here your wifi configuration wifi . link ( \"SSID\" , wifi . WIFI_WPA2 , \"PSW\" ) device_conf = helpers . load_device_conf () publish_period = 3000 # create an ibmcloud iot device instance, connect to mqtt broker, set a command callback and start mqtt reception loop device = iot . Device ( device_conf [ 'device_id' ], device_conf [ 'device_type' ], device_conf [ 'organization' ], device_conf [ 'auth_token' ]) print ( 'connecting to mqtt broker...' ) device . mqtt . connect () device . on_cmd ( 'update_period' , period_callback ) device . mqtt . loop () while True : print ( 'publish random sample...' ) device . publish ( 'env' , { 'temp' : random ( 0 , 10 ) }) sleep ( publish_period )","title":"Examples"},{"location":"reference/libs/ibmcloud/iot/docs/examples/#examples","text":"The following are a list of examples for lib.ibmcloud.iot.","title":"Examples"},{"location":"reference/libs/ibmcloud/iot/docs/examples/#controlled-publish-period","text":"Connect your device to IBM Watson IoT platform and start publishing at a default period, waiting for period updates requested through update period command. main.py # IBM Cloud Watson IoT Controlled publish period # Created at 2017-10-03 08:49:48.182639 import streams import json from wireless import wifi # choose a wifi chip supporting secure sockets from espressif.esp32net import esp32wifi as wifi_driver # import ibmcloud iot module from ibmcloud.iot import iot # import helpers functions to easily load device configuration import helpers # SET DEVICE CONFIGURATION INSIDE THE FOLLOWING JSON FILE new_resource ( 'device.conf.json' ) # define a callback for period updates def period_callback ( cmd ): global publish_period print ( 'requested publish period:' , cmd [ 'publish_period' ]) publish_period = cmd [ 'publish_period' ] streams . serial () wifi_driver . auto_init () print ( 'connecting to wifi...' ) # place here your wifi configuration wifi . link ( \"SSID\" , wifi . WIFI_WPA2 , \"PSW\" ) device_conf = helpers . load_device_conf () publish_period = 3000 # create an ibmcloud iot device instance, connect to mqtt broker, set a command callback and start mqtt reception loop device = iot . Device ( device_conf [ 'device_id' ], device_conf [ 'device_type' ], device_conf [ 'organization' ], device_conf [ 'auth_token' ]) print ( 'connecting to mqtt broker...' ) device . mqtt . connect () device . on_cmd ( 'update_period' , period_callback ) device . mqtt . loop () while True : print ( 'publish random sample...' ) device . publish ( 'env' , { 'temp' : random ( 0 , 10 ) }) sleep ( publish_period )","title":"Controlled Publish Period"},{"location":"reference/libs/ibmcloud/iot/docs/iot/","text":"IBM Cloud Watson IoT Library \u00b6 The Zerynth IBM Cloud Watson IoT Library can be used to ease the connection to the IBM Watson IoT Platform . It allows to make your device act as an IBM Watson IoT Device which can be created through IBM Watson IoT dashboard. The Device class \u00b6 class Device \u00b6 class Device ( device_id , device_type , organization , auth_token ) Create a Device instance representing an IBM Watson IoT Device. The Device object will contain an mqtt client instance pointing to IBM Watson IoT MQTT broker located at organization.messaging.internetofthings.ibmcloud.com . The client is configured with d:organization:device_type:device_id as MQTT id and is able to connect securely through TLS and to authenticate setting auth_token as client password. The client is accessible through mqtt instance attribute and exposes all Zerynth MQTT Client methods so that it is possible, for example, to setup custom callback on MQTT commands (though the Device class already exposes high-level methods to setup IBM Watson IoT specific callbacks). The only difference concerns mqtt.connect method which does not require broker url and ssl context, taking them from Device configuration: my_device = iot . Device ( 'my_device_id' , 'my_device_type' , 'my_organization' , 'auth_token' ) my_device . mqtt . connect () ... my_device . mqtt . loop () Device.publish \u00b6 publish ( event_id , event , format_string = 'json' ) Publish event_id event with event content. event content has to be a dictionary when 'json' is chosen as format_string , a string otherwise. Device.on_cmd \u00b6 on_cmd ( command_id , command_cbk , format_string = 'json' ) Set a callback to respond to command_id command. command_cbk callback will be called passing a dictionary containing command payload when 'json' is chosen as format_string , a string otherwise def turn_led ( cmd_content ): if cmd_content [ 'dir' ] == 'on' : led_on () else : led_off () my_device . on_cmd ( 'turn_led' , turn_led )","title":"IBM Cloud Watson IoT Library"},{"location":"reference/libs/ibmcloud/iot/docs/iot/#ibm-cloud-watson-iot-library","text":"The Zerynth IBM Cloud Watson IoT Library can be used to ease the connection to the IBM Watson IoT Platform . It allows to make your device act as an IBM Watson IoT Device which can be created through IBM Watson IoT dashboard.","title":"IBM Cloud Watson IoT Library"},{"location":"reference/libs/ibmcloud/iot/docs/iot/#the-device-class","text":"","title":"The Device class"},{"location":"reference/libs/ibmcloud/iot/docs/iot/#class-device","text":"class Device ( device_id , device_type , organization , auth_token ) Create a Device instance representing an IBM Watson IoT Device. The Device object will contain an mqtt client instance pointing to IBM Watson IoT MQTT broker located at organization.messaging.internetofthings.ibmcloud.com . The client is configured with d:organization:device_type:device_id as MQTT id and is able to connect securely through TLS and to authenticate setting auth_token as client password. The client is accessible through mqtt instance attribute and exposes all Zerynth MQTT Client methods so that it is possible, for example, to setup custom callback on MQTT commands (though the Device class already exposes high-level methods to setup IBM Watson IoT specific callbacks). The only difference concerns mqtt.connect method which does not require broker url and ssl context, taking them from Device configuration: my_device = iot . Device ( 'my_device_id' , 'my_device_type' , 'my_organization' , 'auth_token' ) my_device . mqtt . connect () ... my_device . mqtt . loop ()","title":"class Device"},{"location":"reference/libs/ibmcloud/iot/docs/iot/#devicepublish","text":"publish ( event_id , event , format_string = 'json' ) Publish event_id event with event content. event content has to be a dictionary when 'json' is chosen as format_string , a string otherwise.","title":"Device.publish"},{"location":"reference/libs/ibmcloud/iot/docs/iot/#deviceon_cmd","text":"on_cmd ( command_id , command_cbk , format_string = 'json' ) Set a callback to respond to command_id command. command_cbk callback will be called passing a dictionary containing command payload when 'json' is chosen as format_string , a string otherwise def turn_led ( cmd_content ): if cmd_content [ 'dir' ] == 'on' : led_on () else : led_off () my_device . on_cmd ( 'turn_led' , turn_led )","title":"Device.on_cmd"},{"location":"reference/libs/idinnovations/id20la/docs/","text":"Index \u00b6 Contents: ID20LA Module Examples rfid reader","title":"Index"},{"location":"reference/libs/idinnovations/id20la/docs/#index","text":"Contents: ID20LA Module Examples rfid reader","title":"Index"},{"location":"reference/libs/idinnovations/id20la/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.idinnovations.id20la. RFID Reader \u00b6 Read continuously from a RFID reader (ID-20LA) and print to serial all the data. main.py # RFID Reader # Init serial communication import streams streams . serial () # Import RFID lib from idinnovations.id20la import id20la # Function to be called everytime is read def cb ( data ): # Convert data (bytearray) to ASCII string # note: the sensor must be put in ASCII mode (see datasheet). id = \"\" . join ([ chr ( c ) for c in data ]) print ( \"Read tag:\" , id ) # Init the reader class, register callback and start reading reader = id20la . ID20LA ( SERIAL2 , cb ) print ( \"Ready to read tags!\" )","title":"Examples"},{"location":"reference/libs/idinnovations/id20la/docs/examples/#examples","text":"The following are a list of examples for lib.idinnovations.id20la.","title":"Examples"},{"location":"reference/libs/idinnovations/id20la/docs/examples/#rfid-reader","text":"Read continuously from a RFID reader (ID-20LA) and print to serial all the data. main.py # RFID Reader # Init serial communication import streams streams . serial () # Import RFID lib from idinnovations.id20la import id20la # Function to be called everytime is read def cb ( data ): # Convert data (bytearray) to ASCII string # note: the sensor must be put in ASCII mode (see datasheet). id = \"\" . join ([ chr ( c ) for c in data ]) print ( \"Read tag:\" , id ) # Init the reader class, register callback and start reading reader = id20la . ID20LA ( SERIAL2 , cb ) print ( \"Ready to read tags!\" )","title":"RFID Reader"},{"location":"reference/libs/idinnovations/id20la/docs/id20la/","text":"ID20LA Module \u00b6 This module contains the Zerynth driver for ID-20LA RFID tag reader from ID Innovation. This is the ID-20LA, a very simple to use RFID reader module from ID Innovations. With a built in antenna, the only holdup is the 2mm pin spacing (breakout board available below). Power the module, hold up a 125kHz card, and get a serial string output containing the unique ID of the card. class ID20LA \u00b6 class ID20LA ( serial_port , callback , read_timeout = 100 ) Creates in instance of the ID20LA class. Aguments: serial_port \u2013 Serial port to be used (RX only). (i.e. SERIAL2) callback \u2013 Callback to be called whenever a tag is read. read_timeout \u2013 Milliseconds to wait when polling sensor. (Default: 100) The serial communication is initialized using the specified serial port. The TX pin is not used since the communication is one-way only. The callback must take exactly one argument, which will be the 10-bytes bytearray read from the tag. It is suggested to put the ID-20LA in ASCII mode to be able to decode the 10 bytes as 10 characters, refer to datasheet for further informations. ID20LA.stop \u00b6 stop () This method stops the reading from the sensor.","title":"ID20LA Module"},{"location":"reference/libs/idinnovations/id20la/docs/id20la/#id20la-module","text":"This module contains the Zerynth driver for ID-20LA RFID tag reader from ID Innovation. This is the ID-20LA, a very simple to use RFID reader module from ID Innovations. With a built in antenna, the only holdup is the 2mm pin spacing (breakout board available below). Power the module, hold up a 125kHz card, and get a serial string output containing the unique ID of the card.","title":"ID20LA Module"},{"location":"reference/libs/idinnovations/id20la/docs/id20la/#class-id20la","text":"class ID20LA ( serial_port , callback , read_timeout = 100 ) Creates in instance of the ID20LA class. Aguments: serial_port \u2013 Serial port to be used (RX only). (i.e. SERIAL2) callback \u2013 Callback to be called whenever a tag is read. read_timeout \u2013 Milliseconds to wait when polling sensor. (Default: 100) The serial communication is initialized using the specified serial port. The TX pin is not used since the communication is one-way only. The callback must take exactly one argument, which will be the 10-bytes bytearray read from the tag. It is suggested to put the ID-20LA in ASCII mode to be able to decode the 10 bytes as 10 characters, refer to datasheet for further informations.","title":"class ID20LA"},{"location":"reference/libs/idinnovations/id20la/docs/id20la/#id20lastop","text":"stop () This method stops the reading from the sensor.","title":"ID20LA.stop"},{"location":"reference/libs/infineon/xmc4eth/docs/","text":"Infineon Ethernet Driver \u00b6 This module implements the Zerynth driver for the Infineon XMC4000 family Ethernet (i.e. XMC4700 Relax Kit). This module supports SSL/TLS. Contents: Infineon XMC4000 Ethernet Module","title":"Infineon Ethernet Driver"},{"location":"reference/libs/infineon/xmc4eth/docs/#infineon-ethernet-driver","text":"This module implements the Zerynth driver for the Infineon XMC4000 family Ethernet (i.e. XMC4700 Relax Kit). This module supports SSL/TLS. Contents: Infineon XMC4000 Ethernet Module","title":"Infineon Ethernet Driver"},{"location":"reference/libs/infineon/xmc4eth/docs/xmc4eth/","text":"Infineon XMC4000 Ethernet Module \u00b6 This module implements the Zerynth driver for the Infineon XMC4000 family Ethernet (i.e. XMC4700 Relax Kit). This module supports SSL/TLS. init \u00b6 init () Initializes the Ethernet chip connected to the device.","title":"Infineon XMC4000 Ethernet Module"},{"location":"reference/libs/infineon/xmc4eth/docs/xmc4eth/#infineon-xmc4000-ethernet-module","text":"This module implements the Zerynth driver for the Infineon XMC4000 family Ethernet (i.e. XMC4700 Relax Kit). This module supports SSL/TLS.","title":"Infineon XMC4000 Ethernet Module"},{"location":"reference/libs/infineon/xmc4eth/docs/xmc4eth/#init","text":"init () Initializes the Ethernet chip connected to the device.","title":"init"},{"location":"reference/libs/liveintersect/iot/docs/","text":"Liveintersect IoT \u00b6 LiveIntersect is an IoT application enablement platform which is designed to help build Connected Products and IoT solutions. The IoT enablement platform provides vital capabilities including: Aggregate data from endpoint assets Store and process device data Hierarchical multi-tenant security model Drag & drop portal development tool Rules and notification engine Integration framework Using the Zerynth Studio, and the LiveIntersect client library you can quickly build IoT solutions that can run on many microcontrollers. The LiveIntersect client library provides functionality to: Register assets (devices) to LiveIntersect Cloud Send sensor data and telemetry data (called metrics) to LiveIntersect Cloud Synchronize attribute configuration data Summary: The Esprida LiveIntersect IoT platform support for Zerynth embedded hardware, helping businesses unlock the full potential of connected solutions, by rapid integration with sensors, actuators and could services. Contents: Liveintersect IoT The Asset class Examples Asset Simulation","title":"Liveintersect IoT"},{"location":"reference/libs/liveintersect/iot/docs/#liveintersect-iot","text":"LiveIntersect is an IoT application enablement platform which is designed to help build Connected Products and IoT solutions. The IoT enablement platform provides vital capabilities including: Aggregate data from endpoint assets Store and process device data Hierarchical multi-tenant security model Drag & drop portal development tool Rules and notification engine Integration framework Using the Zerynth Studio, and the LiveIntersect client library you can quickly build IoT solutions that can run on many microcontrollers. The LiveIntersect client library provides functionality to: Register assets (devices) to LiveIntersect Cloud Send sensor data and telemetry data (called metrics) to LiveIntersect Cloud Synchronize attribute configuration data Summary: The Esprida LiveIntersect IoT platform support for Zerynth embedded hardware, helping businesses unlock the full potential of connected solutions, by rapid integration with sensors, actuators and could services. Contents: Liveintersect IoT The Asset class Examples Asset Simulation","title":"Liveintersect IoT"},{"location":"reference/libs/liveintersect/iot/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.liveintersect.iot. main.py from espressif.esp32net import esp32wifi as wifi_driver from wireless import wifi import streams import helper import ssl from liveintersect.iot import iot new_resource ( 'asset.config.json' ) streams . serial () print ( \"Initializing wifi_driver\" ) wifi_driver . auto_init () print ( \"Establishing wifi_connection\" ) wifi . link ( \"SSID\" , wifi . WIFI_WPA2 , \"PWD\" ) cacert = __lookup ( SSL_CACERT_COMODO_RSA_CERTIFICATION_AUTHORITY ) ctx = ssl . create_ssl_context ( cacert = cacert , options = ssl . CERT_REQUIRED | ssl . SERVER_AUTH ) print ( \"> Connected\" ) try : asset_config = helper . load_asset_conf () my_asset = iot . Asset ( asset_config [ \"baseUrl\" ], asset_config [ \"apiKey\" ], asset_config [ \"srNo\" ], asset_config [ \"assetName\" ], assetTypeCode = asset_config [ \"assetTypeCode\" ], ssl_ctx = ctx ) my_asset . register_asset () print ( helper . get_asset_info ( my_asset )) while ( True ): iot . post_metric ( my_asset , \"T1\" , random ( 0 , 60 )) iot . post_attribute ( my_asset , \"latitude\" , random ( 0 , 60 )) sleep ( 10000 ) except Exception as e : print ( e )","title":"Examples"},{"location":"reference/libs/liveintersect/iot/docs/examples/#examples","text":"The following are a list of examples for lib.liveintersect.iot. main.py from espressif.esp32net import esp32wifi as wifi_driver from wireless import wifi import streams import helper import ssl from liveintersect.iot import iot new_resource ( 'asset.config.json' ) streams . serial () print ( \"Initializing wifi_driver\" ) wifi_driver . auto_init () print ( \"Establishing wifi_connection\" ) wifi . link ( \"SSID\" , wifi . WIFI_WPA2 , \"PWD\" ) cacert = __lookup ( SSL_CACERT_COMODO_RSA_CERTIFICATION_AUTHORITY ) ctx = ssl . create_ssl_context ( cacert = cacert , options = ssl . CERT_REQUIRED | ssl . SERVER_AUTH ) print ( \"> Connected\" ) try : asset_config = helper . load_asset_conf () my_asset = iot . Asset ( asset_config [ \"baseUrl\" ], asset_config [ \"apiKey\" ], asset_config [ \"srNo\" ], asset_config [ \"assetName\" ], assetTypeCode = asset_config [ \"assetTypeCode\" ], ssl_ctx = ctx ) my_asset . register_asset () print ( helper . get_asset_info ( my_asset )) while ( True ): iot . post_metric ( my_asset , \"T1\" , random ( 0 , 60 )) iot . post_attribute ( my_asset , \"latitude\" , random ( 0 , 60 )) sleep ( 10000 ) except Exception as e : print ( e )","title":"Examples"},{"location":"reference/libs/liveintersect/iot/docs/iot/","text":"The Asset class \u00b6 class Asset \u00b6 class Asset ( baseUrl , apiKey , srNo , assetName , assetTypeCode , ssl_ctx ) This class represents asset software which facilitates all communication to the LiveIntersect cloud. LiveIntersect is a IoT enablement platform which collects and manages asset data and enables you to build IoT solutions. baseUrl url to LiveIntersect hosting, If you are using first implementation use Sandbox Environment apiKey A valid API key representing an organization. If a API key has been generated following LiveIntersect srNo A hardware identifier (serial number) which unique within your Organization assetName User friendly name for this Asset (does not need to be unique) assetTypeCode Optional asset-type-code representing asset-type configured in in LiveIntersect environment ssl_ctx initialize SSL context please read Zerynth Documentation my_Asset = li_http.Asset( https://liveintersect.com/ , apiKey, srNo, assetName, assetTypeCode, ssl_ctx) Asset.do_api_get \u00b6 do_api_get ( resourcePath , params = None , headers = None ) Performs GET resource from resourcePath using Asset credentials resourcePath REST resource path within LiveIntersect params Http parameteres (query-string) headers Http headers Asset.do_api_post \u00b6 do_api_post ( resourcePath , jsonObj , headers = None ) Performs POST to resourcePath using Asset credentials resourcePath REST resource path within LiveIntersect jsonObj JSON payload headers Http headers Asset.register_asset \u00b6 register_asset () Use this method to register your device and with the LiveIntersect server. Every asset must be registered before the cloud accepts any communication from the device. This method first checks if asset instance is already registered, if not new registration request will be made. post_metric \u00b6 post_metric ( asset ) Use this method to retrieve information about the current asset. This method will return the asset properties, configuration data (within attribute list), current telemetry data (within cloud) asset LiveIntersect Asset instance returns Api-Response JSON with JSON[\u201cresult\u201d] being asset-information post_metric \u00b6 post_metric ( asset , metric_code , metric_value ) Use this method to send sensor data or telemetry data to the LiveIntersect cloud. asset LiveIntersect Asset instance metric_code unique identifier for the metric associated with the asset type metric_value Raw value of the Metric (may contain unit-symbol i.e. 45C) post_attribute \u00b6 post_attribute ( asset , attr_code , attr_value ) Use this method to configuration data to the LiveIntersect cloud. Note: use get_asset_info to download attribute currently stored in the cloud. asset LiveIntersect Asset instance attr_code unique identifier for the attributes associated with the asset type attr_value Raw value of the attribute (may contain unit-symbol i.e. 45C)","title":"The Asset class"},{"location":"reference/libs/liveintersect/iot/docs/iot/#the-asset-class","text":"","title":"The Asset class"},{"location":"reference/libs/liveintersect/iot/docs/iot/#class-asset","text":"class Asset ( baseUrl , apiKey , srNo , assetName , assetTypeCode , ssl_ctx ) This class represents asset software which facilitates all communication to the LiveIntersect cloud. LiveIntersect is a IoT enablement platform which collects and manages asset data and enables you to build IoT solutions. baseUrl url to LiveIntersect hosting, If you are using first implementation use Sandbox Environment apiKey A valid API key representing an organization. If a API key has been generated following LiveIntersect srNo A hardware identifier (serial number) which unique within your Organization assetName User friendly name for this Asset (does not need to be unique) assetTypeCode Optional asset-type-code representing asset-type configured in in LiveIntersect environment ssl_ctx initialize SSL context please read Zerynth Documentation my_Asset = li_http.Asset( https://liveintersect.com/ , apiKey, srNo, assetName, assetTypeCode, ssl_ctx)","title":"class Asset"},{"location":"reference/libs/liveintersect/iot/docs/iot/#assetdo_api_get","text":"do_api_get ( resourcePath , params = None , headers = None ) Performs GET resource from resourcePath using Asset credentials resourcePath REST resource path within LiveIntersect params Http parameteres (query-string) headers Http headers","title":"Asset.do_api_get"},{"location":"reference/libs/liveintersect/iot/docs/iot/#assetdo_api_post","text":"do_api_post ( resourcePath , jsonObj , headers = None ) Performs POST to resourcePath using Asset credentials resourcePath REST resource path within LiveIntersect jsonObj JSON payload headers Http headers","title":"Asset.do_api_post"},{"location":"reference/libs/liveintersect/iot/docs/iot/#assetregister_asset","text":"register_asset () Use this method to register your device and with the LiveIntersect server. Every asset must be registered before the cloud accepts any communication from the device. This method first checks if asset instance is already registered, if not new registration request will be made.","title":"Asset.register_asset"},{"location":"reference/libs/liveintersect/iot/docs/iot/#post_metric","text":"post_metric ( asset ) Use this method to retrieve information about the current asset. This method will return the asset properties, configuration data (within attribute list), current telemetry data (within cloud) asset LiveIntersect Asset instance returns Api-Response JSON with JSON[\u201cresult\u201d] being asset-information","title":"post_metric"},{"location":"reference/libs/liveintersect/iot/docs/iot/#post_metric_1","text":"post_metric ( asset , metric_code , metric_value ) Use this method to send sensor data or telemetry data to the LiveIntersect cloud. asset LiveIntersect Asset instance metric_code unique identifier for the metric associated with the asset type metric_value Raw value of the Metric (may contain unit-symbol i.e. 45C)","title":"post_metric"},{"location":"reference/libs/liveintersect/iot/docs/iot/#post_attribute","text":"post_attribute ( asset , attr_code , attr_value ) Use this method to configuration data to the LiveIntersect cloud. Note: use get_asset_info to download attribute currently stored in the cloud. asset LiveIntersect Asset instance attr_code unique identifier for the attributes associated with the asset type attr_value Raw value of the attribute (may contain unit-symbol i.e. 45C)","title":"post_attribute"},{"location":"reference/libs/maxim/ds1307/docs/","text":"Maxim DS1307 \u00b6 The DS1307 real-time clock (RTC) is a low-power, full binary-coded decimal (BCD) clock/calendar controllable via I2C protocol. The clock/calendar provides seconds, minutes, hours, day, date, month, and year information. The end of the month date is automatically adjusted for months with fewer than 31 days, including corrections for leap year. The clock operates in either the 24-hour or 12-hour format with AM/PM indicator. The DS1307 has a built-in power-sense circuit that detects power failures and automatically switches to the backup supply. Timekeeping operation continues while the part operates from the backup supply; more information at Maxim dedicated page Technical Details \u00b6 Supply Voltage (Vcc): from 4.5 V to 5.5 V Operation Temperature (Top): from 0 \u00b0C to 70 \u00b0C SCL Clock Frequency (Fscl): from 0 Hz to 100 kHz Active Supply Current (Icca): 1.5 mA (Fosc = 100 kHz) Here below, the Zerynth driver for the Maxim DS1307. Contents: DS1307 Module DS1307 class","title":"Maxim DS1307"},{"location":"reference/libs/maxim/ds1307/docs/#maxim-ds1307","text":"The DS1307 real-time clock (RTC) is a low-power, full binary-coded decimal (BCD) clock/calendar controllable via I2C protocol. The clock/calendar provides seconds, minutes, hours, day, date, month, and year information. The end of the month date is automatically adjusted for months with fewer than 31 days, including corrections for leap year. The clock operates in either the 24-hour or 12-hour format with AM/PM indicator. The DS1307 has a built-in power-sense circuit that detects power failures and automatically switches to the backup supply. Timekeeping operation continues while the part operates from the backup supply; more information at Maxim dedicated page","title":"Maxim DS1307"},{"location":"reference/libs/maxim/ds1307/docs/#technical-details","text":"Supply Voltage (Vcc): from 4.5 V to 5.5 V Operation Temperature (Top): from 0 \u00b0C to 70 \u00b0C SCL Clock Frequency (Fscl): from 0 Hz to 100 kHz Active Supply Current (Icca): 1.5 mA (Fosc = 100 kHz) Here below, the Zerynth driver for the Maxim DS1307. Contents: DS1307 Module DS1307 class","title":"Technical Details"},{"location":"reference/libs/maxim/ds1307/docs/ds1307/","text":"DS1307 Module \u00b6 This module implements the Zerynth driver for the Maxim DS1307 RTC ( datasheet ). Using the module is simple: from maxim.ds1307 import ds1307 import streams streams . serial () ds = ds1307 . DS1307 ( I2C0 ) ds . start () while True : print ( \" %02d : %02d : %02d - %02d / %02d / %d - %d \" % ds . get_time ()) sleep ( 1000 ) DS1307 class \u00b6 class DS1307 \u00b6 class DS1307 ( drvname ) Creates a DS1307 instance using the MCU I2C circuitry drvname (one of I2C0, I2C1, \u2026 check pinmap for details). The created instance is configured and ready to communicate. DS1307 inherits from i2c.I2C, therefore the method start() must be called to setup the I2C channel before the RTC can be used. DS1307.get_time \u00b6 get_time () Returns a tuple (hours,minutes,seconds,day,month,year,day_of_week) with the current time and date readings. Current time is always expressed in the 24 hours format. The time and date readings conversion algorithm assumes that the DS1307 has been previously configured with a call to set_time(). DS1307.set_time \u00b6 set_time ( hours , minutes , seconds , day , month , year , day_of_week ) Configures the DS1307 with time hours:minutes:seconds expressed in 24 hours format. The value of year must be greater or equal than 2000 and day_of_week must be in range 1 to 7 included.","title":"DS1307 Module"},{"location":"reference/libs/maxim/ds1307/docs/ds1307/#ds1307-module","text":"This module implements the Zerynth driver for the Maxim DS1307 RTC ( datasheet ). Using the module is simple: from maxim.ds1307 import ds1307 import streams streams . serial () ds = ds1307 . DS1307 ( I2C0 ) ds . start () while True : print ( \" %02d : %02d : %02d - %02d / %02d / %d - %d \" % ds . get_time ()) sleep ( 1000 )","title":"DS1307 Module"},{"location":"reference/libs/maxim/ds1307/docs/ds1307/#ds1307-class","text":"","title":"DS1307 class"},{"location":"reference/libs/maxim/ds1307/docs/ds1307/#class-ds1307","text":"class DS1307 ( drvname ) Creates a DS1307 instance using the MCU I2C circuitry drvname (one of I2C0, I2C1, \u2026 check pinmap for details). The created instance is configured and ready to communicate. DS1307 inherits from i2c.I2C, therefore the method start() must be called to setup the I2C channel before the RTC can be used.","title":"class DS1307"},{"location":"reference/libs/maxim/ds1307/docs/ds1307/#ds1307get_time","text":"get_time () Returns a tuple (hours,minutes,seconds,day,month,year,day_of_week) with the current time and date readings. Current time is always expressed in the 24 hours format. The time and date readings conversion algorithm assumes that the DS1307 has been previously configured with a call to set_time().","title":"DS1307.get_time"},{"location":"reference/libs/maxim/ds1307/docs/ds1307/#ds1307set_time","text":"set_time ( hours , minutes , seconds , day , month , year , day_of_week ) Configures the DS1307 with time hours:minutes:seconds expressed in 24 hours format. The value of year must be greater or equal than 2000 and day_of_week must be in range 1 to 7 included.","title":"DS1307.set_time"},{"location":"reference/libs/maxim/ds1820/docs/","text":"Maxim DS1820 \u00b6 The DS18S20 digital thermometer provides 9-bit Celsius temperature measurements and has an alarm function with nonvolatile user-programmable upper and lower trigger points. The DS18S20 communicates over a 1-Wire bus that by definition requires only one data line (and ground) for communication with a central microprocessor. In addition, the DS18S20 can derive power directly from the data line (\u201cparasite power\u201d), eliminating the need for an external power supply. Each DS18S20 has a unique 64-bit serial code, which allows multiple DS18S20s to function on the same 1-Wire bus. Thus, it is simple to use one microprocessor to control many DS18S20s distributed over a large area. Applications that can benefit from this feature include HVAC environmental controls, temperature monitoring systems inside buildings, equipment, or machinery; more information at Maxim dedicated page . Technical Details \u00b6 Supply Voltage (Vdd): from 3.0 V to 5.5 V Operation Temperature (Top): from -55 \u00b0C to 125 \u00b0C Active Current (Idd): from 1.0 mA to 1.5 mA Temperature Conversion Time: 750 ms Here below, the Zerynth driver for the Maxim DS1820. Contents: DS1820 Module","title":"Maxim DS1820"},{"location":"reference/libs/maxim/ds1820/docs/#maxim-ds1820","text":"The DS18S20 digital thermometer provides 9-bit Celsius temperature measurements and has an alarm function with nonvolatile user-programmable upper and lower trigger points. The DS18S20 communicates over a 1-Wire bus that by definition requires only one data line (and ground) for communication with a central microprocessor. In addition, the DS18S20 can derive power directly from the data line (\u201cparasite power\u201d), eliminating the need for an external power supply. Each DS18S20 has a unique 64-bit serial code, which allows multiple DS18S20s to function on the same 1-Wire bus. Thus, it is simple to use one microprocessor to control many DS18S20s distributed over a large area. Applications that can benefit from this feature include HVAC environmental controls, temperature monitoring systems inside buildings, equipment, or machinery; more information at Maxim dedicated page .","title":"Maxim DS1820"},{"location":"reference/libs/maxim/ds1820/docs/#technical-details","text":"Supply Voltage (Vdd): from 3.0 V to 5.5 V Operation Temperature (Top): from -55 \u00b0C to 125 \u00b0C Active Current (Idd): from 1.0 mA to 1.5 mA Temperature Conversion Time: 750 ms Here below, the Zerynth driver for the Maxim DS1820. Contents: DS1820 Module","title":"Technical Details"},{"location":"reference/libs/maxim/ds1820/docs/ds1820/","text":"DS1820 Module \u00b6 This module implements the class DS1820 to read OneWire temperature sensors DS18b20 and DS18s20 connected to a DS2482 I2C-OneWire bridge ( datasheet ). class DS1820 \u00b6 class DS1820 ( serial , ow ) Creates a DS1820 instance using the OneWire bridge ow with OneWire serial id serial . DS1820.read \u00b6 read () Returns the temperature readings as float applying the correct conversion for different DS1820 models. If the serial is wrong, raises UnsupportedError .","title":"DS1820 Module"},{"location":"reference/libs/maxim/ds1820/docs/ds1820/#ds1820-module","text":"This module implements the class DS1820 to read OneWire temperature sensors DS18b20 and DS18s20 connected to a DS2482 I2C-OneWire bridge ( datasheet ).","title":"DS1820 Module"},{"location":"reference/libs/maxim/ds1820/docs/ds1820/#class-ds1820","text":"class DS1820 ( serial , ow ) Creates a DS1820 instance using the OneWire bridge ow with OneWire serial id serial .","title":"class DS1820"},{"location":"reference/libs/maxim/ds1820/docs/ds1820/#ds1820read","text":"read () Returns the temperature readings as float applying the correct conversion for different DS1820 models. If the serial is wrong, raises UnsupportedError .","title":"DS1820.read"},{"location":"reference/libs/maxim/ds2482/docs/","text":"Maxim DS2482 \u00b6 The DS2482 is an I2C-to-1-Wire bridge device that interfaces directly to standard (100kHz max) or fast (400kHz max) I2C masters to perform bi-directional protocol conversion between the I2C master and any downstream 1-Wire slave devices. Internal, factory-trimmed timers relieve the system host processor from generating time-critical 1-Wire waveforms, supporting both standard and overdrive 1-Wire communication speeds. To optimize 1-Wire waveform generation, the DS2482 performs slew-rate control on rising and falling 1-Wire edges and provides additional programmable features to match drive characteristics that slave devices can generate. Programmable, strong pullup features support 1-Wire power delivery to 1-Wire devices such as EEPROMs and sensors. The DS2482 combines these features with one (models 100 and 101) or eight (model 800) independent 1-Wire I/O channels. The I2C slave address assignment is controlled by one (model 100), two (model 101), or three (model 800) binary address inputs, resolving potential conflicts with other I2C slave devices in the system. When not in use, the device can be put in sleep mode where power consumption is minimal; more information at Maxim dedicated pages related to model DS2482-100 , DS2482-101 , and DS2482-800 . Technical Details \u00b6 Supply Voltage (Vcc): from 2.9 V to 5.5 V Operation Temperature (Top): from -40 \u00b0C to 85 \u00b0C SCL Clock Frequency (Fscl): from 0 Hz to 400 kHz Operating Current (Icc): 0.75 mA Read Sample Time: 14 us (stardard mode), 1.5 us (overdrive mode) Here below, the Zerynth driver for the Maxim DS2482. Contents: DS2482 Module - One Wire OneWireSensor class","title":"Maxim DS2482"},{"location":"reference/libs/maxim/ds2482/docs/#maxim-ds2482","text":"The DS2482 is an I2C-to-1-Wire bridge device that interfaces directly to standard (100kHz max) or fast (400kHz max) I2C masters to perform bi-directional protocol conversion between the I2C master and any downstream 1-Wire slave devices. Internal, factory-trimmed timers relieve the system host processor from generating time-critical 1-Wire waveforms, supporting both standard and overdrive 1-Wire communication speeds. To optimize 1-Wire waveform generation, the DS2482 performs slew-rate control on rising and falling 1-Wire edges and provides additional programmable features to match drive characteristics that slave devices can generate. Programmable, strong pullup features support 1-Wire power delivery to 1-Wire devices such as EEPROMs and sensors. The DS2482 combines these features with one (models 100 and 101) or eight (model 800) independent 1-Wire I/O channels. The I2C slave address assignment is controlled by one (model 100), two (model 101), or three (model 800) binary address inputs, resolving potential conflicts with other I2C slave devices in the system. When not in use, the device can be put in sleep mode where power consumption is minimal; more information at Maxim dedicated pages related to model DS2482-100 , DS2482-101 , and DS2482-800 .","title":"Maxim DS2482"},{"location":"reference/libs/maxim/ds2482/docs/#technical-details","text":"Supply Voltage (Vcc): from 2.9 V to 5.5 V Operation Temperature (Top): from -40 \u00b0C to 85 \u00b0C SCL Clock Frequency (Fscl): from 0 Hz to 400 kHz Operating Current (Icc): 0.75 mA Read Sample Time: 14 us (stardard mode), 1.5 us (overdrive mode) Here below, the Zerynth driver for the Maxim DS2482. Contents: DS2482 Module - One Wire OneWireSensor class","title":"Technical Details"},{"location":"reference/libs/maxim/ds2482/docs/ds2482/","text":"DS2482 Module - One Wire \u00b6 This module implements the DS2482 functionalities for all models (100,101 and 800). It also implements a generic OneWire sensor class to be used by libraries dependent on DS2482 (datasheet for DS2482-100 , DS2482-101 , and DS2482-800 ). Here an example of use: # The following example interfaces with a DS2482 to read # DS1820 sensors values (temperature) present on the bus from maxim.ds2482 import ds2482 from maxim.ds1820 import ds1820 #this module must be installed separately! import streams streams . serial () print ( \"Init onewire\" ) ow = ds2482 . DS2482 ( I2C0 ) ow . start () # scan all the channels (for DS2482 model 800) for ch in range ( 8 ): try : print ( \"Scanning channel\" , ch ) # set active channel ow . set_channel ( ch ) # search all onewire peripherals on the channel res = ow . search_raw () for i , k in enumerate ( res ): # print the id of the sensor print ( i , \"-->\" , ds2482 . b2s ( k )) # create a sensor instance, derived from OneWireSensor class ss = ds1820 . DS1820 ( k , ow ) # read the sensor tt = ss . read () print ( i , \"==>\" , tt ) except Exception as e : print ( e ) class DS2482 \u00b6 class DS2482 ( drvname , clock = 100000 , addr = 0x18 ) Creates a DS2482 instance using the MCU I2C circuitry drvname (one of I2C0, I2C1, \u2026 check pinmap for details). The created instance is configured and ready to communicate. clock is configured by default in slow mode. DS2482 inherits from i2c.I2C, therefore the method start() must be called to setup the I2C channel before using the OneWire bus. DS2482.search_raw \u00b6 search_raw () Scans the OneWire bus and collect the 64-bit serial numbers of connected peripherals. Returns a set containing the serial numbers as byte sequences (bytes type) DS2482.search \u00b6 search ( sc ) Returns a list of items created by calling sc(serial) for each discovered serial number on the OneWire bus. Common usage is the following code that creates a list of OneWireSensor() instances: from dallas.onewire import sensors res = ow . search ( sensors . OneWireSensor ) # ow is a started instance of DS2482 class DS2482._init \u00b6 _init ( drvname , addr , channel ) Initializes the DS2482 I2C bridge connected to drvname I2C peripheral (I2C0, I2C1, etc..) with address addr on channel channel. Raises exceptions if DS2482 can\u2019t be initialized. DS2482.search_raw \u00b6 search_raw () Scans the OneWire bus and collect the 64-bit serial numbers of connected peripherals. Returns a set containing the serial numbers as byte sequences (bytes type). DS2482.b2s \u00b6 b2s ( serial ) Converts serial given as a byte sequence into the string format. In the string format each byte of serial is converted to hexadecimal and separated by \u201c:\u201d DS2482.s2b \u00b6 s2b ( serial ) Converts serial given in the string format to a byte sequence. OneWireSensor class \u00b6 class OneWireSensor \u00b6 class OneWireSensor ( serial , owbus ) Creates a OneWireSensor instance with serial set to serial . serial can be a string in the appropriate format or a byte sequence (both bytes or bytearray). The first byte of the serial identifies the sensor family. If the family is not supported UnsupportedError is raised. The following members are available: serial: serial number as a byte sequence typeid: the family number of the peripheral If a OneWireSensor instance is converted to string, the result is the serial number in the string format. OneWireSensor.read \u00b6 read () Returns a single reading from the sensor. The result value depends on the sensor family. PeripheralError is raised if there is a problem in the OneWire bus. InvalidHardwareStatusError is raised if a peripheral on the OneWire bus does not respond (e.g. it is disconnected).","title":"DS2482 Module - One Wire"},{"location":"reference/libs/maxim/ds2482/docs/ds2482/#ds2482-module-one-wire","text":"This module implements the DS2482 functionalities for all models (100,101 and 800). It also implements a generic OneWire sensor class to be used by libraries dependent on DS2482 (datasheet for DS2482-100 , DS2482-101 , and DS2482-800 ). Here an example of use: # The following example interfaces with a DS2482 to read # DS1820 sensors values (temperature) present on the bus from maxim.ds2482 import ds2482 from maxim.ds1820 import ds1820 #this module must be installed separately! import streams streams . serial () print ( \"Init onewire\" ) ow = ds2482 . DS2482 ( I2C0 ) ow . start () # scan all the channels (for DS2482 model 800) for ch in range ( 8 ): try : print ( \"Scanning channel\" , ch ) # set active channel ow . set_channel ( ch ) # search all onewire peripherals on the channel res = ow . search_raw () for i , k in enumerate ( res ): # print the id of the sensor print ( i , \"-->\" , ds2482 . b2s ( k )) # create a sensor instance, derived from OneWireSensor class ss = ds1820 . DS1820 ( k , ow ) # read the sensor tt = ss . read () print ( i , \"==>\" , tt ) except Exception as e : print ( e )","title":"DS2482 Module - One Wire"},{"location":"reference/libs/maxim/ds2482/docs/ds2482/#class-ds2482","text":"class DS2482 ( drvname , clock = 100000 , addr = 0x18 ) Creates a DS2482 instance using the MCU I2C circuitry drvname (one of I2C0, I2C1, \u2026 check pinmap for details). The created instance is configured and ready to communicate. clock is configured by default in slow mode. DS2482 inherits from i2c.I2C, therefore the method start() must be called to setup the I2C channel before using the OneWire bus.","title":"class DS2482"},{"location":"reference/libs/maxim/ds2482/docs/ds2482/#ds2482search_raw","text":"search_raw () Scans the OneWire bus and collect the 64-bit serial numbers of connected peripherals. Returns a set containing the serial numbers as byte sequences (bytes type)","title":"DS2482.search_raw"},{"location":"reference/libs/maxim/ds2482/docs/ds2482/#ds2482search","text":"search ( sc ) Returns a list of items created by calling sc(serial) for each discovered serial number on the OneWire bus. Common usage is the following code that creates a list of OneWireSensor() instances: from dallas.onewire import sensors res = ow . search ( sensors . OneWireSensor ) # ow is a started instance of DS2482 class","title":"DS2482.search"},{"location":"reference/libs/maxim/ds2482/docs/ds2482/#ds2482_init","text":"_init ( drvname , addr , channel ) Initializes the DS2482 I2C bridge connected to drvname I2C peripheral (I2C0, I2C1, etc..) with address addr on channel channel. Raises exceptions if DS2482 can\u2019t be initialized.","title":"DS2482._init"},{"location":"reference/libs/maxim/ds2482/docs/ds2482/#ds2482search_raw_1","text":"search_raw () Scans the OneWire bus and collect the 64-bit serial numbers of connected peripherals. Returns a set containing the serial numbers as byte sequences (bytes type).","title":"DS2482.search_raw"},{"location":"reference/libs/maxim/ds2482/docs/ds2482/#ds2482b2s","text":"b2s ( serial ) Converts serial given as a byte sequence into the string format. In the string format each byte of serial is converted to hexadecimal and separated by \u201c:\u201d","title":"DS2482.b2s"},{"location":"reference/libs/maxim/ds2482/docs/ds2482/#ds2482s2b","text":"s2b ( serial ) Converts serial given in the string format to a byte sequence.","title":"DS2482.s2b"},{"location":"reference/libs/maxim/ds2482/docs/ds2482/#onewiresensor-class","text":"","title":"OneWireSensor class"},{"location":"reference/libs/maxim/ds2482/docs/ds2482/#class-onewiresensor","text":"class OneWireSensor ( serial , owbus ) Creates a OneWireSensor instance with serial set to serial . serial can be a string in the appropriate format or a byte sequence (both bytes or bytearray). The first byte of the serial identifies the sensor family. If the family is not supported UnsupportedError is raised. The following members are available: serial: serial number as a byte sequence typeid: the family number of the peripheral If a OneWireSensor instance is converted to string, the result is the serial number in the string format.","title":"class OneWireSensor"},{"location":"reference/libs/maxim/ds2482/docs/ds2482/#onewiresensorread","text":"read () Returns a single reading from the sensor. The result value depends on the sensor family. PeripheralError is raised if there is a problem in the OneWire bus. InvalidHardwareStatusError is raised if a peripheral on the OneWire bus does not respond (e.g. it is disconnected).","title":"OneWireSensor.read"},{"location":"reference/libs/maxim/max11644/docs/","text":"MAXIM MAX11644/11645 \u00b6 The MAX11644/MAX11645 devices are low-power 12-bit Analog-to-Digital Converters (ADC) with I2C serial interface. These devices operate from a single supply of 2.7V to 3.6V (MAX11645) or 4.5V to 5.5V (MAX11644) and require 6uA at 1ksps sample rate. Both MAX11644 and MAX11645 provides two single-ended inputs or one differential input. More information at Maxim dedicated pages MAX11644 , MAX11645 . Technical Details \u00b6 12-bit resolution 2 single-ended inputs or 1 differential input Internal voltage reference Software-configurable Unipolar/Bipolar Low-Power Temperature range: -40\u00b0C to +85\u00b0C Here below, the Zerynth driver for the Maxim MAX11644/11645. Contents: MAX11644/11645 Module MAX11644 class","title":"MAXIM MAX11644/11645"},{"location":"reference/libs/maxim/max11644/docs/#maxim-max1164411645","text":"The MAX11644/MAX11645 devices are low-power 12-bit Analog-to-Digital Converters (ADC) with I2C serial interface. These devices operate from a single supply of 2.7V to 3.6V (MAX11645) or 4.5V to 5.5V (MAX11644) and require 6uA at 1ksps sample rate. Both MAX11644 and MAX11645 provides two single-ended inputs or one differential input. More information at Maxim dedicated pages MAX11644 , MAX11645 .","title":"MAXIM MAX11644/11645"},{"location":"reference/libs/maxim/max11644/docs/#technical-details","text":"12-bit resolution 2 single-ended inputs or 1 differential input Internal voltage reference Software-configurable Unipolar/Bipolar Low-Power Temperature range: -40\u00b0C to +85\u00b0C Here below, the Zerynth driver for the Maxim MAX11644/11645. Contents: MAX11644/11645 Module MAX11644 class","title":"Technical Details"},{"location":"reference/libs/maxim/max11644/docs/max11644/","text":"MAX11644/11645 Module \u00b6 This module contains the Zerynth driver for Maxim MAX1164X low-power Analog-to-Digital Converters with I2C interface ( datasheet ). Example: from maxim.max11644 import max11644 ... my_adc = max11644 . MAX11644 ( I2C1 ) # set the internal reference ON and use it as reference voltage my_adc . setup ( ref = 5 ) # configure the adc to read Ain1 - Ain0 differential input my_adc . config ( 3 , 1 , 0 ) # get the raw converted value from the adc value = my_adc . get_raw_data () MAX11644 class \u00b6 class MAX11644 \u00b6 class MAX11644 ( i2cdrv , clk = 100000 ) Creates an instance of the MAX11644 class. This class allows the control of both MAX11644 and MAX11645 devices. The I2C slave address of these devices is factory programmed to 0x36. Arguments: i2cdrv \u2013 I2C Bus used \u2018(I2C0, \u2026)\u2019 clk \u2013 Clock speed. Allowed values are 100000, 400000, 1000000 MAX11644.setup \u00b6 setup ( ref = 0 , clk = 0 , mode = 0 , rst = 1 ) Writes the device\u2019s setup register. Parameters: - ref : select the reference voltage. \u00b6 ref Reference Voltage REF pin Internal reference state 0-1 Vdd Not connected Always on 2-3 External Reference input Always on 4 Internal Not connected Always on 5 Internal Not connected Always on 6 Internal Reference output Always off 7 Internal Reference output Always on clk : set the clock source: 0 : internal clock 1 : external clock mode : select the operating mode: 0 : unipolar, differential input from 0 to Vref, digital output code is binary 1 : bipolar, differential input from -Vref/2 to Vref/2, digital output is two\u2019s complement rst : reset the configuration register to default: 0 : reset the configuration 1 : no action MAX11644.config \u00b6 config ( scan = 0 , ch = 0 , in_mode = 0 ) Writes the device\u2019s configuration register. Parameters: scan : select the scanning configuration. scan Scanning configuration 0 Scans up from Ain0 to the input selected by ch 1 Converts the input selected by ch 8 times 2 do not use 3 Converts the input selected by ch ch : select input channels to be used for conversion. .tg {border-collapse:collapse;border-spacing:0;} .tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px; overflow:hidden;padding:10px 5px;word-break:normal;} .tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px; font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;} .tg .tg-htbt{background-color:#FFF;border-color:inherit;color:#404040;text-align:left;vertical-align:middle} .tg .tg-5ncm{background-color:#F3F6F6;border-color:inherit;color:#404040;text-align:left;vertical-align:middle} ch Single-ended mode Differential mode positive channel negative channel positive channel negative channel 0 Ain0 GND Ain0 Ain1 1 Ain1 GND Ain1 Ain0 in_mode : select the input mode: 0 : differential mode, digital output depends on mode (see setup() ). 1 : single-ended mode, digital output is binary MAX11644.get_raw_data \u00b6 get_raw_data ( n = 1 ) Return a list containing the conversion results. If n is 1 , return a single value. If the current operating mode is bipolar and the input mode is differential, the values are returned as signed integers, otherwise as unsigned integers.","title":"MAX11644/11645 Module"},{"location":"reference/libs/maxim/max11644/docs/max11644/#max1164411645-module","text":"This module contains the Zerynth driver for Maxim MAX1164X low-power Analog-to-Digital Converters with I2C interface ( datasheet ). Example: from maxim.max11644 import max11644 ... my_adc = max11644 . MAX11644 ( I2C1 ) # set the internal reference ON and use it as reference voltage my_adc . setup ( ref = 5 ) # configure the adc to read Ain1 - Ain0 differential input my_adc . config ( 3 , 1 , 0 ) # get the raw converted value from the adc value = my_adc . get_raw_data ()","title":"MAX11644/11645 Module"},{"location":"reference/libs/maxim/max11644/docs/max11644/#max11644-class","text":"","title":"MAX11644 class"},{"location":"reference/libs/maxim/max11644/docs/max11644/#class-max11644","text":"class MAX11644 ( i2cdrv , clk = 100000 ) Creates an instance of the MAX11644 class. This class allows the control of both MAX11644 and MAX11645 devices. The I2C slave address of these devices is factory programmed to 0x36. Arguments: i2cdrv \u2013 I2C Bus used \u2018(I2C0, \u2026)\u2019 clk \u2013 Clock speed. Allowed values are 100000, 400000, 1000000","title":"class MAX11644"},{"location":"reference/libs/maxim/max11644/docs/max11644/#max11644setup","text":"setup ( ref = 0 , clk = 0 , mode = 0 , rst = 1 ) Writes the device\u2019s setup register. Parameters:","title":"MAX11644.setup"},{"location":"reference/libs/maxim/max11644/docs/max11644/#-ref-select-the-reference-voltage","text":"ref Reference Voltage REF pin Internal reference state 0-1 Vdd Not connected Always on 2-3 External Reference input Always on 4 Internal Not connected Always on 5 Internal Not connected Always on 6 Internal Reference output Always off 7 Internal Reference output Always on clk : set the clock source: 0 : internal clock 1 : external clock mode : select the operating mode: 0 : unipolar, differential input from 0 to Vref, digital output code is binary 1 : bipolar, differential input from -Vref/2 to Vref/2, digital output is two\u2019s complement rst : reset the configuration register to default: 0 : reset the configuration 1 : no action","title":"-   ref : select the reference voltage."},{"location":"reference/libs/maxim/max11644/docs/max11644/#max11644config","text":"config ( scan = 0 , ch = 0 , in_mode = 0 ) Writes the device\u2019s configuration register. Parameters: scan : select the scanning configuration. scan Scanning configuration 0 Scans up from Ain0 to the input selected by ch 1 Converts the input selected by ch 8 times 2 do not use 3 Converts the input selected by ch ch : select input channels to be used for conversion. .tg {border-collapse:collapse;border-spacing:0;} .tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px; overflow:hidden;padding:10px 5px;word-break:normal;} .tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px; font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;} .tg .tg-htbt{background-color:#FFF;border-color:inherit;color:#404040;text-align:left;vertical-align:middle} .tg .tg-5ncm{background-color:#F3F6F6;border-color:inherit;color:#404040;text-align:left;vertical-align:middle} ch Single-ended mode Differential mode positive channel negative channel positive channel negative channel 0 Ain0 GND Ain0 Ain1 1 Ain1 GND Ain1 Ain0 in_mode : select the input mode: 0 : differential mode, digital output depends on mode (see setup() ). 1 : single-ended mode, digital output is binary","title":"MAX11644.config"},{"location":"reference/libs/maxim/max11644/docs/max11644/#max11644get_raw_data","text":"get_raw_data ( n = 1 ) Return a list containing the conversion results. If n is 1 , return a single value. If the current operating mode is bipolar and the input mode is differential, the values are returned as signed integers, otherwise as unsigned integers.","title":"MAX11644.get_raw_data"},{"location":"reference/libs/maxim/max30101/docs/","text":"MAXIM MAX30101 \u00b6 The MAX30101 is an integrated pulse oximetry and heart-rate monitor module by MAXIM. It includes internal LEDs, photodetectors, optical elements, and low-noise electronics with ambient light rejection providing a complete system solution to ease the design-in process for mobile and wearable devices. Communication is through a standard I\u00b2C-comptible interface. More information at MAXIM dedicated page . Technical Details \u00b6 Supply Voltage (Vdd): from 1.7 V to 2.0 V Operating Temperature Range: from -40 \u00b0C to 85 \u00b0C Current Consumption: 1100 uA max Power Dissipation: 440 mW max I\u00b2C interface Here below, the Zerynth driver for the MAXIM MAX30101. Contents: MAX30101 Module MAX30101 Class FIFO configuration Interrupt configuration Mode configuration Temperature Data Part ID Examples heart beat","title":"MAXIM MAX30101"},{"location":"reference/libs/maxim/max30101/docs/#maxim-max30101","text":"The MAX30101 is an integrated pulse oximetry and heart-rate monitor module by MAXIM. It includes internal LEDs, photodetectors, optical elements, and low-noise electronics with ambient light rejection providing a complete system solution to ease the design-in process for mobile and wearable devices. Communication is through a standard I\u00b2C-comptible interface. More information at MAXIM dedicated page .","title":"MAXIM MAX30101"},{"location":"reference/libs/maxim/max30101/docs/#technical-details","text":"Supply Voltage (Vdd): from 1.7 V to 2.0 V Operating Temperature Range: from -40 \u00b0C to 85 \u00b0C Current Consumption: 1100 uA max Power Dissipation: 440 mW max I\u00b2C interface Here below, the Zerynth driver for the MAXIM MAX30101. Contents: MAX30101 Module MAX30101 Class FIFO configuration Interrupt configuration Mode configuration Temperature Data Part ID Examples heart beat","title":"Technical Details"},{"location":"reference/libs/maxim/max30101/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.maxim.max30101. Detect Heart Rate with MAX30101 \u00b6 Read raw data from the MAX30101 sensor and implement an algorithm to detect heart rate. main.py ################################################################################ # Heart Rate Example # # Created: 2017-03-31 10:22:42.543966 # ################################################################################ import streams from maxim.max30101 import max30101 streams . serial () def check_for_beat ( obj , smp ): beat_detected = False obj . _smp_buff [ obj . _cnt ] = smp - obj . _prev obj . _prev = smp obj . _cnt += 1 if obj . _cnt == 8 : obj . _cnt = 0 smp_min = min ( obj . _smp_buff ) if obj . _smp_buff [( obj . _cnt - 4 ) & 0x7 ] == smp_min and obj . _smp_buff [( obj . _cnt - 5 ) & 0x7 ] != 0 and smp_min <= obj . _thr : if smp_min >= - 2000 and smp_min <= - 20 : obj . _thr = ( obj . _thr + obj . _smp_buff [( obj . _cnt - 4 ) & 0x7 ] *. 6 ) / 2 beat_detected = True obj . _smp_buff = [ 0 ] * 8 return beat_detected def detect_pulse ( obj ): cnt = 0 idx = 0 hr_avg = 0 HR_AVG_SIZE = 10 rate = [ 0 ] * HR_AVG_SIZE while True : try : val = obj . read_raw_samples ( 6 ) hr = ( val [ 3 ] << 16 | val [ 4 ] << 8 | val [ 5 ]) cnt += 1 res = check_for_beat ( obj , hr ) if res : dt = cnt * obj . _dt cnt = 0 bpm = 60000 / dt if bpm < 255 and bpm > 20 : rate [ idx ] = bpm idx += 1 if idx == HR_AVG_SIZE : idx = 0 hr_avg = 0 for rr in rate : hr_avg += rr obj . hr_avg = hr_avg / HR_AVG_SIZE if cnt >= 3000 / obj . _dt : cnt = 0 obj . _thr = - 20 rate = [ 0 ] * HR_AVG_SIZE obj . hr_avg = 0 obj . clear_fifo () sleep ( obj . _dt ) except Exception as e : print ( \"ErrorT\" , e ) sleep ( 1000 ) # create an instance of the MAX30101 class try : # Setup sensor # This setup is referred to max30101 mounted on hexiwear device # Power up and init sequence for max30101 inside hexiwear device pinPowerOn = D70 digitalWrite ( pinPowerOn , HIGH ) pinMode ( pinPowerOn , OUTPUT ) # init sensor max = max30101 . MAX30101 ( I2C0 ) print ( \"start...\" ) max . start () max . _thr = - 20 max . _dt = 50 max . _prev = 0 max . _smp_buff = [ 0 ] * 8 max . _cnt = 0 max . hr_avg = 0 print ( \"init...\" ) max . init () # start a thread that reads and process raw data from the sensor thread ( detect_pulse , max ) print ( \"Ready!\" ) print ( \"---------------------------\" ) except Exception as e : print ( e ) while True : print ( \"Heart Rate:\" , int ( max . hr_avg )) print ( \"---------------------------\" ) sleep ( 3000 )","title":"Examples"},{"location":"reference/libs/maxim/max30101/docs/examples/#examples","text":"The following are a list of examples for lib.maxim.max30101.","title":"Examples"},{"location":"reference/libs/maxim/max30101/docs/examples/#detect-heart-rate-with-max30101","text":"Read raw data from the MAX30101 sensor and implement an algorithm to detect heart rate. main.py ################################################################################ # Heart Rate Example # # Created: 2017-03-31 10:22:42.543966 # ################################################################################ import streams from maxim.max30101 import max30101 streams . serial () def check_for_beat ( obj , smp ): beat_detected = False obj . _smp_buff [ obj . _cnt ] = smp - obj . _prev obj . _prev = smp obj . _cnt += 1 if obj . _cnt == 8 : obj . _cnt = 0 smp_min = min ( obj . _smp_buff ) if obj . _smp_buff [( obj . _cnt - 4 ) & 0x7 ] == smp_min and obj . _smp_buff [( obj . _cnt - 5 ) & 0x7 ] != 0 and smp_min <= obj . _thr : if smp_min >= - 2000 and smp_min <= - 20 : obj . _thr = ( obj . _thr + obj . _smp_buff [( obj . _cnt - 4 ) & 0x7 ] *. 6 ) / 2 beat_detected = True obj . _smp_buff = [ 0 ] * 8 return beat_detected def detect_pulse ( obj ): cnt = 0 idx = 0 hr_avg = 0 HR_AVG_SIZE = 10 rate = [ 0 ] * HR_AVG_SIZE while True : try : val = obj . read_raw_samples ( 6 ) hr = ( val [ 3 ] << 16 | val [ 4 ] << 8 | val [ 5 ]) cnt += 1 res = check_for_beat ( obj , hr ) if res : dt = cnt * obj . _dt cnt = 0 bpm = 60000 / dt if bpm < 255 and bpm > 20 : rate [ idx ] = bpm idx += 1 if idx == HR_AVG_SIZE : idx = 0 hr_avg = 0 for rr in rate : hr_avg += rr obj . hr_avg = hr_avg / HR_AVG_SIZE if cnt >= 3000 / obj . _dt : cnt = 0 obj . _thr = - 20 rate = [ 0 ] * HR_AVG_SIZE obj . hr_avg = 0 obj . clear_fifo () sleep ( obj . _dt ) except Exception as e : print ( \"ErrorT\" , e ) sleep ( 1000 ) # create an instance of the MAX30101 class try : # Setup sensor # This setup is referred to max30101 mounted on hexiwear device # Power up and init sequence for max30101 inside hexiwear device pinPowerOn = D70 digitalWrite ( pinPowerOn , HIGH ) pinMode ( pinPowerOn , OUTPUT ) # init sensor max = max30101 . MAX30101 ( I2C0 ) print ( \"start...\" ) max . start () max . _thr = - 20 max . _dt = 50 max . _prev = 0 max . _smp_buff = [ 0 ] * 8 max . _cnt = 0 max . hr_avg = 0 print ( \"init...\" ) max . init () # start a thread that reads and process raw data from the sensor thread ( detect_pulse , max ) print ( \"Ready!\" ) print ( \"---------------------------\" ) except Exception as e : print ( e ) while True : print ( \"Heart Rate:\" , int ( max . hr_avg )) print ( \"---------------------------\" ) sleep ( 3000 )","title":"Detect Heart Rate with MAX30101"},{"location":"reference/libs/maxim/max30101/docs/max30101/","text":"MAX30101 Module \u00b6 This module contains the driver for MAXIM MAX30101 pulse oximetry and heart-rate monitor module. The MAX30101 is capable of direct I2C communication and can be set on 3 different operating mode ( datasheet ). MAX30101 Class \u00b6 class MAX30101 \u00b6 class MAX30101 ( i2cdrv , addr = 0x57 , clk = 400000 ) Creates an intance of the MAX30101 class. Arguments: i2cdrv \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x75 clk \u2013 Clock speed, default 400kHz. Example: from maxim.max30101 import max30101 ... m301 = max30101 . MAX30101 ( I2C0 ) m301 . start () m301 . init () data = m301 . read_raw_samples ( 6 ) MAX30101.init \u00b6 init ( mode = 'spo2' , adc_range = 3 , sample_rate = 50 , pulse_width = 411 , led_current = [ 255 , 255 , 0 , 0 ], proximity_thrs = 0 , slot_multi = [ 0 , 0 , 0 , 0 ]) Initialize the MAX30101. Default paramter values enable \"spo2\" - without proximity - mode with: maximum ADC range, sampling rate of 50 Hz, LED pulse width of 411us and maximum pulse amplitude for both red and IR LEDs. Arguments: mode \u2013 set the operating state of the MAX30101, default mode is spo2 . adc_range \u2013 sets the SpO2 sensor ADC\u2019s full-scale range, maximum range by default. sample_rate \u2013 sets the sampling rate, default is 50 Hz. pulse_width \u2013 LEDs pulse width in microsecond, default value is 411. led_current \u2013 sets red, IR, green and IR for proximity mode LEDs pulse amplitude, by default only red and IR red are set to maximum value. proximity_thrs \u2013 sets the threshold for the proximity mode. slot_multi \u2013 configuration parameter for \"multi\" operating mode. Note For details on available values for all the parameters see set_mode() . FIFO configuration \u00b6 The MAX30101 stores the digital output data in a 32-deep circular FIFO within the IC. The sample size depends on the number of LED configured as active. As each led signal is stored as a 3-byte data, the FIFO width can be 3, 6, 9 or 12 bytes in size. MAX30101.set_sample_averaging \u00b6 set_sample_averaging ( n ) To reduce the amount of data throughput, n adjacent samples (in each individual channel) can be averaged and decimated on the chip by using this method. Accepted values for n are: 1,2,4,8,16 and 32. MAX30101.set_fifo_rollover \u00b6 set_fifo_rollover ( ro = True ) This method controls the behavior of the FIFO when the FIFO becomes completely filled with data. If ro is True , the FIFO Address rolls over to zero and the FIFO continues to fill with new data. If ro is False , then the FIFO is not updated until FIFO is read or the FIFO WRITE/READ pointer positions are changed. MAX30101.set_fifo_afv \u00b6 set_fifo_afv ( n ) This method sets the trigger for the \"full\" interrupt. The interrupt triggers when there are n empty spaces left in FIFO. MAX30101.read_raw_samples \u00b6 read_raw_samples ( nbyte ) Return a nbyte-long bytearray containing raw data read from the FIFO. MAX30101.clear_fifo \u00b6 clear_fifo () This method set to zero the FIFO read and write pointers and the overflow counter. Interrupt configuration \u00b6 MAX30101.enable_interrupt \u00b6 enable_interrupt ( source ) Set bit on enable interrupt registers corresponding to the selected source. \u2018sources\u2019 must be a list including one or more available sources. Available values for \u2018sources\u2019 are: \"full\" : in spo2 or hr mode, this interrupt triggers when FIFO has a certain number of free spaces remaining. \"data\" : in spo2 or hr mode, this interrupt triggers when there is a new sample in the data FIFO. \"alc\" : this interrupt triggers when the ambient light cancellation function of the SpO2/HR photodiode has reached its maximum limit, and therefore, ambient light is affecting the output of the ADC. \"prox\" : the proximity interrupt is triggered when the proximity threshold is reached, and SpO2/HR mode has begun. \"temp\" : when an internal die temperature conversion is finished, this interrupt is triggered so the processor can read the temperature data registers. MAX30101.read_triggered_interrupt \u00b6 read_triggered_interrupt () This method needs to read which interrupt is triggered when more then one is enabled and returns a list containing triggered interrupts. Note interrupt defines are shown in method above; this function can return \u201cpwr\u201d interrupt (triggered on every power-up) that is enabled by default and cannot be disabled. MAX30101.disable_interrupts \u00b6 disable_interrupts () Disable all interrupts. Mode configuration \u00b6 MAX30101.shutdown \u00b6 shutdown () Put the part into a power-save mode. While in power-save mode, all registers retain their values, and write/read operations function as normal. All interrupts are cleared to zero in this mode. MAX30101.wake_up \u00b6 wake_up () Wake up the MAX30101 component. MAX30101.reset \u00b6 reset () All configuration, threshold, and data registers are reset to their power-on-state through a power-on reset. MAX30101.set_mode \u00b6 set_mode ( mode , adc_range , sample_rate , pulse_width , led_current , proximity_thrs , slot_multi ) Set the operating mode of the MAX30101. Default paramter values are the same of init() . Parameters: mode : set the operating state of the MAX30101. Available values are: \"hr\" : Heart Rate mode - only red LED is used for conversion. \"spo2\" : SpO2 mode - red and IR LEDs are used for conversion. \"multi\" : Multi-LED mode - green, red and/or IR LEDs can be used for conversion. adc_range : sets the SpO2 sensor ADC\u2019s full-scale range as shown in the table below. adc_range LSB size (pA) Full Scale (nA) 0 7.81 2048 1 15.63 4096 2 31.25 8192 3 62.5 16384 sample_rate : sets the SpO2 effective sample rate. One sample consists of one IR pulse/conversion and one RED pulse/conversion. The sample rate and pulse width are related in that the sample rate sets an upper bound on the pulse width time. If the user selects a sample rate that is too high for the selected pulse_width setting, the highest possible sample rate is programmed instead. Available sampling rate values are: 50, 100, 200, 400, 800, 1000, 1600, 3200. pulse_width : set the LED pulse width and indirectly sets the ADC resolution. All LEDs (IR, red and green) have the same pulse width. pulse_width Pulse width (us) ADC Resolution (bits) 69 68.95 15 118 117.78 16 215 215.44 17 411 410.75 18 led_current : sets the pulse amplitude for the LEDs. led_current = [red, ir, green, pilot]. The purpose of pilot is to set the LED power during the proximity mode, as well as in \"multi\" mode. red, ir, green or pilot Led Current (mA) 0 0.0 1 0.2 2 0.4 ... ... 15 3.1 ... ... 31 6.4 ... ... 63 12.5 ... ... 127 25.4 ... ... 255 50.0 proximity_thrs : sets the IR ADC count that will trigger the beginning of \"hr\" or \"spo2\" mode and, if enabled, the prox interrupt. The threshold is defined as the 8 MSBs of the ADC count. For example, if proximity_thrs = 1, then an ADC value of 1023 (decimal) or higher triggers the prox interrupt. If proximity_thrs = 255, then only a saturated ADC triggers the interrupt. slot_multi : In \"multi\" mode, each sample is split into up to four time slots, slot1 through slot4. slot_multi = [slot1, slot2, slot3, slot4]. These method control which LED is active with which amplitude in each time slot, making for a very flexible configuration. The slots should be enabled in order (i.e., slot1 should not be disabled if slot2 or slot3 are enabled). slotX Active Led Led Pulse Amplitude (led_current value) 0 None Off 1 RED red 2 IR ir 3 GREEN green 4 None Off 5 RED pilot 6 IR pilot 7 GREEN pilot Temperature Data \u00b6 MAX30101.enable_temperature \u00b6 enable_temperature () Initiates a single temperature reading from the temperature sensor. MAX30101.get_temperature \u00b6 get_temperature () Returns a float representing the last temperature reading in Celsius. Part ID \u00b6 MAX30101.get_part_id \u00b6 get_part_id () Returns the Part ID of the component. MAX30101.get_revision_id \u00b6 get_revision_id () Returns the Revision ID of the component.","title":"MAX30101 Module"},{"location":"reference/libs/maxim/max30101/docs/max30101/#max30101-module","text":"This module contains the driver for MAXIM MAX30101 pulse oximetry and heart-rate monitor module. The MAX30101 is capable of direct I2C communication and can be set on 3 different operating mode ( datasheet ).","title":"MAX30101 Module"},{"location":"reference/libs/maxim/max30101/docs/max30101/#max30101-class","text":"","title":"MAX30101 Class"},{"location":"reference/libs/maxim/max30101/docs/max30101/#class-max30101","text":"class MAX30101 ( i2cdrv , addr = 0x57 , clk = 400000 ) Creates an intance of the MAX30101 class. Arguments: i2cdrv \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x75 clk \u2013 Clock speed, default 400kHz. Example: from maxim.max30101 import max30101 ... m301 = max30101 . MAX30101 ( I2C0 ) m301 . start () m301 . init () data = m301 . read_raw_samples ( 6 )","title":"class MAX30101"},{"location":"reference/libs/maxim/max30101/docs/max30101/#max30101init","text":"init ( mode = 'spo2' , adc_range = 3 , sample_rate = 50 , pulse_width = 411 , led_current = [ 255 , 255 , 0 , 0 ], proximity_thrs = 0 , slot_multi = [ 0 , 0 , 0 , 0 ]) Initialize the MAX30101. Default paramter values enable \"spo2\" - without proximity - mode with: maximum ADC range, sampling rate of 50 Hz, LED pulse width of 411us and maximum pulse amplitude for both red and IR LEDs. Arguments: mode \u2013 set the operating state of the MAX30101, default mode is spo2 . adc_range \u2013 sets the SpO2 sensor ADC\u2019s full-scale range, maximum range by default. sample_rate \u2013 sets the sampling rate, default is 50 Hz. pulse_width \u2013 LEDs pulse width in microsecond, default value is 411. led_current \u2013 sets red, IR, green and IR for proximity mode LEDs pulse amplitude, by default only red and IR red are set to maximum value. proximity_thrs \u2013 sets the threshold for the proximity mode. slot_multi \u2013 configuration parameter for \"multi\" operating mode. Note For details on available values for all the parameters see set_mode() .","title":"MAX30101.init"},{"location":"reference/libs/maxim/max30101/docs/max30101/#fifo-configuration","text":"The MAX30101 stores the digital output data in a 32-deep circular FIFO within the IC. The sample size depends on the number of LED configured as active. As each led signal is stored as a 3-byte data, the FIFO width can be 3, 6, 9 or 12 bytes in size.","title":"FIFO configuration"},{"location":"reference/libs/maxim/max30101/docs/max30101/#max30101set_sample_averaging","text":"set_sample_averaging ( n ) To reduce the amount of data throughput, n adjacent samples (in each individual channel) can be averaged and decimated on the chip by using this method. Accepted values for n are: 1,2,4,8,16 and 32.","title":"MAX30101.set_sample_averaging"},{"location":"reference/libs/maxim/max30101/docs/max30101/#max30101set_fifo_rollover","text":"set_fifo_rollover ( ro = True ) This method controls the behavior of the FIFO when the FIFO becomes completely filled with data. If ro is True , the FIFO Address rolls over to zero and the FIFO continues to fill with new data. If ro is False , then the FIFO is not updated until FIFO is read or the FIFO WRITE/READ pointer positions are changed.","title":"MAX30101.set_fifo_rollover"},{"location":"reference/libs/maxim/max30101/docs/max30101/#max30101set_fifo_afv","text":"set_fifo_afv ( n ) This method sets the trigger for the \"full\" interrupt. The interrupt triggers when there are n empty spaces left in FIFO.","title":"MAX30101.set_fifo_afv"},{"location":"reference/libs/maxim/max30101/docs/max30101/#max30101read_raw_samples","text":"read_raw_samples ( nbyte ) Return a nbyte-long bytearray containing raw data read from the FIFO.","title":"MAX30101.read_raw_samples"},{"location":"reference/libs/maxim/max30101/docs/max30101/#max30101clear_fifo","text":"clear_fifo () This method set to zero the FIFO read and write pointers and the overflow counter.","title":"MAX30101.clear_fifo"},{"location":"reference/libs/maxim/max30101/docs/max30101/#interrupt-configuration","text":"","title":"Interrupt configuration"},{"location":"reference/libs/maxim/max30101/docs/max30101/#max30101enable_interrupt","text":"enable_interrupt ( source ) Set bit on enable interrupt registers corresponding to the selected source. \u2018sources\u2019 must be a list including one or more available sources. Available values for \u2018sources\u2019 are: \"full\" : in spo2 or hr mode, this interrupt triggers when FIFO has a certain number of free spaces remaining. \"data\" : in spo2 or hr mode, this interrupt triggers when there is a new sample in the data FIFO. \"alc\" : this interrupt triggers when the ambient light cancellation function of the SpO2/HR photodiode has reached its maximum limit, and therefore, ambient light is affecting the output of the ADC. \"prox\" : the proximity interrupt is triggered when the proximity threshold is reached, and SpO2/HR mode has begun. \"temp\" : when an internal die temperature conversion is finished, this interrupt is triggered so the processor can read the temperature data registers.","title":"MAX30101.enable_interrupt"},{"location":"reference/libs/maxim/max30101/docs/max30101/#max30101read_triggered_interrupt","text":"read_triggered_interrupt () This method needs to read which interrupt is triggered when more then one is enabled and returns a list containing triggered interrupts. Note interrupt defines are shown in method above; this function can return \u201cpwr\u201d interrupt (triggered on every power-up) that is enabled by default and cannot be disabled.","title":"MAX30101.read_triggered_interrupt"},{"location":"reference/libs/maxim/max30101/docs/max30101/#max30101disable_interrupts","text":"disable_interrupts () Disable all interrupts.","title":"MAX30101.disable_interrupts"},{"location":"reference/libs/maxim/max30101/docs/max30101/#mode-configuration","text":"","title":"Mode configuration"},{"location":"reference/libs/maxim/max30101/docs/max30101/#max30101shutdown","text":"shutdown () Put the part into a power-save mode. While in power-save mode, all registers retain their values, and write/read operations function as normal. All interrupts are cleared to zero in this mode.","title":"MAX30101.shutdown"},{"location":"reference/libs/maxim/max30101/docs/max30101/#max30101wake_up","text":"wake_up () Wake up the MAX30101 component.","title":"MAX30101.wake_up"},{"location":"reference/libs/maxim/max30101/docs/max30101/#max30101reset","text":"reset () All configuration, threshold, and data registers are reset to their power-on-state through a power-on reset.","title":"MAX30101.reset"},{"location":"reference/libs/maxim/max30101/docs/max30101/#max30101set_mode","text":"set_mode ( mode , adc_range , sample_rate , pulse_width , led_current , proximity_thrs , slot_multi ) Set the operating mode of the MAX30101. Default paramter values are the same of init() . Parameters: mode : set the operating state of the MAX30101. Available values are: \"hr\" : Heart Rate mode - only red LED is used for conversion. \"spo2\" : SpO2 mode - red and IR LEDs are used for conversion. \"multi\" : Multi-LED mode - green, red and/or IR LEDs can be used for conversion. adc_range : sets the SpO2 sensor ADC\u2019s full-scale range as shown in the table below. adc_range LSB size (pA) Full Scale (nA) 0 7.81 2048 1 15.63 4096 2 31.25 8192 3 62.5 16384 sample_rate : sets the SpO2 effective sample rate. One sample consists of one IR pulse/conversion and one RED pulse/conversion. The sample rate and pulse width are related in that the sample rate sets an upper bound on the pulse width time. If the user selects a sample rate that is too high for the selected pulse_width setting, the highest possible sample rate is programmed instead. Available sampling rate values are: 50, 100, 200, 400, 800, 1000, 1600, 3200. pulse_width : set the LED pulse width and indirectly sets the ADC resolution. All LEDs (IR, red and green) have the same pulse width. pulse_width Pulse width (us) ADC Resolution (bits) 69 68.95 15 118 117.78 16 215 215.44 17 411 410.75 18 led_current : sets the pulse amplitude for the LEDs. led_current = [red, ir, green, pilot]. The purpose of pilot is to set the LED power during the proximity mode, as well as in \"multi\" mode. red, ir, green or pilot Led Current (mA) 0 0.0 1 0.2 2 0.4 ... ... 15 3.1 ... ... 31 6.4 ... ... 63 12.5 ... ... 127 25.4 ... ... 255 50.0 proximity_thrs : sets the IR ADC count that will trigger the beginning of \"hr\" or \"spo2\" mode and, if enabled, the prox interrupt. The threshold is defined as the 8 MSBs of the ADC count. For example, if proximity_thrs = 1, then an ADC value of 1023 (decimal) or higher triggers the prox interrupt. If proximity_thrs = 255, then only a saturated ADC triggers the interrupt. slot_multi : In \"multi\" mode, each sample is split into up to four time slots, slot1 through slot4. slot_multi = [slot1, slot2, slot3, slot4]. These method control which LED is active with which amplitude in each time slot, making for a very flexible configuration. The slots should be enabled in order (i.e., slot1 should not be disabled if slot2 or slot3 are enabled). slotX Active Led Led Pulse Amplitude (led_current value) 0 None Off 1 RED red 2 IR ir 3 GREEN green 4 None Off 5 RED pilot 6 IR pilot 7 GREEN pilot","title":"MAX30101.set_mode"},{"location":"reference/libs/maxim/max30101/docs/max30101/#temperature-data","text":"","title":"Temperature Data"},{"location":"reference/libs/maxim/max30101/docs/max30101/#max30101enable_temperature","text":"enable_temperature () Initiates a single temperature reading from the temperature sensor.","title":"MAX30101.enable_temperature"},{"location":"reference/libs/maxim/max30101/docs/max30101/#max30101get_temperature","text":"get_temperature () Returns a float representing the last temperature reading in Celsius.","title":"MAX30101.get_temperature"},{"location":"reference/libs/maxim/max30101/docs/max30101/#part-id","text":"","title":"Part ID"},{"location":"reference/libs/maxim/max30101/docs/max30101/#max30101get_part_id","text":"get_part_id () Returns the Part ID of the component.","title":"MAX30101.get_part_id"},{"location":"reference/libs/maxim/max30101/docs/max30101/#max30101get_revision_id","text":"get_revision_id () Returns the Revision ID of the component.","title":"MAX30101.get_revision_id"},{"location":"reference/libs/maxim/max7219/docs/","text":"MAXIM MAX7219 \u00b6 The MAX7219 is a serial input/output common-cathode display drivers to interface microprocessors to 7-segment numeric LED displays of up to 8 digits, bar-graph displays, or 64 (8x8 Matrix) individual LEDs. A convenient 4-wire serial interface connects to all common \u00b5Cs. Individual digits may be addressed and updated without rewriting the entire display. The MAX7219 also allow the user to select code-B decoding or no-decode for each digit. More information at Maxim dedicated page . Technical Details \u00b6 Supply Voltage (Vdd): from 4.0 V to 5.5 V Operation Temperature (Top): from 0 \u00b0C to 70 \u00b0C Operating Supply Current: 330 mA Continue Power Dissipation (Ta 85 \u00b0C): ~1W SPI interface Here below, the Zerynth driver for the Maxim MAX729. Contents: MAX7219 Module Examples led matrix","title":"MAXIM MAX7219"},{"location":"reference/libs/maxim/max7219/docs/#maxim-max7219","text":"The MAX7219 is a serial input/output common-cathode display drivers to interface microprocessors to 7-segment numeric LED displays of up to 8 digits, bar-graph displays, or 64 (8x8 Matrix) individual LEDs. A convenient 4-wire serial interface connects to all common \u00b5Cs. Individual digits may be addressed and updated without rewriting the entire display. The MAX7219 also allow the user to select code-B decoding or no-decode for each digit. More information at Maxim dedicated page .","title":"MAXIM MAX7219"},{"location":"reference/libs/maxim/max7219/docs/#technical-details","text":"Supply Voltage (Vdd): from 4.0 V to 5.5 V Operation Temperature (Top): from 0 \u00b0C to 70 \u00b0C Operating Supply Current: 330 mA Continue Power Dissipation (Ta 85 \u00b0C): ~1W SPI interface Here below, the Zerynth driver for the Maxim MAX729. Contents: MAX7219 Module Examples led matrix","title":"Technical Details"},{"location":"reference/libs/maxim/max7219/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.maxim.max7219. LED Matrix \u00b6 Basic Example of MAX7219 usage for drawing maxi numbers on a 8x8 led matrix display. main.py ################################################################################ # Led Matrix Display Example # # Created: 2017-02-24 12:48:43.342375 # ################################################################################ import streams # import MAX7219 library to handle 8x8 led matrix from maxim.max7219 import max7219 # import fonts file where matrix numbers are defined import fonts # Create a serial console streams . serial () # Setup Led Matrix (8x8 Click on slot A of a Flip n Click device) display = max7219 . MAX7219 ( SPI0 , D17 ) # counter variable num = 0 display . shutdown ( False ) intensity = 9 display . set_intensity ( intensity ) while True : for num in range ( 10 ): # increment the intensity intensity += 1 if intensity > 15 : intensity = 0 display . set_intensity ( intensity ) print ( \"Display Number:\" , num , \" with light intensity:\" , intensity ) # print the maxi number on led matrix for row in range ( 8 ): for col in range ( 8 ): if fonts . numbers [ num ][ row ][ col ]: display . set_led ( row , col , 1 ) else : display . set_led ( row , col , 0 ) sleep ( 2000 ) # Test print row and print column display . clear_display () print ( \"Reload...\" ) display . set_row ( 1 , 1 ) sleep ( 500 ) display . set_column ( 1 , 1 ) sleep ( 500 ) display . set_row ( 6 , 1 ) sleep ( 500 ) display . set_column ( 6 , 1 ) sleep ( 500 )","title":"Examples"},{"location":"reference/libs/maxim/max7219/docs/examples/#examples","text":"The following are a list of examples for lib.maxim.max7219.","title":"Examples"},{"location":"reference/libs/maxim/max7219/docs/examples/#led-matrix","text":"Basic Example of MAX7219 usage for drawing maxi numbers on a 8x8 led matrix display. main.py ################################################################################ # Led Matrix Display Example # # Created: 2017-02-24 12:48:43.342375 # ################################################################################ import streams # import MAX7219 library to handle 8x8 led matrix from maxim.max7219 import max7219 # import fonts file where matrix numbers are defined import fonts # Create a serial console streams . serial () # Setup Led Matrix (8x8 Click on slot A of a Flip n Click device) display = max7219 . MAX7219 ( SPI0 , D17 ) # counter variable num = 0 display . shutdown ( False ) intensity = 9 display . set_intensity ( intensity ) while True : for num in range ( 10 ): # increment the intensity intensity += 1 if intensity > 15 : intensity = 0 display . set_intensity ( intensity ) print ( \"Display Number:\" , num , \" with light intensity:\" , intensity ) # print the maxi number on led matrix for row in range ( 8 ): for col in range ( 8 ): if fonts . numbers [ num ][ row ][ col ]: display . set_led ( row , col , 1 ) else : display . set_led ( row , col , 0 ) sleep ( 2000 ) # Test print row and print column display . clear_display () print ( \"Reload...\" ) display . set_row ( 1 , 1 ) sleep ( 500 ) display . set_column ( 1 , 1 ) sleep ( 500 ) display . set_row ( 6 , 1 ) sleep ( 500 ) display . set_column ( 6 , 1 ) sleep ( 500 )","title":"LED Matrix"},{"location":"reference/libs/maxim/max7219/docs/max7219/","text":"MAX7219 Module \u00b6 This Module exposes all functionalities of Maxim MAX7219 Led Display driver ([datasheet( https://datasheets.maximintegrated.com/en/ds/MAX7219-MAX7221.pdf )). class MAX7219 \u00b6 class MAX7219 ( spidrv , cs , clk = 1000000 ) Creates an intance of a new MAX7219. Arguments: spidrv \u2013 SPI Bus used \u2018( SPI0, \u2026 )\u2019 cs \u2013 Chip Select clk \u2013 Clock speed, default 100kHz Example: from maxim.max7219 import max7219 ... display = max7219 . MAX7219 ( SPI0 , D17 ) display . set_led ( row , col , 1 ) # set to on the led in 0x0 position MAX7219.shutdown \u00b6 shutdown ( powerdown ) Function to shutdown the display attached Arguments: powerdown \u2013 Boolean True or False MAX7219.set_scan_limit \u00b6 set_scan_limit ( limit ) * only for 7 - segments Display * Method that is used for seven segment displays that limits the number of digits. Arguments: limit \u2013 number of banks (values 0 to 7). MAX7219.set_intensity \u00b6 set_intensity ( intensity ) Sets the intensity of the LEDs output. Arguments: intensity \u2013 light output intensity (values 0 to 15). MAX7219.clear_display \u00b6 clear_display () Clears the display by setting all LEDs to 0. MAX7219.set_led \u00b6 set_led ( row , column , state ) Allows the control of a single LED. Arguments: row \u2013 is the row (values 0 to 7) column \u2013 is the column (values 0 to 7) state \u2013 is True for Led ON, and False for Led OFF MAX7219.set_row \u00b6 set_row ( row , state ) Sets an entire row. Arguments: row \u2013 row to control (values from 0 to 7) state \u2013 is True for Led ON, and False for Led OFF MAX7219.set_column \u00b6 set_column ( col , state ) Sets an entire column. Arguments: column \u2013 column to control (values from 0 to 7) state \u2013 is True for Led ON, and False for Led OFF MAX7219.set_digit \u00b6 set_digit ( digit , value , dp ) * only for 7 - segments Display * Used with 7 segment displays to set a digit to display on the 7 segments. Arguments: digit \u2013 is the bank from 0 to 7 to display value \u2013 is the number value dp \u2013 is the decimal point MAX7219.set_char \u00b6 set_char ( dev_num , digit , value , state ) * only for 7 - segments Display * Arguments: digit \u2013 is the bank from 0 to 7 to display value \u2013 is the character value state \u2013 is True for Led ON, and False for Led OFF","title":"MAX7219 Module"},{"location":"reference/libs/maxim/max7219/docs/max7219/#max7219-module","text":"This Module exposes all functionalities of Maxim MAX7219 Led Display driver ([datasheet( https://datasheets.maximintegrated.com/en/ds/MAX7219-MAX7221.pdf )).","title":"MAX7219 Module"},{"location":"reference/libs/maxim/max7219/docs/max7219/#class-max7219","text":"class MAX7219 ( spidrv , cs , clk = 1000000 ) Creates an intance of a new MAX7219. Arguments: spidrv \u2013 SPI Bus used \u2018( SPI0, \u2026 )\u2019 cs \u2013 Chip Select clk \u2013 Clock speed, default 100kHz Example: from maxim.max7219 import max7219 ... display = max7219 . MAX7219 ( SPI0 , D17 ) display . set_led ( row , col , 1 ) # set to on the led in 0x0 position","title":"class MAX7219"},{"location":"reference/libs/maxim/max7219/docs/max7219/#max7219shutdown","text":"shutdown ( powerdown ) Function to shutdown the display attached Arguments: powerdown \u2013 Boolean True or False","title":"MAX7219.shutdown"},{"location":"reference/libs/maxim/max7219/docs/max7219/#max7219set_scan_limit","text":"set_scan_limit ( limit ) * only for 7 - segments Display * Method that is used for seven segment displays that limits the number of digits. Arguments: limit \u2013 number of banks (values 0 to 7).","title":"MAX7219.set_scan_limit"},{"location":"reference/libs/maxim/max7219/docs/max7219/#max7219set_intensity","text":"set_intensity ( intensity ) Sets the intensity of the LEDs output. Arguments: intensity \u2013 light output intensity (values 0 to 15).","title":"MAX7219.set_intensity"},{"location":"reference/libs/maxim/max7219/docs/max7219/#max7219clear_display","text":"clear_display () Clears the display by setting all LEDs to 0.","title":"MAX7219.clear_display"},{"location":"reference/libs/maxim/max7219/docs/max7219/#max7219set_led","text":"set_led ( row , column , state ) Allows the control of a single LED. Arguments: row \u2013 is the row (values 0 to 7) column \u2013 is the column (values 0 to 7) state \u2013 is True for Led ON, and False for Led OFF","title":"MAX7219.set_led"},{"location":"reference/libs/maxim/max7219/docs/max7219/#max7219set_row","text":"set_row ( row , state ) Sets an entire row. Arguments: row \u2013 row to control (values from 0 to 7) state \u2013 is True for Led ON, and False for Led OFF","title":"MAX7219.set_row"},{"location":"reference/libs/maxim/max7219/docs/max7219/#max7219set_column","text":"set_column ( col , state ) Sets an entire column. Arguments: column \u2013 column to control (values from 0 to 7) state \u2013 is True for Led ON, and False for Led OFF","title":"MAX7219.set_column"},{"location":"reference/libs/maxim/max7219/docs/max7219/#max7219set_digit","text":"set_digit ( digit , value , dp ) * only for 7 - segments Display * Used with 7 segment displays to set a digit to display on the 7 segments. Arguments: digit \u2013 is the bank from 0 to 7 to display value \u2013 is the number value dp \u2013 is the decimal point","title":"MAX7219.set_digit"},{"location":"reference/libs/maxim/max7219/docs/max7219/#max7219set_char","text":"set_char ( dev_num , digit , value , state ) * only for 7 - segments Display * Arguments: digit \u2013 is the bank from 0 to 7 to display value \u2013 is the character value state \u2013 is True for Led ON, and False for Led OFF","title":"MAX7219.set_char"},{"location":"reference/libs/meas/htu21d/docs/","text":"MEAS HTU21D \u00b6 The HTU21D is a relative humidity sensor with temperature output by MEAS. This sensor provides calibrated, linearized signals in digital, I\u00b2C format for interfacing directly with a micro-controller and its low power consumption permits to implement high volume and cost sensitive applications with tight space constraints. The HTU21D is designed for applications in automotive field (defogging, HVAC, etc), home appliance, medical field, printers, humidifier, and many more. More information at MEAS dedicated page . Technical Details \u00b6 Supply Voltage (Vdd): from 1.5 V to 3.6 V Operation Temperature (Top): from -40 \u00b0C to 125 \u00b0C Current Consumption: 500 uA max Power Dissipation: ~2,7 uW Relative Humidity Range: from 0 %RH to 100 %RH Relative Humidity Accuracy: \u00b12 %RH (typ) Temperature Range: from -40 \u00b0C to +125 \u00b0C Temperature Accuracy: \u00b10.3 \u00b0C (typ) I\u00b2C interface Here below, the Zerynth driver for the MEAS HTU21D. Contents: HTU21D Module Examples get humid temp","title":"MEAS HTU21D"},{"location":"reference/libs/meas/htu21d/docs/#meas-htu21d","text":"The HTU21D is a relative humidity sensor with temperature output by MEAS. This sensor provides calibrated, linearized signals in digital, I\u00b2C format for interfacing directly with a micro-controller and its low power consumption permits to implement high volume and cost sensitive applications with tight space constraints. The HTU21D is designed for applications in automotive field (defogging, HVAC, etc), home appliance, medical field, printers, humidifier, and many more. More information at MEAS dedicated page .","title":"MEAS HTU21D"},{"location":"reference/libs/meas/htu21d/docs/#technical-details","text":"Supply Voltage (Vdd): from 1.5 V to 3.6 V Operation Temperature (Top): from -40 \u00b0C to 125 \u00b0C Current Consumption: 500 uA max Power Dissipation: ~2,7 uW Relative Humidity Range: from 0 %RH to 100 %RH Relative Humidity Accuracy: \u00b12 %RH (typ) Temperature Range: from -40 \u00b0C to +125 \u00b0C Temperature Accuracy: \u00b10.3 \u00b0C (typ) I\u00b2C interface Here below, the Zerynth driver for the MEAS HTU21D. Contents: HTU21D Module Examples get humid temp","title":"Technical Details"},{"location":"reference/libs/meas/htu21d/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.meas.htu21d. Read Humidity and Temperature values from HTU21D \u00b6 Basic example to read the current values of temperature and relative humidity from HTU21D sensor. main.py ################################################################################ # Humidity and Temperature Example # # Created: 2017-03-17 11:45:14.498321 # ################################################################################ import streams from meas.htu21d import htu21d streams . serial () try : # Setup sensor # This setup is referred to htu21d mounted on hexiwear device htu = htu21d . HTU21D ( I2C0 ) print ( \"start...\" ) htu . start () print ( \"init...\" ) htu . init () print ( \"Ready!\" ) print ( \"--------------------------------------------------------\" ) except Exception as e : print ( \"Error: \" , e ) try : while True : raw_temp = htu . get_raw_temp () # Read raw temperature print ( \"Raw Temperature: \" , raw_temp ) raw_humid = htu . get_raw_humid () # Read raw humidity print ( \"Raw Humidity: \" , raw_humid ) temp = htu . get_temp () # Read temperature in \u00b0C print ( \"Temperature: \" , temp , \"C\" ) humid = htu . get_humid () # Read relative humidity print ( \"Humidity: \" , humid , \"%\" ) t , h = htu . get_temp_humid () # Read both temperature and humidity print ( \"Temperature - Humidity: \" , t , \" C -\" , h , \" %\" ) print ( \"--------------------------------------------------------\" ) sleep ( 5000 ) except Exception as e : print ( \"Error2: \" , e )","title":"Examples"},{"location":"reference/libs/meas/htu21d/docs/examples/#examples","text":"The following are a list of examples for lib.meas.htu21d.","title":"Examples"},{"location":"reference/libs/meas/htu21d/docs/examples/#read-humidity-and-temperature-values-from-htu21d","text":"Basic example to read the current values of temperature and relative humidity from HTU21D sensor. main.py ################################################################################ # Humidity and Temperature Example # # Created: 2017-03-17 11:45:14.498321 # ################################################################################ import streams from meas.htu21d import htu21d streams . serial () try : # Setup sensor # This setup is referred to htu21d mounted on hexiwear device htu = htu21d . HTU21D ( I2C0 ) print ( \"start...\" ) htu . start () print ( \"init...\" ) htu . init () print ( \"Ready!\" ) print ( \"--------------------------------------------------------\" ) except Exception as e : print ( \"Error: \" , e ) try : while True : raw_temp = htu . get_raw_temp () # Read raw temperature print ( \"Raw Temperature: \" , raw_temp ) raw_humid = htu . get_raw_humid () # Read raw humidity print ( \"Raw Humidity: \" , raw_humid ) temp = htu . get_temp () # Read temperature in \u00b0C print ( \"Temperature: \" , temp , \"C\" ) humid = htu . get_humid () # Read relative humidity print ( \"Humidity: \" , humid , \"%\" ) t , h = htu . get_temp_humid () # Read both temperature and humidity print ( \"Temperature - Humidity: \" , t , \" C -\" , h , \" %\" ) print ( \"--------------------------------------------------------\" ) sleep ( 5000 ) except Exception as e : print ( \"Error2: \" , e )","title":"Read Humidity and Temperature values from HTU21D"},{"location":"reference/libs/meas/htu21d/docs/htu21d/","text":"HTU21D Module \u00b6 This module contains the driver for MEAS HTU21D Relative Humidity and Temperature sensor. The HTU21D is capable of direct I2C communication and can be set on 4 different level of resolution in both temperature and humidity measurements ( datasheet ). class HTU21D \u00b6 class HTU21D ( i2cdrv , addr = 0x40 , clk = 400000 ) Creates an intance of a new HTU21D. Arguments: i2cdrv \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x40 clk \u2013 Clock speed, default 400kHz Example: from meas.htu21d import htu21d ... htu = htu21d . HTU21D ( I2C0 ) htu . start () htu . init () t , h = htu . get_temp_humid () HTU21D.init \u00b6 init ( res = 0 ) Initialize the HTU21D setting the resolution of the sensor. Parameters: res \u2013 set the resolution (from 0 to 3) for temperature and humidity measurements according to the table below; default 0. res value Humid Resolution Temp Resolution Meas. Time Humid Meas. Time Temp 0 12 bits 14 bits 16 ms 50 ms 1 8 bits 12 bits 3 ms 13 ms 2 10 bits 13 bits 5 ms 25 ms 3 11 bits 11 bits 8 ms 7 ms HTU21D.get_raw_temp \u00b6 get_raw_temp () Retrieves the current temperature data from the sensor as raw value. Returns raw_temp. HTU21D.get_raw_humid \u00b6 get_raw_humid () Retrieves the current humidity data from the sensor as raw value. Returns raw_humid. HTU21D.get_temp \u00b6 get_temp () Retrieves the current temperature data from the sensor as calibrate value in \u00b0C. Returns temp. HTU21D.get_humid \u00b6 get_humid () Retrieves the current relative humidity data from the sensor as calibrate value in %RH. Returns humid. HTU21D.get_temp_humid \u00b6 get_temp_humid () Retrieves both temperature and humidity in one call. Returns temp, humid.","title":"HTU21D Module"},{"location":"reference/libs/meas/htu21d/docs/htu21d/#htu21d-module","text":"This module contains the driver for MEAS HTU21D Relative Humidity and Temperature sensor. The HTU21D is capable of direct I2C communication and can be set on 4 different level of resolution in both temperature and humidity measurements ( datasheet ).","title":"HTU21D Module"},{"location":"reference/libs/meas/htu21d/docs/htu21d/#class-htu21d","text":"class HTU21D ( i2cdrv , addr = 0x40 , clk = 400000 ) Creates an intance of a new HTU21D. Arguments: i2cdrv \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x40 clk \u2013 Clock speed, default 400kHz Example: from meas.htu21d import htu21d ... htu = htu21d . HTU21D ( I2C0 ) htu . start () htu . init () t , h = htu . get_temp_humid ()","title":"class HTU21D"},{"location":"reference/libs/meas/htu21d/docs/htu21d/#htu21dinit","text":"init ( res = 0 ) Initialize the HTU21D setting the resolution of the sensor. Parameters: res \u2013 set the resolution (from 0 to 3) for temperature and humidity measurements according to the table below; default 0. res value Humid Resolution Temp Resolution Meas. Time Humid Meas. Time Temp 0 12 bits 14 bits 16 ms 50 ms 1 8 bits 12 bits 3 ms 13 ms 2 10 bits 13 bits 5 ms 25 ms 3 11 bits 11 bits 8 ms 7 ms","title":"HTU21D.init"},{"location":"reference/libs/meas/htu21d/docs/htu21d/#htu21dget_raw_temp","text":"get_raw_temp () Retrieves the current temperature data from the sensor as raw value. Returns raw_temp.","title":"HTU21D.get_raw_temp"},{"location":"reference/libs/meas/htu21d/docs/htu21d/#htu21dget_raw_humid","text":"get_raw_humid () Retrieves the current humidity data from the sensor as raw value. Returns raw_humid.","title":"HTU21D.get_raw_humid"},{"location":"reference/libs/meas/htu21d/docs/htu21d/#htu21dget_temp","text":"get_temp () Retrieves the current temperature data from the sensor as calibrate value in \u00b0C. Returns temp.","title":"HTU21D.get_temp"},{"location":"reference/libs/meas/htu21d/docs/htu21d/#htu21dget_humid","text":"get_humid () Retrieves the current relative humidity data from the sensor as calibrate value in %RH. Returns humid.","title":"HTU21D.get_humid"},{"location":"reference/libs/meas/htu21d/docs/htu21d/#htu21dget_temp_humid","text":"get_temp_humid () Retrieves both temperature and humidity in one call. Returns temp, humid.","title":"HTU21D.get_temp_humid"},{"location":"reference/libs/melexis/mlx90615/docs/","text":"Melexis MLX90615 \u00b6 The Melexis MLX90615 is a miniature Infra Red Thermometer for non-contact temperature measurements. Both the IR sensitive thermopile detector chip and the signal conditioning ASIC are integrated in the same miniature TO-46 can. With its small size, this infrared thermometer is especially suited for medical applications like ear or forehead thermometers or other applications. The infrared thermometer comes factory calibrated with a digital SMBus output giving full access to the measured temperature in the complete temperature range(s) with a resolution of 0.02 \u00b0C. The sensor achieves an accuracy of \u00b10.2 \u00b0C within the relevant medical temperature range; more information at Melexis dedicated page . Technical Details \u00b6 Supply Voltage (Vdd): from 2.6 V to 3.4 V Operation Temperature (Top): from -20 \u00b0C to 85 \u00b0C SCL Clock Frequency (Fscl): 100 kHz Supply Current (Idd): from 1.3 mA to 1.5 mA Read Sample Time: 14 us (stardard mode), 1.5 us (overdrive mode) Measurement Resolution: 0.02 \u00b0C Power saving mode Customizable PWM output for continuous reading Here below, the Zerynth driver for the Melexis MLX90615 and some examples to better understand how to use it. Contents: Melexis MLX90615 Technical Details MLX90615 Module Examples","title":"Melexis MLX90615"},{"location":"reference/libs/melexis/mlx90615/docs/#melexis-mlx90615","text":"The Melexis MLX90615 is a miniature Infra Red Thermometer for non-contact temperature measurements. Both the IR sensitive thermopile detector chip and the signal conditioning ASIC are integrated in the same miniature TO-46 can. With its small size, this infrared thermometer is especially suited for medical applications like ear or forehead thermometers or other applications. The infrared thermometer comes factory calibrated with a digital SMBus output giving full access to the measured temperature in the complete temperature range(s) with a resolution of 0.02 \u00b0C. The sensor achieves an accuracy of \u00b10.2 \u00b0C within the relevant medical temperature range; more information at Melexis dedicated page .","title":"Melexis MLX90615"},{"location":"reference/libs/melexis/mlx90615/docs/#technical-details","text":"Supply Voltage (Vdd): from 2.6 V to 3.4 V Operation Temperature (Top): from -20 \u00b0C to 85 \u00b0C SCL Clock Frequency (Fscl): 100 kHz Supply Current (Idd): from 1.3 mA to 1.5 mA Read Sample Time: 14 us (stardard mode), 1.5 us (overdrive mode) Measurement Resolution: 0.02 \u00b0C Power saving mode Customizable PWM output for continuous reading Here below, the Zerynth driver for the Melexis MLX90615 and some examples to better understand how to use it. Contents: Melexis MLX90615 Technical Details MLX90615 Module Examples","title":"Technical Details"},{"location":"reference/libs/melexis/mlx90615/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.melexis.mlx90615. MLX90615 \u00b6 Simple example to read values from the Melexis MLX90615 infrared thermometer. main.py ################################################################################ # MLX90615 # # Created: 2015-12-04 21:34:56.758233 # ################################################################################ import streams from melexis.mlx90615 import mlx90615 streams . serial () # create a MLX90615 instance passing the I2C peripheral it is connected to mlx = mlx90615 . MLX90615 ( I2C0 ) # start the MLX90615 mlx . start () while True : # read data! print ( \"Object Temperature is:\" , mlx . temperature ()) print ( \"Ambient Temperature is:\" , mlx . ambient ()) print ( \"Raw Infrared value is:\" , mlx . raw ()) print ( \"-\" * 30 ) sleep ( 1000 )","title":"Examples"},{"location":"reference/libs/melexis/mlx90615/docs/examples/#examples","text":"The following are a list of examples for lib.melexis.mlx90615.","title":"Examples"},{"location":"reference/libs/melexis/mlx90615/docs/examples/#mlx90615","text":"Simple example to read values from the Melexis MLX90615 infrared thermometer. main.py ################################################################################ # MLX90615 # # Created: 2015-12-04 21:34:56.758233 # ################################################################################ import streams from melexis.mlx90615 import mlx90615 streams . serial () # create a MLX90615 instance passing the I2C peripheral it is connected to mlx = mlx90615 . MLX90615 ( I2C0 ) # start the MLX90615 mlx . start () while True : # read data! print ( \"Object Temperature is:\" , mlx . temperature ()) print ( \"Ambient Temperature is:\" , mlx . ambient ()) print ( \"Raw Infrared value is:\" , mlx . raw ()) print ( \"-\" * 30 ) sleep ( 1000 )","title":"MLX90615"},{"location":"reference/libs/melexis/mlx90615/docs/mlx90615/","text":"MLX90615 Module \u00b6 This module implements Zerynth driver for the MLX90165 sensor ( datasheet ). The default communication protocol is I2C. To use this module create a MLX90615 instance by passing the I2C peripheral name to which it is connected to. Using the module is simple: from melexis.mlx90615 import mlx90615 import streams streams . serial () mlx = mlx90615 . MLX90615 ( I2C0 ) while True : print ( \"Temperature:\" , mlx . temperature ()) sleep ( 1000 ) MLX90615 class \u00b6 class MLX90615(drvname,clock=100000) Creates a MLX90615 instance using the MCU I2C circuitry drvname (one of I2C0, I2C1, \u2026 check pinmap for details). The created instance is configured and ready to communicate. clock is configured by default in slow mode. MLX90615 inherits from i2c.I2C, therefore the method start() must be called to setup the I2C channel before any temperature can be read. temperature() Returns the object temperature in Celsius. The object temperature is the temperature of the object the mlx90615 is pointing towards. ambient() Returns the ambient temperature in Celsius. The ambient temperature is the temperature inside the MLX90615 package. raw() Returns the raw infrared readings (signed, 16 bits).","title":"MLX90615 Module"},{"location":"reference/libs/melexis/mlx90615/docs/mlx90615/#mlx90615-module","text":"This module implements Zerynth driver for the MLX90165 sensor ( datasheet ). The default communication protocol is I2C. To use this module create a MLX90615 instance by passing the I2C peripheral name to which it is connected to. Using the module is simple: from melexis.mlx90615 import mlx90615 import streams streams . serial () mlx = mlx90615 . MLX90615 ( I2C0 ) while True : print ( \"Temperature:\" , mlx . temperature ()) sleep ( 1000 )","title":"MLX90615 Module"},{"location":"reference/libs/melexis/mlx90615/docs/mlx90615/#mlx90615-class","text":"class MLX90615(drvname,clock=100000) Creates a MLX90615 instance using the MCU I2C circuitry drvname (one of I2C0, I2C1, \u2026 check pinmap for details). The created instance is configured and ready to communicate. clock is configured by default in slow mode. MLX90615 inherits from i2c.I2C, therefore the method start() must be called to setup the I2C channel before any temperature can be read. temperature() Returns the object temperature in Celsius. The object temperature is the temperature of the object the mlx90615 is pointing towards. ambient() Returns the ambient temperature in Celsius. The ambient temperature is the temperature inside the MLX90615 package. raw() Returns the raw infrared readings (signed, 16 bits).","title":"MLX90615 class"},{"location":"reference/libs/microchip/ateccx08a/docs/","text":"ATECCx08A \u00b6 Microchip ATECCx08A crypto elements family provides a series of HW accelerated cryptographic functions, most notably ECDH (508A/608A only) and ECDSA. Product pages: ATECC108A ATECC508A ATECC608A Technical Details \u00b6 Operating Voltage Range: from 2.0 V to 5.5 V Operating Temperature Range: from -40 \u00b0C to 85 \u00b0C Interface Type: Single Wire; I2C Operating Current Typical: 1 mA Below, Zerynth driver documentation for Microchip ATECCx80A crypto elements. Contents: ATECCx08A library Auxiliary methods ATECC508A class Internal methods Public methods Commands ATECC608A class Zerynth HWCrypto Interface Examples ping","title":"Index"},{"location":"reference/libs/microchip/ateccx08a/docs/#ateccx08a","text":"Microchip ATECCx08A crypto elements family provides a series of HW accelerated cryptographic functions, most notably ECDH (508A/608A only) and ECDSA. Product pages: ATECC108A ATECC508A ATECC608A","title":"ATECCx08A"},{"location":"reference/libs/microchip/ateccx08a/docs/#technical-details","text":"Operating Voltage Range: from 2.0 V to 5.5 V Operating Temperature Range: from -40 \u00b0C to 85 \u00b0C Interface Type: Single Wire; I2C Operating Current Typical: 1 mA Below, Zerynth driver documentation for Microchip ATECCx80A crypto elements. Contents: ATECCx08A library Auxiliary methods ATECC508A class Internal methods Public methods Commands ATECC608A class Zerynth HWCrypto Interface Examples ping","title":"Technical Details"},{"location":"reference/libs/microchip/ateccx08a/docs/ateccx08a/","text":"ATECCx08A library \u00b6 This module exports classes for Microchip ATECCx08A chip family and some utilities functions. Furthermore an interface to allow the use of chip-related functionalities from other Zerynth hybrid C/Python libraries is made available. Auxiliary methods \u00b6 crc16 \u00b6 crc16 ( data : bytes ) Compute the CRC16 checksum for some bytes. The CRC is calculated using 0x8005 as polynomial and starting with the registry set as 0x00. Arguments: data ( bytes ) \u2013 bytes to be checksummed. Returns: 2 bytes, representing the computed checksum. Return type: bytes ATECC508A class \u00b6 class ATECC508A \u00b6 class ATECC508A ( i2c . I2C ) Class for controlling the ATECC508A chip. Members: device_awake : Boolean. If True the device is running a multiple commands sequence. ATECC508A. init \u00b6 __init__ ( drvname , addr = DEFAULT_ADDR , clk = 100000 ) Connect to a device and start I2C protocol. Arguments: drvname \u2013 Interface for I2C communication (e.g. I2C0) addr ( int [0-255] ) \u2013 Address of the I2C chip. (Default value = 0x60 for ATECC508A) clk ( int ) \u2013 Clock rate of the I2C communication in kHz. (Default value = 100000). Internal methods \u00b6 ATECC508A._send_cmd \u00b6 _send_cmd ( self , opcode , param1 , param2 : bytes , data = bytes ()) Send a command packet to the device. Output packet structure: [ 0x03 ][ length ][ opcode ][ p1 ][ p2 ][ \u2026data\u2026 ][ crc ] 0x03 is a constant defined in WORD_ADDRS at the beginning of this module. length includes every bytes except the first 0x03 byte. p1 is byte of length 1. (mandatory) p2 is bytes of length 2. (mandatory) data is optional and can have arbitraty length. crc is a 2 byte checksum (calculated using ecc508a.crc16() ). Arguments: opcode ( int ) \u2013 The code representing the selected command. Check OPCODES at the beginning of this module. param1 ( int ) \u2013 The first mandatory parameter. 1 byte long. param2 ( bytes ) \u2013 The second mandatory parameter. 2 bytes long. data ( bytes ) \u2013 Other optional data. (Default value = bytes()) ATECC508A._read_result \u00b6 _read_result () Read, verify checksum, and extract data of a packet from the device. Input packet structure: [ length ][ \u2026data\u2026 ][ crc ] Returns: the extracted data bytes. Return type: bytes Note Length includes itself (1 byte), data (n bytes), and crc16 (2 bytes). Public methods \u00b6 ATECC508A.start_cmd_sequence \u00b6 start_cmd_sequence () Call this function before a command sequence to wake up device from idle mode. This is done by keeping SDA low for more than 60 microseconds. Note At this moment a 0x00 byte is written as a normal I2C transaction, ignoring the exception raised. This workaround won\u2019t work at higher clock rates (more than ~100 kHz)! ATECC508A.end_cmd_sequence \u00b6 end_cmd_sequence () Call this function at the end of a command sequence to put the device in idle mode. This must be done in order to avoid hitting the watchdog timeout (~1 second) which will put the device in idle mode no matter what. send_and_read(*args) Send a command and return the result data. Note If start_cmd_sequence() was not invoked before this method, the device is automatically woke up and put again in idle mode after the command execution. (Default value = 50) Arguments: ***args** \u2013 All arguments are passed to _send_cmd() method. Commands \u00b6 The functions names are the lowercase command name followed by _cmd. Parameters are command specific. A command usually return some bytes as the result of the command execution, or a status code. checkmac_cmd(tempkey_as_message_source:bool,tempkey_as_first_block:bool,source_flag:int,key_id:bytes, challenge:bytes,response:bytes,other_data:bytes) Verify a MAC calculated on another CryptoAuthentication device. Arguments: tempkey_as_message_source ( bool ) \u2013 If False the second 32 bytes of the SHA message are taken from challenge parameter, otherwise they are taken from TempKey. tempkey_as_first_block ( bool ) \u2013 If False Slot in first SHA block is used, otherwise TempKey is. source_flag ( int ) \u2013 Single bit. If tempkey_as_message_source or tempkey_as_first_block are set to True, then the value of this bit must match the value in TempKey.SourceFlag or the command will return an error. The flag is the fourth bit returned by info_cmd(\u2018State\u2019). key_id ( bytes ) \u2013 Internal key used to generate the response. All except last four bits are ignored. challenge ( bytes ) \u2013 32 bytes, challenge sent to client. If tempkey_as_message_source is True, this parameter will be ignored. response ( bytes ) \u2013 32 bytes, response generated by the client. other_data ( bytes ) \u2013 13 bytes, remaining constant data needed for response calculation. Returns: True if response matches the computed digest, False otherwise. Return type: bool read_counter_cmd(key_id) Read one of the two monotonic counters. Arguments: key_id ( int ) \u2013 The specified counter. Can be 0 or 1. Returns: 4 bytes representing the current value of the counter, or 1 byte representing a status code. Return type: bytes inc_counter_cmd(key_id) Increment one of the two monotonic counters. The maximum value that the counter may have is 2,097,151. Any attempt to count beyond this value will result in an error code. Arguments: key_id ( int ) \u2013 The specified counter. Can be 0 or 1. Returns: 4 bytes representing the current value of the counter, or 1 byte representing a status code. Return type: bytes derivekey_cmd(source_flag:int,target_key:bytes,mac=bytes()) The device combines the current value of a key with the nonce stored in TempKey using SHA-256 and places the result into the target key slot. Prior to execution of this command, nonce_cmd() must have been run to create a valid nonce in TempKey. For full documentation check datasheet at pages 63-64. Arguments: source_flag ( int ) \u2013 Single bit (1 or 0). The value of this bit must match the value in TempKey.SourceFlag or the command will return an error. The flag is the fourth bit returned by info_cmd() . target_key ( bytes ) \u2013 2 bytes. Key slot to be written. mac ( bytes ) \u2013 MAC used to validate the operation. (Default value = bytes()). Returns: True if the operation completed successfully. Return type: bool ecdh_cmd(key_id:bytes,x_comp:bytes,y_comp:bytes) Generate an ECDH master secret using stored private key and input public key. Arguments: key_id ( bytes ) \u2013 The private key to be used in the ECDH calculation. x_comp ( bytes ) \u2013 The X component of the public key to be used for ECDH calculation. y_comp ( bytes ) \u2013 The Y component of the public key to be used for ECDH calculation. Returns: If any error occured, the error code. If specified by SlotConfig.ReadKey<3>, the shared secret. Otherwise the success code 0x00. Return type: bytes gendig_cmd(self,zone:int,key_id:bytes,other_data=bytes()) Generate a data digest from a random or input seed and a key. See datasheet page 66-69 for full usage details. Arguments: zone ( int ) \u2013 Possible values are numbers between 0 and 5 (included). If 0x00 (Config), then use key_id to specify any of the four 256-bit blocks of the Configuration zone. If key_id has a value greater than three, the command will return an error. If 0x01 (OTP), use key_id to specify either the first or second 256-bit block of the OTP zone. If 0x02 (Data), then key_id specifies a slot in the Data zone or a transport key in the hardware array. If 0x03 (Shared Nonce), then key_id specifies the location of the input value in the message generation. If 0x04 (Counter), then key_id specifies the monotonic counter ID to be included in the message generation. If 0x05 (Key Config), then key_id specifies the slot for which the configuration information is to be included in the message generation. key_id ( bytes ) \u2013 Identification number of the key to be used, selection of which OTP block or message order for Shared Nonce mode. other_data ( bytes ) \u2013 4 bytes of data for SHA calculation when using a NoMac key, 32 bytes for \u201cShared Nonce\u201d mode, otherwise ignored. (Default value = bytes()) Returns: True if the operation completed successfully. Return type: bool gen_private_key(self,key_slot:int,create_digest=False,other_data=bytes(3)) Generate an ECC private key. Arguments: key_slot ( bytes ) \u2013 Specifies the slot where the private ECC key is generated. create_digest ( bool ) \u2013 If True the device creates a PubKey digest based on the private key in KeyID and places it in TempKey (ignored if create_digest is False). other_data ( bytes ) \u2013 3 bytes, used in the creation of the message used as input for the digest algorithm. Returns: 64 bytes representing public key X and Y coordinates or 1 byte representing a status code if an error occured. Return type: bytes gen_public_key(self,key_slot:int,create_digest=False,other_data=bytes(3)) Generate the ECC public key starting from a private key. Arguments: key_slot: ( int ) \u2013 Specifies the slot where the private ECC key is. create_digest ( bool ) \u2013 If True the device creates a PubKey digest based on the private key in KeyID and places it in TempKey (ignored if create_digest is False). other_data ( bytes ) \u2013 3 bytes, used in the creation of the message used as input for the digest algorithm. Returns: 64 bytes representing public key X and Y coordinates or 1 byte representing a status code if an error occured. Return type: bytes gen_digest_cmd(self,key_id:bytes,other_data:bytes) Generate a digest and store it in TempKey, using key_id as public key. Arguments: key_id ( bytes ) \u2013 Specifies the slot where the public ECC key is. other_data ( bytes ) \u2013 3 bytes, used in the creation of the message used as input for the digest algorithm. Returns: 64 bytes representing public key X and Y coordinates or 1 byte representing a status code if an error occured. Return type: bytes hmac_cmd(self,source_flag:int,key_id:bytes,include_sn:bool) Calculate response from key and other internal data using HMAC/SHA-256. Arguments: source_flag ( int ) \u2013 Single bit. The value of this bit must match the value in TempKey.SourceFlag (1 = True, 0 = False) or the command will return an error. The flag is the fourth bit returned by info_cmd(\u2018State\u2019). key_id ( bytes ) \u2013 Specifies the slot where the key is. Note that while only last four bits are used to select a slot, all the two bytes will be included in the digest message. include_sn ( bool ) \u2013 If True, 48 bits from Configuration Zone are included in the digest message. Returns: 32 bytes, the computed HMAC digest. Return type: bytes info_cmd(self,mode:str,param=bytes(2)) Return device state information. The information read can be static or dynamic. Arguments: zone ( str ) \u2013 Zone to read byte from. The value is case insensitive and can be one of Revision, KeyValid, State, GPIO. param ( bytes ) \u2013 Second parameter (Default value = bytes(2)) Returns: 4 bytes read from the device or 1 byte status code Return type: bytes lock_config_zone_cmd(self,checksum:bytes=None) Prevent further modifications to the Config zone of the device. Arguments: checksum ( bytes ) \u2013 2 bytes representing a CRC summary of the zone. If set the checksum is verified from the device prior locking. (Default value = None) Returns: Single byte 0 if the operation completed successfully. Return type: bytes lock_data_zone_cmd(checksum:bytes = None) Prevent further modifications to the Data and OTP zones of the device. Arguments: checksum ( bytes ) \u2013 2 bytes representing a CRC summary of the zone. If set the checksum is verified from the device prior locking. (Default value = None) Returns: Single byte 0 if the operation completed successfully. Return type: bytes lock_single_slot_cmd(self,slot_number:int) Prevent further modifications to a single slot of the device. Arguments: slot_number ( int ) \u2013 Slot ID to be locked, valid values are the numbers in range 0-15 (included). Returns: Single byte 0 if the operation completed successfully. Return type: bytes mac_cmd(self,key_id:bytes,use_tempkey:bool,include_sn:bool,source_flag:int = 0,challenge:bytes =bytes()) Compute a SHA-256 digest from key and other internal data using SHA-256. The normal command flow to use this command is as follows: Run Nonce command to load input challenge and optionally combine it with a generated random number. The result of this operation is a nonce stored internally on the device. Optionally, run GenDig command to combine one or more stored EEPROM locations in the device with the nonce. The result is stored internally in the device. This capability permits two or more keys to be used as part of the response generation. Run this MAC command to combine the output of step one (and step two if desired) with an EEPROM key to generate an output response (i.e. digest). Note source_flag MUST be specified if use_tempkey is True or a challenge is used. Arguments: key_id ( bytes ) \u2013 2 bytes. Specifies the slot where the key is. Note that while only last four bits are used to select a slot, all the two bytes will be included in the digest message. use_tempkey ( bool ) \u2013 If False the first 32 bytes of the SHA message are loaded from one of the data slots. Otherwise the first 32 bytes are filled with TempKey (and source_flag must be used). include_sn (bool) \u2013 If True, 48 bits from Configuration Zone are included in the digest message. source_flag ( int ) \u2013 Single bit. The value of this bit must match the value in TempKey.SourceFlag (1 = True, 0 = False) or the command will return an error. The flag is the fourth bit returned by info_cmd(\u2018State\u2019) . (Default value = 0) challenge ( bytes ) \u2013 32 bytes. If specified, it will be used in the input of the algorithm. (Default value = bytes()) Returns: 32 bytes, the computed SHA-256 digest. Return type: bytes nonce_cmd(self,use_tempkey:bool,num_in:bytes,force_no_eeprom_update:bool = False) Generate a 32-byte random number and an internally stored Nonce. The body used to create the nonce is stored internally in TempKey. Arguments: use_tempkey ( bool ) \u2013 TempKey is used instead of the RNG in the hash calculation input (message). TempKey is also returned by this command. TempKey must be valid prior to execution of this command and the values of the remaining TempKey flags remain unchanged. num_in ( bytes ) \u2013 20 bytes, the input parameter. force_no_eeprom_update ( bool ) \u2013 If True, the EEPROM is not updated before the RNG generation (the existing EEPROM is used, not recommended). (Default value = False) Returns: TempKey (32 bytes) if use_tempkey is True. Otherwise the RNG output. Return type: bytes nonce_passthrough_cmd(self,num_in:bytes) Pass-through mode of the Nonce command. TempKey is loaded with NumIn. No SHA-256 calculation is performed, and TempKey.SourceFlag is set to Input. (No data is returned to the system in this mode). Arguments: num_in ( bytes ) \u2013 32 bytes, input parameter. Returns: Single byte 0 if the operation completed successfully. Return type: bytes privwrite_cmd(self,encrypt_input:bool,key_id:bytes,value:bytes,mac:bytes) Write an ECC private key into a slot in the Data zone. For best security, PrivWrite should not be used, and private keys should be internally generated from the RNG using gen_private_key command. The slot indicated by this command must be configured via KeyConfig.Private to contain an ECC private key, and SlotConfig.IsSecret must be set to one. See datasheet page 80 for full details. Arguments: encrypt_input ( bool ) \u2013 If True, the input data is encrypt using TempKey. Otherwise, the input data is not encrypted - this is valid only when Data zone is unlocked. key_id ( bytes ) \u2013 2 bytes, slot id to be written. value ( bytes ) \u2013 36 bytes integer. Information to be written to the slot, first 4 bytes should be zero. mac ( bytes ) \u2013 32 bytes. Message Authentication Code to validate EEPROM Write operation. Returns: Single byte 0 if the operation completed successfully. Return type: bytes random_cmd(self,force_no_eeprom_update=False) Generate a random number. The number is generated using a seed stored in the EEPROM and a hardware RNG. Arguments: force_no_eeprom_update ( bool ) \u2013 If True, the EEPROM is not updated before the RNG generation (the existing EEPROM is used, not recommended). (Default value = False) Returns: 32 bytes, output of RNG. Prior to the configuration zone being locked, the RNG produces a value of 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00 to facilitate testing. Return type: bytes read_cmd(self,zone:str,address:bytes,read_32_bytes:bool) Read bytes from the device. This command can read bytes from an address of one of the memory zones See datasheet page 10 for zones details. Arguments: zone ( str ) \u2013 Select the source zone. Must be one of Config, OTP or Data. address ( bytes ) \u2013 2 bytes address of the first word to be read. See datasheet page 58 for correct formats. read_32_bytes ( bool ) \u2013 If True, 32 bytes are read and returned. Otherwise 4 bytes are read and returned. Returns: A single word (4 bytes) or a 8-words block (32 bytes), depending on the read_32_bytes parameter. The bytes can be encrypted depending on the zone and the device status. See datasheet page 81 for usage details. Return type: bytes sha_start_cmd(self) Start a SHA-256 digest computation. This command must be run before sha_end_cmd(). Returns: Single byte 0 if the operation completed correctly. Return type: bytes sha_hmacstart_cmd(self,key_id:bytes) Start a HMAC digest computation. This command must be run before sha_hmacend_cmd() . Arguments: key_id ( bytes ) \u2013 Id of the HMAC key. Returns: Single byte 0 if the operation completed correctly. Return type: bytes sha_update_cmd(self,message:bytes) Add 64 bytes in the message parameter to the SHA context. This command must be run after sha_start_cmd() or sha_hmacstart_cmd() . Arguments: message ( bytes ) \u2013 64 bytes, to be added in the SHA context. Returns: Single byte 0 if the operation completed correctly. Return type: bytes sha_public_cmd(self,key_id:bytes) Add 64 bytes of a public key stored in one of the Data zone slots to the SHA context. Arguments: key_id ( bytes ) \u2013 The slot id of the public key. Returns: Single byte 0 if the operation completed successfully, or an error if the slot contains anything other than a public key. Return type: bytes sha_end_cmd(message:bytes) Complete the SHA-256 computation and load the digest into TempKey and the output buffer. Up to 63 message bytes are accepted (Length must be 0 through 63 inclusive.) This command must be run after sha_start_cmd() and eventually after some sha_update_cmd(). Arguments: message ( bytes ) \u2013 0-63 bytes to be added in the SHA context before the final computation. Returns: 32 bytes representing the SHA256 digest. Return type: bytes sha_hmacend_cmd(message:bytes) Complete the HMAC computation and load the digest into TempKey and the output buffer. Up to 63 message bytes are accepted (length must be 0 through 63 inclusive). This command must be run after sha_hmacstart_cmd() and eventually after some sha_update_cmd(). Arguments: message ( bytes ) \u2013 0-63 bytes to be added in the SHA context before the final computation. Returns: 32 bytes representing the SHA256 digest. Return type: bytes sign_cmd(key_id:bytes,include_sn:bool,use_tempkey:bool,is_verify_invalidate:bool = False) ECDSA signature calculation from an internal private key. Arguments: key_id ( bytes ) \u2013 Internal private key used to generate the signature. include_sn ( bool ) \u2013 If True, 48 bits from Configuration Zone are included in the digest message. use_tempkey ( bool ) \u2013 If True, the message to be signed is in TempKey. Otherwise the message is internally generated (see datasheet page 86). is_verify_invalidate ( bool ) \u2013 This flag must be set to True if the command is being used by verify(invalidate) (Default value = False). Returns: 64 bytes representing the signature composed of R and S, or an error code. Return type: bytes updateextra_cmd(update_byte:int,new_value:int) Update bytes 84 or 85 within the Configuration zone after the Configuration zone has been locked. Arguments: update_byte ( int ) \u2013 Select the byte to be updated, can be one of 84 or 85. new_value ( int ) \u2013 New value to be written in the selected byte. update_byte \u2013 int: new_value \u2013 int: Returns: 0 if the operation succeded, or an error status code. Return type: bytes updateextra_decr_cmd(key_id) Decrement the limited use counter associated with the key in slot after the Configuration zone has been locked. If the slot indicated by the \u201cNewValue\u201d param does not contain a key for which limited use is implemented or enabled, then the command returns without taking any action. If the indicated slot contains a limited use key, which does not have any uses remaining, then the command returns an error. Arguments: key_id (bytes) \u2013 2 bytes, the slot id of the key to be decremented. Returns: 0 if the operation succeded, or an error status code. Return type: bytes verify_external_cmd(curve_type:int,r_comp:bytes,s_comp:bytes,x_comp:bytes,y_comp:bytes) Takes an ECDSA signature and verifies that it is correctly generated from a given message and public key. In this mode the public key is an external input. Prior to this command being run, the message should be written to TempKey using the Nonce command. Arguments: curve_type ( int ) \u2013 Curve type to be used to verify the signature: 0b100 = P256 NIST ECC key 0b111 = Not an ECC key The value in this field is encoded identically to the KeyType field in the KeyConfig words within the Configuration zone. * r_comp ( bytes ) \u2013 32 bytes, the R component of the ECDSA signature to be verified. * s_comp ( bytes ) \u2013 32 bytes, the S component of the ECDSA signature to be verified. * x_comp ( bytes ) \u2013 32 bytes, the X component of the public key to be used. * y_comp ( bytes ) \u2013 32 bytes, the X component of the public key to be used. Returns: 0 if the signature match. 1 if the signature doesn\u2019t match. An error status code if an error occured. Return type: bytes verify_stored_cmd(key_id:bytes,r_comp:bytes,s_comp:bytes) Takes an ECDSA signature and verifies that it is correctly generated from a given message and public key. In this mode the public key to be used is found in the KeyID EEPROM slot. The contents of TempKey should contain the SHA-256 digest of the message. Arguments: key_id ( bytes ) \u2013 2 bytes, the slot id containing the public key to be used. The key type is determined by KeyConfig.KeyType. r_comp ( bytes ) \u2013 32 bytes, the R component of the ECDSA signature to be verified. s_comp ( bytes ) \u2013 32 bytes, the S component of the ECDSA signature to be verified. Returns: 0 if the signature match. 1 if the signature doesn\u2019t match. An error status code if something went wrong. Return type: bytes verify_validate_cmd(key_id:bytes,r_comp:bytes,s_comp:bytes,other_data:bytes,invalidate:bool=False) The Validate and Invalidate modes are used to validate or invalidate the public key stored in the EEPROM. The contents of TempKey should contain a digest of the PublicKey at key_id. It must have been generated using genkey_cmd over the key_id slot. Arguments: key_id ( bytes ) \u2013 Slot id of the key to be (in)validated. The parent key to be used to perform the (in)validation is stored in SlotConfig.ReadKey.SlotConfig .KeyType determines the curve to be used. r_comp ( bytes ) \u2013 32 bytes, the R component of the ECDSA signature to be verified. s_comp ( bytes ) \u2013 32 bytes, the S component of the ECDSA signature to be verified. other_data ( bytes ) \u2013 19 bytes, the bytes used to generate the message for the validation. invalidate (bool) \u2013 If True set the mode to Invalidate instead of Validate. (Default value = False) Returns: 0 if the signature match. 1 if the signature doesn\u2019t match. An error status code if something went wrong. Return type: bytes verify_invalidate_cmd(key_id:bytes,r_comp:bytes,s_comp:bytes,other_data:bytes) Shortcut for verify_validate_cmd() using invalidate mode. verify_validate_external_cmd(key_id:bytes,r_comp:bytes,s_comp:bytes) The ValidateExternal mode is used to validate the public key stored in the EEPROM at key_id when X.509 format certificates are to be used. The digest of the message must be TempKey. TempKey must have been generated using the sha_public_cmd(), and the key for that computation must be the same as key_id. Arguments: key_id ( bytes ) \u2013 The slot containing the public key to be validated which must have been specified by a previous sha_public_cmd(). r_comp ( bytes ) \u2013 32 bytes, the R component of the ECDSA signature to be verified. s_comp ( bytes ) \u2013 32 bytes, the S component of the ECDSA signature to be verified. Returns: 0 if the signature match. 1 if the signature doesn\u2019t match. An error status code if something went wrong. Return type: bytes write_cmd(zone:str,address:bytes,value:bytes,is_input_encrypted:bool,mac:bytes=bytes()) Writes either one four byte word or an 8-word block of 32 bytes to one of the EEPROM zones on the device. Depending upon the value of the WriteConfig byte for this slot, the data may be required to be encrypted by the system prior to being sent to the device. Arguments: zone ( str ) \u2013 Select the source zone. Must be one of Config, OTP or Data. address ( bytes ) \u2013 2 bytes address of the first word to be written. See datasheet page 58 for correct formats. value ( bytes ) \u2013 4 or 32 bytes to be written in the specified address. May be encrypted (set is_input_encrypted to True). is_input_encrypted ( bool ) \u2013 Must be set to True if the input is encrypted. See datasheet page 91 for details. mac ( bytes ) \u2013 Message authentication code to validate address and data. (Default value = bytes()) is_locked(zone:str) Check if selected zone has been locked. Arguments: zone ( str ) \u2013 Select the zone to check. Must be one of Config or Data. Returns: True if selected zone is locked. Return type: bool serial_number() Retrieve secure element\u2019s 72-bit serial number. Returns: Serial number. Return type: bytes ATECC608A class \u00b6 class ATECC608A(i2c.I2C) Class for controlling the ATECC608A chip. This class inherits all ATECC508A methods. Zerynth HWCrypto Interface \u00b6 hwcrypto_init(i2c_drv,key_slot,i2c_addr=0x60,dev_type=DEV_ATECC508A) Note this function is available only when ZERYNTH_HWCRYPTO_ATECCx08A is set in project.yml file. Arguments: i2c_drv \u2013 Interface for I2C communication. (e.g. I2C0 ) key_slot \u2013 Chosen private key slot number (can be used to sign, compute public, \u2026) i2c_addr \u2013 Address of the I2C chip. (Default value = 0x60 ) dev_type \u2013 Crypto chip type (Default = DEV_ATECC508A , can also be DEV_ATECC108A or DEV_ATECC608A ) Init and enable the use of the crypto chip from other Zerynth libraries through Zerynth HWCrypto C interface. C interface based on Microchip Cryptoauth Lib .","title":"ATECCx08A library"},{"location":"reference/libs/microchip/ateccx08a/docs/ateccx08a/#ateccx08a-library","text":"This module exports classes for Microchip ATECCx08A chip family and some utilities functions. Furthermore an interface to allow the use of chip-related functionalities from other Zerynth hybrid C/Python libraries is made available.","title":"ATECCx08A library"},{"location":"reference/libs/microchip/ateccx08a/docs/ateccx08a/#auxiliary-methods","text":"","title":"Auxiliary methods"},{"location":"reference/libs/microchip/ateccx08a/docs/ateccx08a/#crc16","text":"crc16 ( data : bytes ) Compute the CRC16 checksum for some bytes. The CRC is calculated using 0x8005 as polynomial and starting with the registry set as 0x00. Arguments: data ( bytes ) \u2013 bytes to be checksummed. Returns: 2 bytes, representing the computed checksum. Return type: bytes","title":"crc16"},{"location":"reference/libs/microchip/ateccx08a/docs/ateccx08a/#atecc508a-class","text":"","title":"ATECC508A class"},{"location":"reference/libs/microchip/ateccx08a/docs/ateccx08a/#class-atecc508a","text":"class ATECC508A ( i2c . I2C ) Class for controlling the ATECC508A chip. Members: device_awake : Boolean. If True the device is running a multiple commands sequence.","title":"class ATECC508A"},{"location":"reference/libs/microchip/ateccx08a/docs/ateccx08a/#atecc508ainit","text":"__init__ ( drvname , addr = DEFAULT_ADDR , clk = 100000 ) Connect to a device and start I2C protocol. Arguments: drvname \u2013 Interface for I2C communication (e.g. I2C0) addr ( int [0-255] ) \u2013 Address of the I2C chip. (Default value = 0x60 for ATECC508A) clk ( int ) \u2013 Clock rate of the I2C communication in kHz. (Default value = 100000).","title":"ATECC508A.init"},{"location":"reference/libs/microchip/ateccx08a/docs/ateccx08a/#internal-methods","text":"","title":"Internal methods"},{"location":"reference/libs/microchip/ateccx08a/docs/ateccx08a/#atecc508a_send_cmd","text":"_send_cmd ( self , opcode , param1 , param2 : bytes , data = bytes ()) Send a command packet to the device. Output packet structure: [ 0x03 ][ length ][ opcode ][ p1 ][ p2 ][ \u2026data\u2026 ][ crc ] 0x03 is a constant defined in WORD_ADDRS at the beginning of this module. length includes every bytes except the first 0x03 byte. p1 is byte of length 1. (mandatory) p2 is bytes of length 2. (mandatory) data is optional and can have arbitraty length. crc is a 2 byte checksum (calculated using ecc508a.crc16() ). Arguments: opcode ( int ) \u2013 The code representing the selected command. Check OPCODES at the beginning of this module. param1 ( int ) \u2013 The first mandatory parameter. 1 byte long. param2 ( bytes ) \u2013 The second mandatory parameter. 2 bytes long. data ( bytes ) \u2013 Other optional data. (Default value = bytes())","title":"ATECC508A._send_cmd"},{"location":"reference/libs/microchip/ateccx08a/docs/ateccx08a/#atecc508a_read_result","text":"_read_result () Read, verify checksum, and extract data of a packet from the device. Input packet structure: [ length ][ \u2026data\u2026 ][ crc ] Returns: the extracted data bytes. Return type: bytes Note Length includes itself (1 byte), data (n bytes), and crc16 (2 bytes).","title":"ATECC508A._read_result"},{"location":"reference/libs/microchip/ateccx08a/docs/ateccx08a/#public-methods","text":"","title":"Public methods"},{"location":"reference/libs/microchip/ateccx08a/docs/ateccx08a/#atecc508astart_cmd_sequence","text":"start_cmd_sequence () Call this function before a command sequence to wake up device from idle mode. This is done by keeping SDA low for more than 60 microseconds. Note At this moment a 0x00 byte is written as a normal I2C transaction, ignoring the exception raised. This workaround won\u2019t work at higher clock rates (more than ~100 kHz)!","title":"ATECC508A.start_cmd_sequence"},{"location":"reference/libs/microchip/ateccx08a/docs/ateccx08a/#atecc508aend_cmd_sequence","text":"end_cmd_sequence () Call this function at the end of a command sequence to put the device in idle mode. This must be done in order to avoid hitting the watchdog timeout (~1 second) which will put the device in idle mode no matter what. send_and_read(*args) Send a command and return the result data. Note If start_cmd_sequence() was not invoked before this method, the device is automatically woke up and put again in idle mode after the command execution. (Default value = 50) Arguments: ***args** \u2013 All arguments are passed to _send_cmd() method.","title":"ATECC508A.end_cmd_sequence"},{"location":"reference/libs/microchip/ateccx08a/docs/ateccx08a/#commands","text":"The functions names are the lowercase command name followed by _cmd. Parameters are command specific. A command usually return some bytes as the result of the command execution, or a status code. checkmac_cmd(tempkey_as_message_source:bool,tempkey_as_first_block:bool,source_flag:int,key_id:bytes, challenge:bytes,response:bytes,other_data:bytes) Verify a MAC calculated on another CryptoAuthentication device. Arguments: tempkey_as_message_source ( bool ) \u2013 If False the second 32 bytes of the SHA message are taken from challenge parameter, otherwise they are taken from TempKey. tempkey_as_first_block ( bool ) \u2013 If False Slot in first SHA block is used, otherwise TempKey is. source_flag ( int ) \u2013 Single bit. If tempkey_as_message_source or tempkey_as_first_block are set to True, then the value of this bit must match the value in TempKey.SourceFlag or the command will return an error. The flag is the fourth bit returned by info_cmd(\u2018State\u2019). key_id ( bytes ) \u2013 Internal key used to generate the response. All except last four bits are ignored. challenge ( bytes ) \u2013 32 bytes, challenge sent to client. If tempkey_as_message_source is True, this parameter will be ignored. response ( bytes ) \u2013 32 bytes, response generated by the client. other_data ( bytes ) \u2013 13 bytes, remaining constant data needed for response calculation. Returns: True if response matches the computed digest, False otherwise. Return type: bool read_counter_cmd(key_id) Read one of the two monotonic counters. Arguments: key_id ( int ) \u2013 The specified counter. Can be 0 or 1. Returns: 4 bytes representing the current value of the counter, or 1 byte representing a status code. Return type: bytes inc_counter_cmd(key_id) Increment one of the two monotonic counters. The maximum value that the counter may have is 2,097,151. Any attempt to count beyond this value will result in an error code. Arguments: key_id ( int ) \u2013 The specified counter. Can be 0 or 1. Returns: 4 bytes representing the current value of the counter, or 1 byte representing a status code. Return type: bytes derivekey_cmd(source_flag:int,target_key:bytes,mac=bytes()) The device combines the current value of a key with the nonce stored in TempKey using SHA-256 and places the result into the target key slot. Prior to execution of this command, nonce_cmd() must have been run to create a valid nonce in TempKey. For full documentation check datasheet at pages 63-64. Arguments: source_flag ( int ) \u2013 Single bit (1 or 0). The value of this bit must match the value in TempKey.SourceFlag or the command will return an error. The flag is the fourth bit returned by info_cmd() . target_key ( bytes ) \u2013 2 bytes. Key slot to be written. mac ( bytes ) \u2013 MAC used to validate the operation. (Default value = bytes()). Returns: True if the operation completed successfully. Return type: bool ecdh_cmd(key_id:bytes,x_comp:bytes,y_comp:bytes) Generate an ECDH master secret using stored private key and input public key. Arguments: key_id ( bytes ) \u2013 The private key to be used in the ECDH calculation. x_comp ( bytes ) \u2013 The X component of the public key to be used for ECDH calculation. y_comp ( bytes ) \u2013 The Y component of the public key to be used for ECDH calculation. Returns: If any error occured, the error code. If specified by SlotConfig.ReadKey<3>, the shared secret. Otherwise the success code 0x00. Return type: bytes gendig_cmd(self,zone:int,key_id:bytes,other_data=bytes()) Generate a data digest from a random or input seed and a key. See datasheet page 66-69 for full usage details. Arguments: zone ( int ) \u2013 Possible values are numbers between 0 and 5 (included). If 0x00 (Config), then use key_id to specify any of the four 256-bit blocks of the Configuration zone. If key_id has a value greater than three, the command will return an error. If 0x01 (OTP), use key_id to specify either the first or second 256-bit block of the OTP zone. If 0x02 (Data), then key_id specifies a slot in the Data zone or a transport key in the hardware array. If 0x03 (Shared Nonce), then key_id specifies the location of the input value in the message generation. If 0x04 (Counter), then key_id specifies the monotonic counter ID to be included in the message generation. If 0x05 (Key Config), then key_id specifies the slot for which the configuration information is to be included in the message generation. key_id ( bytes ) \u2013 Identification number of the key to be used, selection of which OTP block or message order for Shared Nonce mode. other_data ( bytes ) \u2013 4 bytes of data for SHA calculation when using a NoMac key, 32 bytes for \u201cShared Nonce\u201d mode, otherwise ignored. (Default value = bytes()) Returns: True if the operation completed successfully. Return type: bool gen_private_key(self,key_slot:int,create_digest=False,other_data=bytes(3)) Generate an ECC private key. Arguments: key_slot ( bytes ) \u2013 Specifies the slot where the private ECC key is generated. create_digest ( bool ) \u2013 If True the device creates a PubKey digest based on the private key in KeyID and places it in TempKey (ignored if create_digest is False). other_data ( bytes ) \u2013 3 bytes, used in the creation of the message used as input for the digest algorithm. Returns: 64 bytes representing public key X and Y coordinates or 1 byte representing a status code if an error occured. Return type: bytes gen_public_key(self,key_slot:int,create_digest=False,other_data=bytes(3)) Generate the ECC public key starting from a private key. Arguments: key_slot: ( int ) \u2013 Specifies the slot where the private ECC key is. create_digest ( bool ) \u2013 If True the device creates a PubKey digest based on the private key in KeyID and places it in TempKey (ignored if create_digest is False). other_data ( bytes ) \u2013 3 bytes, used in the creation of the message used as input for the digest algorithm. Returns: 64 bytes representing public key X and Y coordinates or 1 byte representing a status code if an error occured. Return type: bytes gen_digest_cmd(self,key_id:bytes,other_data:bytes) Generate a digest and store it in TempKey, using key_id as public key. Arguments: key_id ( bytes ) \u2013 Specifies the slot where the public ECC key is. other_data ( bytes ) \u2013 3 bytes, used in the creation of the message used as input for the digest algorithm. Returns: 64 bytes representing public key X and Y coordinates or 1 byte representing a status code if an error occured. Return type: bytes hmac_cmd(self,source_flag:int,key_id:bytes,include_sn:bool) Calculate response from key and other internal data using HMAC/SHA-256. Arguments: source_flag ( int ) \u2013 Single bit. The value of this bit must match the value in TempKey.SourceFlag (1 = True, 0 = False) or the command will return an error. The flag is the fourth bit returned by info_cmd(\u2018State\u2019). key_id ( bytes ) \u2013 Specifies the slot where the key is. Note that while only last four bits are used to select a slot, all the two bytes will be included in the digest message. include_sn ( bool ) \u2013 If True, 48 bits from Configuration Zone are included in the digest message. Returns: 32 bytes, the computed HMAC digest. Return type: bytes info_cmd(self,mode:str,param=bytes(2)) Return device state information. The information read can be static or dynamic. Arguments: zone ( str ) \u2013 Zone to read byte from. The value is case insensitive and can be one of Revision, KeyValid, State, GPIO. param ( bytes ) \u2013 Second parameter (Default value = bytes(2)) Returns: 4 bytes read from the device or 1 byte status code Return type: bytes lock_config_zone_cmd(self,checksum:bytes=None) Prevent further modifications to the Config zone of the device. Arguments: checksum ( bytes ) \u2013 2 bytes representing a CRC summary of the zone. If set the checksum is verified from the device prior locking. (Default value = None) Returns: Single byte 0 if the operation completed successfully. Return type: bytes lock_data_zone_cmd(checksum:bytes = None) Prevent further modifications to the Data and OTP zones of the device. Arguments: checksum ( bytes ) \u2013 2 bytes representing a CRC summary of the zone. If set the checksum is verified from the device prior locking. (Default value = None) Returns: Single byte 0 if the operation completed successfully. Return type: bytes lock_single_slot_cmd(self,slot_number:int) Prevent further modifications to a single slot of the device. Arguments: slot_number ( int ) \u2013 Slot ID to be locked, valid values are the numbers in range 0-15 (included). Returns: Single byte 0 if the operation completed successfully. Return type: bytes mac_cmd(self,key_id:bytes,use_tempkey:bool,include_sn:bool,source_flag:int = 0,challenge:bytes =bytes()) Compute a SHA-256 digest from key and other internal data using SHA-256. The normal command flow to use this command is as follows: Run Nonce command to load input challenge and optionally combine it with a generated random number. The result of this operation is a nonce stored internally on the device. Optionally, run GenDig command to combine one or more stored EEPROM locations in the device with the nonce. The result is stored internally in the device. This capability permits two or more keys to be used as part of the response generation. Run this MAC command to combine the output of step one (and step two if desired) with an EEPROM key to generate an output response (i.e. digest). Note source_flag MUST be specified if use_tempkey is True or a challenge is used. Arguments: key_id ( bytes ) \u2013 2 bytes. Specifies the slot where the key is. Note that while only last four bits are used to select a slot, all the two bytes will be included in the digest message. use_tempkey ( bool ) \u2013 If False the first 32 bytes of the SHA message are loaded from one of the data slots. Otherwise the first 32 bytes are filled with TempKey (and source_flag must be used). include_sn (bool) \u2013 If True, 48 bits from Configuration Zone are included in the digest message. source_flag ( int ) \u2013 Single bit. The value of this bit must match the value in TempKey.SourceFlag (1 = True, 0 = False) or the command will return an error. The flag is the fourth bit returned by info_cmd(\u2018State\u2019) . (Default value = 0) challenge ( bytes ) \u2013 32 bytes. If specified, it will be used in the input of the algorithm. (Default value = bytes()) Returns: 32 bytes, the computed SHA-256 digest. Return type: bytes nonce_cmd(self,use_tempkey:bool,num_in:bytes,force_no_eeprom_update:bool = False) Generate a 32-byte random number and an internally stored Nonce. The body used to create the nonce is stored internally in TempKey. Arguments: use_tempkey ( bool ) \u2013 TempKey is used instead of the RNG in the hash calculation input (message). TempKey is also returned by this command. TempKey must be valid prior to execution of this command and the values of the remaining TempKey flags remain unchanged. num_in ( bytes ) \u2013 20 bytes, the input parameter. force_no_eeprom_update ( bool ) \u2013 If True, the EEPROM is not updated before the RNG generation (the existing EEPROM is used, not recommended). (Default value = False) Returns: TempKey (32 bytes) if use_tempkey is True. Otherwise the RNG output. Return type: bytes nonce_passthrough_cmd(self,num_in:bytes) Pass-through mode of the Nonce command. TempKey is loaded with NumIn. No SHA-256 calculation is performed, and TempKey.SourceFlag is set to Input. (No data is returned to the system in this mode). Arguments: num_in ( bytes ) \u2013 32 bytes, input parameter. Returns: Single byte 0 if the operation completed successfully. Return type: bytes privwrite_cmd(self,encrypt_input:bool,key_id:bytes,value:bytes,mac:bytes) Write an ECC private key into a slot in the Data zone. For best security, PrivWrite should not be used, and private keys should be internally generated from the RNG using gen_private_key command. The slot indicated by this command must be configured via KeyConfig.Private to contain an ECC private key, and SlotConfig.IsSecret must be set to one. See datasheet page 80 for full details. Arguments: encrypt_input ( bool ) \u2013 If True, the input data is encrypt using TempKey. Otherwise, the input data is not encrypted - this is valid only when Data zone is unlocked. key_id ( bytes ) \u2013 2 bytes, slot id to be written. value ( bytes ) \u2013 36 bytes integer. Information to be written to the slot, first 4 bytes should be zero. mac ( bytes ) \u2013 32 bytes. Message Authentication Code to validate EEPROM Write operation. Returns: Single byte 0 if the operation completed successfully. Return type: bytes random_cmd(self,force_no_eeprom_update=False) Generate a random number. The number is generated using a seed stored in the EEPROM and a hardware RNG. Arguments: force_no_eeprom_update ( bool ) \u2013 If True, the EEPROM is not updated before the RNG generation (the existing EEPROM is used, not recommended). (Default value = False) Returns: 32 bytes, output of RNG. Prior to the configuration zone being locked, the RNG produces a value of 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00 to facilitate testing. Return type: bytes read_cmd(self,zone:str,address:bytes,read_32_bytes:bool) Read bytes from the device. This command can read bytes from an address of one of the memory zones See datasheet page 10 for zones details. Arguments: zone ( str ) \u2013 Select the source zone. Must be one of Config, OTP or Data. address ( bytes ) \u2013 2 bytes address of the first word to be read. See datasheet page 58 for correct formats. read_32_bytes ( bool ) \u2013 If True, 32 bytes are read and returned. Otherwise 4 bytes are read and returned. Returns: A single word (4 bytes) or a 8-words block (32 bytes), depending on the read_32_bytes parameter. The bytes can be encrypted depending on the zone and the device status. See datasheet page 81 for usage details. Return type: bytes sha_start_cmd(self) Start a SHA-256 digest computation. This command must be run before sha_end_cmd(). Returns: Single byte 0 if the operation completed correctly. Return type: bytes sha_hmacstart_cmd(self,key_id:bytes) Start a HMAC digest computation. This command must be run before sha_hmacend_cmd() . Arguments: key_id ( bytes ) \u2013 Id of the HMAC key. Returns: Single byte 0 if the operation completed correctly. Return type: bytes sha_update_cmd(self,message:bytes) Add 64 bytes in the message parameter to the SHA context. This command must be run after sha_start_cmd() or sha_hmacstart_cmd() . Arguments: message ( bytes ) \u2013 64 bytes, to be added in the SHA context. Returns: Single byte 0 if the operation completed correctly. Return type: bytes sha_public_cmd(self,key_id:bytes) Add 64 bytes of a public key stored in one of the Data zone slots to the SHA context. Arguments: key_id ( bytes ) \u2013 The slot id of the public key. Returns: Single byte 0 if the operation completed successfully, or an error if the slot contains anything other than a public key. Return type: bytes sha_end_cmd(message:bytes) Complete the SHA-256 computation and load the digest into TempKey and the output buffer. Up to 63 message bytes are accepted (Length must be 0 through 63 inclusive.) This command must be run after sha_start_cmd() and eventually after some sha_update_cmd(). Arguments: message ( bytes ) \u2013 0-63 bytes to be added in the SHA context before the final computation. Returns: 32 bytes representing the SHA256 digest. Return type: bytes sha_hmacend_cmd(message:bytes) Complete the HMAC computation and load the digest into TempKey and the output buffer. Up to 63 message bytes are accepted (length must be 0 through 63 inclusive). This command must be run after sha_hmacstart_cmd() and eventually after some sha_update_cmd(). Arguments: message ( bytes ) \u2013 0-63 bytes to be added in the SHA context before the final computation. Returns: 32 bytes representing the SHA256 digest. Return type: bytes sign_cmd(key_id:bytes,include_sn:bool,use_tempkey:bool,is_verify_invalidate:bool = False) ECDSA signature calculation from an internal private key. Arguments: key_id ( bytes ) \u2013 Internal private key used to generate the signature. include_sn ( bool ) \u2013 If True, 48 bits from Configuration Zone are included in the digest message. use_tempkey ( bool ) \u2013 If True, the message to be signed is in TempKey. Otherwise the message is internally generated (see datasheet page 86). is_verify_invalidate ( bool ) \u2013 This flag must be set to True if the command is being used by verify(invalidate) (Default value = False). Returns: 64 bytes representing the signature composed of R and S, or an error code. Return type: bytes updateextra_cmd(update_byte:int,new_value:int) Update bytes 84 or 85 within the Configuration zone after the Configuration zone has been locked. Arguments: update_byte ( int ) \u2013 Select the byte to be updated, can be one of 84 or 85. new_value ( int ) \u2013 New value to be written in the selected byte. update_byte \u2013 int: new_value \u2013 int: Returns: 0 if the operation succeded, or an error status code. Return type: bytes updateextra_decr_cmd(key_id) Decrement the limited use counter associated with the key in slot after the Configuration zone has been locked. If the slot indicated by the \u201cNewValue\u201d param does not contain a key for which limited use is implemented or enabled, then the command returns without taking any action. If the indicated slot contains a limited use key, which does not have any uses remaining, then the command returns an error. Arguments: key_id (bytes) \u2013 2 bytes, the slot id of the key to be decremented. Returns: 0 if the operation succeded, or an error status code. Return type: bytes verify_external_cmd(curve_type:int,r_comp:bytes,s_comp:bytes,x_comp:bytes,y_comp:bytes) Takes an ECDSA signature and verifies that it is correctly generated from a given message and public key. In this mode the public key is an external input. Prior to this command being run, the message should be written to TempKey using the Nonce command. Arguments: curve_type ( int ) \u2013 Curve type to be used to verify the signature: 0b100 = P256 NIST ECC key 0b111 = Not an ECC key The value in this field is encoded identically to the KeyType field in the KeyConfig words within the Configuration zone. * r_comp ( bytes ) \u2013 32 bytes, the R component of the ECDSA signature to be verified. * s_comp ( bytes ) \u2013 32 bytes, the S component of the ECDSA signature to be verified. * x_comp ( bytes ) \u2013 32 bytes, the X component of the public key to be used. * y_comp ( bytes ) \u2013 32 bytes, the X component of the public key to be used. Returns: 0 if the signature match. 1 if the signature doesn\u2019t match. An error status code if an error occured. Return type: bytes verify_stored_cmd(key_id:bytes,r_comp:bytes,s_comp:bytes) Takes an ECDSA signature and verifies that it is correctly generated from a given message and public key. In this mode the public key to be used is found in the KeyID EEPROM slot. The contents of TempKey should contain the SHA-256 digest of the message. Arguments: key_id ( bytes ) \u2013 2 bytes, the slot id containing the public key to be used. The key type is determined by KeyConfig.KeyType. r_comp ( bytes ) \u2013 32 bytes, the R component of the ECDSA signature to be verified. s_comp ( bytes ) \u2013 32 bytes, the S component of the ECDSA signature to be verified. Returns: 0 if the signature match. 1 if the signature doesn\u2019t match. An error status code if something went wrong. Return type: bytes verify_validate_cmd(key_id:bytes,r_comp:bytes,s_comp:bytes,other_data:bytes,invalidate:bool=False) The Validate and Invalidate modes are used to validate or invalidate the public key stored in the EEPROM. The contents of TempKey should contain a digest of the PublicKey at key_id. It must have been generated using genkey_cmd over the key_id slot. Arguments: key_id ( bytes ) \u2013 Slot id of the key to be (in)validated. The parent key to be used to perform the (in)validation is stored in SlotConfig.ReadKey.SlotConfig .KeyType determines the curve to be used. r_comp ( bytes ) \u2013 32 bytes, the R component of the ECDSA signature to be verified. s_comp ( bytes ) \u2013 32 bytes, the S component of the ECDSA signature to be verified. other_data ( bytes ) \u2013 19 bytes, the bytes used to generate the message for the validation. invalidate (bool) \u2013 If True set the mode to Invalidate instead of Validate. (Default value = False) Returns: 0 if the signature match. 1 if the signature doesn\u2019t match. An error status code if something went wrong. Return type: bytes verify_invalidate_cmd(key_id:bytes,r_comp:bytes,s_comp:bytes,other_data:bytes) Shortcut for verify_validate_cmd() using invalidate mode. verify_validate_external_cmd(key_id:bytes,r_comp:bytes,s_comp:bytes) The ValidateExternal mode is used to validate the public key stored in the EEPROM at key_id when X.509 format certificates are to be used. The digest of the message must be TempKey. TempKey must have been generated using the sha_public_cmd(), and the key for that computation must be the same as key_id. Arguments: key_id ( bytes ) \u2013 The slot containing the public key to be validated which must have been specified by a previous sha_public_cmd(). r_comp ( bytes ) \u2013 32 bytes, the R component of the ECDSA signature to be verified. s_comp ( bytes ) \u2013 32 bytes, the S component of the ECDSA signature to be verified. Returns: 0 if the signature match. 1 if the signature doesn\u2019t match. An error status code if something went wrong. Return type: bytes write_cmd(zone:str,address:bytes,value:bytes,is_input_encrypted:bool,mac:bytes=bytes()) Writes either one four byte word or an 8-word block of 32 bytes to one of the EEPROM zones on the device. Depending upon the value of the WriteConfig byte for this slot, the data may be required to be encrypted by the system prior to being sent to the device. Arguments: zone ( str ) \u2013 Select the source zone. Must be one of Config, OTP or Data. address ( bytes ) \u2013 2 bytes address of the first word to be written. See datasheet page 58 for correct formats. value ( bytes ) \u2013 4 or 32 bytes to be written in the specified address. May be encrypted (set is_input_encrypted to True). is_input_encrypted ( bool ) \u2013 Must be set to True if the input is encrypted. See datasheet page 91 for details. mac ( bytes ) \u2013 Message authentication code to validate address and data. (Default value = bytes()) is_locked(zone:str) Check if selected zone has been locked. Arguments: zone ( str ) \u2013 Select the zone to check. Must be one of Config or Data. Returns: True if selected zone is locked. Return type: bool serial_number() Retrieve secure element\u2019s 72-bit serial number. Returns: Serial number. Return type: bytes","title":"Commands"},{"location":"reference/libs/microchip/ateccx08a/docs/ateccx08a/#atecc608a-class","text":"class ATECC608A(i2c.I2C) Class for controlling the ATECC608A chip. This class inherits all ATECC508A methods.","title":"ATECC608A class"},{"location":"reference/libs/microchip/ateccx08a/docs/ateccx08a/#zerynth-hwcrypto-interface","text":"hwcrypto_init(i2c_drv,key_slot,i2c_addr=0x60,dev_type=DEV_ATECC508A) Note this function is available only when ZERYNTH_HWCRYPTO_ATECCx08A is set in project.yml file. Arguments: i2c_drv \u2013 Interface for I2C communication. (e.g. I2C0 ) key_slot \u2013 Chosen private key slot number (can be used to sign, compute public, \u2026) i2c_addr \u2013 Address of the I2C chip. (Default value = 0x60 ) dev_type \u2013 Crypto chip type (Default = DEV_ATECC508A , can also be DEV_ATECC108A or DEV_ATECC608A ) Init and enable the use of the crypto chip from other Zerynth libraries through Zerynth HWCrypto C interface. C interface based on Microchip Cryptoauth Lib .","title":"Zerynth HWCrypto Interface"},{"location":"reference/libs/microchip/ateccx08a/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.microchip.ateccx08a. Ping example \u00b6 The simplest example to be tried for starting with the Zerynth ATECCx08A library and the ATECC508A crypto element. Simply read the Revision bytes of the chip, checking if they are the expected ones. main.py \"\"\" Simplest example of usage for the ATECCx08A library with ATECC508A crypto element. This module can be used an easy check device correct functioning. \"\"\" import streams from microchip.ateccx08a import ateccx08a PORT = I2C0 CLOCK = 100000 streams . serial () crypto = ateccx08a . ATECC508A ( PORT , clk = CLOCK ) def bytes_hex ( data ): \"\"\" Return hex string representation of bytes/bytearray object. \"\"\" res = \"0x\" for byte in data : res += \" %02X \" % byte return res def info_cmd_test (): \"\"\" Send an info command and check the result, which is a chip constant. \"\"\" expected = bytes ([ 0x00 , 0x00 , 0x50 , 0x00 ]) response = crypto . info_cmd ( 'REVISION' ) if response == expected : print ( \"Success. Device replied correctly.\" ) else : print ( \"Response from device not matching:\" ) print ( bytes_hex ( response )) while True : try : info_cmd_test () except Exception as err : print ( err ) sleep ( 1000 )","title":"Examples"},{"location":"reference/libs/microchip/ateccx08a/docs/examples/#examples","text":"The following are a list of examples for lib.microchip.ateccx08a.","title":"Examples"},{"location":"reference/libs/microchip/ateccx08a/docs/examples/#ping-example","text":"The simplest example to be tried for starting with the Zerynth ATECCx08A library and the ATECC508A crypto element. Simply read the Revision bytes of the chip, checking if they are the expected ones. main.py \"\"\" Simplest example of usage for the ATECCx08A library with ATECC508A crypto element. This module can be used an easy check device correct functioning. \"\"\" import streams from microchip.ateccx08a import ateccx08a PORT = I2C0 CLOCK = 100000 streams . serial () crypto = ateccx08a . ATECC508A ( PORT , clk = CLOCK ) def bytes_hex ( data ): \"\"\" Return hex string representation of bytes/bytearray object. \"\"\" res = \"0x\" for byte in data : res += \" %02X \" % byte return res def info_cmd_test (): \"\"\" Send an info command and check the result, which is a chip constant. \"\"\" expected = bytes ([ 0x00 , 0x00 , 0x50 , 0x00 ]) response = crypto . info_cmd ( 'REVISION' ) if response == expected : print ( \"Success. Device replied correctly.\" ) else : print ( \"Response from device not matching:\" ) print ( bytes_hex ( response )) while True : try : info_cmd_test () except Exception as err : print ( err ) sleep ( 1000 )","title":"Ping example"},{"location":"reference/libs/microchip/mcp2515/docs/","text":"Microchip MCP2515 \u00b6 Microchip Technology\u2019s MCP2515 is a stand-alone Controller Area Network (CAN) that implements the CAN specification, Version 2.0B. It is capable of transmitting and receiving both standard and extended data and remote frames. The MCP2515 has two acceptance masks and six acceptance filters that are used to filter out unwanted messages, thereby reducing the host MCU\u2019s overhead. The MCP2515 interfaces with microcontrollers (MCUs) via an industry standard Serial Peripheral Interface (SPI). More Info in Microchip dedicated page . Technical Details \u00b6 Implements CAN V2.0B at 1 Mb/s 0 to 8-byte length in the data field Receive Buffers, Masks and Filters Standard and extended data and remote frames 5 mA active current (typical) Supply Voltage (Vdd): from 2.7 V to 5.5 V Temperature range: -40\u00b0C to +125\u00b0C Here below, the Zerynth driver for the Microchip MCP2515. Contents: MCP2515 class Examples can loopback can communication","title":"Microchip MCP2515"},{"location":"reference/libs/microchip/mcp2515/docs/#microchip-mcp2515","text":"Microchip Technology\u2019s MCP2515 is a stand-alone Controller Area Network (CAN) that implements the CAN specification, Version 2.0B. It is capable of transmitting and receiving both standard and extended data and remote frames. The MCP2515 has two acceptance masks and six acceptance filters that are used to filter out unwanted messages, thereby reducing the host MCU\u2019s overhead. The MCP2515 interfaces with microcontrollers (MCUs) via an industry standard Serial Peripheral Interface (SPI). More Info in Microchip dedicated page .","title":"Microchip MCP2515"},{"location":"reference/libs/microchip/mcp2515/docs/#technical-details","text":"Implements CAN V2.0B at 1 Mb/s 0 to 8-byte length in the data field Receive Buffers, Masks and Filters Standard and extended data and remote frames 5 mA active current (typical) Supply Voltage (Vdd): from 2.7 V to 5.5 V Temperature range: -40\u00b0C to +125\u00b0C Here below, the Zerynth driver for the Microchip MCP2515. Contents: MCP2515 class Examples can loopback can communication","title":"Technical Details"},{"location":"reference/libs/microchip/mcp2515/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.microchip.mcp2515. CAN Loopback Example \u00b6 This example sends/receives an echo message over mcp2515 in loopback mode. This example will test the functionality of the protocol controller, and connections to it. No CAN Bus is required. main.py ################################################################################ # CAN Loopback Example # # Created: 2018-03-05 11:25:41.189984 # ################################################################################ from microchip.mcp2515 import mcp2515 import streams streams . serial () print ( \"start...\" ) try : # This setup is referred to CAN SPI click mounted on flip n click device slot A can = mcp2515 . MCP2515 ( SPI0 , D17 , D16 , clk = 10000000 ) print ( \"...done\" ) print ( \"init...\" ) can . init ( mcp2515 . MCP_ANY , \"500KBPS\" , \"16MHZ\" ) can . set_mode ( \"LOOPBACK\" ) print ( \"...done\" ) print ( \"ready!\" ) print ( \"--------------------------------------------------------\" ) except Exception as e : print ( e ) sleep ( 1000 ) canid = bytearray ([ 0x00 , 0x00 , 0x01 , 0x00 ]) data = [ 0x98 , 0xBB , 0x40 , 0xAC , 0x58 , 0x33 , 0x12 , 0x3E ] # interrupt pin pinMode ( D21 , INPUT ) while True : try : if not digitalRead ( D21 ): id_rx , msg_rx = can . recv () if id_rx [ 3 ] & 0x80 == 0x80 : print ( \"Ext ID:\" , [ e for e in id_rx ], \"DLC:\" , len ( msg_rx )) else : print ( \"Std ID:\" , [ e for e in id_rx ], \"DLC:\" , len ( msg_rx )) if id_rx [ 3 ] & 0x40 == 0x40 : print ( \"remote request frame\" ) else : print ( \"Data:\" , [ x for x in msg_rx ]) sleep ( 500 ) print ( \"sending msg...\" ) can . send ( canid , data ) print ( \"...done\" ) except Exception as e : print ( e ) sleep ( 1000 ) CAN Communication Example \u00b6 In this example CAN Receiver and Transmitter are implemented. 2 devices connected in CAN Bus needed for this example. main.py ################################################################################ # CAN Communication Example # # Created: 2018-03-05 11:25:41.189984 # ################################################################################ from microchip.mcp2515 import mcp2515 import streams streams . serial () print ( \"start...\" ) try : # This setup is referred to CAN SPI click mounted on flip n click device slot A can = mcp2515 . MCP2515 ( SPI0 , D17 , D16 , clk = 10000000 ) print ( \"...done\" ) print ( \"init...\" ) can . init ( mcp2515 . MCP_ANY , \"500KBPS\" , \"16MHZ\" ) can . set_mode ( \"NORMAL\" ) print ( \"...done\" ) print ( \"ready!\" ) print ( \"--------------------------------------------------------\" ) except Exception as e : print ( e ) sleep ( 1000 ) ################################################## # Copy and Paste transmitter.py/receiver.py here # # To obtain the Transmitter/receiver code to be # # uploaded # ##################################################","title":"Examples"},{"location":"reference/libs/microchip/mcp2515/docs/examples/#examples","text":"The following are a list of examples for lib.microchip.mcp2515.","title":"Examples"},{"location":"reference/libs/microchip/mcp2515/docs/examples/#can-loopback-example","text":"This example sends/receives an echo message over mcp2515 in loopback mode. This example will test the functionality of the protocol controller, and connections to it. No CAN Bus is required. main.py ################################################################################ # CAN Loopback Example # # Created: 2018-03-05 11:25:41.189984 # ################################################################################ from microchip.mcp2515 import mcp2515 import streams streams . serial () print ( \"start...\" ) try : # This setup is referred to CAN SPI click mounted on flip n click device slot A can = mcp2515 . MCP2515 ( SPI0 , D17 , D16 , clk = 10000000 ) print ( \"...done\" ) print ( \"init...\" ) can . init ( mcp2515 . MCP_ANY , \"500KBPS\" , \"16MHZ\" ) can . set_mode ( \"LOOPBACK\" ) print ( \"...done\" ) print ( \"ready!\" ) print ( \"--------------------------------------------------------\" ) except Exception as e : print ( e ) sleep ( 1000 ) canid = bytearray ([ 0x00 , 0x00 , 0x01 , 0x00 ]) data = [ 0x98 , 0xBB , 0x40 , 0xAC , 0x58 , 0x33 , 0x12 , 0x3E ] # interrupt pin pinMode ( D21 , INPUT ) while True : try : if not digitalRead ( D21 ): id_rx , msg_rx = can . recv () if id_rx [ 3 ] & 0x80 == 0x80 : print ( \"Ext ID:\" , [ e for e in id_rx ], \"DLC:\" , len ( msg_rx )) else : print ( \"Std ID:\" , [ e for e in id_rx ], \"DLC:\" , len ( msg_rx )) if id_rx [ 3 ] & 0x40 == 0x40 : print ( \"remote request frame\" ) else : print ( \"Data:\" , [ x for x in msg_rx ]) sleep ( 500 ) print ( \"sending msg...\" ) can . send ( canid , data ) print ( \"...done\" ) except Exception as e : print ( e ) sleep ( 1000 )","title":"CAN Loopback Example"},{"location":"reference/libs/microchip/mcp2515/docs/examples/#can-communication-example","text":"In this example CAN Receiver and Transmitter are implemented. 2 devices connected in CAN Bus needed for this example. main.py ################################################################################ # CAN Communication Example # # Created: 2018-03-05 11:25:41.189984 # ################################################################################ from microchip.mcp2515 import mcp2515 import streams streams . serial () print ( \"start...\" ) try : # This setup is referred to CAN SPI click mounted on flip n click device slot A can = mcp2515 . MCP2515 ( SPI0 , D17 , D16 , clk = 10000000 ) print ( \"...done\" ) print ( \"init...\" ) can . init ( mcp2515 . MCP_ANY , \"500KBPS\" , \"16MHZ\" ) can . set_mode ( \"NORMAL\" ) print ( \"...done\" ) print ( \"ready!\" ) print ( \"--------------------------------------------------------\" ) except Exception as e : print ( e ) sleep ( 1000 ) ################################################## # Copy and Paste transmitter.py/receiver.py here # # To obtain the Transmitter/receiver code to be # # uploaded # ##################################################","title":"CAN Communication Example"},{"location":"reference/libs/microchip/mcp2515/docs/mcp2515/","text":"MCP2515 class \u00b6 class MCP2515 \u00b6 class MCP2515 ( dvr , cs , rst = None , clk = 800000 ) Creates an instance of the MCP2515 class. This class allows the control of MCP2515 devices. Arguments: drv \u2013 SPI Driver used \u2018(SPI0, \u2026)\u2019 cs \u2013 Chip select of the SPI driver rst \u2013 Reset pin (default None) clk \u2013 Clock speed, default 800 kHz MCP2515.init \u00b6 init ( idmode , speed , clock ) Initializes the MCP2515 chip Arguments: idmode \u2013 set the RX buffer id mode (selectable from mcp2515.MCP_STDEXT, mcp2515.MCP_STD, mcp2515.MCP_EXT, or mcp2515.MCP_ANY speed \u2013 set the speed of the CAN communication clock \u2013 set the clock of the CAN Communication Possible combination of values for Clock and Speed are: Clock \u2013> 8MHZ Clock Speed \u201c8MHZ\u201d \u201c5KBPS\u201d \u201c8MHZ\u201d \u201c10KBPS\u201d \u201c8MHZ\u201d \u201c20KBPS\u201d \u201c8MHZ\u201d \u201c31KBPS\u201d \u201c8MHZ\u201d \u201c33KBPS\u201d \u201c8MHZ\u201d \u201c40KBPS\u201d \u201c8MHZ\u201d \u201c50KBPS\u201d \u201c8MHZ\u201d \u201c80KBPS\u201d \u201c8MHZ\u201d \u201c100KBPS\u201d \u201c8MHZ\u201d \u201c125KBPS\u201d \u201c8MHZ\u201d \u201c200KBPS\u201d \u201c8MHZ\u201d \u201c250KBPS\u201d \u201c8MHZ\u201d \u201c500KBPS\u201d \u201c8MHZ\u201d \u201c1000KBPS\u201d Clock \u2013> 16MHZ Clock Speed \u201c16MHZ\u201d \u201c5KBPS\u201d \u201c16MHZ\u201d \u201c10KBPS\u201d \u201c16MHZ\u201d \u201c20KBPS\u201d \u201c16MHZ\u201d \u201c33KBPS\u201d \u201c16MHZ\u201d \u201c40KBPS\u201d \u201c16MHZ\u201d \u201c50KBPS\u201d \u201c16MHZ\u201d \u201c80KBPS\u201d \u201c16MHZ\u201d \u201c100KBPS\u201d \u201c16MHZ\u201d \u201c125KBPS\u201d \u201c16MHZ\u201d \u201c200KBPS\u201d \u201c16MHZ\u201d \u201c250KBPS\u201d \u201c16MHZ\u201d \u201c500KBPS\u201d \u201c16MHZ\u201d \u201c1000KBPS\u201d Clock \u2013> 20MHZ Clock Speed \u201c20MHZ\u201d \u201c40KBPS\u201d \u201c20MHZ\u201d \u201c50KBPS\u201d \u201c20MHZ\u201d \u201c80KBPS\u201d \u201c20MHZ\u201d \u201c100KBPS\u201d \u201c20MHZ\u201d \u201c125KBPS\u201d \u201c20MHZ\u201d \u201c200KBPS\u201d \u201c20MHZ\u201d \u201c250KBPS\u201d \u201c20MHZ\u201d \u201c500KBPS\u201d \u201c20MHZ\u201d \u201c1000KBPS\u201d MCP2515.set_mode \u00b6 set_mode ( mode ) Sets the operation mode of the MCP2515. Arguments: mode \u2013 operation mode (\u201cNORMAL\u201d, \u201cSLEEP\u201d, \u201cLOOPBACK\u201d, \u201cLISTENONLY\u201d, \u201cCONFIG\u201d, \u201cPOWERUP\u201d, \u201cONE_SHOT\u201d). MCP2515.init_mask \u00b6 init_mask ( num , data , ext ) Initializes Masks. Arguments: num \u2013 0 to set mask 0 on RX buffer, 1 to set mask 1 on RX buffer data \u2013 Data Mask ext \u2013 0 for standard ID, 1 for Extended ID MCP2515.init_filter \u00b6 init_filter ( num , data , ext ) Initializes Filters. Arguments: num \u2013 number of filter to be set in RX buffer (from 0 to 5) data \u2013 Data Filter ext \u2013 0 for standard ID, 1 for Extended ID MCP2515.send \u00b6 send ( canid , data , ext = None ) Sends CAN messages. Arguments: canid \u2013 ID of the CAN message (bytearray of 4 bytes) data \u2013 Data to be sent (list of 8 bytes) ext \u2013 0 for standard ID, 1 for Extended ID (default None - auto detected) MCP2515.recv \u00b6 recv () Receives CAN messages returnung CAN id value and related data message. Returns canid, msg.","title":"MCP2515 class"},{"location":"reference/libs/microchip/mcp2515/docs/mcp2515/#mcp2515-class","text":"","title":"MCP2515 class"},{"location":"reference/libs/microchip/mcp2515/docs/mcp2515/#class-mcp2515","text":"class MCP2515 ( dvr , cs , rst = None , clk = 800000 ) Creates an instance of the MCP2515 class. This class allows the control of MCP2515 devices. Arguments: drv \u2013 SPI Driver used \u2018(SPI0, \u2026)\u2019 cs \u2013 Chip select of the SPI driver rst \u2013 Reset pin (default None) clk \u2013 Clock speed, default 800 kHz","title":"class MCP2515"},{"location":"reference/libs/microchip/mcp2515/docs/mcp2515/#mcp2515init","text":"init ( idmode , speed , clock ) Initializes the MCP2515 chip Arguments: idmode \u2013 set the RX buffer id mode (selectable from mcp2515.MCP_STDEXT, mcp2515.MCP_STD, mcp2515.MCP_EXT, or mcp2515.MCP_ANY speed \u2013 set the speed of the CAN communication clock \u2013 set the clock of the CAN Communication Possible combination of values for Clock and Speed are: Clock \u2013> 8MHZ Clock Speed \u201c8MHZ\u201d \u201c5KBPS\u201d \u201c8MHZ\u201d \u201c10KBPS\u201d \u201c8MHZ\u201d \u201c20KBPS\u201d \u201c8MHZ\u201d \u201c31KBPS\u201d \u201c8MHZ\u201d \u201c33KBPS\u201d \u201c8MHZ\u201d \u201c40KBPS\u201d \u201c8MHZ\u201d \u201c50KBPS\u201d \u201c8MHZ\u201d \u201c80KBPS\u201d \u201c8MHZ\u201d \u201c100KBPS\u201d \u201c8MHZ\u201d \u201c125KBPS\u201d \u201c8MHZ\u201d \u201c200KBPS\u201d \u201c8MHZ\u201d \u201c250KBPS\u201d \u201c8MHZ\u201d \u201c500KBPS\u201d \u201c8MHZ\u201d \u201c1000KBPS\u201d Clock \u2013> 16MHZ Clock Speed \u201c16MHZ\u201d \u201c5KBPS\u201d \u201c16MHZ\u201d \u201c10KBPS\u201d \u201c16MHZ\u201d \u201c20KBPS\u201d \u201c16MHZ\u201d \u201c33KBPS\u201d \u201c16MHZ\u201d \u201c40KBPS\u201d \u201c16MHZ\u201d \u201c50KBPS\u201d \u201c16MHZ\u201d \u201c80KBPS\u201d \u201c16MHZ\u201d \u201c100KBPS\u201d \u201c16MHZ\u201d \u201c125KBPS\u201d \u201c16MHZ\u201d \u201c200KBPS\u201d \u201c16MHZ\u201d \u201c250KBPS\u201d \u201c16MHZ\u201d \u201c500KBPS\u201d \u201c16MHZ\u201d \u201c1000KBPS\u201d Clock \u2013> 20MHZ Clock Speed \u201c20MHZ\u201d \u201c40KBPS\u201d \u201c20MHZ\u201d \u201c50KBPS\u201d \u201c20MHZ\u201d \u201c80KBPS\u201d \u201c20MHZ\u201d \u201c100KBPS\u201d \u201c20MHZ\u201d \u201c125KBPS\u201d \u201c20MHZ\u201d \u201c200KBPS\u201d \u201c20MHZ\u201d \u201c250KBPS\u201d \u201c20MHZ\u201d \u201c500KBPS\u201d \u201c20MHZ\u201d \u201c1000KBPS\u201d","title":"MCP2515.init"},{"location":"reference/libs/microchip/mcp2515/docs/mcp2515/#mcp2515set_mode","text":"set_mode ( mode ) Sets the operation mode of the MCP2515. Arguments: mode \u2013 operation mode (\u201cNORMAL\u201d, \u201cSLEEP\u201d, \u201cLOOPBACK\u201d, \u201cLISTENONLY\u201d, \u201cCONFIG\u201d, \u201cPOWERUP\u201d, \u201cONE_SHOT\u201d).","title":"MCP2515.set_mode"},{"location":"reference/libs/microchip/mcp2515/docs/mcp2515/#mcp2515init_mask","text":"init_mask ( num , data , ext ) Initializes Masks. Arguments: num \u2013 0 to set mask 0 on RX buffer, 1 to set mask 1 on RX buffer data \u2013 Data Mask ext \u2013 0 for standard ID, 1 for Extended ID","title":"MCP2515.init_mask"},{"location":"reference/libs/microchip/mcp2515/docs/mcp2515/#mcp2515init_filter","text":"init_filter ( num , data , ext ) Initializes Filters. Arguments: num \u2013 number of filter to be set in RX buffer (from 0 to 5) data \u2013 Data Filter ext \u2013 0 for standard ID, 1 for Extended ID","title":"MCP2515.init_filter"},{"location":"reference/libs/microchip/mcp2515/docs/mcp2515/#mcp2515send","text":"send ( canid , data , ext = None ) Sends CAN messages. Arguments: canid \u2013 ID of the CAN message (bytearray of 4 bytes) data \u2013 Data to be sent (list of 8 bytes) ext \u2013 0 for standard ID, 1 for Extended ID (default None - auto detected)","title":"MCP2515.send"},{"location":"reference/libs/microchip/mcp2515/docs/mcp2515/#mcp2515recv","text":"recv () Receives CAN messages returnung CAN id value and related data message. Returns canid, msg.","title":"MCP2515.recv"},{"location":"reference/libs/microchip/mcp3201/docs/","text":"Microchip MCP3201 \u00b6 The MCP3201 is a low-power 12-bit Analog-to-Digital Converter (ADC). The MCP3201 features a successive approximation register architecture and a SPI serial interface. More information at Microchip dedicated page . Technical Details \u00b6 12-bit resolution On-chip Sample and Hold Low-Power CMOS Technology Supply Voltage (Vdd): from 2.7 V to 5.5 V 50 ksps maximum sampling rate @Vdd = 2.7V 0.8 MHz maximum clock frequency @Vdd = 2.7V Temperature range: -40\u00b0C to +85\u00b0C Here below, the Zerynth driver for the Microchip MCP3201. Contents: MCP3201 Module MCP3201 class","title":"Microchip MCP3201"},{"location":"reference/libs/microchip/mcp3201/docs/#microchip-mcp3201","text":"The MCP3201 is a low-power 12-bit Analog-to-Digital Converter (ADC). The MCP3201 features a successive approximation register architecture and a SPI serial interface. More information at Microchip dedicated page .","title":"Microchip MCP3201"},{"location":"reference/libs/microchip/mcp3201/docs/#technical-details","text":"12-bit resolution On-chip Sample and Hold Low-Power CMOS Technology Supply Voltage (Vdd): from 2.7 V to 5.5 V 50 ksps maximum sampling rate @Vdd = 2.7V 0.8 MHz maximum clock frequency @Vdd = 2.7V Temperature range: -40\u00b0C to +85\u00b0C Here below, the Zerynth driver for the Microchip MCP3201. Contents: MCP3201 Module MCP3201 class","title":"Technical Details"},{"location":"reference/libs/microchip/mcp3201/docs/mcp3201/","text":"MCP3201 Module \u00b6 This module contains the driver for Microchip MCP3201 analog to digital converter with SPI serial interface ( datasheet ). Example: from microchip.mcp3201 import mcp3201 ... mcp = mcp3201 . MCP3201 ( SPI0 , D17 ) value = mcp . get_raw_data () MCP3201 class \u00b6 class MCP3201 \u00b6 class MCP3201 ( spidrv , cs , clk = 400000 ) Creates an instance of the MCP3201 class. Arguments: spidrv \u2013 SPI Bus used \u2018(SPI0, \u2026)\u2019 cs \u2013 Chip select pin clk \u2013 Clock speed, default 400 kHz MCP3201.get_raw_data \u00b6 get_raw_data () Return the conversion result as an integer between 0 and 4095 (12 bit). The digital output code is determined by the reference voltage Vref and the analog input voltage Vin : Digital output code = 4096 * Vin / Vref","title":"MCP3201 Module"},{"location":"reference/libs/microchip/mcp3201/docs/mcp3201/#mcp3201-module","text":"This module contains the driver for Microchip MCP3201 analog to digital converter with SPI serial interface ( datasheet ). Example: from microchip.mcp3201 import mcp3201 ... mcp = mcp3201 . MCP3201 ( SPI0 , D17 ) value = mcp . get_raw_data ()","title":"MCP3201 Module"},{"location":"reference/libs/microchip/mcp3201/docs/mcp3201/#mcp3201-class","text":"","title":"MCP3201 class"},{"location":"reference/libs/microchip/mcp3201/docs/mcp3201/#class-mcp3201","text":"class MCP3201 ( spidrv , cs , clk = 400000 ) Creates an instance of the MCP3201 class. Arguments: spidrv \u2013 SPI Bus used \u2018(SPI0, \u2026)\u2019 cs \u2013 Chip select pin clk \u2013 Clock speed, default 400 kHz","title":"class MCP3201"},{"location":"reference/libs/microchip/mcp3201/docs/mcp3201/#mcp3201get_raw_data","text":"get_raw_data () Return the conversion result as an integer between 0 and 4095 (12 bit). The digital output code is determined by the reference voltage Vref and the analog input voltage Vin : Digital output code = 4096 * Vin / Vref","title":"MCP3201.get_raw_data"},{"location":"reference/libs/microchip/mcp3208/docs/","text":"Microchip MCP3204/3208 \u00b6 The MCP3204/MCP3208 devices are successive approximation 12-bit Analog-to-Digital Converters (ADC) with SPI serial interface. The MCP3204 is programmable to provide two pseudo-differential input pairs or four single-ended inputs. The MCP3208 is programmable to provide four pseudo-differential input pairs or eight single-ended inputs. More information at Microchip dedicated pages MCP3204 , MCP3208 . Technical Details \u00b6 12-bit resolution 4 (MCP3204) or 8 (MCP3208) input channels On-chip sample and hold Low-Power CMOS Technology Supply Voltage (Vdd): from 2.7 V to 5.5 V 50 ksps maximum sampling rate @Vdd = 2.7V Temperature range: -40\u00b0C to +85\u00b0C Here below, the Zerynth driver for the Microchip MCP3204/3208. Contents: MCP3204/3208 Module MCP3208 class Examples thumbstick","title":"Microchip MCP3204/3208"},{"location":"reference/libs/microchip/mcp3208/docs/#microchip-mcp32043208","text":"The MCP3204/MCP3208 devices are successive approximation 12-bit Analog-to-Digital Converters (ADC) with SPI serial interface. The MCP3204 is programmable to provide two pseudo-differential input pairs or four single-ended inputs. The MCP3208 is programmable to provide four pseudo-differential input pairs or eight single-ended inputs. More information at Microchip dedicated pages MCP3204 , MCP3208 .","title":"Microchip MCP3204/3208"},{"location":"reference/libs/microchip/mcp3208/docs/#technical-details","text":"12-bit resolution 4 (MCP3204) or 8 (MCP3208) input channels On-chip sample and hold Low-Power CMOS Technology Supply Voltage (Vdd): from 2.7 V to 5.5 V 50 ksps maximum sampling rate @Vdd = 2.7V Temperature range: -40\u00b0C to +85\u00b0C Here below, the Zerynth driver for the Microchip MCP3204/3208. Contents: MCP3204/3208 Module MCP3208 class Examples thumbstick","title":"Technical Details"},{"location":"reference/libs/microchip/mcp3208/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.microchip.mcp3208. Thumbstick controller with MCP3204/3208 \u00b6 Read raw data from an MCP3204/3208 to get direction from a 2-axis thumbstick input device. main.py ################################################################################ # Thumbstick Example # # Created at 2017-08-25 06:56:04.499323 # ################################################################################ import streams from microchip.mcp3208 import mcp3208 # x-axis potentiometer connected to MCP3204 channel 1 # y-axos potentiometer connected to MCP3204 channel 0 def get_x (): return thumbstick . get_raw_data ( True , 1 ) def get_y (): return thumbstick . get_raw_data ( True , 0 ) # read mid-point x and y values def calibrate (): global mid_x , mid_y mid_x = get_x () mid_y = get_y () # read x and y values and return a direction def get_direction ( thr =. 2 ): x = get_x () y = get_y () m_x = abs ( x - mid_x ) / mid_x m_y = abs ( y - mid_y ) / mid_y if m_x < thr and m_y < thr : return 'center' if m_x > m_y : if x > mid_x : return 'right' else : return 'left' else : if y > mid_y : return 'down' else : return 'up' streams . serial () # create an instance of the MCP3208 class thumbstick = mcp3208 . MCP3208 ( SPI0 , D17 ) # calibrate the thumbstick calibrate () # get and print thumbstick direction every 200 ms while True : try : print ( get_direction ()) except Exception as e : print ( e ) sleep ( 200 )","title":"Examples"},{"location":"reference/libs/microchip/mcp3208/docs/examples/#examples","text":"The following are a list of examples for lib.microchip.mcp3208.","title":"Examples"},{"location":"reference/libs/microchip/mcp3208/docs/examples/#thumbstick-controller-with-mcp32043208","text":"Read raw data from an MCP3204/3208 to get direction from a 2-axis thumbstick input device. main.py ################################################################################ # Thumbstick Example # # Created at 2017-08-25 06:56:04.499323 # ################################################################################ import streams from microchip.mcp3208 import mcp3208 # x-axis potentiometer connected to MCP3204 channel 1 # y-axos potentiometer connected to MCP3204 channel 0 def get_x (): return thumbstick . get_raw_data ( True , 1 ) def get_y (): return thumbstick . get_raw_data ( True , 0 ) # read mid-point x and y values def calibrate (): global mid_x , mid_y mid_x = get_x () mid_y = get_y () # read x and y values and return a direction def get_direction ( thr =. 2 ): x = get_x () y = get_y () m_x = abs ( x - mid_x ) / mid_x m_y = abs ( y - mid_y ) / mid_y if m_x < thr and m_y < thr : return 'center' if m_x > m_y : if x > mid_x : return 'right' else : return 'left' else : if y > mid_y : return 'down' else : return 'up' streams . serial () # create an instance of the MCP3208 class thumbstick = mcp3208 . MCP3208 ( SPI0 , D17 ) # calibrate the thumbstick calibrate () # get and print thumbstick direction every 200 ms while True : try : print ( get_direction ()) except Exception as e : print ( e ) sleep ( 200 )","title":"Thumbstick controller with MCP3204/3208"},{"location":"reference/libs/microchip/mcp3208/docs/mcp3208/","text":"MCP3204/3208 Module \u00b6 This module contains the driver for Microchip MCP3204/3208 analog to digital converter with SPI serial interface ( datasheet ). Example: from microchip.mcp3208 import MCP3208 ... mcp = mcp3208 . MCP3208 ( SPI0 , D17 ) value_0 = mcp . get_raw_data ( True , 0 ) value_1 = mcp . get_raw_data ( False , 2 ) MCP3208 class \u00b6 class MCP3208 \u00b6 class MCP3208 ( spidrv , cs , clk = 400000 ) Creates an instance of the MCP3208 class. This class allows the control of both MCP3204 and MCP3208 devices. Arguments: spidrv \u2013 SPI Bus used \u2018(SPI0, \u2026)\u2019 cs \u2013 Chip select pin clk \u2013 Clock speed, default 400 kHz MCP3208.get_raw_data \u00b6 get_raw_data ( single , channel ) Return the conversion result as an integer between 0 and 4095 (12 bit). Input mode and channel are selected by single and channel parameters according to the following table. | single | channel | Input Configuration | Channel Selection | | ------ | ------- | ------------------- | ----------------- | | True | 0 | single - ended | CH0 | | True | 1 | single - ended | CH1 | | True | 2 | single - ended | CH2 | | True | 3 | single - ended | CH3 | | True | 4* | single - ended | CH4 | | True | 5* | single - ended | CH5 | | True | 6* | single - ended | CH6 | | True | 7* | single - ended | CH7 | | False | 0 | differential | CH0 = IN + CH1 = IN - | | False | 1 | differential | CH0 = IN - CH1 = IN + | | False | 2 | differential | CH2 = IN + CH3 = IN - | | False | 3 | differential | CH2 = IN - CH3 = IN + | | False | 4* | differential | CH4 = IN + CH5 = IN - | | False | 5* | differential | CH4 = IN - CH5 = IN + | | False | 6* | differential | CH6 = IN + CH7 = IN - | | False | 7* | differential | CH6 = IN - CH7 = IN + | NOTE: channel values marked with * are available for the MCP3208 only. The digital output code is determined by the reference voltage Vref and the analog input voltage Vin : Digital output code = 4096 * Vin / Vref","title":"MCP3204/3208 Module"},{"location":"reference/libs/microchip/mcp3208/docs/mcp3208/#mcp32043208-module","text":"This module contains the driver for Microchip MCP3204/3208 analog to digital converter with SPI serial interface ( datasheet ). Example: from microchip.mcp3208 import MCP3208 ... mcp = mcp3208 . MCP3208 ( SPI0 , D17 ) value_0 = mcp . get_raw_data ( True , 0 ) value_1 = mcp . get_raw_data ( False , 2 )","title":"MCP3204/3208 Module"},{"location":"reference/libs/microchip/mcp3208/docs/mcp3208/#mcp3208-class","text":"","title":"MCP3208 class"},{"location":"reference/libs/microchip/mcp3208/docs/mcp3208/#class-mcp3208","text":"class MCP3208 ( spidrv , cs , clk = 400000 ) Creates an instance of the MCP3208 class. This class allows the control of both MCP3204 and MCP3208 devices. Arguments: spidrv \u2013 SPI Bus used \u2018(SPI0, \u2026)\u2019 cs \u2013 Chip select pin clk \u2013 Clock speed, default 400 kHz","title":"class MCP3208"},{"location":"reference/libs/microchip/mcp3208/docs/mcp3208/#mcp3208get_raw_data","text":"get_raw_data ( single , channel ) Return the conversion result as an integer between 0 and 4095 (12 bit). Input mode and channel are selected by single and channel parameters according to the following table. | single | channel | Input Configuration | Channel Selection | | ------ | ------- | ------------------- | ----------------- | | True | 0 | single - ended | CH0 | | True | 1 | single - ended | CH1 | | True | 2 | single - ended | CH2 | | True | 3 | single - ended | CH3 | | True | 4* | single - ended | CH4 | | True | 5* | single - ended | CH5 | | True | 6* | single - ended | CH6 | | True | 7* | single - ended | CH7 | | False | 0 | differential | CH0 = IN + CH1 = IN - | | False | 1 | differential | CH0 = IN - CH1 = IN + | | False | 2 | differential | CH2 = IN + CH3 = IN - | | False | 3 | differential | CH2 = IN - CH3 = IN + | | False | 4* | differential | CH4 = IN + CH5 = IN - | | False | 5* | differential | CH4 = IN - CH5 = IN + | | False | 6* | differential | CH6 = IN + CH7 = IN - | | False | 7* | differential | CH6 = IN - CH7 = IN + | NOTE: channel values marked with * are available for the MCP3208 only. The digital output code is determined by the reference voltage Vref and the analog input voltage Vin : Digital output code = 4096 * Vin / Vref","title":"MCP3208.get_raw_data"},{"location":"reference/libs/microchip/mcp3428/docs/","text":"Microchip MCP3426/3427/3428 \u00b6 The MCP3426/3427/3428 devices are multichannel low-noise, high accuracy delta-sigma Analog-to-Digital Converters (ADC) with differential inputs and up to 16 bits of resolution. The devices feature an on-board precision 2.048 V reference voltage, a Programmable Gain Amplifier (PGA) and use a two wire I2C serial interface. MPC3426 and MCP3427 devices have two differential input channels and the MCP3428 has four differential input channels. All electrical properties of these three devices are the same except the differences in number of input channels and I2C address selection options. More information at Microchip dedicated pages MCP3426 , MCP3427 , MCP3428 . Technical Details \u00b6 16-bit resolution 2 (MCP3426, MCP3427) or 4 (MCP3428) differential input channels On-Board Voltage Reference On-Board PGA, gains of 1, 2, 4 or 8 Programmable Date Rate Supply Voltage (Vdd): from 2.7 V to 5.5 V Temperature range: -40\u00b0C to +125\u00b0C Here below, the Zerynth driver for the Microchip MCP3426/3427/3428. Contents: MCP3426/3427/3428 Module MCP3428 class Examples thumbstick","title":"Microchip MCP3426/3427/3428"},{"location":"reference/libs/microchip/mcp3428/docs/#microchip-mcp342634273428","text":"The MCP3426/3427/3428 devices are multichannel low-noise, high accuracy delta-sigma Analog-to-Digital Converters (ADC) with differential inputs and up to 16 bits of resolution. The devices feature an on-board precision 2.048 V reference voltage, a Programmable Gain Amplifier (PGA) and use a two wire I2C serial interface. MPC3426 and MCP3427 devices have two differential input channels and the MCP3428 has four differential input channels. All electrical properties of these three devices are the same except the differences in number of input channels and I2C address selection options. More information at Microchip dedicated pages MCP3426 , MCP3427 , MCP3428 .","title":"Microchip MCP3426/3427/3428"},{"location":"reference/libs/microchip/mcp3428/docs/#technical-details","text":"16-bit resolution 2 (MCP3426, MCP3427) or 4 (MCP3428) differential input channels On-Board Voltage Reference On-Board PGA, gains of 1, 2, 4 or 8 Programmable Date Rate Supply Voltage (Vdd): from 2.7 V to 5.5 V Temperature range: -40\u00b0C to +125\u00b0C Here below, the Zerynth driver for the Microchip MCP3426/3427/3428. Contents: MCP3426/3427/3428 Module MCP3428 class Examples thumbstick","title":"Technical Details"},{"location":"reference/libs/microchip/mcp3428/docs/mcp3428/","text":"MCP3426/3427/3428 Module \u00b6 This module contains the driver for Microchip MCP3426/3427/3428 multichannel analog to digital converters with I2C interface ( datasheet ). Example: from microchip.mcp3428 import MCP3428 ... mcp = mcp3428 . MCP3428 ( I2C0 , addr = 0x6A ) mcp . set ( ch = 1 , pga = 1 ) value1 = mcp . get_raw_data () mcp . set ( ch = 2 , pga = 2 ) value2 = mcp . get_raw_data () MCP3428 class \u00b6 class MCP3428 \u00b6 class MCP3428 ( i2cdrv , addr = 0x68 , clk = 400000 ) Creates an instance of the MCP3428 class. This class allows the control of all MCP3426, MCP3427, and MCP3428 devices. Arguments: i2cdrv \u2013 I2C Bus used \u2018(I2C0, \u2026)\u2019 addr \u2013 Slave address, default 0x68 clk \u2013 Clock speed, default 400 kHz MCP3428.set \u00b6 set ( cmode = 0 , rdy = 0 , ch = 0 , sps = 2 , pga = 1 ) Sets the device\u2019s configuration register. Parameters: cmode: sets the Conversion mode. Available values are: 0 : One-Shot Conversion Mode. The device performs a single conversion and enters a low power standby mode until it receives another command. 1 : Continuous Conversion Mode. The device performs data conversion continuously. rdy: when in Continuous Conversion mode, the value of this parameter has no effect. When in One-Shot Conversion mode, setting this parameter to 1 initiates a new conversion. ch: channel selection. ch selected channel 0 Channel 1 1 Channel 2 2 Channel 3 (MCP3248 only, treated as 0 by MCP3246/MCP3247) 3 Channel 4 (MCP3248 only, treated as 1 by MCP3246/MCP3247) sps : Sample rate / resolution selection. sps Samples per second ADC resolution (bits) 0 240 12 1 60 14 2 15 16 pga: PGA Gain selection. Available values are 1, 2, 4, and 8. Passing an invalid value results in unity gain. MCP3428.get_raw_data \u00b6 get_raw_data () Return the conversion result as an n-bit signed integer, where n depends on last sps value used with set() . Last sps set ADC resolution (bits) Minimum output Maximum output 0 12 -2048 2047 1 14 -8192 8191 2 16 -32768 32767","title":"MCP3426/3427/3428 Module"},{"location":"reference/libs/microchip/mcp3428/docs/mcp3428/#mcp342634273428-module","text":"This module contains the driver for Microchip MCP3426/3427/3428 multichannel analog to digital converters with I2C interface ( datasheet ). Example: from microchip.mcp3428 import MCP3428 ... mcp = mcp3428 . MCP3428 ( I2C0 , addr = 0x6A ) mcp . set ( ch = 1 , pga = 1 ) value1 = mcp . get_raw_data () mcp . set ( ch = 2 , pga = 2 ) value2 = mcp . get_raw_data ()","title":"MCP3426/3427/3428 Module"},{"location":"reference/libs/microchip/mcp3428/docs/mcp3428/#mcp3428-class","text":"","title":"MCP3428 class"},{"location":"reference/libs/microchip/mcp3428/docs/mcp3428/#class-mcp3428","text":"class MCP3428 ( i2cdrv , addr = 0x68 , clk = 400000 ) Creates an instance of the MCP3428 class. This class allows the control of all MCP3426, MCP3427, and MCP3428 devices. Arguments: i2cdrv \u2013 I2C Bus used \u2018(I2C0, \u2026)\u2019 addr \u2013 Slave address, default 0x68 clk \u2013 Clock speed, default 400 kHz","title":"class MCP3428"},{"location":"reference/libs/microchip/mcp3428/docs/mcp3428/#mcp3428set","text":"set ( cmode = 0 , rdy = 0 , ch = 0 , sps = 2 , pga = 1 ) Sets the device\u2019s configuration register. Parameters: cmode: sets the Conversion mode. Available values are: 0 : One-Shot Conversion Mode. The device performs a single conversion and enters a low power standby mode until it receives another command. 1 : Continuous Conversion Mode. The device performs data conversion continuously. rdy: when in Continuous Conversion mode, the value of this parameter has no effect. When in One-Shot Conversion mode, setting this parameter to 1 initiates a new conversion. ch: channel selection. ch selected channel 0 Channel 1 1 Channel 2 2 Channel 3 (MCP3248 only, treated as 0 by MCP3246/MCP3247) 3 Channel 4 (MCP3248 only, treated as 1 by MCP3246/MCP3247) sps : Sample rate / resolution selection. sps Samples per second ADC resolution (bits) 0 240 12 1 60 14 2 15 16 pga: PGA Gain selection. Available values are 1, 2, 4, and 8. Passing an invalid value results in unity gain.","title":"MCP3428.set"},{"location":"reference/libs/microchip/mcp3428/docs/mcp3428/#mcp3428get_raw_data","text":"get_raw_data () Return the conversion result as an n-bit signed integer, where n depends on last sps value used with set() . Last sps set ADC resolution (bits) Minimum output Maximum output 0 12 -2048 2047 1 14 -8192 8191 2 16 -32768 32767","title":"MCP3428.get_raw_data"},{"location":"reference/libs/microchip/mcp4921/docs/","text":"Microchip MCP4921 \u00b6 The MCP4921 is a single channel, 12-bit Digital-to-Analog Converter (DAC) with an external voltage reference and SPI interface. If provides a very high accuracy, low power consumption, and low noise performance. More information at Microchip dedicated page . Technical Details \u00b6 12-bit resolution Single Channel Voltage Output Supply Voltage (Vdd): from 2.7 V to 5.5 V Operating Current 175 uA External Voltage Reference Pin SPI interface Temperature range: -40\u00b0C to +125\u00b0C Here below, the Zerynth driver for the Microchip MCP4921. Contents: MCP4921 Module MCP4921 class","title":"Microchip MCP4921"},{"location":"reference/libs/microchip/mcp4921/docs/#microchip-mcp4921","text":"The MCP4921 is a single channel, 12-bit Digital-to-Analog Converter (DAC) with an external voltage reference and SPI interface. If provides a very high accuracy, low power consumption, and low noise performance. More information at Microchip dedicated page .","title":"Microchip MCP4921"},{"location":"reference/libs/microchip/mcp4921/docs/#technical-details","text":"12-bit resolution Single Channel Voltage Output Supply Voltage (Vdd): from 2.7 V to 5.5 V Operating Current 175 uA External Voltage Reference Pin SPI interface Temperature range: -40\u00b0C to +125\u00b0C Here below, the Zerynth driver for the Microchip MCP4921. Contents: MCP4921 Module MCP4921 class","title":"Technical Details"},{"location":"reference/libs/microchip/mcp4921/docs/mcp4921/","text":"MCP4921 Module \u00b6 This module contains the driver for Microchip MCP4921 single channel 12-bit digital to analog converter with SPI serial interface ( datasheet ). Example: from microchip.mcp4921 import mcp4921 ... mcp = mcp4921 . MCP4921 ( SPI0 , D17 ) mcp . set_value ( 1600 ) MCP4921 class \u00b6 class MCP4921 \u00b6 class MCP4921 ( spidrv , cs , clk = 400000 ) Creates an instance of the MCP4921 class. Arguments: spidrv \u2013 SPI Bus used \u2018(SPI0, \u2026)\u2019 cs \u2013 Chip select pin clk \u2013 Clock speed, default 400 kHz MCP4921.set_value \u00b6 set_value ( v , gain = 1 , buff = False ) Sends the 12-bit value v to the DAC. The gain of the output amplifier can be set through gain parameter, valid values are 1 and 2 . Analog Output Voltage = ( v / 4096) * Vref * gain If buff is True , the device buffers the Voltage Reference input increasing the input impedance but limiting the input range and frequency response. If buff is False the input range is wider (from 0V to Vdd) and the typical input impedence is 165 kOhm with 7pF. If in Shutdown mode, the device is changed to Active mode. In this case the output settling time increases to 10 us. MCP4921.shutdown \u00b6 shutdown () Shutdown the device. During Shutdown mode, most of the internal circuits are turned off for power savings and there will be no analog output.","title":"MCP4921 Module"},{"location":"reference/libs/microchip/mcp4921/docs/mcp4921/#mcp4921-module","text":"This module contains the driver for Microchip MCP4921 single channel 12-bit digital to analog converter with SPI serial interface ( datasheet ). Example: from microchip.mcp4921 import mcp4921 ... mcp = mcp4921 . MCP4921 ( SPI0 , D17 ) mcp . set_value ( 1600 )","title":"MCP4921 Module"},{"location":"reference/libs/microchip/mcp4921/docs/mcp4921/#mcp4921-class","text":"","title":"MCP4921 class"},{"location":"reference/libs/microchip/mcp4921/docs/mcp4921/#class-mcp4921","text":"class MCP4921 ( spidrv , cs , clk = 400000 ) Creates an instance of the MCP4921 class. Arguments: spidrv \u2013 SPI Bus used \u2018(SPI0, \u2026)\u2019 cs \u2013 Chip select pin clk \u2013 Clock speed, default 400 kHz","title":"class MCP4921"},{"location":"reference/libs/microchip/mcp4921/docs/mcp4921/#mcp4921set_value","text":"set_value ( v , gain = 1 , buff = False ) Sends the 12-bit value v to the DAC. The gain of the output amplifier can be set through gain parameter, valid values are 1 and 2 . Analog Output Voltage = ( v / 4096) * Vref * gain If buff is True , the device buffers the Voltage Reference input increasing the input impedance but limiting the input range and frequency response. If buff is False the input range is wider (from 0V to Vdd) and the typical input impedence is 165 kOhm with 7pF. If in Shutdown mode, the device is changed to Active mode. In this case the output settling time increases to 10 us.","title":"MCP4921.set_value"},{"location":"reference/libs/microchip/mcp4921/docs/mcp4921/#mcp4921shutdown","text":"shutdown () Shutdown the device. During Shutdown mode, most of the internal circuits are turned off for power savings and there will be no analog output.","title":"MCP4921.shutdown"},{"location":"reference/libs/microchip/mcw1001a/docs/","text":"Microchip MCW1001A \u00b6 MCW1001A is a companion chip to the MRF24WB0 802.11 module. It provides simple socket based method of sending and receiving data from the MRF24WB0 802.11 module. The MCW1001A has an on-board TCP/IP stack and 802.11 connection manager to simplify the connection between a wireless network and the TCP/IP stack management. After the initial configuration is set, the MCW1001A can access the MRF24WB0 802.11 module to connect to a network and send/receive serial data over a simple UART interface from the Host controller; more information at Microchip dedicated page . Technical Details \u00b6 Supply Voltage (Vdd): from 3.0 V to 5.5 V Operation Temperature (Top): from -40 \u00b0C to 125 \u00b0C Supply Current (Idd): from 1.3 mA to 1.5 mA (Fosc 32 MHz) UART Interface: up to 230 Kbaud Here below, the Zerynth driver for the Microchip MCW1001A. Contents: MCW1001A Module","title":"Microchip MCW1001A"},{"location":"reference/libs/microchip/mcw1001a/docs/#microchip-mcw1001a","text":"MCW1001A is a companion chip to the MRF24WB0 802.11 module. It provides simple socket based method of sending and receiving data from the MRF24WB0 802.11 module. The MCW1001A has an on-board TCP/IP stack and 802.11 connection manager to simplify the connection between a wireless network and the TCP/IP stack management. After the initial configuration is set, the MCW1001A can access the MRF24WB0 802.11 module to connect to a network and send/receive serial data over a simple UART interface from the Host controller; more information at Microchip dedicated page .","title":"Microchip MCW1001A"},{"location":"reference/libs/microchip/mcw1001a/docs/#technical-details","text":"Supply Voltage (Vdd): from 3.0 V to 5.5 V Operation Temperature (Top): from -40 \u00b0C to 125 \u00b0C Supply Current (Idd): from 1.3 mA to 1.5 mA (Fosc 32 MHz) UART Interface: up to 230 Kbaud Here below, the Zerynth driver for the Microchip MCW1001A. Contents: MCW1001A Module","title":"Technical Details"},{"location":"reference/libs/microchip/mcw1001a/docs/mcw1001a/","text":"MCW1001A Module \u00b6 This Zerynth module currently supports multiple concurrent udp and tcp sockets both in client and server mode ( datasheet ). No select support is provided. No DNS service. For WIFI security, only WPA2 is currently supported. Usage example: import streams from wireless import wifi from microchip.mcw1001a import mcw1001a streams . serial () # connect to a wifi network try : mcw1001a . init ( SERIAL1 , D16 ) # specify which serial port will be used and which RST pin print ( \"Establishing Link...\" ) wifi . link ( \"Network SSID\" , wifi . WIFI_WPA2 , \"Password\" ) print ( \"Ok!\" ) except Exception as e : print ( e )","title":"MCW1001A Module"},{"location":"reference/libs/microchip/mcw1001a/docs/mcw1001a/#mcw1001a-module","text":"This Zerynth module currently supports multiple concurrent udp and tcp sockets both in client and server mode ( datasheet ). No select support is provided. No DNS service. For WIFI security, only WPA2 is currently supported. Usage example: import streams from wireless import wifi from microchip.mcw1001a import mcw1001a streams . serial () # connect to a wifi network try : mcw1001a . init ( SERIAL1 , D16 ) # specify which serial port will be used and which RST pin print ( \"Establishing Link...\" ) wifi . link ( \"Network SSID\" , wifi . WIFI_WPA2 , \"Password\" ) print ( \"Ok!\" ) except Exception as e : print ( e )","title":"MCW1001A Module"},{"location":"reference/libs/microchip/rn2483/docs/","text":"Microchip RN2483 \u00b6 The RN2483 is a fully-certified 433/868 MHz module based on wireless LoRa technology. The RN2483 utilizes a unique spread spectrum modulation within the Sub-GHz band to enable long range, low power, and high network capacity. The module\u2019s embedded LoRaWAN Class A protocol enables seamless connectivity to any LoRaWAN compliant network infrastructure, whether public or privately deployed. The module is specifically designed for ease of use, which shortens development time and speeds time to market. LoRa technology is ideal for battery-operated sensors and low power applications such as IoT, M2M, Smart City, Sensor networks, Industrial automation, and more. The RN2483 is the first LoRa module to pass LoRa Alliance Certification testing. It is certified to the LoRaWAN 1.0 specification, ensuring that designers can quickly and easily integrate their end devices into any LoRaWAN network; more information at Microchip dedicated page . Technical Details \u00b6 Supply Voltage (Vdd): from 2.1 V to 3.6 V Operation Temperature (Top): from -40 \u00b0C to 85 \u00b0C Low-power Consumption Programmable RF Communication Bit Rate up to 300 kbps with FSK modulation, 5468 bps with LoRa Technology modulation Here below, the Zerynth driver for the Microchip RN2483 and some examples to better understand how to use it. Contents: RN2483 Module Examples get eui ping custom eui","title":"Microchip RN2483"},{"location":"reference/libs/microchip/rn2483/docs/#microchip-rn2483","text":"The RN2483 is a fully-certified 433/868 MHz module based on wireless LoRa technology. The RN2483 utilizes a unique spread spectrum modulation within the Sub-GHz band to enable long range, low power, and high network capacity. The module\u2019s embedded LoRaWAN Class A protocol enables seamless connectivity to any LoRaWAN compliant network infrastructure, whether public or privately deployed. The module is specifically designed for ease of use, which shortens development time and speeds time to market. LoRa technology is ideal for battery-operated sensors and low power applications such as IoT, M2M, Smart City, Sensor networks, Industrial automation, and more. The RN2483 is the first LoRa module to pass LoRa Alliance Certification testing. It is certified to the LoRaWAN 1.0 specification, ensuring that designers can quickly and easily integrate their end devices into any LoRaWAN network; more information at Microchip dedicated page .","title":"Microchip RN2483"},{"location":"reference/libs/microchip/rn2483/docs/#technical-details","text":"Supply Voltage (Vdd): from 2.1 V to 3.6 V Operation Temperature (Top): from -40 \u00b0C to 85 \u00b0C Low-power Consumption Programmable RF Communication Bit Rate up to 300 kbps with FSK modulation, 5468 bps with LoRa Technology modulation Here below, the Zerynth driver for the Microchip RN2483 and some examples to better understand how to use it. Contents: RN2483 Module Examples get eui ping custom eui","title":"Technical Details"},{"location":"reference/libs/microchip/rn2483/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.microchip.rn2483. EUI \u00b6 Get EUI from RN2483 for registration to LoRaWAN server. main.py import streams from microchip.rn2483 import rn2483 streams . serial () # get deveui specifying serial connection used for device-to-module communication # and module reset pin print ( \"DEVEUI: \" , rn2483 . get_hweui ( SERIAL1 , D16 )) LoRa Ping \u00b6 Basic example of LoRa usage with RN2483. main.py import streams from microchip.rn2483 import rn2483 streams . serial () rst = D16 # insert otaa credentials!! appeui = \"\" appkey = \"\" print ( \"joining...\" ) if not rn2483 . init ( SERIAL1 , appeui , appkey , rst ): print ( \"denied :(\" ) raise Exception print ( \"sending first message, res:\" ) print ( rn2483 . tx_uncnf ( 'TTN' )) while True : print ( \"ping, res:\" ) print ( rn2483 . tx_uncnf ( \".\" )) sleep ( 5000 ) Custom EUI \u00b6 Join a LoRaWAN network using the over-the-air activation with a custom EUI. main.py import streams from microchip.rn2483 import rn2483 streams . serial () print ( \"init rn2483 module\" ) rn2483 . init ( SERIAL2 , None , None , D4 , join_lora = False ) # insert otaa credentials!! appeui = '' appkey = '' deveui = '' print ( \"config rn2483 module\" ) rn2483 . config ( appeui , appkey , deveui ) print ( \"join LoRaWAN network:\" ) i = 1 while True : try : print ( \"attempt\" , i , \"...\" ) if rn2483 . join (): print ( \"...succeded!\" ) break else : print ( \"...failed :(\" ) except Exception as e : print ( e ) i += 1 sleep ( 5000 ) while True : try : print ( \"sending ping, res:\" ) print ( rn2483 . tx_uncnf ( \".\" )) except rn2483Exception as e : print ( e ) sleep ( 5000 )","title":"Examples"},{"location":"reference/libs/microchip/rn2483/docs/examples/#examples","text":"The following are a list of examples for lib.microchip.rn2483.","title":"Examples"},{"location":"reference/libs/microchip/rn2483/docs/examples/#eui","text":"Get EUI from RN2483 for registration to LoRaWAN server. main.py import streams from microchip.rn2483 import rn2483 streams . serial () # get deveui specifying serial connection used for device-to-module communication # and module reset pin print ( \"DEVEUI: \" , rn2483 . get_hweui ( SERIAL1 , D16 ))","title":"EUI"},{"location":"reference/libs/microchip/rn2483/docs/examples/#lora-ping","text":"Basic example of LoRa usage with RN2483. main.py import streams from microchip.rn2483 import rn2483 streams . serial () rst = D16 # insert otaa credentials!! appeui = \"\" appkey = \"\" print ( \"joining...\" ) if not rn2483 . init ( SERIAL1 , appeui , appkey , rst ): print ( \"denied :(\" ) raise Exception print ( \"sending first message, res:\" ) print ( rn2483 . tx_uncnf ( 'TTN' )) while True : print ( \"ping, res:\" ) print ( rn2483 . tx_uncnf ( \".\" )) sleep ( 5000 )","title":"LoRa Ping"},{"location":"reference/libs/microchip/rn2483/docs/examples/#custom-eui","text":"Join a LoRaWAN network using the over-the-air activation with a custom EUI. main.py import streams from microchip.rn2483 import rn2483 streams . serial () print ( \"init rn2483 module\" ) rn2483 . init ( SERIAL2 , None , None , D4 , join_lora = False ) # insert otaa credentials!! appeui = '' appkey = '' deveui = '' print ( \"config rn2483 module\" ) rn2483 . config ( appeui , appkey , deveui ) print ( \"join LoRaWAN network:\" ) i = 1 while True : try : print ( \"attempt\" , i , \"...\" ) if rn2483 . join (): print ( \"...succeded!\" ) break else : print ( \"...failed :(\" ) except Exception as e : print ( e ) i += 1 sleep ( 5000 ) while True : try : print ( \"sending ping, res:\" ) print ( rn2483 . tx_uncnf ( \".\" )) except rn2483Exception as e : print ( e ) sleep ( 5000 )","title":"Custom EUI"},{"location":"reference/libs/microchip/rn2483/docs/rn2483/","text":"RN2483 Module \u00b6 This Zerynth module currently supports over-the-air activation only to join a LoRaWAN network. Class A LoRaWAN devices, after correctly joining a network, are able to transmit a message up to 222 bytes and receive a response up to 230 bytes during the subsequent downlink session. Sent messages can be confirmed (acknowledged) or unconfirmed; check your network policy to choose the proper transmit method ( datasheet , command reference , LoRaWAN specification ). NOTE: rn2483Exception is defined. Usage example: import streams from microchip.rn2483 import rn2483 streams . serial () rst = D16 # insert otaa credentials!! appeui = \"\" appkey = \"\" print ( \"joining...\" ) if not rn2483 . init ( SERIAL1 , appeui , appkey , rst ): print ( \"denied :(\" ) raise Exception print ( \"sending first message, res:\" ) print ( rn2483 . tx_uncnf ( 'TTN' )) while True : print ( \"ping, res:\" ) print ( rn2483 . tx_uncnf ( \".\" )) sleep ( 5000 ) get_hweui \u00b6 get_hweui ( ser = None , rst = None ) Gets device EUI. If you need to get the EUI before joining a network, it is possible to specify: ser serial port used for device-to-module communication (ex. SERIAL1) rst module reset pin and call get_hweui() before init(). get_ch_status \u00b6 get_ch_status ( channel ) Gets channel channel status: \u2018on\u2019 if enabled, \u2018off\u2019 otherwise. get_duty_cycle \u00b6 get_duty_cycle ( channel , raw = False ) Gets channel channel duty cycle: returned by default as a percentage. As a raw value passing raw as True. get_ar \u00b6 get_ar () Gets current automatic reply state (\u2018on\u2019 or \u2018off\u2019). set_ar \u00b6 set_ar ( state ) Sets automatic reply to \u2018on\u2019 or \u2018off\u2019 state. Currently setting ar to \u2018on\u2019 does not have consequences on downlink session. set_retransmissions \u00b6 set_retransmissions ( n ) Sets number of retransmissions to be used for an uplink confirmed packet, if no downlink acknoledgement is received from the server. config \u00b6 config ( appeui = None , appkey = None , deveui = None , pwridx = '1' , adr = 'off' , rx2 = '3 869525000' , retx = 5 , ar = 'off' ) Configures the lora module with otaa join credentials and other parameters. appeui , appkey are needed for otaa deveui is needed fot otaa too but if it is None, module\u2019s hardware eui will be used for activation pwridx sets the output power adr controls the adaptive data rate rx2 data rate and frequency used for the second Receive window retx number of retransmissions to be used for an uplink confirmed packet ar sets the state of the automatic reply set_config \u00b6 set_config () Sets the configuration parameters Configures the lora module with otaa join credentials and other parameters. appeui , appkey are needed for otaa deveui is needed fot otaa too but if it is None, module\u2019s hardware eui will be used for activation pwridx sets the output power adr controls the adaptive data rate rx2 data rate and frequency used for the second Receive window retx number of retransmissions to be used for an uplink confirmed packet ar sets the state of the automatic reply join \u00b6 join () Attempts to join the network using over-the-air activation. init \u00b6 init ( ser , appeui , appkey , rst , join_lora = True ) Performs basic module configuration and try over-the-air activation. ser is the serial port used for device-to-module communication (ex. SERIAL1) appeui , appkey are needed for otaa rst is the module reset pin if join_lora is False the configuration and over-the-air activation attempt are skipped and the module can be configured through the config() function and then the LoRa network can be joined calling the join() function. tx_uncnf \u00b6 tx_uncnf ( data ) Transmits an unconfirmed message. data is a string or a bytearray. Returns True if no data is available during downlink session, a tuple (True, resp_data), where resp_data is a bytearray, otherwise. tx_cnf \u00b6 tx_cnf ( data ) Transmits a confirmed message. data is a string or a bytearray. Returns True if no data is available during downlink session, a tuple (True, resp_data), where resp_data is a bytearray, otherwise. get_snr \u00b6 get_snr () Returns an integer between -128 and 127 representing the signal to noise ratio (SNR) for the last received packet. get_pwr \u00b6 get_pwr () Returns an integer between -3 and 15 representing the current power level settings used in operation.","title":"RN2483 Module"},{"location":"reference/libs/microchip/rn2483/docs/rn2483/#rn2483-module","text":"This Zerynth module currently supports over-the-air activation only to join a LoRaWAN network. Class A LoRaWAN devices, after correctly joining a network, are able to transmit a message up to 222 bytes and receive a response up to 230 bytes during the subsequent downlink session. Sent messages can be confirmed (acknowledged) or unconfirmed; check your network policy to choose the proper transmit method ( datasheet , command reference , LoRaWAN specification ). NOTE: rn2483Exception is defined. Usage example: import streams from microchip.rn2483 import rn2483 streams . serial () rst = D16 # insert otaa credentials!! appeui = \"\" appkey = \"\" print ( \"joining...\" ) if not rn2483 . init ( SERIAL1 , appeui , appkey , rst ): print ( \"denied :(\" ) raise Exception print ( \"sending first message, res:\" ) print ( rn2483 . tx_uncnf ( 'TTN' )) while True : print ( \"ping, res:\" ) print ( rn2483 . tx_uncnf ( \".\" )) sleep ( 5000 )","title":"RN2483 Module"},{"location":"reference/libs/microchip/rn2483/docs/rn2483/#get_hweui","text":"get_hweui ( ser = None , rst = None ) Gets device EUI. If you need to get the EUI before joining a network, it is possible to specify: ser serial port used for device-to-module communication (ex. SERIAL1) rst module reset pin and call get_hweui() before init().","title":"get_hweui"},{"location":"reference/libs/microchip/rn2483/docs/rn2483/#get_ch_status","text":"get_ch_status ( channel ) Gets channel channel status: \u2018on\u2019 if enabled, \u2018off\u2019 otherwise.","title":"get_ch_status"},{"location":"reference/libs/microchip/rn2483/docs/rn2483/#get_duty_cycle","text":"get_duty_cycle ( channel , raw = False ) Gets channel channel duty cycle: returned by default as a percentage. As a raw value passing raw as True.","title":"get_duty_cycle"},{"location":"reference/libs/microchip/rn2483/docs/rn2483/#get_ar","text":"get_ar () Gets current automatic reply state (\u2018on\u2019 or \u2018off\u2019).","title":"get_ar"},{"location":"reference/libs/microchip/rn2483/docs/rn2483/#set_ar","text":"set_ar ( state ) Sets automatic reply to \u2018on\u2019 or \u2018off\u2019 state. Currently setting ar to \u2018on\u2019 does not have consequences on downlink session.","title":"set_ar"},{"location":"reference/libs/microchip/rn2483/docs/rn2483/#set_retransmissions","text":"set_retransmissions ( n ) Sets number of retransmissions to be used for an uplink confirmed packet, if no downlink acknoledgement is received from the server.","title":"set_retransmissions"},{"location":"reference/libs/microchip/rn2483/docs/rn2483/#config","text":"config ( appeui = None , appkey = None , deveui = None , pwridx = '1' , adr = 'off' , rx2 = '3 869525000' , retx = 5 , ar = 'off' ) Configures the lora module with otaa join credentials and other parameters. appeui , appkey are needed for otaa deveui is needed fot otaa too but if it is None, module\u2019s hardware eui will be used for activation pwridx sets the output power adr controls the adaptive data rate rx2 data rate and frequency used for the second Receive window retx number of retransmissions to be used for an uplink confirmed packet ar sets the state of the automatic reply","title":"config"},{"location":"reference/libs/microchip/rn2483/docs/rn2483/#set_config","text":"set_config () Sets the configuration parameters Configures the lora module with otaa join credentials and other parameters. appeui , appkey are needed for otaa deveui is needed fot otaa too but if it is None, module\u2019s hardware eui will be used for activation pwridx sets the output power adr controls the adaptive data rate rx2 data rate and frequency used for the second Receive window retx number of retransmissions to be used for an uplink confirmed packet ar sets the state of the automatic reply","title":"set_config"},{"location":"reference/libs/microchip/rn2483/docs/rn2483/#join","text":"join () Attempts to join the network using over-the-air activation.","title":"join"},{"location":"reference/libs/microchip/rn2483/docs/rn2483/#init","text":"init ( ser , appeui , appkey , rst , join_lora = True ) Performs basic module configuration and try over-the-air activation. ser is the serial port used for device-to-module communication (ex. SERIAL1) appeui , appkey are needed for otaa rst is the module reset pin if join_lora is False the configuration and over-the-air activation attempt are skipped and the module can be configured through the config() function and then the LoRa network can be joined calling the join() function.","title":"init"},{"location":"reference/libs/microchip/rn2483/docs/rn2483/#tx_uncnf","text":"tx_uncnf ( data ) Transmits an unconfirmed message. data is a string or a bytearray. Returns True if no data is available during downlink session, a tuple (True, resp_data), where resp_data is a bytearray, otherwise.","title":"tx_uncnf"},{"location":"reference/libs/microchip/rn2483/docs/rn2483/#tx_cnf","text":"tx_cnf ( data ) Transmits a confirmed message. data is a string or a bytearray. Returns True if no data is available during downlink session, a tuple (True, resp_data), where resp_data is a bytearray, otherwise.","title":"tx_cnf"},{"location":"reference/libs/microchip/rn2483/docs/rn2483/#get_snr","text":"get_snr () Returns an integer between -128 and 127 representing the signal to noise ratio (SNR) for the last received packet.","title":"get_snr"},{"location":"reference/libs/microchip/rn2483/docs/rn2483/#get_pwr","text":"get_pwr () Returns an integer between -3 and 15 representing the current power level settings used in operation.","title":"get_pwr"},{"location":"reference/libs/microchip/winc1500/docs/","text":"Microchip WINC1500 \u00b6 Microchip\u2019s WINC1500 is an IEEE 802.11 b/g/n IoT network controller. It brings Wi-Fi and Network capabilities through SPI-to-Wi-Fi interface. The WINC1500\u2019s most advanced mode is a single stream 1x1 802.11n mode providing up to 72 Mbps PHY throughput. The WINC1500 features a fully integrated Power Amplifier, LNA, Switch and Power Management. The WINC1500 provides internal Flash memory as well as multiple peripheral interfaces including UART and SPI. The only external clock source needed for the WINC1500 is a high-speed crystal or oscillator (26 MHz). The WINC1500 is available in a QFN package or as a certified module. The WINC1500 has 4 Mb of flash memory which can be used for system software. Note All the reported information are extracted from the official Microchip WINC1500 page , visit this page for more details and updates. Technical Details \u00b6 Operating Voltage Range: from 3.0 V to 4.2 V Operating Temperature Range: from -40 \u00b0C to 85 \u00b0C Frequency Range: from 2412 MHz to 2472 MHz Power Consumption: 70 mA (RX Mode) to 172 mA (TX Mode) Below, Zerynth driver documentation for Microchip WINC1500 wifi chip. Contents: WINC1500 Module","title":"Microchip WINC1500"},{"location":"reference/libs/microchip/winc1500/docs/#microchip-winc1500","text":"Microchip\u2019s WINC1500 is an IEEE 802.11 b/g/n IoT network controller. It brings Wi-Fi and Network capabilities through SPI-to-Wi-Fi interface. The WINC1500\u2019s most advanced mode is a single stream 1x1 802.11n mode providing up to 72 Mbps PHY throughput. The WINC1500 features a fully integrated Power Amplifier, LNA, Switch and Power Management. The WINC1500 provides internal Flash memory as well as multiple peripheral interfaces including UART and SPI. The only external clock source needed for the WINC1500 is a high-speed crystal or oscillator (26 MHz). The WINC1500 is available in a QFN package or as a certified module. The WINC1500 has 4 Mb of flash memory which can be used for system software. Note All the reported information are extracted from the official Microchip WINC1500 page , visit this page for more details and updates.","title":"Microchip WINC1500"},{"location":"reference/libs/microchip/winc1500/docs/#technical-details","text":"Operating Voltage Range: from 3.0 V to 4.2 V Operating Temperature Range: from -40 \u00b0C to 85 \u00b0C Frequency Range: from 2412 MHz to 2472 MHz Power Consumption: 70 mA (RX Mode) to 172 mA (TX Mode) Below, Zerynth driver documentation for Microchip WINC1500 wifi chip. Contents: WINC1500 Module","title":"Technical Details"},{"location":"reference/libs/microchip/winc1500/docs/winc1500/","text":"WINC1500 Module \u00b6 This module implements the winc1500 wifi driver. At the moment some functionalities are missing: wifi ap mode wifi direct p2p mode internal firmware ota upgrade It can be used to enable Arduino/Genuino MKR1000 wifi capabilities or with any other device mounting Microchip WINC1500 IEEE 802.11 network controller . Zerynth driver current implementation supports only communication with the chip through standard SPI interface. Note Zerynth driver is based on Microchip driver version 19.5.4 provided with Advanced Software Framework version 3.37.0 requiring the internal Firmware to be upgraded at least to version 19.5.4. For the upgrading procedure follow this guide: Firmware Updater . The WINC1500 chip supports secure connections through tls v1.2. To take advantage of this feature import the ssl module or simply try https requests with Zerynth requests module. Note To access securely specific websites root certificates must be loaded on the chip: Certificate Uploading . To use the module expand on the following example: from microchip.winc1500 import winc1500 as wifi_driver from wireless import wifi wifi_driver . auto_init () for retry in range ( 10 ): try : wifi . link ( \"Network-SSID\" , wifi . WIFI_WPA2 , \"password\" ) break except Exception as e : print ( e ) if not wifi . is_linked (): raise IOError init \u00b6 init ( spidrv , cs , int_pin , rst , enable , wake , clock ) To initialize the driver the following parameters are needed: MCU SPI circuitry spidrv (one of SPI0, SPI1, \u2026 check pinmap for details); chip select pin cs ; interrupt pin int_pin ; reset pin rst ; enable pin enable ; wake pin wake (can be not set); clock clock , default at 8MHz. Note For supported boards (e.g. Arduino/Genuino MKR1000), auto_init function is available with preset params.","title":"WINC1500 Module"},{"location":"reference/libs/microchip/winc1500/docs/winc1500/#winc1500-module","text":"This module implements the winc1500 wifi driver. At the moment some functionalities are missing: wifi ap mode wifi direct p2p mode internal firmware ota upgrade It can be used to enable Arduino/Genuino MKR1000 wifi capabilities or with any other device mounting Microchip WINC1500 IEEE 802.11 network controller . Zerynth driver current implementation supports only communication with the chip through standard SPI interface. Note Zerynth driver is based on Microchip driver version 19.5.4 provided with Advanced Software Framework version 3.37.0 requiring the internal Firmware to be upgraded at least to version 19.5.4. For the upgrading procedure follow this guide: Firmware Updater . The WINC1500 chip supports secure connections through tls v1.2. To take advantage of this feature import the ssl module or simply try https requests with Zerynth requests module. Note To access securely specific websites root certificates must be loaded on the chip: Certificate Uploading . To use the module expand on the following example: from microchip.winc1500 import winc1500 as wifi_driver from wireless import wifi wifi_driver . auto_init () for retry in range ( 10 ): try : wifi . link ( \"Network-SSID\" , wifi . WIFI_WPA2 , \"password\" ) break except Exception as e : print ( e ) if not wifi . is_linked (): raise IOError","title":"WINC1500 Module"},{"location":"reference/libs/microchip/winc1500/docs/winc1500/#init","text":"init ( spidrv , cs , int_pin , rst , enable , wake , clock ) To initialize the driver the following parameters are needed: MCU SPI circuitry spidrv (one of SPI0, SPI1, \u2026 check pinmap for details); chip select pin cs ; interrupt pin int_pin ; reset pin rst ; enable pin enable ; wake pin wake (can be not set); clock clock , default at 8MHz. Note For supported boards (e.g. Arduino/Genuino MKR1000), auto_init function is available with preset params.","title":"init"},{"location":"reference/libs/mozilla/webthing/docs/","text":"Mozilla \u00b6 All modules provided by the namespace Mozilla. Contents: Mozilla WebThing Mozilla WebThing library. Thing class Examples Simple Thing","title":"Index"},{"location":"reference/libs/mozilla/webthing/docs/#mozilla","text":"All modules provided by the namespace Mozilla. Contents: Mozilla WebThing Mozilla WebThing library. Thing class Examples Simple Thing","title":"Mozilla"},{"location":"reference/libs/mozilla/webthing/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.mozilla.webthing. Simple_Thing \u00b6 In this example a simple Thing is created and will be able to control a LED. Properties, events and actions are exposed through the Mozilla Web of Things API specifications. We used a Xinabox ESP32 which has an onboard LED. See https://iot.mozilla.org/wot/#web-thing-rest-api for more informations. How to run this example \u00b6 Edit the Wi-Fi informations at the beginning of main.py ; compile and uplink the project through Zerynth Studio and open the serial monitor. Your board will print out it's local IP address and an URL you can use to begin with. E.g.: http://192.168.1.137/xinabox . We'll be using curl command in a Linux terminal to easily test our API. Fetch Thing informations \u00b6 $ curl http://192.168.8.137/xinabox { \"name\": \"Xinabox ESP32\", \"description\": \"My really cool Xinabox ESP32\", \"properties\": { \"led\": { \"label\": \"LED\", \"type\": \"boolean\", \"readOnly\": false, \"description\": \"A LED which can be turned ON or OFF\", \"links\": [ { \"href\": \"/xinabox/properties/led\" } ] } }, \"actions\": { \"led\": { \"label\": \"LED\", \"description\": \"A LED which can be turned ON or OFF\", \"input\": { \"type\": null } } }, \"events\": { \"led_change\": { \"description\": \"LED changed status\" } }, \"links\": [ { \"rel\": \"properties\", \"href\": \"/xinabox/properties\" }, { \"rel\": \"actions\", \"href\": \"/xinabox/actions\" }, { \"rel\": \"events\", \"href\": \"/xinabox/events\" } ] } Fetch current LED status \u00b6 $ curl http://192.168.8.137/xinabox/properties { \"led\": true } Turn LED on/off \u00b6 $ curl -XPUT -H 'Content-Type: application/json' -d '{ \"led\": false }' http://192.168.8.137/xinabox/properties/led { \"led\": false } $ curl -XPUT -H 'Content-Type: application/json' -d '{ \"led\": true }' http://192.168.8.137/xinabox/properties/led { \"led\": true } main.py ############################################# # Simple_Thing # Created at 2018-12-01 23:59:48.293498 ############################################# import streams import json import requests from espressif.esp32net import esp32wifi as wifi_driver # Esp32 Wifi driver from wireless import wifi import mcu import threading # Mozilla WebThing library from mozilla.webthing import webthing # Wifi SSID and password SSID = \"YourSSID\" PASSWORD = \"YourPassword\" def setup_wifi (): ''' Init wifi driver and connect to the network using ssid and password provided in the `config` module. ''' wifi_driver . auto_init () print ( \"Establishing link to %s \" % SSID ) try : wifi . link ( SSID , wifi . WIFI_WPA2 , PASSWORD ) except Exception as e : print ( \"Error connecting to Wi-Fi\" ) print ( e ) sleep ( 5000 ) mcu . reset () # reboot device so it can retry print ( \"Connected\" ) def get_timestamp_from_the_web (): ''' Fetch and return current timestamp from a web service. ''' try : time_data = requests . get ( 'http://now.zerynth.com' ) . json () return time_data [ 'now' ][ 'iso8601' ] except Exception as e : print ( \"Error while obtaining current time\" ) print ( e ) streams . serial () # init serial connection for print setup_wifi () # connect to Wi-Fi # Init a Thing xinabox_thing = webthing . Thing ( \"xinabox\" , \"Xinabox ESP32\" , description = \"My really cool Xinabox ESP32\" , timestamp_fn = get_timestamp_from_the_web ) # Register available EVENTS xinabox_thing . register_event ( \"led_change\" , \"LED changed status\" ) # Register available PROPERTIES # for this example a LED can change its status (on or off) pinMode ( LED0 , OUTPUT_PUSHPULL ) digitalWrite ( LED0 , HIGH ) _led_status = True # we'll remember the LED status here def get_led ( payload = None ): ''' Return a boolean indicating if the led is currently on or not. ''' res = _led_status return res def set_led ( status ): ''' Set the LED to a new status indicated in payload[\"led\"]. ''' global _led_status digitalWrite ( LED0 , HIGH if status else LOW ) _led_status = status xinabox_thing . signal_event ( 'led_change' , inp_data = { \"new_status\" : status }) return status xinabox_thing . add_property ( \"led\" , \"LED\" , \"boolean\" , get_led , # This function is called on GET requests setter = set_led , # This function is called on PUT requests description = \"A LED which can be turned ON or OFF\" ) # Register available ACTIONS xinabox_thing . add_action ( \"led\" , \"LED\" , callback = get_led , description = \"A LED which can be turned ON or OFF\" ) # Start the webserver exposing this Thing via HTTP requests webthing . run_server ( xinabox_thing )","title":"Examples"},{"location":"reference/libs/mozilla/webthing/docs/examples/#examples","text":"The following are a list of examples for lib.mozilla.webthing.","title":"Examples"},{"location":"reference/libs/mozilla/webthing/docs/examples/#simple_thing","text":"In this example a simple Thing is created and will be able to control a LED. Properties, events and actions are exposed through the Mozilla Web of Things API specifications. We used a Xinabox ESP32 which has an onboard LED. See https://iot.mozilla.org/wot/#web-thing-rest-api for more informations.","title":"Simple_Thing"},{"location":"reference/libs/mozilla/webthing/docs/examples/#how-to-run-this-example","text":"Edit the Wi-Fi informations at the beginning of main.py ; compile and uplink the project through Zerynth Studio and open the serial monitor. Your board will print out it's local IP address and an URL you can use to begin with. E.g.: http://192.168.1.137/xinabox . We'll be using curl command in a Linux terminal to easily test our API.","title":"How to run this example"},{"location":"reference/libs/mozilla/webthing/docs/examples/#fetch-thing-informations","text":"$ curl http://192.168.8.137/xinabox { \"name\": \"Xinabox ESP32\", \"description\": \"My really cool Xinabox ESP32\", \"properties\": { \"led\": { \"label\": \"LED\", \"type\": \"boolean\", \"readOnly\": false, \"description\": \"A LED which can be turned ON or OFF\", \"links\": [ { \"href\": \"/xinabox/properties/led\" } ] } }, \"actions\": { \"led\": { \"label\": \"LED\", \"description\": \"A LED which can be turned ON or OFF\", \"input\": { \"type\": null } } }, \"events\": { \"led_change\": { \"description\": \"LED changed status\" } }, \"links\": [ { \"rel\": \"properties\", \"href\": \"/xinabox/properties\" }, { \"rel\": \"actions\", \"href\": \"/xinabox/actions\" }, { \"rel\": \"events\", \"href\": \"/xinabox/events\" } ] }","title":"Fetch Thing informations"},{"location":"reference/libs/mozilla/webthing/docs/examples/#fetch-current-led-status","text":"$ curl http://192.168.8.137/xinabox/properties { \"led\": true }","title":"Fetch current LED status"},{"location":"reference/libs/mozilla/webthing/docs/examples/#turn-led-onoff","text":"$ curl -XPUT -H 'Content-Type: application/json' -d '{ \"led\": false }' http://192.168.8.137/xinabox/properties/led { \"led\": false } $ curl -XPUT -H 'Content-Type: application/json' -d '{ \"led\": true }' http://192.168.8.137/xinabox/properties/led { \"led\": true } main.py ############################################# # Simple_Thing # Created at 2018-12-01 23:59:48.293498 ############################################# import streams import json import requests from espressif.esp32net import esp32wifi as wifi_driver # Esp32 Wifi driver from wireless import wifi import mcu import threading # Mozilla WebThing library from mozilla.webthing import webthing # Wifi SSID and password SSID = \"YourSSID\" PASSWORD = \"YourPassword\" def setup_wifi (): ''' Init wifi driver and connect to the network using ssid and password provided in the `config` module. ''' wifi_driver . auto_init () print ( \"Establishing link to %s \" % SSID ) try : wifi . link ( SSID , wifi . WIFI_WPA2 , PASSWORD ) except Exception as e : print ( \"Error connecting to Wi-Fi\" ) print ( e ) sleep ( 5000 ) mcu . reset () # reboot device so it can retry print ( \"Connected\" ) def get_timestamp_from_the_web (): ''' Fetch and return current timestamp from a web service. ''' try : time_data = requests . get ( 'http://now.zerynth.com' ) . json () return time_data [ 'now' ][ 'iso8601' ] except Exception as e : print ( \"Error while obtaining current time\" ) print ( e ) streams . serial () # init serial connection for print setup_wifi () # connect to Wi-Fi # Init a Thing xinabox_thing = webthing . Thing ( \"xinabox\" , \"Xinabox ESP32\" , description = \"My really cool Xinabox ESP32\" , timestamp_fn = get_timestamp_from_the_web ) # Register available EVENTS xinabox_thing . register_event ( \"led_change\" , \"LED changed status\" ) # Register available PROPERTIES # for this example a LED can change its status (on or off) pinMode ( LED0 , OUTPUT_PUSHPULL ) digitalWrite ( LED0 , HIGH ) _led_status = True # we'll remember the LED status here def get_led ( payload = None ): ''' Return a boolean indicating if the led is currently on or not. ''' res = _led_status return res def set_led ( status ): ''' Set the LED to a new status indicated in payload[\"led\"]. ''' global _led_status digitalWrite ( LED0 , HIGH if status else LOW ) _led_status = status xinabox_thing . signal_event ( 'led_change' , inp_data = { \"new_status\" : status }) return status xinabox_thing . add_property ( \"led\" , \"LED\" , \"boolean\" , get_led , # This function is called on GET requests setter = set_led , # This function is called on PUT requests description = \"A LED which can be turned ON or OFF\" ) # Register available ACTIONS xinabox_thing . add_action ( \"led\" , \"LED\" , callback = get_led , description = \"A LED which can be turned ON or OFF\" ) # Start the webserver exposing this Thing via HTTP requests webthing . run_server ( xinabox_thing )","title":"Turn LED on/off"},{"location":"reference/libs/mozilla/webthing/docs/webserver/","text":"","title":"Webserver"},{"location":"reference/libs/mozilla/webthing/docs/webthing/","text":"Mozilla WebThing library. \u00b6 Thing class \u00b6 class Thing \u00b6 class Thing () A Thing is an object exposing some REST API containing properties, actionsand events. Thing. init \u00b6 __init__ ( thing_id , name , description = None , base_url = \"/\" , timestamp_fn = None ) thing_id is the unique id for a Thing. name is pretty name for human interfaces. description is a human readable description of this Thing. base_url is the base path, configurable for advanced purposes. timestamp_fn is a function to call for retrieving a timestamp string to be used in events generation. Store a webserver instance for using it later when an action is created. .. method:: add_property(prop_id, label, prop_type, getter, setter=None, unit=None, description=None) Add a new property to this thing. prop_id is a string for identifying uniquely a property. label is a pretty name for this property. prop_type can be one of [\u201cinteger\u201d, \u201cnumber\u201d, \u201cboolean\u201d]. getter is a function that must return current status of this property. setter is a function that must accept new status as a parameter and set it. unit is a pretty name for the measure unit of this property. description is a human readable description of this property. Thing.add_action \u00b6 add_action ( act_id , label , callback , input_type = None , description = None ) Add a new action to this thing. act_id is a string for identifying uniquely an action. label is a pretty name for this action. input_type can be one of [\u201cinteger\u201d, \u201cnumber\u201d, \u201cboolean\u201d]. callback is a function that must accept a parameter of input_type and use it. description is a human readable description of this action. Thing.register_event \u00b6 register_event ( evt_id , description ) Register a new event type to this Thing. evt_id is a string for identifying uniquely this event type. description is a human readable description for this event. Thing.signal_event \u00b6 signal_event ( evt_id , inp_data = None ) Log a new event of type evt_id. evt_id is a string for choosing a registered event type. inp_data is an optional argument for this event type. Thing.as_dict \u00b6 as_dict () Return a dict representing this Thing.","title":"Mozilla WebThing library."},{"location":"reference/libs/mozilla/webthing/docs/webthing/#mozilla-webthing-library","text":"","title":"Mozilla WebThing library."},{"location":"reference/libs/mozilla/webthing/docs/webthing/#thing-class","text":"","title":"Thing class"},{"location":"reference/libs/mozilla/webthing/docs/webthing/#class-thing","text":"class Thing () A Thing is an object exposing some REST API containing properties, actionsand events.","title":"class Thing"},{"location":"reference/libs/mozilla/webthing/docs/webthing/#thinginit","text":"__init__ ( thing_id , name , description = None , base_url = \"/\" , timestamp_fn = None ) thing_id is the unique id for a Thing. name is pretty name for human interfaces. description is a human readable description of this Thing. base_url is the base path, configurable for advanced purposes. timestamp_fn is a function to call for retrieving a timestamp string to be used in events generation. Store a webserver instance for using it later when an action is created. .. method:: add_property(prop_id, label, prop_type, getter, setter=None, unit=None, description=None) Add a new property to this thing. prop_id is a string for identifying uniquely a property. label is a pretty name for this property. prop_type can be one of [\u201cinteger\u201d, \u201cnumber\u201d, \u201cboolean\u201d]. getter is a function that must return current status of this property. setter is a function that must accept new status as a parameter and set it. unit is a pretty name for the measure unit of this property. description is a human readable description of this property.","title":"Thing.init"},{"location":"reference/libs/mozilla/webthing/docs/webthing/#thingadd_action","text":"add_action ( act_id , label , callback , input_type = None , description = None ) Add a new action to this thing. act_id is a string for identifying uniquely an action. label is a pretty name for this action. input_type can be one of [\u201cinteger\u201d, \u201cnumber\u201d, \u201cboolean\u201d]. callback is a function that must accept a parameter of input_type and use it. description is a human readable description of this action.","title":"Thing.add_action"},{"location":"reference/libs/mozilla/webthing/docs/webthing/#thingregister_event","text":"register_event ( evt_id , description ) Register a new event type to this Thing. evt_id is a string for identifying uniquely this event type. description is a human readable description for this event.","title":"Thing.register_event"},{"location":"reference/libs/mozilla/webthing/docs/webthing/#thingsignal_event","text":"signal_event ( evt_id , inp_data = None ) Log a new event of type evt_id. evt_id is a string for choosing a registered event type. inp_data is an optional argument for this event type.","title":"Thing.signal_event"},{"location":"reference/libs/mozilla/webthing/docs/webthing/#thingas_dict","text":"as_dict () Return a dict representing this Thing.","title":"Thing.as_dict"},{"location":"reference/libs/murata/lbee5kl1dx/docs/","text":"Murata LBEE5KL1DX \u00b6 The Type 1DX module is an ultra-small module that includes 2.4GHz WLAN and Bluetooth functionality. Based on Cypress CYW4343W, the module provide high-efficiency RF front end circuits. The module is designed to fit into small spaces and is smaller than a dime. Minimal external circuitry is required to complete a radio design; add an antenna, power source, clocks, processor, and associated interface hardware and the radio hardware design is complete. To ease Wi-Fi certification, the Type 1DX module complies with IEEE 802.11b/g/n and Bluetooth Version 4.1 plus EDR, Power Class 1 (10dBm max) + BLE. The Murata LBEE5KL1DX single-chip device provides the highest level of integration for mobile and handheld wireless systems, featuring integrated IEEE 802.11 b/g and handheld device class IEEE 802.11n. It includes a 2.4 GHz WLAN CMOS power amplifier (PA) that meets the output power requirements of most handheld systems. Along with the integrated power amplifier, the LBEE5KL1DX also includes integrated transmit and receive baluns, further reducing the overall solution cost. Technical Details \u00b6 Power Supply Voltage (Vbat): from 3.35 V to 4.2 V Operation Temperature (Top): from -30 \u00b0C to 70 \u00b0C Frequency Range: from 2400 MHz to 2483.5 MHz Transmit Power: +17dBm @ 11Mbps (2.4GHz) +13dBm @ 54Mbps (2.4GHz) +12dBm @ 65Mbps Receiver Sensitivity: -89dBm @ 11Mbps (2.4GHz) -75dBm @ 54Mbps (2.4GHz) -73dBm @ 65Mbps (2.4GHz) Transmit Mode Current: 320mA @ 11Mbps 270mA @ 54Mbps 260mA @ 65Mbps Receive Mode Current: 47mA @ 11Mbps (2.4GHz) 47mA @ 54Mbps (2.4GHz) 47mA @ 65Mbps (2.4GHz) Here below, the Zerynth driver for the Murata LBEE5KL1DX wifi chip. Contents: LBEE5KL1DX Module","title":"Murata LBEE5KL1DX"},{"location":"reference/libs/murata/lbee5kl1dx/docs/#murata-lbee5kl1dx","text":"The Type 1DX module is an ultra-small module that includes 2.4GHz WLAN and Bluetooth functionality. Based on Cypress CYW4343W, the module provide high-efficiency RF front end circuits. The module is designed to fit into small spaces and is smaller than a dime. Minimal external circuitry is required to complete a radio design; add an antenna, power source, clocks, processor, and associated interface hardware and the radio hardware design is complete. To ease Wi-Fi certification, the Type 1DX module complies with IEEE 802.11b/g/n and Bluetooth Version 4.1 plus EDR, Power Class 1 (10dBm max) + BLE. The Murata LBEE5KL1DX single-chip device provides the highest level of integration for mobile and handheld wireless systems, featuring integrated IEEE 802.11 b/g and handheld device class IEEE 802.11n. It includes a 2.4 GHz WLAN CMOS power amplifier (PA) that meets the output power requirements of most handheld systems. Along with the integrated power amplifier, the LBEE5KL1DX also includes integrated transmit and receive baluns, further reducing the overall solution cost.","title":"Murata LBEE5KL1DX"},{"location":"reference/libs/murata/lbee5kl1dx/docs/#technical-details","text":"Power Supply Voltage (Vbat): from 3.35 V to 4.2 V Operation Temperature (Top): from -30 \u00b0C to 70 \u00b0C Frequency Range: from 2400 MHz to 2483.5 MHz Transmit Power: +17dBm @ 11Mbps (2.4GHz) +13dBm @ 54Mbps (2.4GHz) +12dBm @ 65Mbps Receiver Sensitivity: -89dBm @ 11Mbps (2.4GHz) -75dBm @ 54Mbps (2.4GHz) -73dBm @ 65Mbps (2.4GHz) Transmit Mode Current: 320mA @ 11Mbps 270mA @ 54Mbps 260mA @ 65Mbps Receive Mode Current: 47mA @ 11Mbps (2.4GHz) 47mA @ 54Mbps (2.4GHz) 47mA @ 65Mbps (2.4GHz) Here below, the Zerynth driver for the Murata LBEE5KL1DX wifi chip. Contents: LBEE5KL1DX Module","title":"Technical Details"},{"location":"reference/libs/murata/lbee5kl1dx/docs/lbee5kl1dx/","text":"LBEE5KL1DX Module \u00b6 This module implements the lbee5kl1dx wifi driver. At the moment some functionalities are missing: soft ap wifi direct It can be used with Cypress PSoC6 WiFi-BT Pioneer Kit. lbee5kl1dx communication is based on the SDIO standard. TLS support is available by means of Zeynth mbedTLS integration. To enable it and allow the creation of TLS sockets using the Zerynth ssl module, place ZERYNTH_SSL: true inside your project project.yml file. init \u00b6 init ( country ) Arguments: contry \u2013 two-letter country code Tries to init the lbee5kl1dx driver. Raises PeripheralError: in case of failed initialization auto_init \u00b6 auto_init ( country = \"US\" ) Arguments: contry \u2013 two-letter country code Tries to automatically init the lbee5kl1dx driver by looking at the device type. Raises PeripheralError: in case of failed initialization","title":"LBEE5KL1DX Module"},{"location":"reference/libs/murata/lbee5kl1dx/docs/lbee5kl1dx/#lbee5kl1dx-module","text":"This module implements the lbee5kl1dx wifi driver. At the moment some functionalities are missing: soft ap wifi direct It can be used with Cypress PSoC6 WiFi-BT Pioneer Kit. lbee5kl1dx communication is based on the SDIO standard. TLS support is available by means of Zeynth mbedTLS integration. To enable it and allow the creation of TLS sockets using the Zerynth ssl module, place ZERYNTH_SSL: true inside your project project.yml file.","title":"LBEE5KL1DX Module"},{"location":"reference/libs/murata/lbee5kl1dx/docs/lbee5kl1dx/#init","text":"init ( country ) Arguments: contry \u2013 two-letter country code Tries to init the lbee5kl1dx driver. Raises PeripheralError: in case of failed initialization","title":"init"},{"location":"reference/libs/murata/lbee5kl1dx/docs/lbee5kl1dx/#auto_init","text":"auto_init ( country = \"US\" ) Arguments: contry \u2013 two-letter country code Tries to automatically init the lbee5kl1dx driver by looking at the device type. Raises PeripheralError: in case of failed initialization","title":"auto_init"},{"location":"reference/libs/nordic/nrf52_ble/docs/","text":"Nordic NRF5 BLE \u00b6 The nRF52832 and nRF52840 SoC are powerful, highly flexible ultra-low power multiprotocol SoC implementing a powerful BLE stack. The following driver enables the use of the S132/S140 SoftDevice (BLE 4.2 compliant) in peripheral role with scanning capabilities. Contents: Nordic NRF5 BLE NRF52 BLE Examples BLE Alerts BLE Alerts Secure 1 BLE Alerts Secure 2 BLE Battery Service BLE Scanner","title":"Nordic NRF5 BLE"},{"location":"reference/libs/nordic/nrf52_ble/docs/#nordic-nrf5-ble","text":"The nRF52832 and nRF52840 SoC are powerful, highly flexible ultra-low power multiprotocol SoC implementing a powerful BLE stack. The following driver enables the use of the S132/S140 SoftDevice (BLE 4.2 compliant) in peripheral role with scanning capabilities. Contents: Nordic NRF5 BLE NRF52 BLE Examples BLE Alerts BLE Alerts Secure 1 BLE Alerts Secure 2 BLE Battery Service BLE Scanner","title":"Nordic NRF5 BLE"},{"location":"reference/libs/nordic/nrf52_ble/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.nordic.nrf52_ble. BLE Alerts \u00b6 An implementationof an Alert Notification device to show how services and characteristics can be easily created. main.py ################################################################################ # BLE Alerts # # Created by Zerynth Team 2019 CC # Author: G. Baldi ############################################################################### import streams # import a BLE driver: in this example we use NRF52 from nordic.nrf52_ble import nrf52_ble as bledrv # then import the BLE modue from wireless import ble streams . serial () notifications_enabled = True connected = False # Let's define some callbacks def value_cb ( status , val ): # check incoming commands and enable/disable notifications global notifications_enabled print ( \"Value changed to\" , val [ 0 ], val [ 1 ]) if val [ 0 ] == 0 : print ( \"Notifications enabled\" ) notifications_enabled = True elif val [ 0 ] == 2 : notifications_enabled = False print ( \"Notifications disabled\" ) else : print ( \"Notifications unchanged\" ) def connection_cb ( address ): global connected print ( \"Connected to\" , ble . btos ( address )) connected = True def disconnection_cb ( address ): global connected print ( \"Disconnected from\" , ble . btos ( address )) # let's start advertising again ble . start_advertising () connected = False try : # initialize BLE driver bledrv . init () # Set GAP name and no security ble . gap ( \"ZNotifier\" , security = ( ble . SECURITY_MODE_1 , ble . SECURITY_LEVEL_1 )) # add some GAP callbacks ble . add_callback ( ble . EVT_CONNECTED , connection_cb ) ble . add_callback ( ble . EVT_DISCONNECTED , disconnection_cb ) # Create a GATT Service: let's try an Alert Notification Service # (here are the specs: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.service.alert_notification.xml) s = ble . Service ( 0x1811 ) # The Alert Notification service has multiple characteristics. Let's add them one by one # Create a GATT Characteristic for counting new alerts. # specs: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.characteristic.supported_new_alert_category.xml cn = ble . Characteristic ( 0x2A47 , ble . NOTIFY | ble . READ , 16 , \"New Alerts\" , ble . BYTES ) # Add the GATT Characteristic to the Service s . add_characteristic ( cn ) # Create anothr GATT Characteristic for enabling/disabling alerts # specs: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.characteristic.alert_notification_control_point.xml cc = ble . Characteristic ( 0x2A44 , ble . WRITE , 2 , \"Alerts control\" , ble . BYTES ) # Add the GATT Characteristic to the Service s . add_characteristic ( cc ) # Add a callback to be notified of changes cc . set_callback ( value_cb ) # Add the Service. You can create additional services and add them one by one ble . add_service ( s ) # Setup advertising to 50ms ble . advertising ( 50 ) # Start the BLE stack ble . start () # Now start advertising ble . start_advertising () except Exception as e : print ( e ) # loop forever while True : print ( \".\" ) if random ( 0 , 100 ) < 50 and notifications_enabled and connected : value = bytearray ( cn . get_value ()) value [ 0 ] = 0 # simple alert type if value [ 1 ] < 255 : value [ 1 ] = value [ 1 ] + 1 # add a notification print ( \"Adding a new notification, total of\" , value [ 1 ]) # the remaining 14 bytes can be some text value [ 2 : 10 ] = \"Zerynth!\" # set the new value. If ble notifications are enabled, the connected device will receive the change cn . set_value ( value ) sleep ( 5000 ) BLE Alerts with Security 1 \u00b6 An implementationof an Alert Notification device to show how services and characteristics can be easily created. It also features secure connections with bonding. main.py ################################################################################ # BLE Alerts with security # # Created by Zerynth Team 2019 CC # Author: G. Baldi ############################################################################### import streams # import a BLE driver: in this example we use NRF52 from nordic.nrf52_ble import nrf52_ble as bledrv # then import the BLE modue from wireless import ble streams . serial () notifications_enabled = True connected = False # Let's define some callbacks def value_cb ( status , val ): # check incoming commands and enable/disable notifications global notifications_enabled print ( \"Value changed to\" , val [ 0 ], val [ 1 ]) if val [ 0 ] == 0 : print ( \"Notifications enabled\" ) notifications_enabled = True elif val [ 0 ] == 2 : notifications_enabled = False print ( \"Notifications disabled\" ) else : print ( \"Notifications unchanged\" ) def connection_cb ( address ): global connected print ( \"Connected to\" , ble . btos ( address )) connected = True def disconnection_cb ( address ): global connected print ( \"Disconnected from\" , ble . btos ( address )) # let's start advertising again ble . start_advertising () connected = False # Let's define some security callbacks def show_key_cb ( passkey ): print ( \"ENTER THIS PIN ON THE MASTER:\" , passkey ) try : # initialize BLE driver bledrv . init () # Set GAP name and LEVEL 2 security # !!! If security is not set, no secure connection will be possible ble . gap ( \"ZNotifier\" , security = ( ble . SECURITY_MODE_1 , ble . SECURITY_LEVEL_2 )) # add some GAP callbacks ble . add_callback ( ble . EVT_CONNECTED , connection_cb ) ble . add_callback ( ble . EVT_DISCONNECTED , disconnection_cb ) # Create a GATT Service: let's try an Alert Notification Service # (here are the specs: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.service.alert_notification.xml) s = ble . Service ( 0x1811 ) # The Alert Notification service has multiple characteristics. Let's add them one by one # Create a GATT Characteristic for counting new alerts. # specs: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.characteristic.supported_new_alert_category.xml cn = ble . Characteristic ( 0x2A47 , ble . NOTIFY | ble . READ , 16 , \"New Alerts\" , ble . BYTES ) # Add the GATT Characteristic to the Service s . add_characteristic ( cn ) # Create anothr GATT Characteristic for enabling/disabling alerts # specs: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.characteristic.alert_notification_control_point.xml cc = ble . Characteristic ( 0x2A44 , ble . WRITE , 2 , \"Alerts control\" , ble . BYTES ) # Add the GATT Characteristic to the Service s . add_characteristic ( cc ) # Add a callback to be notified of changes cc . set_callback ( value_cb ) # Add the Service. You can create additional services and add them one by one ble . add_service ( s ) # Configure security. BLE security is very flexible. # In this case we declare that the device has only an output capability (CAP_DISPLAY_ONLY), # that we require a bonding (storage of the keys after pairing) # and that we want both secure connection and main in the middle protection. # Since we have CAP_DISPLAY_ONLY, we also declare a passkey that will be shown to the user # to be entered on the master (i.e. the smartphone) to finalize the bonding. ble . security ( capabilities = ble . CAP_DISPLAY_ONLY , bonding = ble . AUTH_BOND , scheme = ble . AUTH_SC | ble . AUTH_MITM , key_size = 16 , passkey = 225575 ) # To do so, we need a callback to display the passkey when needed ble . add_callback ( ble . EVT_SHOW_PASSKEY , show_key_cb ) # Setup advertising to 50ms ble . advertising ( 50 ) # Start the BLE stack ble . start () # Now start advertising ble . start_advertising () except Exception as e : print ( e ) # loop forever while True : print ( \".\" ) if random ( 0 , 100 ) < 50 and notifications_enabled and connected : value = bytearray ( cn . get_value ()) value [ 0 ] = 0 # simple alert type if value [ 1 ] < 255 : value [ 1 ] = value [ 1 ] + 1 # add a notification print ( \"Adding a new notification, total of\" , value [ 1 ]) # the remaining 14 bytes can be some text value [ 2 : 10 ] = \"Zerynth!\" # set the new value. If ble notifications are enabled, the connected device will receive the change cn . set_value ( value ) sleep ( 5000 ) BLE Alerts with Security 2 \u00b6 An implementationof an Alert Notification device to show how services and characteristics can be easily created. It also features secure connections with bonding using confirmation capabilities of the device. main.py ################################################################################ # BLE Alerts with Security 2 # # Created by Zerynth Team 2019 CC # Author: G. Baldi ############################################################################### import streams # import a BLE driver: in this example we use NRF52 from nordic.nrf52_ble import nrf52_ble as bledrv # then import the BLE modue from wireless import ble streams . serial () notifications_enabled = True connected = False # Let's define some callbacks def value_cb ( status , val ): # check incoming commands and enable/disable notifications global notifications_enabled print ( \"Value changed to\" , val [ 0 ], val [ 1 ]) if val [ 0 ] == 0 : print ( \"Notifications enabled\" ) notifications_enabled = True elif val [ 0 ] == 2 : notifications_enabled = False print ( \"Notifications disabled\" ) else : print ( \"Notifications unchanged\" ) def connection_cb ( address ): global connected print ( \"Connected to\" , ble . btos ( address )) connected = True def disconnection_cb ( address ): global connected print ( \"Disconnected from\" , ble . btos ( address )) # let's start advertising again ble . start_advertising () connected = False # Let's define some security callbacks def match_key_cb ( passkey ): print ( \"MASTER KEY IS:\" , passkey , \"CAN WE PROCEED? PRESS BUTTON FOR YES\" ) pinMode ( BTN0 , INPUT ) for i in range ( 5 ): if digitalRead ( BTN0 ) != 0 : ble . confirm_passkey ( 1 ) print ( \"Confirmed!\" ) return sleep ( 1000 ) ble . confirm_passkey ( 0 ) print ( \"Not confirmed!\" ) try : # initialize BLE driver bledrv . init () # Set GAP name and LEVEL 2 security # !!! If security is not set, no secure connection will be possible ble . gap ( \"ZNotifier\" , security = ( ble . SECURITY_MODE_1 , ble . SECURITY_LEVEL_2 )) # add some GAP callbacks ble . add_callback ( ble . EVT_CONNECTED , connection_cb ) ble . add_callback ( ble . EVT_DISCONNECTED , disconnection_cb ) # Create a GATT Service: let's try an Alert Notification Service # (here are the specs: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.service.alert_notification.xml) s = ble . Service ( 0x1811 ) # The Alert Notification service has multiple characteristics. Let's add them one by one # Create a GATT Characteristic for counting new alerts. # specs: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.characteristic.supported_new_alert_category.xml cn = ble . Characteristic ( 0x2A47 , ble . NOTIFY | ble . READ , 16 , \"New Alerts\" , ble . BYTES ) # Add the GATT Characteristic to the Service s . add_characteristic ( cn ) # Create anothr GATT Characteristic for enabling/disabling alerts # specs: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.characteristic.alert_notification_control_point.xml cc = ble . Characteristic ( 0x2A44 , ble . WRITE , 2 , \"Alerts control\" , ble . BYTES ) # Add the GATT Characteristic to the Service s . add_characteristic ( cc ) # Add a callback to be notified of changes cc . set_callback ( value_cb ) # Add the Service. You can create additional services and add them one by one ble . add_service ( s ) # Configure security. BLE security is very flexible. # In this case we declare that the device has only an output capability with yes o or no input (CAP_DISPLAY_YES_NO), # that we require a bonding (storage of the keys after pairing) # and that we want both secure connection and main in the middle protection. ble . security ( capabilities = ble . CAP_DISPLAY_YES_NO , bonding = ble . AUTH_BOND , scheme = ble . AUTH_SC | ble . AUTH_MITM , key_size = 16 ) # To do so, we need a callback to accept the passkey when needed ble . add_callback ( ble . EVT_MATCH_PASSKEY , match_key_cb ) # Setup advertising to 50ms ble . advertising ( 50 ) # Start the BLE stack ble . start () # Now start advertising ble . start_advertising () except Exception as e : print ( e ) # Uncomment the following lines to delte bonded devices! for bond in ble . bonded (): print ( \"Removing bonded:\" , ble . btos ( bond )) ble . remove_bonded ( bond ) # loop forever while True : print ( \".\" ) if random ( 0 , 100 ) < 50 and notifications_enabled and connected : value = bytearray ( cn . get_value ()) value [ 0 ] = 0 # simple alert type if value [ 1 ] < 255 : value [ 1 ] = value [ 1 ] + 1 # add a notification print ( \"Adding a new notification, total of\" , value [ 1 ]) # the remaining 14 bytes can be some text value [ 2 : 10 ] = \"Zerynth!\" # set the new value. If ble notifications are enabled, the connected device will receive the change cn . set_value ( value ) sleep ( 5000 ) BLE Battery Service \u00b6 A minimal example implementing a Battery Level Service on a NRF52 chip. main.py ################################################################################ # BLE Battery Service # # Created by Zerynth Team 2016 CC # Author: G. Baldi ############################################################################### import streams # import a BLE driver: in this example we use NRF52 from nordic.nrf52_ble import nrf52_ble as bledrv # then import the BLE modue from wireless import ble streams . serial () # initialize NRF52 driver bledrv . init () # Set GAP name ble . gap ( \"Zerynth\" ) # Create a GATT Service: let's try a Battery Service (uuid is 0x180F) s = ble . Service ( 0x180F ) # Create a GATT Characteristic: (uuid for Battery Level is 0x2A19, and it is an 8-bit number) c = ble . Characteristic ( 0x2A19 , ble . NOTIFY | ble . READ , 1 , \"Battery Level\" , ble . NUMBER ) # Add the GATT Characteristic to the Service s . add_characteristic ( c ) # Add the Service ble . add_service ( s ) # Start the BLE stack ble . start () # Begin advertising ble . start_advertising () while True : print ( \".\" ) sleep ( 1000 ) # Let's update the Characteristic Value c . set_value ( random ( 0 , 100 )) BLE Scanner \u00b6 A simple example implementing a BLE packet scanner. main.py ################################################################################ # BLE Scanner # # Created by Zerynth Team 2019 CC # Author: G. Baldi ############################################################################### import streams # import a BLE driver: in this example we use NRF52 from nordic.nrf52_ble import nrf52_ble as bledrv # then import the BLE modue from wireless import ble streams . serial () # Let's define some callbacks and constants # How long to scan for in milliseconds scan_time = 30000 def scan_report_cb ( data ): print ( \"Detected packet from\" , ble . btos ( data [ 4 ]), \"containing\" , ble . btos ( data [ 3 ])) print ( \" packet is of type\" , ble . btos ( data [ 0 ]), \"while address is of type\" , ble . btos ( data [ 1 ])) print ( \" remote device has RSSI of\" , ble . btos ( data [ 2 ])) def scan_start_cb ( data ): print ( \"Scan started\" ) def scan_stop_cb ( data ): print ( \"Scan stopped\" ) #let's start it up again ble . start_scanning ( scan_time ) try : # initialize BLE driver bledrv . init () # Set GAP name and no security ble . gap ( \"Zerynth\" , security = ( ble . SECURITY_MODE_1 , ble . SECURITY_LEVEL_1 )) ble . add_callback ( ble . EVT_SCAN_REPORT , scan_report_cb ) ble . add_callback ( ble . EVT_SCAN_STARTED , scan_start_cb ) ble . add_callback ( ble . EVT_SCAN_STOPPED , scan_stop_cb ) #set scanning parameters: every 100ms for 50ms and no duplicates ble . scanning ( 100 , 50 , duplicates = 0 ) # Start the BLE stack ble . start () # Now start scanning for 30 seconds ble . start_scanning ( scan_time ) except Exception as e : print ( e ) # loop forever while True : print ( \".\" ) sleep ( 10000 )","title":"Examples"},{"location":"reference/libs/nordic/nrf52_ble/docs/examples/#examples","text":"The following are a list of examples for lib.nordic.nrf52_ble.","title":"Examples"},{"location":"reference/libs/nordic/nrf52_ble/docs/examples/#ble-alerts","text":"An implementationof an Alert Notification device to show how services and characteristics can be easily created. main.py ################################################################################ # BLE Alerts # # Created by Zerynth Team 2019 CC # Author: G. Baldi ############################################################################### import streams # import a BLE driver: in this example we use NRF52 from nordic.nrf52_ble import nrf52_ble as bledrv # then import the BLE modue from wireless import ble streams . serial () notifications_enabled = True connected = False # Let's define some callbacks def value_cb ( status , val ): # check incoming commands and enable/disable notifications global notifications_enabled print ( \"Value changed to\" , val [ 0 ], val [ 1 ]) if val [ 0 ] == 0 : print ( \"Notifications enabled\" ) notifications_enabled = True elif val [ 0 ] == 2 : notifications_enabled = False print ( \"Notifications disabled\" ) else : print ( \"Notifications unchanged\" ) def connection_cb ( address ): global connected print ( \"Connected to\" , ble . btos ( address )) connected = True def disconnection_cb ( address ): global connected print ( \"Disconnected from\" , ble . btos ( address )) # let's start advertising again ble . start_advertising () connected = False try : # initialize BLE driver bledrv . init () # Set GAP name and no security ble . gap ( \"ZNotifier\" , security = ( ble . SECURITY_MODE_1 , ble . SECURITY_LEVEL_1 )) # add some GAP callbacks ble . add_callback ( ble . EVT_CONNECTED , connection_cb ) ble . add_callback ( ble . EVT_DISCONNECTED , disconnection_cb ) # Create a GATT Service: let's try an Alert Notification Service # (here are the specs: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.service.alert_notification.xml) s = ble . Service ( 0x1811 ) # The Alert Notification service has multiple characteristics. Let's add them one by one # Create a GATT Characteristic for counting new alerts. # specs: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.characteristic.supported_new_alert_category.xml cn = ble . Characteristic ( 0x2A47 , ble . NOTIFY | ble . READ , 16 , \"New Alerts\" , ble . BYTES ) # Add the GATT Characteristic to the Service s . add_characteristic ( cn ) # Create anothr GATT Characteristic for enabling/disabling alerts # specs: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.characteristic.alert_notification_control_point.xml cc = ble . Characteristic ( 0x2A44 , ble . WRITE , 2 , \"Alerts control\" , ble . BYTES ) # Add the GATT Characteristic to the Service s . add_characteristic ( cc ) # Add a callback to be notified of changes cc . set_callback ( value_cb ) # Add the Service. You can create additional services and add them one by one ble . add_service ( s ) # Setup advertising to 50ms ble . advertising ( 50 ) # Start the BLE stack ble . start () # Now start advertising ble . start_advertising () except Exception as e : print ( e ) # loop forever while True : print ( \".\" ) if random ( 0 , 100 ) < 50 and notifications_enabled and connected : value = bytearray ( cn . get_value ()) value [ 0 ] = 0 # simple alert type if value [ 1 ] < 255 : value [ 1 ] = value [ 1 ] + 1 # add a notification print ( \"Adding a new notification, total of\" , value [ 1 ]) # the remaining 14 bytes can be some text value [ 2 : 10 ] = \"Zerynth!\" # set the new value. If ble notifications are enabled, the connected device will receive the change cn . set_value ( value ) sleep ( 5000 )","title":"BLE Alerts"},{"location":"reference/libs/nordic/nrf52_ble/docs/examples/#ble-alerts-with-security-1","text":"An implementationof an Alert Notification device to show how services and characteristics can be easily created. It also features secure connections with bonding. main.py ################################################################################ # BLE Alerts with security # # Created by Zerynth Team 2019 CC # Author: G. Baldi ############################################################################### import streams # import a BLE driver: in this example we use NRF52 from nordic.nrf52_ble import nrf52_ble as bledrv # then import the BLE modue from wireless import ble streams . serial () notifications_enabled = True connected = False # Let's define some callbacks def value_cb ( status , val ): # check incoming commands and enable/disable notifications global notifications_enabled print ( \"Value changed to\" , val [ 0 ], val [ 1 ]) if val [ 0 ] == 0 : print ( \"Notifications enabled\" ) notifications_enabled = True elif val [ 0 ] == 2 : notifications_enabled = False print ( \"Notifications disabled\" ) else : print ( \"Notifications unchanged\" ) def connection_cb ( address ): global connected print ( \"Connected to\" , ble . btos ( address )) connected = True def disconnection_cb ( address ): global connected print ( \"Disconnected from\" , ble . btos ( address )) # let's start advertising again ble . start_advertising () connected = False # Let's define some security callbacks def show_key_cb ( passkey ): print ( \"ENTER THIS PIN ON THE MASTER:\" , passkey ) try : # initialize BLE driver bledrv . init () # Set GAP name and LEVEL 2 security # !!! If security is not set, no secure connection will be possible ble . gap ( \"ZNotifier\" , security = ( ble . SECURITY_MODE_1 , ble . SECURITY_LEVEL_2 )) # add some GAP callbacks ble . add_callback ( ble . EVT_CONNECTED , connection_cb ) ble . add_callback ( ble . EVT_DISCONNECTED , disconnection_cb ) # Create a GATT Service: let's try an Alert Notification Service # (here are the specs: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.service.alert_notification.xml) s = ble . Service ( 0x1811 ) # The Alert Notification service has multiple characteristics. Let's add them one by one # Create a GATT Characteristic for counting new alerts. # specs: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.characteristic.supported_new_alert_category.xml cn = ble . Characteristic ( 0x2A47 , ble . NOTIFY | ble . READ , 16 , \"New Alerts\" , ble . BYTES ) # Add the GATT Characteristic to the Service s . add_characteristic ( cn ) # Create anothr GATT Characteristic for enabling/disabling alerts # specs: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.characteristic.alert_notification_control_point.xml cc = ble . Characteristic ( 0x2A44 , ble . WRITE , 2 , \"Alerts control\" , ble . BYTES ) # Add the GATT Characteristic to the Service s . add_characteristic ( cc ) # Add a callback to be notified of changes cc . set_callback ( value_cb ) # Add the Service. You can create additional services and add them one by one ble . add_service ( s ) # Configure security. BLE security is very flexible. # In this case we declare that the device has only an output capability (CAP_DISPLAY_ONLY), # that we require a bonding (storage of the keys after pairing) # and that we want both secure connection and main in the middle protection. # Since we have CAP_DISPLAY_ONLY, we also declare a passkey that will be shown to the user # to be entered on the master (i.e. the smartphone) to finalize the bonding. ble . security ( capabilities = ble . CAP_DISPLAY_ONLY , bonding = ble . AUTH_BOND , scheme = ble . AUTH_SC | ble . AUTH_MITM , key_size = 16 , passkey = 225575 ) # To do so, we need a callback to display the passkey when needed ble . add_callback ( ble . EVT_SHOW_PASSKEY , show_key_cb ) # Setup advertising to 50ms ble . advertising ( 50 ) # Start the BLE stack ble . start () # Now start advertising ble . start_advertising () except Exception as e : print ( e ) # loop forever while True : print ( \".\" ) if random ( 0 , 100 ) < 50 and notifications_enabled and connected : value = bytearray ( cn . get_value ()) value [ 0 ] = 0 # simple alert type if value [ 1 ] < 255 : value [ 1 ] = value [ 1 ] + 1 # add a notification print ( \"Adding a new notification, total of\" , value [ 1 ]) # the remaining 14 bytes can be some text value [ 2 : 10 ] = \"Zerynth!\" # set the new value. If ble notifications are enabled, the connected device will receive the change cn . set_value ( value ) sleep ( 5000 )","title":"BLE Alerts with Security 1"},{"location":"reference/libs/nordic/nrf52_ble/docs/examples/#ble-alerts-with-security-2","text":"An implementationof an Alert Notification device to show how services and characteristics can be easily created. It also features secure connections with bonding using confirmation capabilities of the device. main.py ################################################################################ # BLE Alerts with Security 2 # # Created by Zerynth Team 2019 CC # Author: G. Baldi ############################################################################### import streams # import a BLE driver: in this example we use NRF52 from nordic.nrf52_ble import nrf52_ble as bledrv # then import the BLE modue from wireless import ble streams . serial () notifications_enabled = True connected = False # Let's define some callbacks def value_cb ( status , val ): # check incoming commands and enable/disable notifications global notifications_enabled print ( \"Value changed to\" , val [ 0 ], val [ 1 ]) if val [ 0 ] == 0 : print ( \"Notifications enabled\" ) notifications_enabled = True elif val [ 0 ] == 2 : notifications_enabled = False print ( \"Notifications disabled\" ) else : print ( \"Notifications unchanged\" ) def connection_cb ( address ): global connected print ( \"Connected to\" , ble . btos ( address )) connected = True def disconnection_cb ( address ): global connected print ( \"Disconnected from\" , ble . btos ( address )) # let's start advertising again ble . start_advertising () connected = False # Let's define some security callbacks def match_key_cb ( passkey ): print ( \"MASTER KEY IS:\" , passkey , \"CAN WE PROCEED? PRESS BUTTON FOR YES\" ) pinMode ( BTN0 , INPUT ) for i in range ( 5 ): if digitalRead ( BTN0 ) != 0 : ble . confirm_passkey ( 1 ) print ( \"Confirmed!\" ) return sleep ( 1000 ) ble . confirm_passkey ( 0 ) print ( \"Not confirmed!\" ) try : # initialize BLE driver bledrv . init () # Set GAP name and LEVEL 2 security # !!! If security is not set, no secure connection will be possible ble . gap ( \"ZNotifier\" , security = ( ble . SECURITY_MODE_1 , ble . SECURITY_LEVEL_2 )) # add some GAP callbacks ble . add_callback ( ble . EVT_CONNECTED , connection_cb ) ble . add_callback ( ble . EVT_DISCONNECTED , disconnection_cb ) # Create a GATT Service: let's try an Alert Notification Service # (here are the specs: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.service.alert_notification.xml) s = ble . Service ( 0x1811 ) # The Alert Notification service has multiple characteristics. Let's add them one by one # Create a GATT Characteristic for counting new alerts. # specs: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.characteristic.supported_new_alert_category.xml cn = ble . Characteristic ( 0x2A47 , ble . NOTIFY | ble . READ , 16 , \"New Alerts\" , ble . BYTES ) # Add the GATT Characteristic to the Service s . add_characteristic ( cn ) # Create anothr GATT Characteristic for enabling/disabling alerts # specs: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.characteristic.alert_notification_control_point.xml cc = ble . Characteristic ( 0x2A44 , ble . WRITE , 2 , \"Alerts control\" , ble . BYTES ) # Add the GATT Characteristic to the Service s . add_characteristic ( cc ) # Add a callback to be notified of changes cc . set_callback ( value_cb ) # Add the Service. You can create additional services and add them one by one ble . add_service ( s ) # Configure security. BLE security is very flexible. # In this case we declare that the device has only an output capability with yes o or no input (CAP_DISPLAY_YES_NO), # that we require a bonding (storage of the keys after pairing) # and that we want both secure connection and main in the middle protection. ble . security ( capabilities = ble . CAP_DISPLAY_YES_NO , bonding = ble . AUTH_BOND , scheme = ble . AUTH_SC | ble . AUTH_MITM , key_size = 16 ) # To do so, we need a callback to accept the passkey when needed ble . add_callback ( ble . EVT_MATCH_PASSKEY , match_key_cb ) # Setup advertising to 50ms ble . advertising ( 50 ) # Start the BLE stack ble . start () # Now start advertising ble . start_advertising () except Exception as e : print ( e ) # Uncomment the following lines to delte bonded devices! for bond in ble . bonded (): print ( \"Removing bonded:\" , ble . btos ( bond )) ble . remove_bonded ( bond ) # loop forever while True : print ( \".\" ) if random ( 0 , 100 ) < 50 and notifications_enabled and connected : value = bytearray ( cn . get_value ()) value [ 0 ] = 0 # simple alert type if value [ 1 ] < 255 : value [ 1 ] = value [ 1 ] + 1 # add a notification print ( \"Adding a new notification, total of\" , value [ 1 ]) # the remaining 14 bytes can be some text value [ 2 : 10 ] = \"Zerynth!\" # set the new value. If ble notifications are enabled, the connected device will receive the change cn . set_value ( value ) sleep ( 5000 )","title":"BLE Alerts with Security 2"},{"location":"reference/libs/nordic/nrf52_ble/docs/examples/#ble-battery-service","text":"A minimal example implementing a Battery Level Service on a NRF52 chip. main.py ################################################################################ # BLE Battery Service # # Created by Zerynth Team 2016 CC # Author: G. Baldi ############################################################################### import streams # import a BLE driver: in this example we use NRF52 from nordic.nrf52_ble import nrf52_ble as bledrv # then import the BLE modue from wireless import ble streams . serial () # initialize NRF52 driver bledrv . init () # Set GAP name ble . gap ( \"Zerynth\" ) # Create a GATT Service: let's try a Battery Service (uuid is 0x180F) s = ble . Service ( 0x180F ) # Create a GATT Characteristic: (uuid for Battery Level is 0x2A19, and it is an 8-bit number) c = ble . Characteristic ( 0x2A19 , ble . NOTIFY | ble . READ , 1 , \"Battery Level\" , ble . NUMBER ) # Add the GATT Characteristic to the Service s . add_characteristic ( c ) # Add the Service ble . add_service ( s ) # Start the BLE stack ble . start () # Begin advertising ble . start_advertising () while True : print ( \".\" ) sleep ( 1000 ) # Let's update the Characteristic Value c . set_value ( random ( 0 , 100 ))","title":"BLE Battery Service"},{"location":"reference/libs/nordic/nrf52_ble/docs/examples/#ble-scanner","text":"A simple example implementing a BLE packet scanner. main.py ################################################################################ # BLE Scanner # # Created by Zerynth Team 2019 CC # Author: G. Baldi ############################################################################### import streams # import a BLE driver: in this example we use NRF52 from nordic.nrf52_ble import nrf52_ble as bledrv # then import the BLE modue from wireless import ble streams . serial () # Let's define some callbacks and constants # How long to scan for in milliseconds scan_time = 30000 def scan_report_cb ( data ): print ( \"Detected packet from\" , ble . btos ( data [ 4 ]), \"containing\" , ble . btos ( data [ 3 ])) print ( \" packet is of type\" , ble . btos ( data [ 0 ]), \"while address is of type\" , ble . btos ( data [ 1 ])) print ( \" remote device has RSSI of\" , ble . btos ( data [ 2 ])) def scan_start_cb ( data ): print ( \"Scan started\" ) def scan_stop_cb ( data ): print ( \"Scan stopped\" ) #let's start it up again ble . start_scanning ( scan_time ) try : # initialize BLE driver bledrv . init () # Set GAP name and no security ble . gap ( \"Zerynth\" , security = ( ble . SECURITY_MODE_1 , ble . SECURITY_LEVEL_1 )) ble . add_callback ( ble . EVT_SCAN_REPORT , scan_report_cb ) ble . add_callback ( ble . EVT_SCAN_STARTED , scan_start_cb ) ble . add_callback ( ble . EVT_SCAN_STOPPED , scan_stop_cb ) #set scanning parameters: every 100ms for 50ms and no duplicates ble . scanning ( 100 , 50 , duplicates = 0 ) # Start the BLE stack ble . start () # Now start scanning for 30 seconds ble . start_scanning ( scan_time ) except Exception as e : print ( e ) # loop forever while True : print ( \".\" ) sleep ( 10000 )","title":"BLE Scanner"},{"location":"reference/libs/nordic/nrf52_ble/docs/nrf52_ble/","text":"NRF52 BLE \u00b6 This module implements the NRF52 ble driver for peripheral roles. It can be used for every kind of board based on NRF52832 and NRF52840 <> _ ; it has been tested on RedBear boards and Nordic development kits (PCA10040 and PCA10056). The driver is based on NRF52 SDK and can function on Virtual Machines compiled with support for Nordic SoftDevices (S132 and S140). To use the module expand on the following example: from nordic.nrf52_ble import nrf52_ble as bledrv from wireless import ble bledrv . init () ble . gap ( \"Zerynth\" ) ble . start () while True : sleep ( 1000 ) # do things here","title":"NRF52 BLE"},{"location":"reference/libs/nordic/nrf52_ble/docs/nrf52_ble/#nrf52-ble","text":"This module implements the NRF52 ble driver for peripheral roles. It can be used for every kind of board based on NRF52832 and NRF52840 <> _ ; it has been tested on RedBear boards and Nordic development kits (PCA10040 and PCA10056). The driver is based on NRF52 SDK and can function on Virtual Machines compiled with support for Nordic SoftDevices (S132 and S140). To use the module expand on the following example: from nordic.nrf52_ble import nrf52_ble as bledrv from wireless import ble bledrv . init () ble . gap ( \"Zerynth\" ) ble . start () while True : sleep ( 1000 ) # do things here","title":"NRF52 BLE"},{"location":"reference/libs/nxp/fxas21002c/docs/","text":"NXP FXAS21002C \u00b6 The FXAS21002C is a small, low-power, yaw, pitch, and roll angular rate gyroscope with 16 bit ADC resolution. The full-scale range is adjustable from \u00b1250\u00b0/s to \u00b12000\u00b0/s. It features the I2C interfaces. FXAS21002C is capable of measuring angular rates up to \u00b12000\u00b0/s, with output data rates (ODR) from 12.5 to 800 Hz. An integrated Low-Pass Filter (LPF) allows the host application to limit the digital signal bandwidth. The device may be configured to generate an interrupt when a user-programmable angular rate threshold is crossed on any one of the enabled axes. More information at NXP dedicated page . Technical Details \u00b6 Supply Voltage (Vdd): from 1.95 V to 3.6 V Operation Temperature (Top): from -40 \u00b0C to 85 \u00b0C Current Consumption: from 2.8 uA (Standby mode) mA to 2.7 mA (Active mode) Angular Rate Sensitivity: 0.0625\u00b0/s (in \u00b12000\u00b0/s FSR mode) Dynamically Selectable Range \u00b1250/\u00b1500/\u00b11000/\u00b12000\u00b0/s or \u00b1500/\u00b11000/\u00b12000/\u00b14000\u00b0/s setting the full-scale double features Output data rates (ODR) from 12.5 Hz to 800 Hz I\u00b2C interface Here below, the Zerynth driver for the NXP FXAS21002C. Contents: FXAS21002C Module Examples get angular velocity","title":"NXP FXAS21002C"},{"location":"reference/libs/nxp/fxas21002c/docs/#nxp-fxas21002c","text":"The FXAS21002C is a small, low-power, yaw, pitch, and roll angular rate gyroscope with 16 bit ADC resolution. The full-scale range is adjustable from \u00b1250\u00b0/s to \u00b12000\u00b0/s. It features the I2C interfaces. FXAS21002C is capable of measuring angular rates up to \u00b12000\u00b0/s, with output data rates (ODR) from 12.5 to 800 Hz. An integrated Low-Pass Filter (LPF) allows the host application to limit the digital signal bandwidth. The device may be configured to generate an interrupt when a user-programmable angular rate threshold is crossed on any one of the enabled axes. More information at NXP dedicated page .","title":"NXP FXAS21002C"},{"location":"reference/libs/nxp/fxas21002c/docs/#technical-details","text":"Supply Voltage (Vdd): from 1.95 V to 3.6 V Operation Temperature (Top): from -40 \u00b0C to 85 \u00b0C Current Consumption: from 2.8 uA (Standby mode) mA to 2.7 mA (Active mode) Angular Rate Sensitivity: 0.0625\u00b0/s (in \u00b12000\u00b0/s FSR mode) Dynamically Selectable Range \u00b1250/\u00b1500/\u00b11000/\u00b12000\u00b0/s or \u00b1500/\u00b11000/\u00b12000/\u00b14000\u00b0/s setting the full-scale double features Output data rates (ODR) from 12.5 Hz to 800 Hz I\u00b2C interface Here below, the Zerynth driver for the NXP FXAS21002C. Contents: FXAS21002C Module Examples get angular velocity","title":"Technical Details"},{"location":"reference/libs/nxp/fxas21002c/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.nxp.fxas21002c. Read Gyroscope Data from FXAS21002C \u00b6 Basic example to read the angular velocity from FXAS21002C gyroscope. main.py ################################################################################ # Gyroscope Example # # Created: 2017-03-23 15:45:48.789211 # ################################################################################ import streams from nxp.fxas21002c import fxas21002c streams . serial () try : # Setup sensor # This setup is referred to fxas21002c mounted on hexiwear device fxas = fxas21002c . FXAS21002C ( I2C1 ) print ( \"start...\" ) fxas . start () print ( \"init...\" ) fxas . init () print ( \"Ready!\" ) print ( \"--------------------------------------------------------\" ) except Exception as e : print ( \"Error: \" , e ) try : while True : raw_gyro = fxas . get_raw_gyro () # Read raw gyroscope data print ( \"Raw Acceleration: \" , raw_gyro ) raw_temp = fxas . get_raw_int_temp () # Read raw internal trmperature print ( \"Raw Internal Temperature: \" , raw_temp ) gyro = fxas . get_gyro () # Read gyroscope data in dps (degrees per second) print ( \"Gyroscope Data: \" , gyro , \"dps\" ) gyro_x = fxas . get_gyro ( 'x' ) # Read gyroscope data on x axis in dps gyro_y = fxas . get_gyro ( 'y' ) # Read gyroscope data on y axis in dps gyro_z = fxas . get_gyro ( 'z' ) # Read gyroscope data on z axis in dps print ( \"Gyroscope Data: x -->\" , gyro_x , \"dps\" ) print ( \"Gyroscope Data: y -->\" , gyro_y , \"dps\" ) print ( \"Gyroscope Data: z -->\" , gyro_z , \"dps\" ) temp_c = fxas . get_int_temp ( 'C' ) # Read internal termperature in C temp_k = fxas . get_int_temp ( 'K' ) # Read internal termperature in K temp_f = fxas . get_int_temp ( 'F' ) # Read internal termperature in F print ( \"Internal Temperature: Celtius -->\" , temp_c , \"C\" ) print ( \"Internal Temperature: Kelvin -->\" , temp_k , \"K\" ) print ( \"Internal Temperature: Fahrenheit -->\" , temp_f , \"F\" ) print ( \"--------------------------------------------------------\" ) sleep ( 5000 ) except Exception as e : print ( \"Error2: \" , e )","title":"Examples"},{"location":"reference/libs/nxp/fxas21002c/docs/examples/#examples","text":"The following are a list of examples for lib.nxp.fxas21002c.","title":"Examples"},{"location":"reference/libs/nxp/fxas21002c/docs/examples/#read-gyroscope-data-from-fxas21002c","text":"Basic example to read the angular velocity from FXAS21002C gyroscope. main.py ################################################################################ # Gyroscope Example # # Created: 2017-03-23 15:45:48.789211 # ################################################################################ import streams from nxp.fxas21002c import fxas21002c streams . serial () try : # Setup sensor # This setup is referred to fxas21002c mounted on hexiwear device fxas = fxas21002c . FXAS21002C ( I2C1 ) print ( \"start...\" ) fxas . start () print ( \"init...\" ) fxas . init () print ( \"Ready!\" ) print ( \"--------------------------------------------------------\" ) except Exception as e : print ( \"Error: \" , e ) try : while True : raw_gyro = fxas . get_raw_gyro () # Read raw gyroscope data print ( \"Raw Acceleration: \" , raw_gyro ) raw_temp = fxas . get_raw_int_temp () # Read raw internal trmperature print ( \"Raw Internal Temperature: \" , raw_temp ) gyro = fxas . get_gyro () # Read gyroscope data in dps (degrees per second) print ( \"Gyroscope Data: \" , gyro , \"dps\" ) gyro_x = fxas . get_gyro ( 'x' ) # Read gyroscope data on x axis in dps gyro_y = fxas . get_gyro ( 'y' ) # Read gyroscope data on y axis in dps gyro_z = fxas . get_gyro ( 'z' ) # Read gyroscope data on z axis in dps print ( \"Gyroscope Data: x -->\" , gyro_x , \"dps\" ) print ( \"Gyroscope Data: y -->\" , gyro_y , \"dps\" ) print ( \"Gyroscope Data: z -->\" , gyro_z , \"dps\" ) temp_c = fxas . get_int_temp ( 'C' ) # Read internal termperature in C temp_k = fxas . get_int_temp ( 'K' ) # Read internal termperature in K temp_f = fxas . get_int_temp ( 'F' ) # Read internal termperature in F print ( \"Internal Temperature: Celtius -->\" , temp_c , \"C\" ) print ( \"Internal Temperature: Kelvin -->\" , temp_k , \"K\" ) print ( \"Internal Temperature: Fahrenheit -->\" , temp_f , \"F\" ) print ( \"--------------------------------------------------------\" ) sleep ( 5000 ) except Exception as e : print ( \"Error2: \" , e )","title":"Read Gyroscope Data from FXAS21002C"},{"location":"reference/libs/nxp/fxas21002c/docs/fxas21002c/","text":"FXAS21002C Module \u00b6 This module contains the driver for NXP FXAS21002C gyroscope for measuring the angular velocity. The FXAS21002C provides direct I2C communication and can be set on 4 different full-scale range and 8 different over sample rate values ( datasheet ). class FXAS21002C \u00b6 class FXAS21002C ( i2cdrv , addr = 0x20 , clk = 400000 ) Creates an intance of a new FXAS21002C. Arguments: i2cdrv \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x20 clk \u2013 Clock speed, default 400kHz Example: from nxp.fxas21002c import fxas21002c ... fxas = fxas21002c . FXAS21002C ( I2C0 ) fxas . start () fxas . init () gyro = fxas . get_gyro () FXAS21002C.init \u00b6 init ( fsr = 0 , odr = 2 , fs_exp = 0 ) Initialize the FXAS21002C setting the mode value. Arguments: fsr \u2013 select the full-scale range (from 0 to 3 - refer to page 39 of the FXAS21002C datasheet), default 0 odr \u2013 set the over sample rate (from 0 to 7 - refer to page 46 of the FXAS21002C datasheet), default 2 fs_exp \u2013 Full-scale range expansion enable (allowed values 0,1 - refer to page 49 of the FXAS21002C datasheet), default 0 FSR Value FS_EXP Value Degrees per Second 0 0 2000 dps 1 0 1000 dps 2 0 500 dps 3 0 250 dps 0 1 4000 dps 1 1 2000 dps 2 1 1000 dps 3 1 500 dps ODR Value Frequency 0 800 Hz 1 400 Hz 2 200 Hz 3 100 Hz 4 50 Hz 5 25 HZ 6 12.5 Hz 7 12.5 Hz FXAS21002C.get_raw_gyro \u00b6 get_raw_gyro () Retrieves the current gyroscope data as a tuple of X, Y, Z, raw values. Returns [gyro_x, gyro_y, gyro_z]. FXAS21002C.get_raw_int_temp \u00b6 get_raw_int_temp () Retrieves the current device internal temperature data as raw value. Returns raw_t. FXAS21002C.get_gyro \u00b6 get_gyro ( axis = None ) Retrieves the current gyroscope data in degrees per second as a tuple of X, Y, Z values or single axis value if axis argument is provided. Arguments: axis \u2013 select the axis (allowed values: \u201cx\u201d for x-axis, \u201cy\u201d for y-axis, \u201cz\u201d for z-axis); default None for all values. Returns: [gyro_x, gyro_y, gyro_z] or gyro_x or gyro_y or gyro_z. FXAS21002C.get_int_temp \u00b6 get_int_temp ( unit = \"C\" ) Retrieves the current device internal temperature value in Celtius, Kelvin or Fahrenheit degrees. Arguments: unit \u2013 select the unit of measure for internal temperature (allowed values: \u201cC\u201d for Celtius degrees, \u201cK\u201d for Kelvin degrees, \u201cF\u201d Fahrenheit degrees); default \u201cC\u201d. Returns int_temp.","title":"FXAS21002C Module"},{"location":"reference/libs/nxp/fxas21002c/docs/fxas21002c/#fxas21002c-module","text":"This module contains the driver for NXP FXAS21002C gyroscope for measuring the angular velocity. The FXAS21002C provides direct I2C communication and can be set on 4 different full-scale range and 8 different over sample rate values ( datasheet ).","title":"FXAS21002C Module"},{"location":"reference/libs/nxp/fxas21002c/docs/fxas21002c/#class-fxas21002c","text":"class FXAS21002C ( i2cdrv , addr = 0x20 , clk = 400000 ) Creates an intance of a new FXAS21002C. Arguments: i2cdrv \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x20 clk \u2013 Clock speed, default 400kHz Example: from nxp.fxas21002c import fxas21002c ... fxas = fxas21002c . FXAS21002C ( I2C0 ) fxas . start () fxas . init () gyro = fxas . get_gyro ()","title":"class FXAS21002C"},{"location":"reference/libs/nxp/fxas21002c/docs/fxas21002c/#fxas21002cinit","text":"init ( fsr = 0 , odr = 2 , fs_exp = 0 ) Initialize the FXAS21002C setting the mode value. Arguments: fsr \u2013 select the full-scale range (from 0 to 3 - refer to page 39 of the FXAS21002C datasheet), default 0 odr \u2013 set the over sample rate (from 0 to 7 - refer to page 46 of the FXAS21002C datasheet), default 2 fs_exp \u2013 Full-scale range expansion enable (allowed values 0,1 - refer to page 49 of the FXAS21002C datasheet), default 0 FSR Value FS_EXP Value Degrees per Second 0 0 2000 dps 1 0 1000 dps 2 0 500 dps 3 0 250 dps 0 1 4000 dps 1 1 2000 dps 2 1 1000 dps 3 1 500 dps ODR Value Frequency 0 800 Hz 1 400 Hz 2 200 Hz 3 100 Hz 4 50 Hz 5 25 HZ 6 12.5 Hz 7 12.5 Hz","title":"FXAS21002C.init"},{"location":"reference/libs/nxp/fxas21002c/docs/fxas21002c/#fxas21002cget_raw_gyro","text":"get_raw_gyro () Retrieves the current gyroscope data as a tuple of X, Y, Z, raw values. Returns [gyro_x, gyro_y, gyro_z].","title":"FXAS21002C.get_raw_gyro"},{"location":"reference/libs/nxp/fxas21002c/docs/fxas21002c/#fxas21002cget_raw_int_temp","text":"get_raw_int_temp () Retrieves the current device internal temperature data as raw value. Returns raw_t.","title":"FXAS21002C.get_raw_int_temp"},{"location":"reference/libs/nxp/fxas21002c/docs/fxas21002c/#fxas21002cget_gyro","text":"get_gyro ( axis = None ) Retrieves the current gyroscope data in degrees per second as a tuple of X, Y, Z values or single axis value if axis argument is provided. Arguments: axis \u2013 select the axis (allowed values: \u201cx\u201d for x-axis, \u201cy\u201d for y-axis, \u201cz\u201d for z-axis); default None for all values. Returns: [gyro_x, gyro_y, gyro_z] or gyro_x or gyro_y or gyro_z.","title":"FXAS21002C.get_gyro"},{"location":"reference/libs/nxp/fxas21002c/docs/fxas21002c/#fxas21002cget_int_temp","text":"get_int_temp ( unit = \"C\" ) Retrieves the current device internal temperature value in Celtius, Kelvin or Fahrenheit degrees. Arguments: unit \u2013 select the unit of measure for internal temperature (allowed values: \u201cC\u201d for Celtius degrees, \u201cK\u201d for Kelvin degrees, \u201cF\u201d Fahrenheit degrees); default \u201cC\u201d. Returns int_temp.","title":"FXAS21002C.get_int_temp"},{"location":"reference/libs/nxp/fxos8700cq/docs/","text":"NXP FXOS8700CQ \u00b6 The NXP FXOS8700CQ is a small, low-power, 3-axis, linear accelerometer and 3-axis, magnetometer combined into a single package. This component features an I2C interface and the 14-bit accelerometer and 16-bit magnetometer are combined with a high-performance ASIC to enable an eCompass solution capable of a typical orientation resolution of 0.1\u00b0 and sub-5\u00b0 compass heading accuracy for most applications. FXOS8700CQ has dynamically selectable acceleration full-scale ranges of \u00b12 g/\u00b14 g/\u00b18 g and a fixed magnetic measurement range of \u00b11200 \u03bcT. Output data rates (ODR) from 1.563 Hz to 800 Hz are selectable by the user for each sensor. Interleaved magnetic and acceleration data is available at ODR rates of up to 400 Hz. More information at NXP dedicated page . Technical Details \u00b6 Supply Voltage (Vdd): from 1.95 V to 3.6 V Operation Temperature (Top): from -40 \u00b0C to 85 \u00b0C Dynamically Selectable Acceleration Full-scale Range: \u00b12 g or \u00b14 g or \u00b18 g Accelerometer Sensitivity: 0.244 mg or 0.488 mg or 0.976 mg (according to the Full-scale Range) Magnetic Sensor Full-scale Range: \u00b11200 uT MAgnetometer Sensotivity: 0.1 uT Current Consumption: 240 uA @ 100 Hz with both sensors active I\u00b2C interface Here below, the Zerynth driver for the NXP FXOS8700CQ. Contents: FXOS8700CQ Module Examples get accel magn","title":"NXP FXOS8700CQ"},{"location":"reference/libs/nxp/fxos8700cq/docs/#nxp-fxos8700cq","text":"The NXP FXOS8700CQ is a small, low-power, 3-axis, linear accelerometer and 3-axis, magnetometer combined into a single package. This component features an I2C interface and the 14-bit accelerometer and 16-bit magnetometer are combined with a high-performance ASIC to enable an eCompass solution capable of a typical orientation resolution of 0.1\u00b0 and sub-5\u00b0 compass heading accuracy for most applications. FXOS8700CQ has dynamically selectable acceleration full-scale ranges of \u00b12 g/\u00b14 g/\u00b18 g and a fixed magnetic measurement range of \u00b11200 \u03bcT. Output data rates (ODR) from 1.563 Hz to 800 Hz are selectable by the user for each sensor. Interleaved magnetic and acceleration data is available at ODR rates of up to 400 Hz. More information at NXP dedicated page .","title":"NXP FXOS8700CQ"},{"location":"reference/libs/nxp/fxos8700cq/docs/#technical-details","text":"Supply Voltage (Vdd): from 1.95 V to 3.6 V Operation Temperature (Top): from -40 \u00b0C to 85 \u00b0C Dynamically Selectable Acceleration Full-scale Range: \u00b12 g or \u00b14 g or \u00b18 g Accelerometer Sensitivity: 0.244 mg or 0.488 mg or 0.976 mg (according to the Full-scale Range) Magnetic Sensor Full-scale Range: \u00b11200 uT MAgnetometer Sensotivity: 0.1 uT Current Consumption: 240 uA @ 100 Hz with both sensors active I\u00b2C interface Here below, the Zerynth driver for the NXP FXOS8700CQ. Contents: FXOS8700CQ Module Examples get accel magn","title":"Technical Details"},{"location":"reference/libs/nxp/fxos8700cq/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.nxp.fxos8700cq. Read Accelerometer and Magnetometer data from FXOS8700CQ \u00b6 Basic example to read the accelerometer and magnetometer data from FXOS8700CQ sensor. main.py ################################################################################ # Accelerometer and Magnetometer Example # # Created: 2017-03-30 09:42:08.655652 # ################################################################################ import streams from nxp.fxos8700cq import fxos8700cq streams . serial () try : # Setup sensor # This setup is referred to fxos8700cq mounted on hexiwear device fxos = fxos8700cq . FXOS8700CQ ( I2C1 ) print ( \"start...\" ) fxos . start () print ( \"init...\" ) fxos . init () print ( \"Ready!\" ) print ( \"--------------------------------------------------------\" ) except Exception as e : print ( \"Error: \" , e ) try : while True : raw_acc = fxos . get_raw_acc () # Read raw accelerometer data print ( \"Raw Acceleration: \" , raw_acc ) raw_mag = fxos . get_raw_mag () # Read raw magnetometer data print ( \"Raw Magnetometer Data: \" , raw_mag ) raw_temp = fxos . get_raw_int_temp () # Read raw trmperature print ( \"Raw Temperature: \" , raw_temp ) acc = fxos . get_acc () # Read accelerometer data in m/s^2 print ( \"Acceleration: \" , acc , \"m/s^2\" ) mag_x = fxos . get_mag ( 'x' ) # Read magnetometer data on x axis in uT mag_y = fxos . get_mag ( 'y' ) # Read magnetometer data on y axis in uT mag_z = fxos . get_mag ( 'z' ) # Read magnetometer data on z axis in uT print ( \"Magnetometer Data: x -->\" , mag_x , \"uT\" ) print ( \"Magnetometer Data: y -->\" , mag_y , \"uT\" ) print ( \"Magnetometer Data: z -->\" , mag_z , \"uT\" ) temp_c = fxos . get_int_temp ( 'C' ) # Read termperature in C temp_k = fxos . get_int_temp ( 'K' ) # Read termperature in K temp_f = fxos . get_int_temp ( 'F' ) # Read termperature in F print ( \"Temperature: Celtius -->\" , temp_c , \"C\" ) print ( \"Temperature: Kelvin -->\" , temp_k , \"K\" ) print ( \"Temperature: Fahrenheit -->\" , temp_f , \"F\" ) print ( \"--------------------------------------------------------\" ) sleep ( 5000 ) except Exception as e : print ( \"Error2: \" , e )","title":"Examples"},{"location":"reference/libs/nxp/fxos8700cq/docs/examples/#examples","text":"The following are a list of examples for lib.nxp.fxos8700cq.","title":"Examples"},{"location":"reference/libs/nxp/fxos8700cq/docs/examples/#read-accelerometer-and-magnetometer-data-from-fxos8700cq","text":"Basic example to read the accelerometer and magnetometer data from FXOS8700CQ sensor. main.py ################################################################################ # Accelerometer and Magnetometer Example # # Created: 2017-03-30 09:42:08.655652 # ################################################################################ import streams from nxp.fxos8700cq import fxos8700cq streams . serial () try : # Setup sensor # This setup is referred to fxos8700cq mounted on hexiwear device fxos = fxos8700cq . FXOS8700CQ ( I2C1 ) print ( \"start...\" ) fxos . start () print ( \"init...\" ) fxos . init () print ( \"Ready!\" ) print ( \"--------------------------------------------------------\" ) except Exception as e : print ( \"Error: \" , e ) try : while True : raw_acc = fxos . get_raw_acc () # Read raw accelerometer data print ( \"Raw Acceleration: \" , raw_acc ) raw_mag = fxos . get_raw_mag () # Read raw magnetometer data print ( \"Raw Magnetometer Data: \" , raw_mag ) raw_temp = fxos . get_raw_int_temp () # Read raw trmperature print ( \"Raw Temperature: \" , raw_temp ) acc = fxos . get_acc () # Read accelerometer data in m/s^2 print ( \"Acceleration: \" , acc , \"m/s^2\" ) mag_x = fxos . get_mag ( 'x' ) # Read magnetometer data on x axis in uT mag_y = fxos . get_mag ( 'y' ) # Read magnetometer data on y axis in uT mag_z = fxos . get_mag ( 'z' ) # Read magnetometer data on z axis in uT print ( \"Magnetometer Data: x -->\" , mag_x , \"uT\" ) print ( \"Magnetometer Data: y -->\" , mag_y , \"uT\" ) print ( \"Magnetometer Data: z -->\" , mag_z , \"uT\" ) temp_c = fxos . get_int_temp ( 'C' ) # Read termperature in C temp_k = fxos . get_int_temp ( 'K' ) # Read termperature in K temp_f = fxos . get_int_temp ( 'F' ) # Read termperature in F print ( \"Temperature: Celtius -->\" , temp_c , \"C\" ) print ( \"Temperature: Kelvin -->\" , temp_k , \"K\" ) print ( \"Temperature: Fahrenheit -->\" , temp_f , \"F\" ) print ( \"--------------------------------------------------------\" ) sleep ( 5000 ) except Exception as e : print ( \"Error2: \" , e )","title":"Read Accelerometer and Magnetometer data from FXOS8700CQ"},{"location":"reference/libs/nxp/fxos8700cq/docs/fxos8700cq/","text":"FXOS8700CQ Module \u00b6 This module contains the driver for NXP FXOS8700CQ accelerometer and magnetometer. The FXOS8700CQ provides direct I2C communication and the accelerometer can be set on 3 different full-scale range and 8 different over sample rate values ( datasheet ). class FXOS8700CQ \u00b6 class FXOS8700CQ ( i2cdrv , addr = 0x1E , clk = 400000 ) Creates an intance of a new FXOS8700CQ. Arguments: i2cdrv \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x1E clk \u2013 Clock speed, default 400kHz Example: from nxp.fxos8700cq import fxos8700cq ... fxos = fxos8700cq . FXOS8700CQ ( I2C0 ) fxos . start () fxos . init () acc = fxos . get_acc () mag = fxos . get_mag () FXOS8700CQ.init \u00b6 init ( mode = ACCMAG , odr = 0 , osr = 0 , range = RANGE4G ) Initialize the FXOS8700CQ setting the operating mode, the output data rate , the full-scale range and the oversample ratio. Arguments: mode \u2013 select the operating mode (allowed values: ACCONLY for accelerometer only, MAGONLY for magnetometer only, ACCMAG for both active), default ACCMAG odr \u2013 set the output data rate (from 0 to 7 - refer to page 44 of the FXOS8700CQ datasheet), default 0 osr \u2013 set the over sample ratio for magnetometer (from 0 to 7 - refer to page 97 of the FXOS8700CQ datasheet), default 0 range \u2013 accelerometer full-scale range (allowed values RANGE2G, RANGE4G, RANGE8G), default RANGE4G ODR ACC/MAG Mode Data Ready ACC/MAG Hybrid Mode Data Ready Hybrid 0 800 Hz 1.25 ms 400 Hz 2.5 ms 1 400 Hz 2.5 ms 200 Hz 5 ms 2 200 Hz 5 ms 100 Hz 10 ms 3 100 Hz 10 ms 50 Hz 20 ms 4 50 Hz 20 ms 25 Hz 80 ms 5 12.5 Hz 80 ms 6.25 Hz 160 ms 6 6.25 Hz 160 ms 3.125 Hz 320 ms 7 1.56 Hz 640 ms 0.7813 1280 ms ODR OSR=0 OSR=1 OSR=2 OSR=3 OSR=4 OSR=5 OSR=6 OSR=7 1.56 Hz 16 16 32 64 128 256 512 1024 6.25 Hz 4 4 8 16 32 64 128 256 12.5 Hz 2 2 4 8 16 32 64 128 50 Hz 2 2 2 2 4 8 16 32 100 Hz 2 2 2 2 2 4 8 16 200 Hz 2 2 2 2 2 2 4 8 400 Hz 2 2 2 2 2 2 2 4 800 Hz 2 2 2 2 2 2 2 2 FXOS8700CQ.get_raw_acc \u00b6 get_raw_acc () Retrieves the current accelerometer data as a tuple of X, Y, Z, raw values. Returns [ax, ay, az]. FXOS8700CQ.get_raw_mag \u00b6 get_raw_mag () Retrieves the current magnetometer data as a tuple of X, Y, Z, raw values. Returns [mx, my, mz]. FXOS8700CQ.get_raw_int_temp \u00b6 get_raw_int_temp () Retrieves the current internal temperature data as raw values. Returns raw_t. FXOS8700CQ.get_acc \u00b6 get_acc ( axis = None ) Retrieves the current accelerometer data in m/s^2 as a tuple of X, Y, Z values or single axis value if axis argument is provided. Arguments: axis \u2013 select the axis (allowed values: \u201cx\u201d for x-axis, \u201cy\u201d for y-axis, \u201cz\u201d for z-axis); default None for all values. Returns [acc_x, acc_y, acc_z] or acc_x or acc_y or acc_z. FXOS8700CQ.get_mag \u00b6 get_mag ( axis = None ) Retrieves the current magnetometer data in uT as a tuple of X, Y, Z values or single axis value if axis argument is provided. Arguments: axis \u2013 select the axis (allowed values: \u201cx\u201d for x-axis, \u201cy\u201d for y-axis, \u201cz\u201d for z-axis); default None for all values.. Returns [mag_x, mag_y, mag_z] or mag_x or mag_y or mag_z. FXOS8700CQ.get_int_temp \u00b6 get_int_temp ( unit = \"C\" ) Retrieves the current device internal temperature value in Celtius, Kelvin or Fahrenheit degrees. Arguments: unit \u2013 select the unit of measure for internal temperature (allowed values: \u201cC\u201d for Celtius degrees, \u201cK\u201d for Kelvin degrees, \u201cF\u201d Fahrenheit degrees); default \u201cC\u201d. Returns int_temp.","title":"FXOS8700CQ Module"},{"location":"reference/libs/nxp/fxos8700cq/docs/fxos8700cq/#fxos8700cq-module","text":"This module contains the driver for NXP FXOS8700CQ accelerometer and magnetometer. The FXOS8700CQ provides direct I2C communication and the accelerometer can be set on 3 different full-scale range and 8 different over sample rate values ( datasheet ).","title":"FXOS8700CQ Module"},{"location":"reference/libs/nxp/fxos8700cq/docs/fxos8700cq/#class-fxos8700cq","text":"class FXOS8700CQ ( i2cdrv , addr = 0x1E , clk = 400000 ) Creates an intance of a new FXOS8700CQ. Arguments: i2cdrv \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x1E clk \u2013 Clock speed, default 400kHz Example: from nxp.fxos8700cq import fxos8700cq ... fxos = fxos8700cq . FXOS8700CQ ( I2C0 ) fxos . start () fxos . init () acc = fxos . get_acc () mag = fxos . get_mag ()","title":"class FXOS8700CQ"},{"location":"reference/libs/nxp/fxos8700cq/docs/fxos8700cq/#fxos8700cqinit","text":"init ( mode = ACCMAG , odr = 0 , osr = 0 , range = RANGE4G ) Initialize the FXOS8700CQ setting the operating mode, the output data rate , the full-scale range and the oversample ratio. Arguments: mode \u2013 select the operating mode (allowed values: ACCONLY for accelerometer only, MAGONLY for magnetometer only, ACCMAG for both active), default ACCMAG odr \u2013 set the output data rate (from 0 to 7 - refer to page 44 of the FXOS8700CQ datasheet), default 0 osr \u2013 set the over sample ratio for magnetometer (from 0 to 7 - refer to page 97 of the FXOS8700CQ datasheet), default 0 range \u2013 accelerometer full-scale range (allowed values RANGE2G, RANGE4G, RANGE8G), default RANGE4G ODR ACC/MAG Mode Data Ready ACC/MAG Hybrid Mode Data Ready Hybrid 0 800 Hz 1.25 ms 400 Hz 2.5 ms 1 400 Hz 2.5 ms 200 Hz 5 ms 2 200 Hz 5 ms 100 Hz 10 ms 3 100 Hz 10 ms 50 Hz 20 ms 4 50 Hz 20 ms 25 Hz 80 ms 5 12.5 Hz 80 ms 6.25 Hz 160 ms 6 6.25 Hz 160 ms 3.125 Hz 320 ms 7 1.56 Hz 640 ms 0.7813 1280 ms ODR OSR=0 OSR=1 OSR=2 OSR=3 OSR=4 OSR=5 OSR=6 OSR=7 1.56 Hz 16 16 32 64 128 256 512 1024 6.25 Hz 4 4 8 16 32 64 128 256 12.5 Hz 2 2 4 8 16 32 64 128 50 Hz 2 2 2 2 4 8 16 32 100 Hz 2 2 2 2 2 4 8 16 200 Hz 2 2 2 2 2 2 4 8 400 Hz 2 2 2 2 2 2 2 4 800 Hz 2 2 2 2 2 2 2 2","title":"FXOS8700CQ.init"},{"location":"reference/libs/nxp/fxos8700cq/docs/fxos8700cq/#fxos8700cqget_raw_acc","text":"get_raw_acc () Retrieves the current accelerometer data as a tuple of X, Y, Z, raw values. Returns [ax, ay, az].","title":"FXOS8700CQ.get_raw_acc"},{"location":"reference/libs/nxp/fxos8700cq/docs/fxos8700cq/#fxos8700cqget_raw_mag","text":"get_raw_mag () Retrieves the current magnetometer data as a tuple of X, Y, Z, raw values. Returns [mx, my, mz].","title":"FXOS8700CQ.get_raw_mag"},{"location":"reference/libs/nxp/fxos8700cq/docs/fxos8700cq/#fxos8700cqget_raw_int_temp","text":"get_raw_int_temp () Retrieves the current internal temperature data as raw values. Returns raw_t.","title":"FXOS8700CQ.get_raw_int_temp"},{"location":"reference/libs/nxp/fxos8700cq/docs/fxos8700cq/#fxos8700cqget_acc","text":"get_acc ( axis = None ) Retrieves the current accelerometer data in m/s^2 as a tuple of X, Y, Z values or single axis value if axis argument is provided. Arguments: axis \u2013 select the axis (allowed values: \u201cx\u201d for x-axis, \u201cy\u201d for y-axis, \u201cz\u201d for z-axis); default None for all values. Returns [acc_x, acc_y, acc_z] or acc_x or acc_y or acc_z.","title":"FXOS8700CQ.get_acc"},{"location":"reference/libs/nxp/fxos8700cq/docs/fxos8700cq/#fxos8700cqget_mag","text":"get_mag ( axis = None ) Retrieves the current magnetometer data in uT as a tuple of X, Y, Z values or single axis value if axis argument is provided. Arguments: axis \u2013 select the axis (allowed values: \u201cx\u201d for x-axis, \u201cy\u201d for y-axis, \u201cz\u201d for z-axis); default None for all values.. Returns [mag_x, mag_y, mag_z] or mag_x or mag_y or mag_z.","title":"FXOS8700CQ.get_mag"},{"location":"reference/libs/nxp/fxos8700cq/docs/fxos8700cq/#fxos8700cqget_int_temp","text":"get_int_temp ( unit = \"C\" ) Retrieves the current device internal temperature value in Celtius, Kelvin or Fahrenheit degrees. Arguments: unit \u2013 select the unit of measure for internal temperature (allowed values: \u201cC\u201d for Celtius degrees, \u201cK\u201d for Kelvin degrees, \u201cF\u201d Fahrenheit degrees); default \u201cC\u201d. Returns int_temp.","title":"FXOS8700CQ.get_int_temp"},{"location":"reference/libs/nxp/hexiwear/docs/","text":"NXP Hexiwear \u00b6 Hexiwear platform combines the style and usability found in high-end consumer devices, with the functionality and expandability of sophisticated engineering development platforms, making Hexiwear the ideal form factor for the IoT edge node and wearable markets. Completely open-source and developed by MikroElektronika in partnership with NXP. the Hexiwear hardware includes the low power, high performance Kinetis K6x Microcontroller based on ARM Cortex-M4 core, the Kinetis KW40Z multimode radio SoC, supporting BLE in Hexiwear. The Hardware features included 6 on-board sensors such as Optical Heart Rate Monitor, Accelerometer and Magnetometer, Gyroscope, Temperature, Humidity, light and Pressure sensors. Hexiwear also includes Color OLED Display, Rechargeable battery and External flash memory. More information at NXP dedicated page . Features \u00b6 Eye-catching Smart Watch form factor with powerful, low power Kinetis K6x MCU and 6 on-board sensors. Designed for wearable applications with the onboard rechargeable battery, OLED screen and onboard sensors such as optical heart rate, accelerometer, magnetometer and gyroscope. Designed for IoT end node applications with the onboard sensor\u2019s such as temperature, pressure, humidity and ambient light. Complete software solution with open source embedded software, cell phone apps and cloud connectivity. Flexibility to let you add the sensors of your choice nearly 200 additional sensors through click boards. Here below, the Zerynth driver for the NXP Hexiwear Module. Contents: HEXIWEAR Module KW40Z Module Examples hexiwear example ble hexiwear ble data transmission","title":"NXP Hexiwear"},{"location":"reference/libs/nxp/hexiwear/docs/#nxp-hexiwear","text":"Hexiwear platform combines the style and usability found in high-end consumer devices, with the functionality and expandability of sophisticated engineering development platforms, making Hexiwear the ideal form factor for the IoT edge node and wearable markets. Completely open-source and developed by MikroElektronika in partnership with NXP. the Hexiwear hardware includes the low power, high performance Kinetis K6x Microcontroller based on ARM Cortex-M4 core, the Kinetis KW40Z multimode radio SoC, supporting BLE in Hexiwear. The Hardware features included 6 on-board sensors such as Optical Heart Rate Monitor, Accelerometer and Magnetometer, Gyroscope, Temperature, Humidity, light and Pressure sensors. Hexiwear also includes Color OLED Display, Rechargeable battery and External flash memory. More information at NXP dedicated page .","title":"NXP Hexiwear"},{"location":"reference/libs/nxp/hexiwear/docs/#features","text":"Eye-catching Smart Watch form factor with powerful, low power Kinetis K6x MCU and 6 on-board sensors. Designed for wearable applications with the onboard rechargeable battery, OLED screen and onboard sensors such as optical heart rate, accelerometer, magnetometer and gyroscope. Designed for IoT end node applications with the onboard sensor\u2019s such as temperature, pressure, humidity and ambient light. Complete software solution with open source embedded software, cell phone apps and cloud connectivity. Flexibility to let you add the sensors of your choice nearly 200 additional sensors through click boards. Here below, the Zerynth driver for the NXP Hexiwear Module. Contents: HEXIWEAR Module KW40Z Module Examples hexiwear example ble hexiwear ble data transmission","title":"Features"},{"location":"reference/libs/nxp/hexiwear/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.nxp.hexiwear. Basic example of use for Hexiwear Library \u00b6 Example of use for Hexiwear supported library with all its peripherals enabled. main.py ################################################################################ # Basic example of use for Hexiwear Library # # Created: 2017-03-30 07:55:48.081359 # ################################################################################ import streams from nxp.hexiwear import hexiwear import threading import zLogo streams . serial () def pressed_up (): print ( \"Up Button Pressed\" ) hexi . vibration ( 100 ) hexi . enable_bt_upd_sensors () def pressed_down (): print ( \"Down Button Pressed\" ) hexi . vibration ( 100 ) hexi . disable_bt_upd_sensors () def toggle_ble (): try : print ( \"Left Button Pressed\" ) hexi . vibration ( 100 ) hexi . bt_driver . toggle_adv_mode () except Exception as e : print ( \"error on left_pressed\" , e ) def toggle_touch (): try : print ( \"Right Button Pressed\" ) hexi . vibration ( 100 ) hexi . bt_driver . toggle_tsi_group () except Exception as e : print ( \"error on right_pressed\" , e ) def print_paircode (): # print the pair code in the serial monitor print ( \"Your Pair Code:\" , hexi . bt_driver . passkey ) # used to check the bluetooth status pinMode ( LED2 , OUTPUT ) try : print ( \"init\" ) hexi = hexiwear . HEXIWEAR () print ( \"start\" ) hexi . fill_screen ( 0xFFFF , False ) # attach toggle_ble function to left button (enabled/disabled ble) hexi . attach_button_left ( toggle_ble ) # attach toggle_touch function to right button (toggle active button - left/right pair) hexi . attach_button_right ( toggle_touch ) # attach pressed_up function to up button - enabled ble update sensor value thread hexi . attach_button_up ( pressed_up ) # attach pressed_up function to down button - disabled ble update sensor value thread hexi . attach_button_down ( pressed_down ) # attach print_paircode function to bluetooth pairing request hexi . attach_passkey ( print_paircode ) print ( \"Ready!\" ) print ( \"------------------------------------------------------------------------------\" ) except Exception as e : print ( e ) def read_bt_status (): while True : bt_on , bt_touch , bt_link = hexi . bluetooth_info () digitalWrite ( LED2 , 0 if bt_on == 1 else 1 ) sleep ( 1000 ) thread ( read_bt_status ) hexi . draw_image ( zLogo . zz , 38 , 10 , 20 , 20 ) hexi . draw_text ( \"Start!\" , 0 , 60 , 96 , 20 , align = 3 , color = 0xFFFF , background = 0x0000 , encode = False ) while True : try : bl , chg = hexi . get_battery_level ( chg_state = True ) print ( \"Battery Level:\" , bl , \"% - Charging:\" , chg ) al = hexi . get_ambient_light () print ( \"Ambient Light:\" , al ) acc = hexi . get_accelerometer_data () print ( \"Accelerometer Data [xyz]\" , acc , \"m/s^2\" ) magn = hexi . get_magnetometer_data () print ( \"Magnetometer Data [xyz]\" , magn , \"uT\" ) magn = hexi . get_gyroscope_data () print ( \"Gyroscope Data [xyz]\" , magn , \"dps\" ) temp = hexi . get_temperature () print ( \"Temperature\" , temp , \"*C\" ) humid = hexi . get_humidity () print ( \"Humidity\" , humid , \"RH%\" ) press = hexi . get_pressure () print ( \"Pressure\" , press , \"Pa\" ) hr = hexi . get_heart_rate () print ( \"Heart Rate\" , hr , \"bpm\" ) print ( \"------------------------------------------------------------------------------\" ) sleep ( 3000 ) except Exception as e : print ( e ) sleep ( 3000 ) Basic example of use for kw40z on hexiwear device \u00b6 Interact with ble chip on hexiwear device to set on/off the bluetooth feature and to test the bluetooth pairing. main.py ################################################################################ # Basic example for interacting with bluetooth low energy chip on hexiwear # # Created: 2017-03-29 12:50:52.955862 # ################################################################################ from nxp.hexiwear.kw40z import kw40z import streams import threading streams . serial () def pressed_up (): print ( \"Up Button Pressed\" ) def pressed_down (): print ( \"Down Button Pressed\" ) def toggle_ble (): try : print ( \"Left Button Pressed\" ) bt_driver . toggle_adv_mode () except Exception as e : print ( \"error on left_pressed\" , e ) def toggle_touch (): try : print ( \"Right Button Pressed\" ) bt_driver . toggle_tsi_group () except Exception as e : print ( \"error on right_pressed\" , e ) def print_paircode (): print ( \"Your Pair Code:\" , bt_driver . passkey ) # used to check the bluetooth status pinMode ( LED1 , OUTPUT ) def check_status (): print ( \"Device Settings\" ) bt_on , bt_touch , bt_link = bt_driver . info () print ( \"Bluetooth State: \" , ( \"On\" if bt_on == 1 else \"Off\" )) digitalWrite ( LED1 , 0 if bt_on == 1 else 1 ) print ( \"Capacitive Button Active: \" , ( \"Left\" if bt_touch == 0 else \"Right\" )) print ( \"Link State: \" , ( \"Connected\" if bt_link == 1 else \"Disconnected\" )) while True : bt_on_new , bt_touch_new , bt_link_new = bt_driver . info () if bt_on_new != bt_on : print ( \"Bluetooth State: \" , ( \"On\" if bt_on_new == 1 else \"Off\" )) digitalWrite ( LED1 , 0 if bt_on_new == 1 else 1 ) bt_on = bt_on_new if bt_touch_new != bt_touch : print ( \"Capacitive Button Active: \" , ( \"Left\" if bt_touch_new == 0 else \"Right\" )) bt_touch = bt_touch_new if bt_link_new != bt_link : print ( \"Link State: \" , ( \"Connected\" if bt_link_new == 1 else \"Disconnected\" )) bt_link = bt_link_new sleep ( 500 ) try : print ( \"init...\" ) # Setup ble chip # This setup is referred to kw40z mounted on Hexiwear device # The original Hexiwear default application binary file must be pre-loaded inside the kw40z # The application binary file for kw40z can be found here: # Link: https://github.com/MikroElektronika/HEXIWEAR/blob/master/SW/binaries/HEXIWEAR_KW40.bin bt_driver = kw40z . KW40Z_HEXI_APP ( SERIAL1 ) print ( \"start\" ) bt_driver . start () # wait for starting the ble chip sleep ( 1000 ) # start thread for check ble status thread ( check_status ) # attach callback function to left and right button bt_driver . attach_button_left ( toggle_ble ) bt_driver . attach_button_right ( toggle_touch ) bt_driver . attach_button_up ( pressed_up ) bt_driver . attach_button_down ( pressed_down ) bt_driver . attach_passkey ( print_paircode ) except Exception as e : print ( \"error1:\" , e ) while True : try : print ( \".\" ) sleep ( 5000 ) except Exception as e : print ( \"error2\" , e ) sleep ( 1000 ) Sensor Data Exchange via Bluetooth \u00b6 Expose Hexiwear data sensors via bluetoooth readable through any smartphone/tablet/pc bluetooth terminal. main.py ################################################################################ # Send Battery Level via Bluetooth # # Created: 2017-03-29 14:45:18.159845 # ################################################################################ from nxp.hexiwear.kw40z import kw40z import streams import threading streams . serial () def toggle_ble (): try : print ( \"Left Button Pressed\" ) bt_driver . toggle_adv_mode () except Exception as e : print ( \"error on left_pressed\" , e ) def print_paircode (): print ( \"Your Pair Code:\" , bt_driver . passkey ) pinMode ( LED1 , OUTPUT ) def check_status (): print ( \"Device Settings\" ) bt_on , bt_touch , bt_link = bt_driver . info () print ( \"Bluetooth State: \" , ( \"On\" if bt_on == 1 else \"Off\" )) digitalWrite ( LED1 , 0 if bt_on == 1 else 1 ) print ( \"Capacitive Button Active: \" , ( \"Left\" if bt_touch == 0 else \"Right\" )) print ( \"Link State: \" , ( \"Connected\" if bt_link == 1 else \"Disconnected\" )) while True : bt_on_new , bt_touch_new , bt_link_new = bt_driver . info () if bt_on_new != bt_on : print ( \"Bluetooth State: \" , ( \"On\" if bt_on_new == 1 else \"Off\" )) digitalWrite ( LED1 , 0 if bt_on_new == 1 else 1 ) bt_on = bt_on_new if bt_touch_new != bt_touch : print ( \"Capacitive Button Active: \" , ( \"Left\" if bt_touch_new == 0 else \"Right\" )) bt_touch = bt_touch_new if bt_link_new != bt_link : print ( \"Link State: \" , ( \"Connected\" if bt_link_new == 1 else \"Disconnected\" )) bt_link = bt_link_new sleep ( 500 ) try : # Setup ble chip # This setup is referred to kw40z mounted on Hexiwear device # The original Hexiwear default application binary file must be pre-loaded inside the kw40z # The application binary file for kw40z can be found here: # Link: https://github.com/MikroElektronika/HEXIWEAR/blob/master/SW/binaries/HEXIWEAR_KW40.bin print ( \"init...\" ) bt_driver = kw40z . KW40Z_HEXI_APP ( SERIAL1 ) print ( \"start\" ) bt_driver . start () # wait for starting the ble chip sleep ( 1000 ) # start thread for check ble status thread ( check_status ) # attach callback function to left and right button bt_driver . attach_button_left ( toggle_ble ) bt_driver . attach_passkey ( print_paircode ) except Exception as e : print ( \"error1:\" , e ) level = 0 while True : try : print ( \".\" ) bt_driver . upd_sensors ( battery = level ) level += 1 if level > 100 : level = 0 sleep ( 5000 ) except Exception as e : print ( \"error2\" , e ) sleep ( 1000 )","title":"Examples"},{"location":"reference/libs/nxp/hexiwear/docs/examples/#examples","text":"The following are a list of examples for lib.nxp.hexiwear.","title":"Examples"},{"location":"reference/libs/nxp/hexiwear/docs/examples/#basic-example-of-use-for-hexiwear-library","text":"Example of use for Hexiwear supported library with all its peripherals enabled. main.py ################################################################################ # Basic example of use for Hexiwear Library # # Created: 2017-03-30 07:55:48.081359 # ################################################################################ import streams from nxp.hexiwear import hexiwear import threading import zLogo streams . serial () def pressed_up (): print ( \"Up Button Pressed\" ) hexi . vibration ( 100 ) hexi . enable_bt_upd_sensors () def pressed_down (): print ( \"Down Button Pressed\" ) hexi . vibration ( 100 ) hexi . disable_bt_upd_sensors () def toggle_ble (): try : print ( \"Left Button Pressed\" ) hexi . vibration ( 100 ) hexi . bt_driver . toggle_adv_mode () except Exception as e : print ( \"error on left_pressed\" , e ) def toggle_touch (): try : print ( \"Right Button Pressed\" ) hexi . vibration ( 100 ) hexi . bt_driver . toggle_tsi_group () except Exception as e : print ( \"error on right_pressed\" , e ) def print_paircode (): # print the pair code in the serial monitor print ( \"Your Pair Code:\" , hexi . bt_driver . passkey ) # used to check the bluetooth status pinMode ( LED2 , OUTPUT ) try : print ( \"init\" ) hexi = hexiwear . HEXIWEAR () print ( \"start\" ) hexi . fill_screen ( 0xFFFF , False ) # attach toggle_ble function to left button (enabled/disabled ble) hexi . attach_button_left ( toggle_ble ) # attach toggle_touch function to right button (toggle active button - left/right pair) hexi . attach_button_right ( toggle_touch ) # attach pressed_up function to up button - enabled ble update sensor value thread hexi . attach_button_up ( pressed_up ) # attach pressed_up function to down button - disabled ble update sensor value thread hexi . attach_button_down ( pressed_down ) # attach print_paircode function to bluetooth pairing request hexi . attach_passkey ( print_paircode ) print ( \"Ready!\" ) print ( \"------------------------------------------------------------------------------\" ) except Exception as e : print ( e ) def read_bt_status (): while True : bt_on , bt_touch , bt_link = hexi . bluetooth_info () digitalWrite ( LED2 , 0 if bt_on == 1 else 1 ) sleep ( 1000 ) thread ( read_bt_status ) hexi . draw_image ( zLogo . zz , 38 , 10 , 20 , 20 ) hexi . draw_text ( \"Start!\" , 0 , 60 , 96 , 20 , align = 3 , color = 0xFFFF , background = 0x0000 , encode = False ) while True : try : bl , chg = hexi . get_battery_level ( chg_state = True ) print ( \"Battery Level:\" , bl , \"% - Charging:\" , chg ) al = hexi . get_ambient_light () print ( \"Ambient Light:\" , al ) acc = hexi . get_accelerometer_data () print ( \"Accelerometer Data [xyz]\" , acc , \"m/s^2\" ) magn = hexi . get_magnetometer_data () print ( \"Magnetometer Data [xyz]\" , magn , \"uT\" ) magn = hexi . get_gyroscope_data () print ( \"Gyroscope Data [xyz]\" , magn , \"dps\" ) temp = hexi . get_temperature () print ( \"Temperature\" , temp , \"*C\" ) humid = hexi . get_humidity () print ( \"Humidity\" , humid , \"RH%\" ) press = hexi . get_pressure () print ( \"Pressure\" , press , \"Pa\" ) hr = hexi . get_heart_rate () print ( \"Heart Rate\" , hr , \"bpm\" ) print ( \"------------------------------------------------------------------------------\" ) sleep ( 3000 ) except Exception as e : print ( e ) sleep ( 3000 )","title":"Basic example of use for Hexiwear Library"},{"location":"reference/libs/nxp/hexiwear/docs/examples/#basic-example-of-use-for-kw40z-on-hexiwear-device","text":"Interact with ble chip on hexiwear device to set on/off the bluetooth feature and to test the bluetooth pairing. main.py ################################################################################ # Basic example for interacting with bluetooth low energy chip on hexiwear # # Created: 2017-03-29 12:50:52.955862 # ################################################################################ from nxp.hexiwear.kw40z import kw40z import streams import threading streams . serial () def pressed_up (): print ( \"Up Button Pressed\" ) def pressed_down (): print ( \"Down Button Pressed\" ) def toggle_ble (): try : print ( \"Left Button Pressed\" ) bt_driver . toggle_adv_mode () except Exception as e : print ( \"error on left_pressed\" , e ) def toggle_touch (): try : print ( \"Right Button Pressed\" ) bt_driver . toggle_tsi_group () except Exception as e : print ( \"error on right_pressed\" , e ) def print_paircode (): print ( \"Your Pair Code:\" , bt_driver . passkey ) # used to check the bluetooth status pinMode ( LED1 , OUTPUT ) def check_status (): print ( \"Device Settings\" ) bt_on , bt_touch , bt_link = bt_driver . info () print ( \"Bluetooth State: \" , ( \"On\" if bt_on == 1 else \"Off\" )) digitalWrite ( LED1 , 0 if bt_on == 1 else 1 ) print ( \"Capacitive Button Active: \" , ( \"Left\" if bt_touch == 0 else \"Right\" )) print ( \"Link State: \" , ( \"Connected\" if bt_link == 1 else \"Disconnected\" )) while True : bt_on_new , bt_touch_new , bt_link_new = bt_driver . info () if bt_on_new != bt_on : print ( \"Bluetooth State: \" , ( \"On\" if bt_on_new == 1 else \"Off\" )) digitalWrite ( LED1 , 0 if bt_on_new == 1 else 1 ) bt_on = bt_on_new if bt_touch_new != bt_touch : print ( \"Capacitive Button Active: \" , ( \"Left\" if bt_touch_new == 0 else \"Right\" )) bt_touch = bt_touch_new if bt_link_new != bt_link : print ( \"Link State: \" , ( \"Connected\" if bt_link_new == 1 else \"Disconnected\" )) bt_link = bt_link_new sleep ( 500 ) try : print ( \"init...\" ) # Setup ble chip # This setup is referred to kw40z mounted on Hexiwear device # The original Hexiwear default application binary file must be pre-loaded inside the kw40z # The application binary file for kw40z can be found here: # Link: https://github.com/MikroElektronika/HEXIWEAR/blob/master/SW/binaries/HEXIWEAR_KW40.bin bt_driver = kw40z . KW40Z_HEXI_APP ( SERIAL1 ) print ( \"start\" ) bt_driver . start () # wait for starting the ble chip sleep ( 1000 ) # start thread for check ble status thread ( check_status ) # attach callback function to left and right button bt_driver . attach_button_left ( toggle_ble ) bt_driver . attach_button_right ( toggle_touch ) bt_driver . attach_button_up ( pressed_up ) bt_driver . attach_button_down ( pressed_down ) bt_driver . attach_passkey ( print_paircode ) except Exception as e : print ( \"error1:\" , e ) while True : try : print ( \".\" ) sleep ( 5000 ) except Exception as e : print ( \"error2\" , e ) sleep ( 1000 )","title":"Basic example of use for kw40z on hexiwear device"},{"location":"reference/libs/nxp/hexiwear/docs/examples/#sensor-data-exchange-via-bluetooth","text":"Expose Hexiwear data sensors via bluetoooth readable through any smartphone/tablet/pc bluetooth terminal. main.py ################################################################################ # Send Battery Level via Bluetooth # # Created: 2017-03-29 14:45:18.159845 # ################################################################################ from nxp.hexiwear.kw40z import kw40z import streams import threading streams . serial () def toggle_ble (): try : print ( \"Left Button Pressed\" ) bt_driver . toggle_adv_mode () except Exception as e : print ( \"error on left_pressed\" , e ) def print_paircode (): print ( \"Your Pair Code:\" , bt_driver . passkey ) pinMode ( LED1 , OUTPUT ) def check_status (): print ( \"Device Settings\" ) bt_on , bt_touch , bt_link = bt_driver . info () print ( \"Bluetooth State: \" , ( \"On\" if bt_on == 1 else \"Off\" )) digitalWrite ( LED1 , 0 if bt_on == 1 else 1 ) print ( \"Capacitive Button Active: \" , ( \"Left\" if bt_touch == 0 else \"Right\" )) print ( \"Link State: \" , ( \"Connected\" if bt_link == 1 else \"Disconnected\" )) while True : bt_on_new , bt_touch_new , bt_link_new = bt_driver . info () if bt_on_new != bt_on : print ( \"Bluetooth State: \" , ( \"On\" if bt_on_new == 1 else \"Off\" )) digitalWrite ( LED1 , 0 if bt_on_new == 1 else 1 ) bt_on = bt_on_new if bt_touch_new != bt_touch : print ( \"Capacitive Button Active: \" , ( \"Left\" if bt_touch_new == 0 else \"Right\" )) bt_touch = bt_touch_new if bt_link_new != bt_link : print ( \"Link State: \" , ( \"Connected\" if bt_link_new == 1 else \"Disconnected\" )) bt_link = bt_link_new sleep ( 500 ) try : # Setup ble chip # This setup is referred to kw40z mounted on Hexiwear device # The original Hexiwear default application binary file must be pre-loaded inside the kw40z # The application binary file for kw40z can be found here: # Link: https://github.com/MikroElektronika/HEXIWEAR/blob/master/SW/binaries/HEXIWEAR_KW40.bin print ( \"init...\" ) bt_driver = kw40z . KW40Z_HEXI_APP ( SERIAL1 ) print ( \"start\" ) bt_driver . start () # wait for starting the ble chip sleep ( 1000 ) # start thread for check ble status thread ( check_status ) # attach callback function to left and right button bt_driver . attach_button_left ( toggle_ble ) bt_driver . attach_passkey ( print_paircode ) except Exception as e : print ( \"error1:\" , e ) level = 0 while True : try : print ( \".\" ) bt_driver . upd_sensors ( battery = level ) level += 1 if level > 100 : level = 0 sleep ( 5000 ) except Exception as e : print ( \"error2\" , e ) sleep ( 1000 )","title":"Sensor Data Exchange via Bluetooth"},{"location":"reference/libs/nxp/hexiwear/docs/hexiwear/","text":"HEXIWEAR Module \u00b6 This module contains the driver for enabling and handling all Hexiwear onboard sensors and features. The HEXIWEAR class permits an easier access to the internal peripherals and exposes all functionalities in simple function calls ( wiki ). HEXIWEAR \u00b6 HEXIWEAR ( battery_en = True , oled_en = True , amb_light_en = True , heart_rate_en = True , temp_humid_en = True , gyro_en = True , acc_magn_en = True , pressure_en = True , bt_driver_en = True ) Creates an instance of a new HEXIWEAR. Arguments: battery_en(bool) \u2013 Flag for enabling the battery level reading feature; default True oled_en(bool) \u2013 Flag for enabling the onboard color oled display; default True amb_light_en(bool) \u2013 Flag for enabling the ambient light sensor; default True heart_rate_en(bool) \u2013 Flag for enabling the heart rate sensor; default True temp_humid_en(bool) \u2013 Flag for enabling the temperature and humidity sensor; default True gyro_en(bool) \u2013 Flag for enabling the onboard gyroscope; default True acc_magn_en(bool) \u2013 Flag for enabling the onboard accelerometer and magnetometer; default True pressure_en(bool) \u2013 Flag for enabling the pressure sensor; default True bt_driver_en(bool) \u2013 Flag for enabling driver for bluetooth features; default True Example: from nxp.hexiwear import hexiwear ... hexi = hexiwear . HEXIWEAR () t = hexi . get_temperature () h = hexi . get_humidity () ... gyro = hexi . get_gyroscope_data () get_battery_level \u00b6 get_battery_level ( chg_state ) If battery level reading feature is enabled; retrieves the current battery level in percentage and the charging battery status if chg=True is provided. Arguments chg_state(bool) \u2013 flag for enabling the battery charging status reading; default False Returns battery_level or battery_level, charging_status or None get_pressure \u00b6 get_pressure () If pressure sensor is enabled; retrieves the current pressure data from the onboard sensor as calibrate value in Pa. Returns pressure or None get_temperature \u00b6 get_temperature () If temperature and humidity sensor is enabled; retrieves the current temperature data from the onboard sensor as calibrate value in \u00b0C. Returns temperature or None. get_humidity \u00b6 get_humidity () If temperature and humidity sensor is enabled; retrieves the current humidity data from the onboard sensor as calibrate value in %RH. Returns humidity or None. get_accelerometer_data \u00b6 get_accelerometer_data () If accelerometer and magnetometer are enabled; retrieves the current accelerometer data from the onboard sensor in m/s^2 as a tuple of X, Y, Z values. Returns [acc_x, acc_y, acc_z] or None. get_magnetometer_data \u00b6 get_magnetometer_data () If accelerometer and magnetometer are enabled; retrieves the current magnetometer data from the onboard sensor in uT as a tuple of X, Y, Z values. Returns [magn_x, magn_y, magn_z] or None get_gyroscope_data \u00b6 get_gyroscope_data () If gyroscope is enabled; retrieves the current gyroscope data from the onboard sensor in degrees per second as a tuple of X, Y, Z values. Returns [gyro_x, gyro_y, gyro_z] or None get_ambient_light \u00b6 get_ambient_light () If ambient light sensor is enabled; Converts the raw sensor values to the standard SI lux equivalent. Returns lux or None get_heart_rate \u00b6 get_heart_rate () If heart rate sensor is enabled; retrieves the current heart rate from the onboard sensor as value in bpm (beat per minute). Returns heart_rate or None get_altitude \u00b6 get_altitude () If pressure sensor is enabled; calculates, from measured pressure, the current altitude data as value in meters. Returns altitude or None attach_button_up \u00b6 attach_button_up ( callback ) If bluetooth driver is enabled; sets the callback function to be executed when Capacitive Button Up on Hexiwear device is pressed. attach_button_down \u00b6 attach_button_down ( callback ) If bluetooth driver is enabled; sets the callback function to be executed when Capacitive Button Down on Hexiwear device is pressed. attach_button_left \u00b6 attach_button_left ( callback ) If bluetooth driver is enabled; sets the callback function to be executed when Capacitive Button Left on Hexiwear device is pressed. attach_button_right \u00b6 attach_button_right ( callback ) If bluetooth driver is enabled; sets the callback function to be executed when Capacitive Button Right on Hexiwear device is pressed. attach_passkey \u00b6 attach_passkey ( callback ) If bluetooth driver is enabled; sets the callback function to be executed when KW40Z receives a bluetooth pairing request. Note When the KW40Z receives this kind of request it generates a pairing code stored in the passkey KW40Z class attribute of bt_driver internal instance. bluetooth_on \u00b6 bluetooth_on () If bluetooth driver is enabled; turns on the bluetooth features. bluetooth_off \u00b6 bluetooth_off () If bluetooth driver is enabled; turns off the bluetooth features. right_capacitive_buttons_active \u00b6 right_capacitive_buttons_active () If bluetooth driver is enabled; turns active the right pair of capacitive buttons. right_capacitive_buttons_active \u00b6 right_capacitive_buttons_active () If bluetooth driver is enabled; turns active the left pair of capacitive buttons. bluetooth_info \u00b6 bluetooth_info () If bluetooth driver is enabled; retrieves the bluetooth chip informations regarding the status, which capacitive touch buttons are active, and the \u201cconnection with other devices\u201d status. Bluetooth Status ( bool ): 1 Bluetooth is on, 0 Bluetooth is off; Capacitive Touch Buttons ( bool ): 1 active right pair, 0 acive left pair; Link Status ( bool ): 1 device is connected, 0 device is disconnected. Returns bt_on, bt_touch, bt_link enable_bt_upd_sensors \u00b6 enable_bt_upd_sensors () If bluetooth driver is enabled; enables the automatic update of all sensor values in the KW40Z bluetooth chip to be readable through any smartphone/tablet/pc bluetooth terminal (once every 5 seconds). disable_bt_upd_sensors \u00b6 disable_bt_upd_sensors () If bluetooth driver is enabled; disables the automatic update of all sensor values in the KW40Z bluetooth chip. display_on \u00b6 display_on () If color oled display is enabled; turns on the onboard display. display_off \u00b6 display_off () If color oled display is enabled; turns off the onboard display. clear_display \u00b6 clear_display () If color oled display is enabled; clears the onboard display. fill_screen \u00b6 fill_screen ( color , encode = True ) If color oled display is enabled; fills the entire display with color code provided as argument. Arguments color \u2013 hex color code for the screen encode(bool) \u2013 flag for enabling the color encoding; default True Note The onboard color oled is a 65K color display, so if a stadard hex color code (24 bit) is provided it is necessary to encode it into a 16 bit format. If a 16 bit color code is provided, the encode flag must be set to False. fill_rect \u00b6 fill_rect ( x , y , w , h , color , encode = True ) If color oled display is enabled; draws a rectangular area in the screen colored with the color code provided as argument. Arguments x \u2013 x-coordinate for left high corner of the rectangular area y \u2013 y-coordinate for left high corner of the rectangular area w \u2013 width of the rectangular area h \u2013 height of the rectangular area color \u2013 hex color code for the rectangular area encode(bool) \u2013 flag for enabling the color encoding; default True Note The onboard color oled is a 65K color display, so if a stadard hex color code (24 bit) is provided it is necessary to encode it into a 16 bit format. If a 16 bit color code is provided, the encode flag must be set to False. draw_image \u00b6 draw_image ( image , x , y , w , h ) If color oled display is enabled; draws a rectangular area in the screen colored with the color code provided as argument. Arguments: image \u2013 image to draw in the oled display converted to hex array format and passed as bytearray x \u2013 x-coordinate for left high corner of the image y \u2013 y-coordinate for left high corner of the image w \u2013 width of the image h \u2013 height of the image Note To obtain a converted image in hex array format, you can go and use this online tool . After uploading your image, you can resize it setting the width and height fields; you can also choose the code format (HEX:0x recommended) and the color format (65K color for this display). Clicking on the \u201cGet C string\u201d button, the tool converts your image with your settings to a hex string that you can copy and paste inside a bytearray in your project and privide to this function. draw_pixel \u00b6 draw_pixel ( x , y , color , encode = True ) If color oled display is enabled; draws a single pixel in the screen colored with the color code provided as argument. Arguments: x \u2013 pixel x-coordinate y \u2013 pixel y-coordinate color \u2013 hex color code for the pixel encode(bool) \u2013 flag for enabling the color encoding; default True Note The onboard color oled is a 65K color display, so if a stadard hex color code (24 bit) is provided it is necessary to encode it into a 16 bit format. If a 16 bit color code is provided, the encode flag must be set to False. draw_text \u00b6 draw_text ( text , x = None , y = None , w = None , h = None , color = None , align = None , background = None , encode = True ) If color oled display is enabled; prints a string inside a text box in the screen. Arguments: text \u2013 string to be written in the display x \u2013 x-coordinate for left high corner of the text box; default None y \u2013 y-coordinate for left high corner of the text box; default None w \u2013 width of the text box; default None h \u2013 height of the text box; default None color \u2013 hex color code for the font; default None align \u2013 alignment of the text inside the text box (1 for left alignment, 2 for right alignment, 3 for center alignment); default None background \u2013 hex color code for the background; default None encode(bool) \u2013 flag for enabling the color encoding of the font and background color; default True Note The onboard color oled is a 65K color display, so if a stadard hex color code (24 bit) is provided it is necessary to encode it into a 16 bit format. If a 16 bit color code is provided, the encode flag must be set to False. Note If only text argument is provided, an automatic text box is created with the following values: x = 0 y = 0 w = min text width according to the font h = max char height according to the font color = 0xFFFF align = 3 (centered horizontally) background = 0x4471 vibration \u00b6 vibration ( ms ) Turns on the vibration motor for ms milliseconds. Arguments: ms \u2013 motor vibration duration py3 leds_on \u00b6 py3 leds_on () Turns on the rgb onboard led (white light). leds_off \u00b6 leds_off () Turns off the rgb onboard led.","title":"HEXIWEAR Module"},{"location":"reference/libs/nxp/hexiwear/docs/hexiwear/#hexiwear-module","text":"This module contains the driver for enabling and handling all Hexiwear onboard sensors and features. The HEXIWEAR class permits an easier access to the internal peripherals and exposes all functionalities in simple function calls ( wiki ).","title":"HEXIWEAR Module"},{"location":"reference/libs/nxp/hexiwear/docs/hexiwear/#hexiwear","text":"HEXIWEAR ( battery_en = True , oled_en = True , amb_light_en = True , heart_rate_en = True , temp_humid_en = True , gyro_en = True , acc_magn_en = True , pressure_en = True , bt_driver_en = True ) Creates an instance of a new HEXIWEAR. Arguments: battery_en(bool) \u2013 Flag for enabling the battery level reading feature; default True oled_en(bool) \u2013 Flag for enabling the onboard color oled display; default True amb_light_en(bool) \u2013 Flag for enabling the ambient light sensor; default True heart_rate_en(bool) \u2013 Flag for enabling the heart rate sensor; default True temp_humid_en(bool) \u2013 Flag for enabling the temperature and humidity sensor; default True gyro_en(bool) \u2013 Flag for enabling the onboard gyroscope; default True acc_magn_en(bool) \u2013 Flag for enabling the onboard accelerometer and magnetometer; default True pressure_en(bool) \u2013 Flag for enabling the pressure sensor; default True bt_driver_en(bool) \u2013 Flag for enabling driver for bluetooth features; default True Example: from nxp.hexiwear import hexiwear ... hexi = hexiwear . HEXIWEAR () t = hexi . get_temperature () h = hexi . get_humidity () ... gyro = hexi . get_gyroscope_data ()","title":"HEXIWEAR"},{"location":"reference/libs/nxp/hexiwear/docs/hexiwear/#get_battery_level","text":"get_battery_level ( chg_state ) If battery level reading feature is enabled; retrieves the current battery level in percentage and the charging battery status if chg=True is provided. Arguments chg_state(bool) \u2013 flag for enabling the battery charging status reading; default False Returns battery_level or battery_level, charging_status or None","title":"get_battery_level"},{"location":"reference/libs/nxp/hexiwear/docs/hexiwear/#get_pressure","text":"get_pressure () If pressure sensor is enabled; retrieves the current pressure data from the onboard sensor as calibrate value in Pa. Returns pressure or None","title":"get_pressure"},{"location":"reference/libs/nxp/hexiwear/docs/hexiwear/#get_temperature","text":"get_temperature () If temperature and humidity sensor is enabled; retrieves the current temperature data from the onboard sensor as calibrate value in \u00b0C. Returns temperature or None.","title":"get_temperature"},{"location":"reference/libs/nxp/hexiwear/docs/hexiwear/#get_humidity","text":"get_humidity () If temperature and humidity sensor is enabled; retrieves the current humidity data from the onboard sensor as calibrate value in %RH. Returns humidity or None.","title":"get_humidity"},{"location":"reference/libs/nxp/hexiwear/docs/hexiwear/#get_accelerometer_data","text":"get_accelerometer_data () If accelerometer and magnetometer are enabled; retrieves the current accelerometer data from the onboard sensor in m/s^2 as a tuple of X, Y, Z values. Returns [acc_x, acc_y, acc_z] or None.","title":"get_accelerometer_data"},{"location":"reference/libs/nxp/hexiwear/docs/hexiwear/#get_magnetometer_data","text":"get_magnetometer_data () If accelerometer and magnetometer are enabled; retrieves the current magnetometer data from the onboard sensor in uT as a tuple of X, Y, Z values. Returns [magn_x, magn_y, magn_z] or None","title":"get_magnetometer_data"},{"location":"reference/libs/nxp/hexiwear/docs/hexiwear/#get_gyroscope_data","text":"get_gyroscope_data () If gyroscope is enabled; retrieves the current gyroscope data from the onboard sensor in degrees per second as a tuple of X, Y, Z values. Returns [gyro_x, gyro_y, gyro_z] or None","title":"get_gyroscope_data"},{"location":"reference/libs/nxp/hexiwear/docs/hexiwear/#get_ambient_light","text":"get_ambient_light () If ambient light sensor is enabled; Converts the raw sensor values to the standard SI lux equivalent. Returns lux or None","title":"get_ambient_light"},{"location":"reference/libs/nxp/hexiwear/docs/hexiwear/#get_heart_rate","text":"get_heart_rate () If heart rate sensor is enabled; retrieves the current heart rate from the onboard sensor as value in bpm (beat per minute). Returns heart_rate or None","title":"get_heart_rate"},{"location":"reference/libs/nxp/hexiwear/docs/hexiwear/#get_altitude","text":"get_altitude () If pressure sensor is enabled; calculates, from measured pressure, the current altitude data as value in meters. Returns altitude or None","title":"get_altitude"},{"location":"reference/libs/nxp/hexiwear/docs/hexiwear/#attach_button_up","text":"attach_button_up ( callback ) If bluetooth driver is enabled; sets the callback function to be executed when Capacitive Button Up on Hexiwear device is pressed.","title":"attach_button_up"},{"location":"reference/libs/nxp/hexiwear/docs/hexiwear/#attach_button_down","text":"attach_button_down ( callback ) If bluetooth driver is enabled; sets the callback function to be executed when Capacitive Button Down on Hexiwear device is pressed.","title":"attach_button_down"},{"location":"reference/libs/nxp/hexiwear/docs/hexiwear/#attach_button_left","text":"attach_button_left ( callback ) If bluetooth driver is enabled; sets the callback function to be executed when Capacitive Button Left on Hexiwear device is pressed.","title":"attach_button_left"},{"location":"reference/libs/nxp/hexiwear/docs/hexiwear/#attach_button_right","text":"attach_button_right ( callback ) If bluetooth driver is enabled; sets the callback function to be executed when Capacitive Button Right on Hexiwear device is pressed.","title":"attach_button_right"},{"location":"reference/libs/nxp/hexiwear/docs/hexiwear/#attach_passkey","text":"attach_passkey ( callback ) If bluetooth driver is enabled; sets the callback function to be executed when KW40Z receives a bluetooth pairing request. Note When the KW40Z receives this kind of request it generates a pairing code stored in the passkey KW40Z class attribute of bt_driver internal instance.","title":"attach_passkey"},{"location":"reference/libs/nxp/hexiwear/docs/hexiwear/#bluetooth_on","text":"bluetooth_on () If bluetooth driver is enabled; turns on the bluetooth features.","title":"bluetooth_on"},{"location":"reference/libs/nxp/hexiwear/docs/hexiwear/#bluetooth_off","text":"bluetooth_off () If bluetooth driver is enabled; turns off the bluetooth features.","title":"bluetooth_off"},{"location":"reference/libs/nxp/hexiwear/docs/hexiwear/#right_capacitive_buttons_active","text":"right_capacitive_buttons_active () If bluetooth driver is enabled; turns active the right pair of capacitive buttons.","title":"right_capacitive_buttons_active"},{"location":"reference/libs/nxp/hexiwear/docs/hexiwear/#right_capacitive_buttons_active_1","text":"right_capacitive_buttons_active () If bluetooth driver is enabled; turns active the left pair of capacitive buttons.","title":"right_capacitive_buttons_active"},{"location":"reference/libs/nxp/hexiwear/docs/hexiwear/#bluetooth_info","text":"bluetooth_info () If bluetooth driver is enabled; retrieves the bluetooth chip informations regarding the status, which capacitive touch buttons are active, and the \u201cconnection with other devices\u201d status. Bluetooth Status ( bool ): 1 Bluetooth is on, 0 Bluetooth is off; Capacitive Touch Buttons ( bool ): 1 active right pair, 0 acive left pair; Link Status ( bool ): 1 device is connected, 0 device is disconnected. Returns bt_on, bt_touch, bt_link","title":"bluetooth_info"},{"location":"reference/libs/nxp/hexiwear/docs/hexiwear/#enable_bt_upd_sensors","text":"enable_bt_upd_sensors () If bluetooth driver is enabled; enables the automatic update of all sensor values in the KW40Z bluetooth chip to be readable through any smartphone/tablet/pc bluetooth terminal (once every 5 seconds).","title":"enable_bt_upd_sensors"},{"location":"reference/libs/nxp/hexiwear/docs/hexiwear/#disable_bt_upd_sensors","text":"disable_bt_upd_sensors () If bluetooth driver is enabled; disables the automatic update of all sensor values in the KW40Z bluetooth chip.","title":"disable_bt_upd_sensors"},{"location":"reference/libs/nxp/hexiwear/docs/hexiwear/#display_on","text":"display_on () If color oled display is enabled; turns on the onboard display.","title":"display_on"},{"location":"reference/libs/nxp/hexiwear/docs/hexiwear/#display_off","text":"display_off () If color oled display is enabled; turns off the onboard display.","title":"display_off"},{"location":"reference/libs/nxp/hexiwear/docs/hexiwear/#clear_display","text":"clear_display () If color oled display is enabled; clears the onboard display.","title":"clear_display"},{"location":"reference/libs/nxp/hexiwear/docs/hexiwear/#fill_screen","text":"fill_screen ( color , encode = True ) If color oled display is enabled; fills the entire display with color code provided as argument. Arguments color \u2013 hex color code for the screen encode(bool) \u2013 flag for enabling the color encoding; default True Note The onboard color oled is a 65K color display, so if a stadard hex color code (24 bit) is provided it is necessary to encode it into a 16 bit format. If a 16 bit color code is provided, the encode flag must be set to False.","title":"fill_screen"},{"location":"reference/libs/nxp/hexiwear/docs/hexiwear/#fill_rect","text":"fill_rect ( x , y , w , h , color , encode = True ) If color oled display is enabled; draws a rectangular area in the screen colored with the color code provided as argument. Arguments x \u2013 x-coordinate for left high corner of the rectangular area y \u2013 y-coordinate for left high corner of the rectangular area w \u2013 width of the rectangular area h \u2013 height of the rectangular area color \u2013 hex color code for the rectangular area encode(bool) \u2013 flag for enabling the color encoding; default True Note The onboard color oled is a 65K color display, so if a stadard hex color code (24 bit) is provided it is necessary to encode it into a 16 bit format. If a 16 bit color code is provided, the encode flag must be set to False.","title":"fill_rect"},{"location":"reference/libs/nxp/hexiwear/docs/hexiwear/#draw_image","text":"draw_image ( image , x , y , w , h ) If color oled display is enabled; draws a rectangular area in the screen colored with the color code provided as argument. Arguments: image \u2013 image to draw in the oled display converted to hex array format and passed as bytearray x \u2013 x-coordinate for left high corner of the image y \u2013 y-coordinate for left high corner of the image w \u2013 width of the image h \u2013 height of the image Note To obtain a converted image in hex array format, you can go and use this online tool . After uploading your image, you can resize it setting the width and height fields; you can also choose the code format (HEX:0x recommended) and the color format (65K color for this display). Clicking on the \u201cGet C string\u201d button, the tool converts your image with your settings to a hex string that you can copy and paste inside a bytearray in your project and privide to this function.","title":"draw_image"},{"location":"reference/libs/nxp/hexiwear/docs/hexiwear/#draw_pixel","text":"draw_pixel ( x , y , color , encode = True ) If color oled display is enabled; draws a single pixel in the screen colored with the color code provided as argument. Arguments: x \u2013 pixel x-coordinate y \u2013 pixel y-coordinate color \u2013 hex color code for the pixel encode(bool) \u2013 flag for enabling the color encoding; default True Note The onboard color oled is a 65K color display, so if a stadard hex color code (24 bit) is provided it is necessary to encode it into a 16 bit format. If a 16 bit color code is provided, the encode flag must be set to False.","title":"draw_pixel"},{"location":"reference/libs/nxp/hexiwear/docs/hexiwear/#draw_text","text":"draw_text ( text , x = None , y = None , w = None , h = None , color = None , align = None , background = None , encode = True ) If color oled display is enabled; prints a string inside a text box in the screen. Arguments: text \u2013 string to be written in the display x \u2013 x-coordinate for left high corner of the text box; default None y \u2013 y-coordinate for left high corner of the text box; default None w \u2013 width of the text box; default None h \u2013 height of the text box; default None color \u2013 hex color code for the font; default None align \u2013 alignment of the text inside the text box (1 for left alignment, 2 for right alignment, 3 for center alignment); default None background \u2013 hex color code for the background; default None encode(bool) \u2013 flag for enabling the color encoding of the font and background color; default True Note The onboard color oled is a 65K color display, so if a stadard hex color code (24 bit) is provided it is necessary to encode it into a 16 bit format. If a 16 bit color code is provided, the encode flag must be set to False. Note If only text argument is provided, an automatic text box is created with the following values: x = 0 y = 0 w = min text width according to the font h = max char height according to the font color = 0xFFFF align = 3 (centered horizontally) background = 0x4471","title":"draw_text"},{"location":"reference/libs/nxp/hexiwear/docs/hexiwear/#vibration","text":"vibration ( ms ) Turns on the vibration motor for ms milliseconds. Arguments: ms \u2013 motor vibration duration","title":"vibration"},{"location":"reference/libs/nxp/hexiwear/docs/hexiwear/#py3-leds_on","text":"py3 leds_on () Turns on the rgb onboard led (white light).","title":"py3 leds_on"},{"location":"reference/libs/nxp/hexiwear/docs/hexiwear/#leds_off","text":"leds_off () Turns off the rgb onboard led.","title":"leds_off"},{"location":"reference/libs/nxp/hexiwear/docs/kw40z_kw40z/","text":"KW40Z Module \u00b6 The KW40Z SoC can be used in applications as a \u201cBlackBox\u201d modem by simply adding BLE or IEEE Std. 802.15.4 connectivity to an existing embedded controller system, or used as a stand-alone smart wireless sensor with embedded application where no host controller is required. ( datasheet ). This module contains the driver for NXP KW40Z Bluetooth Low Energy chip mounted on the Hexiwear device and pre-loaded of the related original default application firmware. This application exposes all features through a specific serial communication protocol, handles all capacitive touch buttons on Hexiwear device and permits to exchange Hexiwear sensor data via bluetoooth. Note This module works only if the HEXIWEAR_KW40.bin file is loaded on the nxp kw40z chip. The binary file can be found here . A step-by-step tutorial for loading the binary file inside the kw40z chip can be found here . KW40Z_HEXI_APP \u00b6 KW40Z_HEXI_APP ( ser ) Creates an intance of a new KW40Z_HEXI_APP. Arguments: ser \u2013 Serial used \u2018( SERIAL1, \u2026 )\u2019 Example: from nxp.kw40z import kw40z ... bt_driver = kw40z . KW40Z_HEXI_APP ( SERIAL1 ) bt_driver . start () ... start \u00b6 start () Starts the serial communication with the KW40Z and check the KW40Z status (check if Bluetooth is active, if there are connections with other devices, and which set of capacitive touch buttons are active) attach_button_up \u00b6 attach_button_up ( callback ) Sets the callback function to be executed when Capacitive Button Up on Hexiwear device is pressed. attach_button_down \u00b6 attach_button_down ( callback ) Sets the callback function to be executed when Capacitive Button Down on Hexiwear device is pressed. attach_button_left \u00b6 attach_button_left ( callback ) Sets the callback function to be executed when Capacitive Button Left on Hexiwear device is pressed. attach_button_right \u00b6 attach_button_right ( callback ) Sets the callback function to be executed when Capacitive Button Right on Hexiwear device is pressed. attach_alert \u00b6 attach_alert ( callback ) Sets the callback function to be executed when KW40Z receives an input alert. attach_notification \u00b6 attach_notification ( callback ) Sets the callback function to be executed when KW40Z receives a notification. attach_passkey \u00b6 attach_passkey ( callback ) Sets the callback function to be executed when KW40Z receives a bluetooth pairing request. Note When the KW40Z receives this kind of request it generates a pairing code stored in the passkey class attribute. upd_sensors \u00b6 upd_sensors ( battery = None , accel = None , gyro = None , magn = None , aLight = None , temp = None , humid = None , press = None ) Updates Hexiwear sensor data in the KW40Z chip to be readable through any smartphone/tablet/pc bluetooth terminal. Arguments: battery \u2013 update the battery level value in percentage if passed as argument; default None; accel \u2013 update the acceleration values (list of 3 uint_16 elements for x,y,z axis) if passed as argument; default None; gyro \u2013 update the gyroscope values (list of 3 uint_16 elements for x,y,z axis) if passed as argument; default None; magn \u2013 update the magnetometer values (list of 3 uint_16 elements for x,y,z axis) if passed as argument; default None; aLight \u2013 update the ambient light level value in percentage if passed as argument; default None; temp \u2013 update the temperature value (uint_16) if passed as argument; default None; humid \u2013 update the humidity value (uint_16) if passed as argument; default None; press \u2013 update the pressure value (uint_16) if passed as argument; default None. send_alert \u00b6 send_alert () Sends alerts from Hexiwear device to the connected smartphone/tablet/pc via Bluetooth. toggle_adv_mode \u00b6 toggle_adv_mode () Changes the status of advertising process. Sets on/off the Bluetooth status. toggle_tsi_group \u00b6 toggle_tsi_group () Changes active group (pair) of vertical touch sense electrodes. Sets right/left pair capacitive touch buttons. info \u00b6 info () Retrieves the device setting informations regarding the Bluetooth status, which capacitive touch buttons are active, and the connection with other devices status. Bluetooth Status ( bool ): 1 Bluetooth is on, 0 Bluetooth is off; Capacitive Touch Buttons ( bool ): 1 active right pair, 0 acive left pair; Link Status ( bool ): 1 device is connected, 0 device is disconnected. Returns bt_on, bt_touch, bt_link.","title":"KW40Z Module"},{"location":"reference/libs/nxp/hexiwear/docs/kw40z_kw40z/#kw40z-module","text":"The KW40Z SoC can be used in applications as a \u201cBlackBox\u201d modem by simply adding BLE or IEEE Std. 802.15.4 connectivity to an existing embedded controller system, or used as a stand-alone smart wireless sensor with embedded application where no host controller is required. ( datasheet ). This module contains the driver for NXP KW40Z Bluetooth Low Energy chip mounted on the Hexiwear device and pre-loaded of the related original default application firmware. This application exposes all features through a specific serial communication protocol, handles all capacitive touch buttons on Hexiwear device and permits to exchange Hexiwear sensor data via bluetoooth. Note This module works only if the HEXIWEAR_KW40.bin file is loaded on the nxp kw40z chip. The binary file can be found here . A step-by-step tutorial for loading the binary file inside the kw40z chip can be found here .","title":"KW40Z Module"},{"location":"reference/libs/nxp/hexiwear/docs/kw40z_kw40z/#kw40z_hexi_app","text":"KW40Z_HEXI_APP ( ser ) Creates an intance of a new KW40Z_HEXI_APP. Arguments: ser \u2013 Serial used \u2018( SERIAL1, \u2026 )\u2019 Example: from nxp.kw40z import kw40z ... bt_driver = kw40z . KW40Z_HEXI_APP ( SERIAL1 ) bt_driver . start () ...","title":"KW40Z_HEXI_APP"},{"location":"reference/libs/nxp/hexiwear/docs/kw40z_kw40z/#start","text":"start () Starts the serial communication with the KW40Z and check the KW40Z status (check if Bluetooth is active, if there are connections with other devices, and which set of capacitive touch buttons are active)","title":"start"},{"location":"reference/libs/nxp/hexiwear/docs/kw40z_kw40z/#attach_button_up","text":"attach_button_up ( callback ) Sets the callback function to be executed when Capacitive Button Up on Hexiwear device is pressed.","title":"attach_button_up"},{"location":"reference/libs/nxp/hexiwear/docs/kw40z_kw40z/#attach_button_down","text":"attach_button_down ( callback ) Sets the callback function to be executed when Capacitive Button Down on Hexiwear device is pressed.","title":"attach_button_down"},{"location":"reference/libs/nxp/hexiwear/docs/kw40z_kw40z/#attach_button_left","text":"attach_button_left ( callback ) Sets the callback function to be executed when Capacitive Button Left on Hexiwear device is pressed.","title":"attach_button_left"},{"location":"reference/libs/nxp/hexiwear/docs/kw40z_kw40z/#attach_button_right","text":"attach_button_right ( callback ) Sets the callback function to be executed when Capacitive Button Right on Hexiwear device is pressed.","title":"attach_button_right"},{"location":"reference/libs/nxp/hexiwear/docs/kw40z_kw40z/#attach_alert","text":"attach_alert ( callback ) Sets the callback function to be executed when KW40Z receives an input alert.","title":"attach_alert"},{"location":"reference/libs/nxp/hexiwear/docs/kw40z_kw40z/#attach_notification","text":"attach_notification ( callback ) Sets the callback function to be executed when KW40Z receives a notification.","title":"attach_notification"},{"location":"reference/libs/nxp/hexiwear/docs/kw40z_kw40z/#attach_passkey","text":"attach_passkey ( callback ) Sets the callback function to be executed when KW40Z receives a bluetooth pairing request. Note When the KW40Z receives this kind of request it generates a pairing code stored in the passkey class attribute.","title":"attach_passkey"},{"location":"reference/libs/nxp/hexiwear/docs/kw40z_kw40z/#upd_sensors","text":"upd_sensors ( battery = None , accel = None , gyro = None , magn = None , aLight = None , temp = None , humid = None , press = None ) Updates Hexiwear sensor data in the KW40Z chip to be readable through any smartphone/tablet/pc bluetooth terminal. Arguments: battery \u2013 update the battery level value in percentage if passed as argument; default None; accel \u2013 update the acceleration values (list of 3 uint_16 elements for x,y,z axis) if passed as argument; default None; gyro \u2013 update the gyroscope values (list of 3 uint_16 elements for x,y,z axis) if passed as argument; default None; magn \u2013 update the magnetometer values (list of 3 uint_16 elements for x,y,z axis) if passed as argument; default None; aLight \u2013 update the ambient light level value in percentage if passed as argument; default None; temp \u2013 update the temperature value (uint_16) if passed as argument; default None; humid \u2013 update the humidity value (uint_16) if passed as argument; default None; press \u2013 update the pressure value (uint_16) if passed as argument; default None.","title":"upd_sensors"},{"location":"reference/libs/nxp/hexiwear/docs/kw40z_kw40z/#send_alert","text":"send_alert () Sends alerts from Hexiwear device to the connected smartphone/tablet/pc via Bluetooth.","title":"send_alert"},{"location":"reference/libs/nxp/hexiwear/docs/kw40z_kw40z/#toggle_adv_mode","text":"toggle_adv_mode () Changes the status of advertising process. Sets on/off the Bluetooth status.","title":"toggle_adv_mode"},{"location":"reference/libs/nxp/hexiwear/docs/kw40z_kw40z/#toggle_tsi_group","text":"toggle_tsi_group () Changes active group (pair) of vertical touch sense electrodes. Sets right/left pair capacitive touch buttons.","title":"toggle_tsi_group"},{"location":"reference/libs/nxp/hexiwear/docs/kw40z_kw40z/#info","text":"info () Retrieves the device setting informations regarding the Bluetooth status, which capacitive touch buttons are active, and the connection with other devices status. Bluetooth Status ( bool ): 1 Bluetooth is on, 0 Bluetooth is off; Capacitive Touch Buttons ( bool ): 1 active right pair, 0 acive left pair; Link Status ( bool ): 1 device is connected, 0 device is disconnected. Returns bt_on, bt_touch, bt_link.","title":"info"},{"location":"reference/libs/nxp/mpl3115a2/docs/","text":"NXP MPL3115A2 \u00b6 The MPL3115A2 is a compact piezoresistive absolute pressure sensor with an I2C interface. MPL3115 has a wide operating range of 20kPa to 110 kPa, a range that covers all surface elevations on Earth. The fully internally compensated MEMS in conjunction with an embedded high resolution 24-bit equivalent ADC provide accurate pressure [Pascals] /altitude [meters] and temperature [degrees Celsius] data. The internal processing in MPL3115A2 removes compensation and unit conversion load from the system MCU, simplifying system design. More information at NXP dedicated page . Technical Details \u00b6 Supply Voltage (Vdd): from 1.95 V to 3.6 V Operation Temperature (Top): from -40 \u00b0C to 85 \u00b0C Operating range: 20 kPa to 110 kPa absolute pressure Pressure 20-bit measurement (Pascals): from 20 kPa to 110 kPa Altitude 20-bit measurement (meters): from \u2013698 m to 11775 m Temperature 12-bit measurement (\u00b0C): from -40 \u00b0C to 85 \u00b0C Precision ADC resulting in 0.1 meter of effective resolution Fully compensated internally I\u00b2C interface Here below, the Zerynth driver for the NXP MPL3115A2. Contents: MPL3115A2 Module Examples get pressure","title":"NXP MPL3115A2"},{"location":"reference/libs/nxp/mpl3115a2/docs/#nxp-mpl3115a2","text":"The MPL3115A2 is a compact piezoresistive absolute pressure sensor with an I2C interface. MPL3115 has a wide operating range of 20kPa to 110 kPa, a range that covers all surface elevations on Earth. The fully internally compensated MEMS in conjunction with an embedded high resolution 24-bit equivalent ADC provide accurate pressure [Pascals] /altitude [meters] and temperature [degrees Celsius] data. The internal processing in MPL3115A2 removes compensation and unit conversion load from the system MCU, simplifying system design. More information at NXP dedicated page .","title":"NXP MPL3115A2"},{"location":"reference/libs/nxp/mpl3115a2/docs/#technical-details","text":"Supply Voltage (Vdd): from 1.95 V to 3.6 V Operation Temperature (Top): from -40 \u00b0C to 85 \u00b0C Operating range: 20 kPa to 110 kPa absolute pressure Pressure 20-bit measurement (Pascals): from 20 kPa to 110 kPa Altitude 20-bit measurement (meters): from \u2013698 m to 11775 m Temperature 12-bit measurement (\u00b0C): from -40 \u00b0C to 85 \u00b0C Precision ADC resulting in 0.1 meter of effective resolution Fully compensated internally I\u00b2C interface Here below, the Zerynth driver for the NXP MPL3115A2. Contents: MPL3115A2 Module Examples get pressure","title":"Technical Details"},{"location":"reference/libs/nxp/mpl3115a2/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.nxp.mpl3115a2. Read Pressure from MPL3115A2 \u00b6 Basic example to read the pressure from MPL3115A2 sensor. main.py ################################################################################ # Pressure Example # # Created: 2017-03-22 11:02:42.526582 # ################################################################################ import streams from nxp.mpl3115a2 import mpl3115a2 streams . serial () try : # Setup sensor # This setup is referred to mpl3115a2 mounted on hexiwear device mpl = mpl3115a2 . MPL3115A2 ( I2C1 ) print ( \"start...\" ) mpl . start () print ( \"init...\" ) mpl . init () print ( \"Ready!\" ) print ( \"--------------------------------------------------------\" ) except Exception as e : print ( \"Error: \" , e ) try : while True : raw_alt = mpl . get_raw_alt () # Read raw altitude print ( \"Raw Altitude: \" , raw_alt ) raw_pres = mpl . get_raw_pres () # Read raw pressure print ( \"Raw Pressure: \" , raw_pres ) raw_temp = mpl . get_raw_temp () # Read raw temperature print ( \"Raw Temperature: \" , raw_temp ) alt = mpl . get_alt () # Read altitude print ( \"Altitude: \" , alt , \"m\" ) pres = mpl . get_pres () # Read pressure print ( \"Pressure: \" , pres , \"Pa\" ) temp = mpl . get_temp () # Read trmperature print ( \"Temperature: \" , temp , \"C\" ) print ( \"--------------------------------------------------------\" ) sleep ( 5000 ) except Exception as e : print ( \"Error2: \" , e )","title":"Examples"},{"location":"reference/libs/nxp/mpl3115a2/docs/examples/#examples","text":"The following are a list of examples for lib.nxp.mpl3115a2.","title":"Examples"},{"location":"reference/libs/nxp/mpl3115a2/docs/examples/#read-pressure-from-mpl3115a2","text":"Basic example to read the pressure from MPL3115A2 sensor. main.py ################################################################################ # Pressure Example # # Created: 2017-03-22 11:02:42.526582 # ################################################################################ import streams from nxp.mpl3115a2 import mpl3115a2 streams . serial () try : # Setup sensor # This setup is referred to mpl3115a2 mounted on hexiwear device mpl = mpl3115a2 . MPL3115A2 ( I2C1 ) print ( \"start...\" ) mpl . start () print ( \"init...\" ) mpl . init () print ( \"Ready!\" ) print ( \"--------------------------------------------------------\" ) except Exception as e : print ( \"Error: \" , e ) try : while True : raw_alt = mpl . get_raw_alt () # Read raw altitude print ( \"Raw Altitude: \" , raw_alt ) raw_pres = mpl . get_raw_pres () # Read raw pressure print ( \"Raw Pressure: \" , raw_pres ) raw_temp = mpl . get_raw_temp () # Read raw temperature print ( \"Raw Temperature: \" , raw_temp ) alt = mpl . get_alt () # Read altitude print ( \"Altitude: \" , alt , \"m\" ) pres = mpl . get_pres () # Read pressure print ( \"Pressure: \" , pres , \"Pa\" ) temp = mpl . get_temp () # Read trmperature print ( \"Temperature: \" , temp , \"C\" ) print ( \"--------------------------------------------------------\" ) sleep ( 5000 ) except Exception as e : print ( \"Error2: \" , e )","title":"Read Pressure from MPL3115A2"},{"location":"reference/libs/nxp/mpl3115a2/docs/mpl3115a2/","text":"MPL3115A2 Module \u00b6 This module contains the driver for NXP MPL3115A2 Pressure, Altitude and Temperature sensor. The MPL3115A2 is capable of direct I2C communication; the pressure and temperature data is fed into a high resolution ADC to provide fully compensated and digitized outputs for pressure in Pascals and temperature in \u00b0C. The compensated pressure output can then be converted to altitude (utilizing the formula stated in Section 8.1.3 \u201cPressure/altitude\u201d of the datasheet or putting the sensor in altimeter operating mode) provided in meters. class MPL3115A2 \u00b6 class MPL3115A2 ( i2cdrv , addr = 0x60 , clk = 400000 ) Creates an instance of a new MPL3115A2. Arguments: i2cdrv \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x60 clk \u2013 Clock speed, default 400kHz Example: from nxp.mpl3115a2 import mpl3115a2 ... mpl = mpl3115a2 . MPL3115A2 ( I2C0 ) mpl . start () mpl . init () alt = mpl . get_alt () pres = mpl . get_pres () MPL3115A2.init \u00b6 init ( osr = 0 ) Initialize the MPL3115A2 setting the oversample rate value. Arguments: osr \u2013 set the oversample rate value (from 0 to 7), default 0. OSR Value Oversample Ratio Data Ready 0 1 6 ms 1 2 10 ms 2 4 18 ms 3 8 34 ms 4 16 66 ms 5 32 130 ms 6 64 258 ms 7 128 512 ms MPL3115A2.get_raw_alt \u00b6 get_raw_alt () Retrieves the current altitude data from the sensor as raw value. Returns raw_a. get_raw_pres() Retrieves the current pressure data from the sensor as raw value. Returns raw_p. MPL3115A2.get_raw_temp \u00b6 get_raw_temp () Retrieves the current temperature data from the sensor as raw value. Returns raw_t. MPL3115A2.get_alt \u00b6 get_alt () Calculates, from measured pressure, the current altitude data as value in meters. Returns altitude. MPL3115A2.get_pres \u00b6 get_pres () Retrieves the current pressure data from the sensor as calibrate value in Pa. Returns pres. MPL3115A2.get_temp \u00b6 get_temp () Retrieves the current temperature data from the sensor as calibrate value in \u00b0C. Returns temp.","title":"MPL3115A2 Module"},{"location":"reference/libs/nxp/mpl3115a2/docs/mpl3115a2/#mpl3115a2-module","text":"This module contains the driver for NXP MPL3115A2 Pressure, Altitude and Temperature sensor. The MPL3115A2 is capable of direct I2C communication; the pressure and temperature data is fed into a high resolution ADC to provide fully compensated and digitized outputs for pressure in Pascals and temperature in \u00b0C. The compensated pressure output can then be converted to altitude (utilizing the formula stated in Section 8.1.3 \u201cPressure/altitude\u201d of the datasheet or putting the sensor in altimeter operating mode) provided in meters.","title":"MPL3115A2 Module"},{"location":"reference/libs/nxp/mpl3115a2/docs/mpl3115a2/#class-mpl3115a2","text":"class MPL3115A2 ( i2cdrv , addr = 0x60 , clk = 400000 ) Creates an instance of a new MPL3115A2. Arguments: i2cdrv \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x60 clk \u2013 Clock speed, default 400kHz Example: from nxp.mpl3115a2 import mpl3115a2 ... mpl = mpl3115a2 . MPL3115A2 ( I2C0 ) mpl . start () mpl . init () alt = mpl . get_alt () pres = mpl . get_pres ()","title":"class MPL3115A2"},{"location":"reference/libs/nxp/mpl3115a2/docs/mpl3115a2/#mpl3115a2init","text":"init ( osr = 0 ) Initialize the MPL3115A2 setting the oversample rate value. Arguments: osr \u2013 set the oversample rate value (from 0 to 7), default 0. OSR Value Oversample Ratio Data Ready 0 1 6 ms 1 2 10 ms 2 4 18 ms 3 8 34 ms 4 16 66 ms 5 32 130 ms 6 64 258 ms 7 128 512 ms","title":"MPL3115A2.init"},{"location":"reference/libs/nxp/mpl3115a2/docs/mpl3115a2/#mpl3115a2get_raw_alt","text":"get_raw_alt () Retrieves the current altitude data from the sensor as raw value. Returns raw_a. get_raw_pres() Retrieves the current pressure data from the sensor as raw value. Returns raw_p.","title":"MPL3115A2.get_raw_alt"},{"location":"reference/libs/nxp/mpl3115a2/docs/mpl3115a2/#mpl3115a2get_raw_temp","text":"get_raw_temp () Retrieves the current temperature data from the sensor as raw value. Returns raw_t.","title":"MPL3115A2.get_raw_temp"},{"location":"reference/libs/nxp/mpl3115a2/docs/mpl3115a2/#mpl3115a2get_alt","text":"get_alt () Calculates, from measured pressure, the current altitude data as value in meters. Returns altitude.","title":"MPL3115A2.get_alt"},{"location":"reference/libs/nxp/mpl3115a2/docs/mpl3115a2/#mpl3115a2get_pres","text":"get_pres () Retrieves the current pressure data from the sensor as calibrate value in Pa. Returns pres.","title":"MPL3115A2.get_pres"},{"location":"reference/libs/nxp/mpl3115a2/docs/mpl3115a2/#mpl3115a2get_temp","text":"get_temp () Retrieves the current temperature data from the sensor as calibrate value in \u00b0C. Returns temp.","title":"MPL3115A2.get_temp"},{"location":"reference/libs/okdo/iot/docs/","text":"Zerynth OKdo \u00b6 OKdo IoT Cloud is an integrated maker platform for connecting devices, capturing an visualizing data easily. And for free! You can signup for an account at the following link . OKdo IoT Cloud provides connectivity endpoints for MQTT, HTTP and UDP protocols. The Zerynth libraries for OKdo IoT Cloud abstract away both the protocols and the data format, making the OKdo experience even more quickly. Contents: OKdo IoT Library The Device class Examples Mqtt Http","title":"Zerynth OKdo"},{"location":"reference/libs/okdo/iot/docs/#zerynth-okdo","text":"OKdo IoT Cloud is an integrated maker platform for connecting devices, capturing an visualizing data easily. And for free! You can signup for an account at the following link . OKdo IoT Cloud provides connectivity endpoints for MQTT, HTTP and UDP protocols. The Zerynth libraries for OKdo IoT Cloud abstract away both the protocols and the data format, making the OKdo experience even more quickly. Contents: OKdo IoT Library The Device class Examples Mqtt Http","title":"Zerynth OKdo"},{"location":"reference/libs/okdo/iot/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.okdo.iot. MQTT \u00b6 A simple example connecting a device to the OKDO IoT cloud using the MQTT protocol. main.py ################################################################################ # MQTT at OKDO Cloud IoT # # Created at 2019-05-06 08:40:34.990336 # ################################################################################ import streams from wireless import wifi # choose a wifi chip (esp32) from espressif.esp32net import esp32wifi as wifi_driver # let's import the OKDO cloud modules; first the IoT module... from okdo.iot import iot # ...then the mqtt client from okdo.iot import mqtt_client # Let's define a global variable to store the publishing rate (in ms) rate = 3000 # Customize the following variables ssid = \"SSID\" # this is the SSID of the WiFi network wifipwd = \"\" # this is the Password for WiFi device_id = \"device_id\" # this is the device identifier. Can be obtained from the OKDO cloud dashboard device_token = \"device_token\" # this is the device token. Can be obtained from the OKDO cloud dashboard # Remember to add a device to your okdo cloud and define some assets: # - a \"rate\" actuator, with type integer # - a \"random\" sensor of type integer def rate_cb ( asset , value , previous_value ): global rate value = int ( value ) if value < 1000 : value = 1000 rate = value print ( \"Rate changed to\" , rate , \"ms\" ) streams . serial () try : # Let's initialize the WiFi wifi_driver . auto_init () for _ in range ( 0 , 5 ): # put your SSID and password here try : wifi . link ( ssid , wifi . WIFI_WPA2 , wifipwd ) break except : print ( \"Trying to connect...\" ) sleep ( 2000 ) else : print ( \"oops, can't attach to wifi!\" ) raise IOError print ( \"Connecting to OKDO IoT Cloud...\" ) # let's create a device passing the id, the token and the type of client device = iot . Device ( device_id , device_token , mqtt_client . MqttClient ) device . connect () print ( \"Device is connected\" ) # define the callbacks to call when an asset command is received device . watch_command ( \"rate\" , rate_cb ) # start the device device . run () print ( \"Device is up and running\" ) while True : # sleep as indicated by rate sleep ( rate ) x = random ( 0 , 100 ) msg = device . publish_asset ( \"random\" , x ) print ( \"Published asset\" , msg ) # alternatively, you can publish more than one asset state at a time # by providing them as a dictionary to the following function (uncomment to test) # msg = device.publish_state({\"random\":x}) # print(\"Published state\",msg) except Exception as e : print ( e ) HTTP \u00b6 A simple example connecting a device to the OKDO IoT cloud using the HTTP protocol. main.py ################################################################################ # HTTP at OKDO Cloud IoT # # Created at 2019-05-06 08:40:34.990336 # ################################################################################ import streams from wireless import wifi # choose a wifi chip (esp32) from espressif.esp32net import esp32wifi as wifi_driver # let's import the OKDO cloud modules; first the IoT module... from okdo.iot import iot # ...then the http client from okdo.iot import http_client # Let's define a global variable to store the publishing rate (in ms) rate = 3000 # Customize the following variables ssid = \"SSID\" # this is the SSID of the WiFi network wifipwd = \"\" # this is the Password for WiFi device_id = \"device_id\" # this is the device identifier. Can be obtained from the OKDO cloud dashboard device_token = \"device_token\" # this is the device token. Can be obtained from the OKDO cloud dashboard # Remember to add a device to your okdo cloud and define some assets: # - a \"random\" sensor of type integer streams . serial () try : # Let's initialize the WiFi wifi_driver . auto_init () for _ in range ( 0 , 5 ): # put your SSID and password here try : wifi . link ( ssid , wifi . WIFI_WPA2 , wifipwd ) break except : print ( \"Trying to connect...\" ) sleep ( 2000 ) else : print ( \"oops, can't attach to wifi!\" ) raise IOError print ( \"Connecting to OKDO IoT Cloud...\" ) # let's create a device passing the id, the token and the type of client device = iot . Device ( device_id , device_token , http_client . HttpClient ) device . connect () print ( \"Device is connected\" ) # start the device device . run () print ( \"Device is up and running\" ) while True : # sleep as indicated by rate sleep ( rate ) x = random ( 0 , 100 ) msg = device . publish_asset ( \"random\" , x ) print ( \"Published asset\" , msg ) # alternatively, you can publish more than one asset state at a time # by providing them as a dictionary to the following function (uncomment to test) # msg = device.publish_state({\"random\":x}) # print(\"Published state\",msg) except Exception as e : print ( e )","title":"Examples"},{"location":"reference/libs/okdo/iot/docs/examples/#examples","text":"The following are a list of examples for lib.okdo.iot.","title":"Examples"},{"location":"reference/libs/okdo/iot/docs/examples/#mqtt","text":"A simple example connecting a device to the OKDO IoT cloud using the MQTT protocol. main.py ################################################################################ # MQTT at OKDO Cloud IoT # # Created at 2019-05-06 08:40:34.990336 # ################################################################################ import streams from wireless import wifi # choose a wifi chip (esp32) from espressif.esp32net import esp32wifi as wifi_driver # let's import the OKDO cloud modules; first the IoT module... from okdo.iot import iot # ...then the mqtt client from okdo.iot import mqtt_client # Let's define a global variable to store the publishing rate (in ms) rate = 3000 # Customize the following variables ssid = \"SSID\" # this is the SSID of the WiFi network wifipwd = \"\" # this is the Password for WiFi device_id = \"device_id\" # this is the device identifier. Can be obtained from the OKDO cloud dashboard device_token = \"device_token\" # this is the device token. Can be obtained from the OKDO cloud dashboard # Remember to add a device to your okdo cloud and define some assets: # - a \"rate\" actuator, with type integer # - a \"random\" sensor of type integer def rate_cb ( asset , value , previous_value ): global rate value = int ( value ) if value < 1000 : value = 1000 rate = value print ( \"Rate changed to\" , rate , \"ms\" ) streams . serial () try : # Let's initialize the WiFi wifi_driver . auto_init () for _ in range ( 0 , 5 ): # put your SSID and password here try : wifi . link ( ssid , wifi . WIFI_WPA2 , wifipwd ) break except : print ( \"Trying to connect...\" ) sleep ( 2000 ) else : print ( \"oops, can't attach to wifi!\" ) raise IOError print ( \"Connecting to OKDO IoT Cloud...\" ) # let's create a device passing the id, the token and the type of client device = iot . Device ( device_id , device_token , mqtt_client . MqttClient ) device . connect () print ( \"Device is connected\" ) # define the callbacks to call when an asset command is received device . watch_command ( \"rate\" , rate_cb ) # start the device device . run () print ( \"Device is up and running\" ) while True : # sleep as indicated by rate sleep ( rate ) x = random ( 0 , 100 ) msg = device . publish_asset ( \"random\" , x ) print ( \"Published asset\" , msg ) # alternatively, you can publish more than one asset state at a time # by providing them as a dictionary to the following function (uncomment to test) # msg = device.publish_state({\"random\":x}) # print(\"Published state\",msg) except Exception as e : print ( e )","title":"MQTT"},{"location":"reference/libs/okdo/iot/docs/examples/#http","text":"A simple example connecting a device to the OKDO IoT cloud using the HTTP protocol. main.py ################################################################################ # HTTP at OKDO Cloud IoT # # Created at 2019-05-06 08:40:34.990336 # ################################################################################ import streams from wireless import wifi # choose a wifi chip (esp32) from espressif.esp32net import esp32wifi as wifi_driver # let's import the OKDO cloud modules; first the IoT module... from okdo.iot import iot # ...then the http client from okdo.iot import http_client # Let's define a global variable to store the publishing rate (in ms) rate = 3000 # Customize the following variables ssid = \"SSID\" # this is the SSID of the WiFi network wifipwd = \"\" # this is the Password for WiFi device_id = \"device_id\" # this is the device identifier. Can be obtained from the OKDO cloud dashboard device_token = \"device_token\" # this is the device token. Can be obtained from the OKDO cloud dashboard # Remember to add a device to your okdo cloud and define some assets: # - a \"random\" sensor of type integer streams . serial () try : # Let's initialize the WiFi wifi_driver . auto_init () for _ in range ( 0 , 5 ): # put your SSID and password here try : wifi . link ( ssid , wifi . WIFI_WPA2 , wifipwd ) break except : print ( \"Trying to connect...\" ) sleep ( 2000 ) else : print ( \"oops, can't attach to wifi!\" ) raise IOError print ( \"Connecting to OKDO IoT Cloud...\" ) # let's create a device passing the id, the token and the type of client device = iot . Device ( device_id , device_token , http_client . HttpClient ) device . connect () print ( \"Device is connected\" ) # start the device device . run () print ( \"Device is up and running\" ) while True : # sleep as indicated by rate sleep ( rate ) x = random ( 0 , 100 ) msg = device . publish_asset ( \"random\" , x ) print ( \"Published asset\" , msg ) # alternatively, you can publish more than one asset state at a time # by providing them as a dictionary to the following function (uncomment to test) # msg = device.publish_state({\"random\":x}) # print(\"Published state\",msg) except Exception as e : print ( e )","title":"HTTP"},{"location":"reference/libs/okdo/iot/docs/http_client/","text":"","title":"Http client"},{"location":"reference/libs/okdo/iot/docs/iot/","text":"OKdo IoT Library \u00b6 The Zerynth OKdo IoT Library can be used to ease the connection to the OKdo IoT Cloud . It makes your device act as an OKdo IoT Device which can be created and provisioned on the OKdo IoT Cloud dashboard. The device always send and receive data in the JSON format. Check out the examples for a jump start. The Device class \u00b6 class Device \u00b6 class Device ( device_id , device_token , client ) Create a Device instance representing an OKdo device. The device is provisioned by the device_id and device_token , obtained from the OKdo dashboard upon the creation of a new device. the client parameter is a class that provides the implementation of the low level details for the connection. It can be one of MqttClient in the mqtt_client module, or HttpClient in the http_client module. Device.connect \u00b6 connect () Setup a connection to the OKdo Cloud. It can raise an exception in case of error. Device.run \u00b6 run () Starts the device by executing the underlying client. It can start a new thread depending on the type of client (Mqtt vs Http) Device.publish_asset \u00b6 publish_asset ( asset_name , value ) Modify a device asset state. After a successful execution, the new state of the device asset asset_name will be set to value . Return the message sent to the OKdo Cloud, or None if the message cannot be sent. Device.publish_state \u00b6 publish_state ( state ) Modify a device state. After a successful execution, the new state of the device will be set to the values contained in state . state is a dict where each key is the name of an asset and each value the desired state. Return the message sent to the OKdo Cloud, or None if the message cannot be sent. Device.watch_command \u00b6 watch_command ( asset_name , callback ) Start listening for asset command on the device asset identified by asset_name . When a new asset command arrives, the function callback is executed receiving as arguments the asset name, the new value and the previous value (or None if it is the first update). Incoming values are checked against the last received timestamp in order to avoid triggering the callback for Modify a device state. After a successful execution, the new state of the device will be set to the values contained in state . state is a dict where each key is the name of an asset and each value the desired state. Return the message sent to the OKdo Cloud, or None if the message cannot be sent.","title":"OKdo IoT Library"},{"location":"reference/libs/okdo/iot/docs/iot/#okdo-iot-library","text":"The Zerynth OKdo IoT Library can be used to ease the connection to the OKdo IoT Cloud . It makes your device act as an OKdo IoT Device which can be created and provisioned on the OKdo IoT Cloud dashboard. The device always send and receive data in the JSON format. Check out the examples for a jump start.","title":"OKdo IoT Library"},{"location":"reference/libs/okdo/iot/docs/iot/#the-device-class","text":"","title":"The Device class"},{"location":"reference/libs/okdo/iot/docs/iot/#class-device","text":"class Device ( device_id , device_token , client ) Create a Device instance representing an OKdo device. The device is provisioned by the device_id and device_token , obtained from the OKdo dashboard upon the creation of a new device. the client parameter is a class that provides the implementation of the low level details for the connection. It can be one of MqttClient in the mqtt_client module, or HttpClient in the http_client module.","title":"class Device"},{"location":"reference/libs/okdo/iot/docs/iot/#deviceconnect","text":"connect () Setup a connection to the OKdo Cloud. It can raise an exception in case of error.","title":"Device.connect"},{"location":"reference/libs/okdo/iot/docs/iot/#devicerun","text":"run () Starts the device by executing the underlying client. It can start a new thread depending on the type of client (Mqtt vs Http)","title":"Device.run"},{"location":"reference/libs/okdo/iot/docs/iot/#devicepublish_asset","text":"publish_asset ( asset_name , value ) Modify a device asset state. After a successful execution, the new state of the device asset asset_name will be set to value . Return the message sent to the OKdo Cloud, or None if the message cannot be sent.","title":"Device.publish_asset"},{"location":"reference/libs/okdo/iot/docs/iot/#devicepublish_state","text":"publish_state ( state ) Modify a device state. After a successful execution, the new state of the device will be set to the values contained in state . state is a dict where each key is the name of an asset and each value the desired state. Return the message sent to the OKdo Cloud, or None if the message cannot be sent.","title":"Device.publish_state"},{"location":"reference/libs/okdo/iot/docs/iot/#devicewatch_command","text":"watch_command ( asset_name , callback ) Start listening for asset command on the device asset identified by asset_name . When a new asset command arrives, the function callback is executed receiving as arguments the asset name, the new value and the previous value (or None if it is the first update). Incoming values are checked against the last received timestamp in order to avoid triggering the callback for Modify a device state. After a successful execution, the new state of the device will be set to the values contained in state . state is a dict where each key is the name of an asset and each value the desired state. Return the message sent to the OKdo Cloud, or None if the message cannot be sent.","title":"Device.watch_command"},{"location":"reference/libs/okdo/iot/docs/mqtt_client/","text":"","title":"Mqtt client"},{"location":"reference/libs/onsemi/ncv7240/docs/","text":"NCV7240 \u00b6 The NCV7240 is an automotive eight channel low side driver providing drive capability up to 600 mA per channel. Output control is via a SPI port and offers reporting of faults for open load (or short to ground), over load, and over temperature conditions. Additionally, parallel control of the outputs is addressable (in pairs) via the INx pins. A dedicated limp home mode pin (LHI) enables OUT1 thru OUT4 while disabling OUT5 thru OUT8. Each output driver is protected for over load current and includes an output clamp for inductive loads. The NCV7240 is available in a SSOP24 fused lead package. Technical Details \u00b6 8 Channels; 600mA Low Side Drivers; 16 bit SPI control; Parallel Input Pins; Low Quiescent Current; 3.3V and 5V compatible Digital Input Supply Range; Fault Reporting of Open Load, Over Load, and Over Temperature; Power On Reset; AEC-Q100 Qualified; Below, Zerynth driver documentation for ON Semiconductor NCV7240 chip. Contents: NCV7240 Technical Details NCV7240 Module","title":"NCV7240"},{"location":"reference/libs/onsemi/ncv7240/docs/#ncv7240","text":"The NCV7240 is an automotive eight channel low side driver providing drive capability up to 600 mA per channel. Output control is via a SPI port and offers reporting of faults for open load (or short to ground), over load, and over temperature conditions. Additionally, parallel control of the outputs is addressable (in pairs) via the INx pins. A dedicated limp home mode pin (LHI) enables OUT1 thru OUT4 while disabling OUT5 thru OUT8. Each output driver is protected for over load current and includes an output clamp for inductive loads. The NCV7240 is available in a SSOP24 fused lead package.","title":"NCV7240"},{"location":"reference/libs/onsemi/ncv7240/docs/#technical-details","text":"8 Channels; 600mA Low Side Drivers; 16 bit SPI control; Parallel Input Pins; Low Quiescent Current; 3.3V and 5V compatible Digital Input Supply Range; Fault Reporting of Open Load, Over Load, and Over Temperature; Power On Reset; AEC-Q100 Qualified; Below, Zerynth driver documentation for ON Semiconductor NCV7240 chip. Contents: NCV7240 Technical Details NCV7240 Module","title":"Technical Details"},{"location":"reference/libs/onsemi/ncv7240/docs/ncv7240/","text":"NCV7240 Module \u00b6 This module contains the Zerynth driver for the OnSemi NCV7240 automotive eight channel low-side/relay driver, that can be controlled with a standard SPI interface or parallel input pins. Each output driver is protected for over load current and includes an output clamp for inductive loads. Open load or shorts to ground can be detected when the driver is in the off state. class NCV7240 \u00b6 class NCV7240 () The NCV7240 class implements several methods to access the I/O expander over an SPI bus and easily control its features. Each one of the 8 channels can be configured in one of 4 modes: Standby (default) - the channel is disabled On - the output driver is active (low), with over-load fault detection Off - the output driver is inactive, with open-load fault detection Input - the output driver on/off state is controlled by input pins (PWM capable) Note Faults are latched and must be cleared by switching the channel to Standby mode to attempt recovery. Note Off mode and open-load detection can be used as way to read channels as digital inputs. NCV7240. init \u00b6 __init__ ( spidrv , cs , clk = 500000 ) Creates an instance of NCV7240 class, using the specified SPI settings. Arguments: spidrv \u2013 the SPI driver to use (SPI0, \u2026) cs \u2013 Chip select pin to access the NCV7240 chip clk \u2013 Clock speed, default 500 kHz Note SPI mode is fixed by the slave chip protocol (CPOL=0,CPHA=1) NCV7240.setChannel \u00b6 setChannel ( channel , mode ) Set one channel to the specified mode. Arguments: channel \u2013 Index of the channel (0-7) mode \u2013 One of the four possible modes: CH_STANDBY , CH_ON , CH_OFF , CH_INPUT NCV7240.setAllChannels \u00b6 setAllChannels ( mode ) Set all channels to the specified mode. Arguments: mode \u2013 One of the four possible modes: CH_STANDBY , CH_ON , CH_OFF , CH_INPUT Note If mode is a list or a tuple, each element specifies the corresponding channel mode. NCV7240.getChannel \u00b6 getChannel ( channel ) Get the status of the specified channel. Arguments: channel \u2013 Index of the channel (0-7). Returns: One of the two possible states: CH_OPEN , CH_FAULT Note Put the channel in Standby mode to clear status. NCV7240.getAllChannels \u00b6 getAllChannels () Get the status of all channels. Returns: A tuple where each element specifies the corresponding channel state: CH_OPEN or CH_FAULT Note Put the channel in Standby mode to clear status. NCV7240.channelInputMode \u00b6 channelInputMode ( channel ) Set the specified channel to input mode (output driver state is controlled directly by the corresponding input pin on the NCV7240 chip). Arguments: channel \u2013 Index of the channel (0-7) NCV7240.channelStandby \u00b6 channelStandby ( channel ) Set the specified channel to standby mode (output driver and fault detection are disabled, fault status cleared). Arguments: channel \u2013 Index of the channel (0-7) NCV7240.channelOn \u00b6 channelOn ( channel ) Switch the specified channel output driver on (polarity active-low, over-load/over-temperature fault detection is active). Arguments: channel \u2013 Index of the channel (0-7) NCV7240.channelOff \u00b6 channelOff ( channel ) Switch the specified channel output driver off (open-load fault detection current is active). Arguments: channel \u2013 Index of the channel (0-7) NCV7240.isChannelOpen \u00b6 isChannelOpen ( channel ) Returns whether the channel status indicates an open-load fault (only meaningful when the channel is off). Arguments: channel \u2013 Index of the channel (0-7) Note Put the channel in Standby mode to clear fault status. NCV7240.isChannelFault \u00b6 isChannelFault ( channel ) Returns whether the channel status indicates an over-current/over-temperature fault (only meaningful when the channel is on). Arguments: channel \u2013 Index of the channel (0-7) Note Put the channel in Standby mode to clear fault status.","title":"NCV7240 Module"},{"location":"reference/libs/onsemi/ncv7240/docs/ncv7240/#ncv7240-module","text":"This module contains the Zerynth driver for the OnSemi NCV7240 automotive eight channel low-side/relay driver, that can be controlled with a standard SPI interface or parallel input pins. Each output driver is protected for over load current and includes an output clamp for inductive loads. Open load or shorts to ground can be detected when the driver is in the off state.","title":"NCV7240 Module"},{"location":"reference/libs/onsemi/ncv7240/docs/ncv7240/#class-ncv7240","text":"class NCV7240 () The NCV7240 class implements several methods to access the I/O expander over an SPI bus and easily control its features. Each one of the 8 channels can be configured in one of 4 modes: Standby (default) - the channel is disabled On - the output driver is active (low), with over-load fault detection Off - the output driver is inactive, with open-load fault detection Input - the output driver on/off state is controlled by input pins (PWM capable) Note Faults are latched and must be cleared by switching the channel to Standby mode to attempt recovery. Note Off mode and open-load detection can be used as way to read channels as digital inputs.","title":"class NCV7240"},{"location":"reference/libs/onsemi/ncv7240/docs/ncv7240/#ncv7240init","text":"__init__ ( spidrv , cs , clk = 500000 ) Creates an instance of NCV7240 class, using the specified SPI settings. Arguments: spidrv \u2013 the SPI driver to use (SPI0, \u2026) cs \u2013 Chip select pin to access the NCV7240 chip clk \u2013 Clock speed, default 500 kHz Note SPI mode is fixed by the slave chip protocol (CPOL=0,CPHA=1)","title":"NCV7240.init"},{"location":"reference/libs/onsemi/ncv7240/docs/ncv7240/#ncv7240setchannel","text":"setChannel ( channel , mode ) Set one channel to the specified mode. Arguments: channel \u2013 Index of the channel (0-7) mode \u2013 One of the four possible modes: CH_STANDBY , CH_ON , CH_OFF , CH_INPUT","title":"NCV7240.setChannel"},{"location":"reference/libs/onsemi/ncv7240/docs/ncv7240/#ncv7240setallchannels","text":"setAllChannels ( mode ) Set all channels to the specified mode. Arguments: mode \u2013 One of the four possible modes: CH_STANDBY , CH_ON , CH_OFF , CH_INPUT Note If mode is a list or a tuple, each element specifies the corresponding channel mode.","title":"NCV7240.setAllChannels"},{"location":"reference/libs/onsemi/ncv7240/docs/ncv7240/#ncv7240getchannel","text":"getChannel ( channel ) Get the status of the specified channel. Arguments: channel \u2013 Index of the channel (0-7). Returns: One of the two possible states: CH_OPEN , CH_FAULT Note Put the channel in Standby mode to clear status.","title":"NCV7240.getChannel"},{"location":"reference/libs/onsemi/ncv7240/docs/ncv7240/#ncv7240getallchannels","text":"getAllChannels () Get the status of all channels. Returns: A tuple where each element specifies the corresponding channel state: CH_OPEN or CH_FAULT Note Put the channel in Standby mode to clear status.","title":"NCV7240.getAllChannels"},{"location":"reference/libs/onsemi/ncv7240/docs/ncv7240/#ncv7240channelinputmode","text":"channelInputMode ( channel ) Set the specified channel to input mode (output driver state is controlled directly by the corresponding input pin on the NCV7240 chip). Arguments: channel \u2013 Index of the channel (0-7)","title":"NCV7240.channelInputMode"},{"location":"reference/libs/onsemi/ncv7240/docs/ncv7240/#ncv7240channelstandby","text":"channelStandby ( channel ) Set the specified channel to standby mode (output driver and fault detection are disabled, fault status cleared). Arguments: channel \u2013 Index of the channel (0-7)","title":"NCV7240.channelStandby"},{"location":"reference/libs/onsemi/ncv7240/docs/ncv7240/#ncv7240channelon","text":"channelOn ( channel ) Switch the specified channel output driver on (polarity active-low, over-load/over-temperature fault detection is active). Arguments: channel \u2013 Index of the channel (0-7)","title":"NCV7240.channelOn"},{"location":"reference/libs/onsemi/ncv7240/docs/ncv7240/#ncv7240channeloff","text":"channelOff ( channel ) Switch the specified channel output driver off (open-load fault detection current is active). Arguments: channel \u2013 Index of the channel (0-7)","title":"NCV7240.channelOff"},{"location":"reference/libs/onsemi/ncv7240/docs/ncv7240/#ncv7240ischannelopen","text":"isChannelOpen ( channel ) Returns whether the channel status indicates an open-load fault (only meaningful when the channel is off). Arguments: channel \u2013 Index of the channel (0-7) Note Put the channel in Standby mode to clear fault status.","title":"NCV7240.isChannelOpen"},{"location":"reference/libs/onsemi/ncv7240/docs/ncv7240/#ncv7240ischannelfault","text":"isChannelFault ( channel ) Returns whether the channel status indicates an over-current/over-temperature fault (only meaningful when the channel is on). Arguments: channel \u2013 Index of the channel (0-7) Note Put the channel in Standby mode to clear fault status.","title":"NCV7240.isChannelFault"},{"location":"reference/libs/patlite/la6/docs/","text":"PATLITE LA6-5DTNWB-PoE \u00b6 Programmable 60 mm multi-color LED signal tower, equipped with Power over Ethernet (PoE) support. Ethernet connection with PoE (Power over Ethernet) support, which allows you to install only one cable. It supports Modbus TCP / IP and HTTP protocols to work easily with the indication of the existing infrastructure. It includes 21 programmable LED colors and 11 selectable alarms, for unambiguous indications. Technical Details \u00b6 Supply Voltage (Vcc): 24V DC or PoE 48V Operation Temperature (Top): from -10 \u00b0C to 50 \u00b0C Active Current: 420 mA * 1 / 70 mA * 2 (a 26,4 V CC) 10 mA (PoE: a 48 V CC) * 1 Degree of protection: IP65 Protocols: MODBUS TCP and HTTP For more details see product datasheet https://www.patlite.it/product/index.php?Command=Index&method=Download&id=651&idx=5 . Here below, the Zerynth driver for the Patlite la6 and some examples to better understand how to use it. Contents: PATLITE LA6-5DTNWB-PoE Technical Details PATLITE LA6 Library Examples","title":"PATLITE LA6-5DTNWB-PoE"},{"location":"reference/libs/patlite/la6/docs/#patlite-la6-5dtnwb-poe","text":"Programmable 60 mm multi-color LED signal tower, equipped with Power over Ethernet (PoE) support. Ethernet connection with PoE (Power over Ethernet) support, which allows you to install only one cable. It supports Modbus TCP / IP and HTTP protocols to work easily with the indication of the existing infrastructure. It includes 21 programmable LED colors and 11 selectable alarms, for unambiguous indications.","title":"PATLITE LA6-5DTNWB-PoE"},{"location":"reference/libs/patlite/la6/docs/#technical-details","text":"Supply Voltage (Vcc): 24V DC or PoE 48V Operation Temperature (Top): from -10 \u00b0C to 50 \u00b0C Active Current: 420 mA * 1 / 70 mA * 2 (a 26,4 V CC) 10 mA (PoE: a 48 V CC) * 1 Degree of protection: IP65 Protocols: MODBUS TCP and HTTP For more details see product datasheet https://www.patlite.it/product/index.php?Command=Index&method=Download&id=651&idx=5 . Here below, the Zerynth driver for the Patlite la6 and some examples to better understand how to use it. Contents: PATLITE LA6-5DTNWB-PoE Technical Details PATLITE LA6 Library Examples","title":"Technical Details"},{"location":"reference/libs/patlite/la6/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.patlite.la6. main.py #--------------------------------# # Author: Alex Moriconi | # Date: 10-06-2019 | # Example Library Patlite La6 | # Protocol: HTTP Basic | #--------------------------------# #----- necessary streams import import streams # the ethernet module needs a networking driver to be loaded # in order to control the board hardware. # FOR THIS EXAMPLE TO WORK, A NETWORK DRIVER MUST BE SELECTED BELOW # uncomment the following line to use the ESP32 driver # from espressif.esp32net import esp32eth as ethernet # uncomment the following line to use INFINEON xmc4eth driver # from infineon.xmc4eth import xmc4eth as ethernet from patlite.la6 import la6 #----- Network initialization ethernet . init () ethernet . set_link_info ( \"192.168.10.2\" , \"255.255.255.0\" , \"0.0.0.0\" , \"0.0.0.0\" ) ethernet . link () #----- Serial PC initialization streams . serial () #----- initialization try : lamp = la6 . la6HTTP () except Exception as e : print ( e ) while True : #----- Animation Example lamp . set_LED_colors ([ \"green\" , \"green\" , \"green\" , \"green\" , \"green\" ]) sleep ( 2000 ) lamp . set_LED_colors ([ \"white\" , \"white\" , \"white\" , \"white\" , \"white\" ]) sleep ( 2000 ) lamp . set_LED_colors ([ \"red\" , \"red\" , \"red\" , \"red\" , \"red\" ]) sleep ( 2000 ) main.py #--------------------------------# # Author: Alex Moriconi | # Date: 10-06-2019 | # Example Library Patlite La6 | # Protocol: MODBUS Basic | #--------------------------------# #----- necessary streams import import streams # the ethernet module needs a networking driver to be loaded # in order to control the board hardware. # FOR THIS EXAMPLE TO WORK, A NETWORK DRIVER MUST BE SELECTED BELOW # uncomment the following line to use the ESP32 driver # from espressif.esp32net import esp32eth as ethernet # uncomment the following line to use INFINEON xmc4eth driver # from infineon.xmc4eth import xmc4eth as ethernet from patlite.la6 import la6 #----- Network initialization ethernet . init () ethernet . set_link_info ( \"192.168.10.2\" , \"255.255.255.0\" , \"0.0.0.0\" , \"0.0.0.0\" ) ethernet . link () #----- Serial PC initialization streams . serial () #----- initialization try : lamp = la6 . la6MODBUS () except Exception as e : print ( e ) while True : #----- Animation Example lamp . set_LED_colors ([ \"green\" , \"green\" , \"green\" , \"green\" , \"green\" ]) sleep ( 2000 ) lamp . set_LED_colors ([ \"white\" , \"white\" , \"white\" , \"white\" , \"white\" ]) sleep ( 2000 ) lamp . set_LED_colors ([ \"red\" , \"red\" , \"red\" , \"red\" , \"red\" ]) sleep ( 2000 ) main.py #--------------------------------# # Author: Alex Moriconi | # Date: 10-06-2019 | # Esempio Library Patlite La6 | # Protocol: HTTP | #--------------------------------# #----- necessary streams import import streams # the ethernet module needs a networking driver to be loaded # in order to control the board hardware. # FOR THIS EXAMPLE TO WORK, A NETWORK DRIVER MUST BE SELECTED BELOW # uncomment the following line to use the ESP32 driver # from espressif.esp32net import esp32eth as ethernet # uncomment the following line to use INFINEON xmc4eth driver # from infineon.xmc4eth import xmc4eth as ethernet from patlite.la6 import la6 #----- Network initialization ethernet . init () ethernet . set_link_info ( \"192.168.10.2\" , \"255.255.255.0\" , \"0.0.0.0\" , \"0.0.0.0\" ) ethernet . link () #----- Serial PC initialization streams . serial () #----- initialization try : lamp = la6 . la6HTTP () except Exception as e : print ( e ) print ( \"----- Start Animation\" ) while True : #----- Animation Example print ( \"--- Restart Animation\" ) lamp . set_LED_colors ([ \"red\" , \"off\" , \"off\" , \"off\" , \"off\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"red\" , \"off\" , \"off\" , \"off\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"off\" , \"red\" , \"off\" , \"off\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"off\" , \"off\" , \"red\" , \"off\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"off\" , \"off\" , \"off\" , \"red\" ]) sleep ( 300 ) lamp . set_LED_colors ([ \"red\" , \"off\" , \"off\" , \"off\" , \"red\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"red\" , \"off\" , \"off\" , \"red\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"off\" , \"red\" , \"off\" , \"red\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"off\" , \"off\" , \"red\" , \"red\" ]) sleep ( 300 ) lamp . set_LED_colors ([ \"white\" , \"off\" , \"off\" , \"red\" , \"red\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"white\" , \"off\" , \"red\" , \"red\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"off\" , \"white\" , \"red\" , \"red\" ]) sleep ( 300 ) lamp . set_LED_colors ([ \"green\" , \"off\" , \"white\" , \"red\" , \"red\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"green\" , \"white\" , \"red\" , \"red\" ]) sleep ( 300 ) lamp . set_LED_colors ([ \"green\" , \"green\" , \"white\" , \"red\" , \"red\" ]) lamp . set_buzzer ( \"on\" ) #Start Buzzer sleep ( 50 ) lamp . set_buzzer ( \"off\" ) #Stop Buzzer sleep ( 10 ) lamp . set_flash ( \"on\" ) #Start Flash LED sleep ( 5000 ) lamp . clear () sleep ( 10 ) lamp . set_smartmode ( 2 ) sleep ( 9000 ) lamp . clear () sleep ( 1000 ) print ( \"--- Finish Animation\" ) main.py #--------------------------------# # Author: Alex Moriconi | # Date: 10-06-2019 | # Esempio Library Patlite La6 | # Protocol: MODBUS | #--------------------------------# #----- necessary streams import import streams # the ethernet module needs a networking driver to be loaded # in order to control the board hardware. # FOR THIS EXAMPLE TO WORK, A NETWORK DRIVER MUST BE SELECTED BELOW # uncomment the following line to use the ESP32 driver # from espressif.esp32net import esp32eth as ethernet # uncomment the following line to use INFINEON xmc4eth driver # from infineon.xmc4eth import xmc4eth as ethernet from patlite.la6 import la6 #----- Network initialization ethernet . init () ethernet . set_link_info ( \"192.168.10.2\" , \"255.255.255.0\" , \"0.0.0.0\" , \"0.0.0.0\" ) ethernet . link () #----- Serial PC initialization streams . serial () #----- initialization try : lamp = la6 . la6MODBUS () except Exception as e : print ( e ) print ( \"----- Start Animation\" ) while True : #----- Animation Example print ( \"--- Restart Animation\" ) lamp . set_LED_colors ([ \"red\" , \"off\" , \"off\" , \"off\" , \"off\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"red\" , \"off\" , \"off\" , \"off\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"off\" , \"red\" , \"off\" , \"off\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"off\" , \"off\" , \"red\" , \"off\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"off\" , \"off\" , \"off\" , \"red\" ]) sleep ( 300 ) lamp . set_LED_colors ([ \"red\" , \"off\" , \"off\" , \"off\" , \"red\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"red\" , \"off\" , \"off\" , \"red\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"off\" , \"red\" , \"off\" , \"red\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"off\" , \"off\" , \"red\" , \"red\" ]) sleep ( 300 ) lamp . set_LED_colors ([ \"white\" , \"off\" , \"off\" , \"red\" , \"red\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"white\" , \"off\" , \"red\" , \"red\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"off\" , \"white\" , \"red\" , \"red\" ]) sleep ( 300 ) lamp . set_LED_colors ([ \"green\" , \"off\" , \"white\" , \"red\" , \"red\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"green\" , \"white\" , \"red\" , \"red\" ]) sleep ( 300 ) lamp . set_LED_colors ([ \"green\" , \"green\" , \"white\" , \"red\" , \"red\" ]) lamp . set_buzzer ( \"on\" ) #Start Buzzer sleep ( 50 ) lamp . set_buzzer ( \"off\" ) #Stop Buzzer sleep ( 10 ) lamp . set_flash ( \"on\" ) #Start Flash LED sleep ( 5000 ) lamp . clear () sleep ( 10 ) lamp . set_smartmode ( 2 ) sleep ( 9000 ) lamp . clear () sleep ( 1000 ) print ( \"--- Finish Animation\" )","title":"Examples"},{"location":"reference/libs/patlite/la6/docs/examples/#examples","text":"The following are a list of examples for lib.patlite.la6. main.py #--------------------------------# # Author: Alex Moriconi | # Date: 10-06-2019 | # Example Library Patlite La6 | # Protocol: HTTP Basic | #--------------------------------# #----- necessary streams import import streams # the ethernet module needs a networking driver to be loaded # in order to control the board hardware. # FOR THIS EXAMPLE TO WORK, A NETWORK DRIVER MUST BE SELECTED BELOW # uncomment the following line to use the ESP32 driver # from espressif.esp32net import esp32eth as ethernet # uncomment the following line to use INFINEON xmc4eth driver # from infineon.xmc4eth import xmc4eth as ethernet from patlite.la6 import la6 #----- Network initialization ethernet . init () ethernet . set_link_info ( \"192.168.10.2\" , \"255.255.255.0\" , \"0.0.0.0\" , \"0.0.0.0\" ) ethernet . link () #----- Serial PC initialization streams . serial () #----- initialization try : lamp = la6 . la6HTTP () except Exception as e : print ( e ) while True : #----- Animation Example lamp . set_LED_colors ([ \"green\" , \"green\" , \"green\" , \"green\" , \"green\" ]) sleep ( 2000 ) lamp . set_LED_colors ([ \"white\" , \"white\" , \"white\" , \"white\" , \"white\" ]) sleep ( 2000 ) lamp . set_LED_colors ([ \"red\" , \"red\" , \"red\" , \"red\" , \"red\" ]) sleep ( 2000 ) main.py #--------------------------------# # Author: Alex Moriconi | # Date: 10-06-2019 | # Example Library Patlite La6 | # Protocol: MODBUS Basic | #--------------------------------# #----- necessary streams import import streams # the ethernet module needs a networking driver to be loaded # in order to control the board hardware. # FOR THIS EXAMPLE TO WORK, A NETWORK DRIVER MUST BE SELECTED BELOW # uncomment the following line to use the ESP32 driver # from espressif.esp32net import esp32eth as ethernet # uncomment the following line to use INFINEON xmc4eth driver # from infineon.xmc4eth import xmc4eth as ethernet from patlite.la6 import la6 #----- Network initialization ethernet . init () ethernet . set_link_info ( \"192.168.10.2\" , \"255.255.255.0\" , \"0.0.0.0\" , \"0.0.0.0\" ) ethernet . link () #----- Serial PC initialization streams . serial () #----- initialization try : lamp = la6 . la6MODBUS () except Exception as e : print ( e ) while True : #----- Animation Example lamp . set_LED_colors ([ \"green\" , \"green\" , \"green\" , \"green\" , \"green\" ]) sleep ( 2000 ) lamp . set_LED_colors ([ \"white\" , \"white\" , \"white\" , \"white\" , \"white\" ]) sleep ( 2000 ) lamp . set_LED_colors ([ \"red\" , \"red\" , \"red\" , \"red\" , \"red\" ]) sleep ( 2000 ) main.py #--------------------------------# # Author: Alex Moriconi | # Date: 10-06-2019 | # Esempio Library Patlite La6 | # Protocol: HTTP | #--------------------------------# #----- necessary streams import import streams # the ethernet module needs a networking driver to be loaded # in order to control the board hardware. # FOR THIS EXAMPLE TO WORK, A NETWORK DRIVER MUST BE SELECTED BELOW # uncomment the following line to use the ESP32 driver # from espressif.esp32net import esp32eth as ethernet # uncomment the following line to use INFINEON xmc4eth driver # from infineon.xmc4eth import xmc4eth as ethernet from patlite.la6 import la6 #----- Network initialization ethernet . init () ethernet . set_link_info ( \"192.168.10.2\" , \"255.255.255.0\" , \"0.0.0.0\" , \"0.0.0.0\" ) ethernet . link () #----- Serial PC initialization streams . serial () #----- initialization try : lamp = la6 . la6HTTP () except Exception as e : print ( e ) print ( \"----- Start Animation\" ) while True : #----- Animation Example print ( \"--- Restart Animation\" ) lamp . set_LED_colors ([ \"red\" , \"off\" , \"off\" , \"off\" , \"off\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"red\" , \"off\" , \"off\" , \"off\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"off\" , \"red\" , \"off\" , \"off\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"off\" , \"off\" , \"red\" , \"off\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"off\" , \"off\" , \"off\" , \"red\" ]) sleep ( 300 ) lamp . set_LED_colors ([ \"red\" , \"off\" , \"off\" , \"off\" , \"red\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"red\" , \"off\" , \"off\" , \"red\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"off\" , \"red\" , \"off\" , \"red\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"off\" , \"off\" , \"red\" , \"red\" ]) sleep ( 300 ) lamp . set_LED_colors ([ \"white\" , \"off\" , \"off\" , \"red\" , \"red\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"white\" , \"off\" , \"red\" , \"red\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"off\" , \"white\" , \"red\" , \"red\" ]) sleep ( 300 ) lamp . set_LED_colors ([ \"green\" , \"off\" , \"white\" , \"red\" , \"red\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"green\" , \"white\" , \"red\" , \"red\" ]) sleep ( 300 ) lamp . set_LED_colors ([ \"green\" , \"green\" , \"white\" , \"red\" , \"red\" ]) lamp . set_buzzer ( \"on\" ) #Start Buzzer sleep ( 50 ) lamp . set_buzzer ( \"off\" ) #Stop Buzzer sleep ( 10 ) lamp . set_flash ( \"on\" ) #Start Flash LED sleep ( 5000 ) lamp . clear () sleep ( 10 ) lamp . set_smartmode ( 2 ) sleep ( 9000 ) lamp . clear () sleep ( 1000 ) print ( \"--- Finish Animation\" ) main.py #--------------------------------# # Author: Alex Moriconi | # Date: 10-06-2019 | # Esempio Library Patlite La6 | # Protocol: MODBUS | #--------------------------------# #----- necessary streams import import streams # the ethernet module needs a networking driver to be loaded # in order to control the board hardware. # FOR THIS EXAMPLE TO WORK, A NETWORK DRIVER MUST BE SELECTED BELOW # uncomment the following line to use the ESP32 driver # from espressif.esp32net import esp32eth as ethernet # uncomment the following line to use INFINEON xmc4eth driver # from infineon.xmc4eth import xmc4eth as ethernet from patlite.la6 import la6 #----- Network initialization ethernet . init () ethernet . set_link_info ( \"192.168.10.2\" , \"255.255.255.0\" , \"0.0.0.0\" , \"0.0.0.0\" ) ethernet . link () #----- Serial PC initialization streams . serial () #----- initialization try : lamp = la6 . la6MODBUS () except Exception as e : print ( e ) print ( \"----- Start Animation\" ) while True : #----- Animation Example print ( \"--- Restart Animation\" ) lamp . set_LED_colors ([ \"red\" , \"off\" , \"off\" , \"off\" , \"off\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"red\" , \"off\" , \"off\" , \"off\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"off\" , \"red\" , \"off\" , \"off\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"off\" , \"off\" , \"red\" , \"off\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"off\" , \"off\" , \"off\" , \"red\" ]) sleep ( 300 ) lamp . set_LED_colors ([ \"red\" , \"off\" , \"off\" , \"off\" , \"red\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"red\" , \"off\" , \"off\" , \"red\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"off\" , \"red\" , \"off\" , \"red\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"off\" , \"off\" , \"red\" , \"red\" ]) sleep ( 300 ) lamp . set_LED_colors ([ \"white\" , \"off\" , \"off\" , \"red\" , \"red\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"white\" , \"off\" , \"red\" , \"red\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"off\" , \"white\" , \"red\" , \"red\" ]) sleep ( 300 ) lamp . set_LED_colors ([ \"green\" , \"off\" , \"white\" , \"red\" , \"red\" ]) sleep ( 100 ) lamp . set_LED_colors ([ \"off\" , \"green\" , \"white\" , \"red\" , \"red\" ]) sleep ( 300 ) lamp . set_LED_colors ([ \"green\" , \"green\" , \"white\" , \"red\" , \"red\" ]) lamp . set_buzzer ( \"on\" ) #Start Buzzer sleep ( 50 ) lamp . set_buzzer ( \"off\" ) #Stop Buzzer sleep ( 10 ) lamp . set_flash ( \"on\" ) #Start Flash LED sleep ( 5000 ) lamp . clear () sleep ( 10 ) lamp . set_smartmode ( 2 ) sleep ( 9000 ) lamp . clear () sleep ( 1000 ) print ( \"--- Finish Animation\" )","title":"Examples"},{"location":"reference/libs/patlite/la6/docs/la6/","text":"PATLITE LA6 Library \u00b6 To talk with a lamp device an object of type HTTP protocol or MODBUS TCP. Example: #----- HTTP Protocol import la6 lamp = la6 . la6HTTP () lamp . set_LED_colors ([ \"green\" , \"green\" , \"white\" , \"red\" , \"red\" ]) #----- MODBUS TCP Protocol import la6 lamp = la6 . la6MODBUS () lamp . set_LED_colors ([ \"green\" , \"green\" , \"white\" , \"red\" , \"red\" ]) Warning To be able to communicate via HTTP or MODBUS TCP the patlite la6 must be previously configured to accept commands via these protocols. Set the \u201cControl-system Switchover\u201d parameter on the \u201cMain Unit Setup\u201d page to the \u201cCommand Control\u201d value via the web interface. la6HTTP class \u00b6 class la6HTTP \u00b6 class la6HTTP ( colors = [ \"off,\" off , \"off\" , \"off\" , \"off\" ], buzzer = \"off\" , flash = \"off\" , address = \"192.168.10.1\" ) Create an instance of the la6HTTP class for control patlite la6 lamp with HTTP protocol. Arguments: colors \u2013 Array of 5 positions containing the colors of the led strips. String Color off off red Red amber Amber lemon Lemon green Green skyblue Sky Blue blue Blue purple Purple pink Pink white White buzzer \u2013 Buzzer status upon initialization. Value Effect off Turned off on Turned on 2-11 audio effects set by set by the lamp manufacturer flash \u2013 Flash LED unit status upon initialization [\u201coff\u201d or \u201con\u201d]. address \u2013 The IP address of the devices concerned. la6HTTP.set_LED_colors \u00b6 set_LED_colors ( colors ) Arguments: colors \u2013 Array of 5 positions containing the colors of the led strips. la6HTTP.set_buzzer \u00b6 set_buzzer ( buzzer ) Arguments: buzzer \u2013 Buzzer status. la6HTTP.set_flash \u00b6 set_flash ( flash ) Arguments: flash \u2013 Flash LED unit status. la6HTTP.clear \u00b6 clear () LED unit and buzzer reset. la6HTTP.set_smartmode \u00b6 set_smartmode ( command ) Arguments: command \u2013 Through this parameter composed of the digits from 1 to 15 it is possible to draw on the SmartMode LED animation functions sanctioned by the lamp manufacturer. la6MODBUS class \u00b6 class la6MODBUS \u00b6 class la6MODBUS ( colors = [ \"off,\" off , \"off\" , \"off\" , \"off\" ], buzzer = \"off\" , flash = \"off\" , address = \"192.168.10.1\" , port = 502 ) Create an instance of the la6MODBUS class for control patlite la6 lamp with MODBUS TCP protocol. Arguments: colors \u2013 Array of 5 positions containing the colors of the led strips. String Color off off red Red amber Amber lemon Lemon green Green skyblue Sky Blue blue Blue purple Purple pink Pink white White buzzer \u2013 Buzzer status upon initialization. Value Effect off Turned off on Turned on 2-11 audio effects set by set by the lamp manufacturer flash \u2013 Flash LED unit status upon initialization [\u201coff\u201d or \u201con\u201d]. address \u2013 The IP address of the devices concerned. port \u2013 Network port for connection in modbus protocol. la6MODBUS.set_LED_colors \u00b6 set_LED_colors ( colors ) Arguments: colors \u2013 Array of 5 positions containing the colors of the led strips. la6MODBUS.set_buzzer \u00b6 set_buzzer ( buzzer ) Arguments: buzzer \u2013 Buzzer status. la6MODBUS.set_flash \u00b6 set_flash ( flash ) Arguments: flash \u2013 Flash LED unit status. la6MODBUS.set_smartmode \u00b6 set_smartmode ( command ) Arguments: command \u2013 Through this parameter composed of the digits from 1 to 15 it is possible to draw on the SmartMode LED animation functions sanctioned by the lamp manufacturer. la6MODBUS.clear \u00b6 clear () LED unit and buzzer reset.","title":"PATLITE LA6 Library"},{"location":"reference/libs/patlite/la6/docs/la6/#patlite-la6-library","text":"To talk with a lamp device an object of type HTTP protocol or MODBUS TCP. Example: #----- HTTP Protocol import la6 lamp = la6 . la6HTTP () lamp . set_LED_colors ([ \"green\" , \"green\" , \"white\" , \"red\" , \"red\" ]) #----- MODBUS TCP Protocol import la6 lamp = la6 . la6MODBUS () lamp . set_LED_colors ([ \"green\" , \"green\" , \"white\" , \"red\" , \"red\" ]) Warning To be able to communicate via HTTP or MODBUS TCP the patlite la6 must be previously configured to accept commands via these protocols. Set the \u201cControl-system Switchover\u201d parameter on the \u201cMain Unit Setup\u201d page to the \u201cCommand Control\u201d value via the web interface.","title":"PATLITE LA6 Library"},{"location":"reference/libs/patlite/la6/docs/la6/#la6http-class","text":"","title":"la6HTTP class"},{"location":"reference/libs/patlite/la6/docs/la6/#class-la6http","text":"class la6HTTP ( colors = [ \"off,\" off , \"off\" , \"off\" , \"off\" ], buzzer = \"off\" , flash = \"off\" , address = \"192.168.10.1\" ) Create an instance of the la6HTTP class for control patlite la6 lamp with HTTP protocol. Arguments: colors \u2013 Array of 5 positions containing the colors of the led strips. String Color off off red Red amber Amber lemon Lemon green Green skyblue Sky Blue blue Blue purple Purple pink Pink white White buzzer \u2013 Buzzer status upon initialization. Value Effect off Turned off on Turned on 2-11 audio effects set by set by the lamp manufacturer flash \u2013 Flash LED unit status upon initialization [\u201coff\u201d or \u201con\u201d]. address \u2013 The IP address of the devices concerned.","title":"class la6HTTP"},{"location":"reference/libs/patlite/la6/docs/la6/#la6httpset_led_colors","text":"set_LED_colors ( colors ) Arguments: colors \u2013 Array of 5 positions containing the colors of the led strips.","title":"la6HTTP.set_LED_colors"},{"location":"reference/libs/patlite/la6/docs/la6/#la6httpset_buzzer","text":"set_buzzer ( buzzer ) Arguments: buzzer \u2013 Buzzer status.","title":"la6HTTP.set_buzzer"},{"location":"reference/libs/patlite/la6/docs/la6/#la6httpset_flash","text":"set_flash ( flash ) Arguments: flash \u2013 Flash LED unit status.","title":"la6HTTP.set_flash"},{"location":"reference/libs/patlite/la6/docs/la6/#la6httpclear","text":"clear () LED unit and buzzer reset.","title":"la6HTTP.clear"},{"location":"reference/libs/patlite/la6/docs/la6/#la6httpset_smartmode","text":"set_smartmode ( command ) Arguments: command \u2013 Through this parameter composed of the digits from 1 to 15 it is possible to draw on the SmartMode LED animation functions sanctioned by the lamp manufacturer.","title":"la6HTTP.set_smartmode"},{"location":"reference/libs/patlite/la6/docs/la6/#la6modbus-class","text":"","title":"la6MODBUS class"},{"location":"reference/libs/patlite/la6/docs/la6/#class-la6modbus","text":"class la6MODBUS ( colors = [ \"off,\" off , \"off\" , \"off\" , \"off\" ], buzzer = \"off\" , flash = \"off\" , address = \"192.168.10.1\" , port = 502 ) Create an instance of the la6MODBUS class for control patlite la6 lamp with MODBUS TCP protocol. Arguments: colors \u2013 Array of 5 positions containing the colors of the led strips. String Color off off red Red amber Amber lemon Lemon green Green skyblue Sky Blue blue Blue purple Purple pink Pink white White buzzer \u2013 Buzzer status upon initialization. Value Effect off Turned off on Turned on 2-11 audio effects set by set by the lamp manufacturer flash \u2013 Flash LED unit status upon initialization [\u201coff\u201d or \u201con\u201d]. address \u2013 The IP address of the devices concerned. port \u2013 Network port for connection in modbus protocol.","title":"class la6MODBUS"},{"location":"reference/libs/patlite/la6/docs/la6/#la6modbusset_led_colors","text":"set_LED_colors ( colors ) Arguments: colors \u2013 Array of 5 positions containing the colors of the led strips.","title":"la6MODBUS.set_LED_colors"},{"location":"reference/libs/patlite/la6/docs/la6/#la6modbusset_buzzer","text":"set_buzzer ( buzzer ) Arguments: buzzer \u2013 Buzzer status.","title":"la6MODBUS.set_buzzer"},{"location":"reference/libs/patlite/la6/docs/la6/#la6modbusset_flash","text":"set_flash ( flash ) Arguments: flash \u2013 Flash LED unit status.","title":"la6MODBUS.set_flash"},{"location":"reference/libs/patlite/la6/docs/la6/#la6modbusset_smartmode","text":"set_smartmode ( command ) Arguments: command \u2013 Through this parameter composed of the digits from 1 to 15 it is possible to draw on the SmartMode LED animation functions sanctioned by the lamp manufacturer.","title":"la6MODBUS.set_smartmode"},{"location":"reference/libs/patlite/la6/docs/la6/#la6modbusclear","text":"clear () LED unit and buzzer reset.","title":"la6MODBUS.clear"},{"location":"reference/libs/quectel/bg96/docs/","text":"Quectel BG96 \u00b6 This module implements the Zerynth driver for the Quectel BG96 LTE Cat-M1, LTE Cat-NB1 and EGPRS modem ( Product page ). The driver must be used together with the standard library GSM Module. Contents: BG96 Module Network Time GNSS BG96_GNSS Module NMEA Examples UDP Socket","title":"Quectel BG96"},{"location":"reference/libs/quectel/bg96/docs/#quectel-bg96","text":"This module implements the Zerynth driver for the Quectel BG96 LTE Cat-M1, LTE Cat-NB1 and EGPRS modem ( Product page ). The driver must be used together with the standard library GSM Module. Contents: BG96 Module Network Time GNSS BG96_GNSS Module NMEA Examples UDP Socket","title":"Quectel BG96"},{"location":"reference/libs/quectel/bg96/docs/bg96/","text":"BG96 Module \u00b6 This module implements the Zerynth driver for the Quectel BG96 LTE Cat-M1, LTE Cat-NB1 and EGPRS modem ( Product page ). The driver must be used together with the standard library GSM Module. The following functionalities are implemented: attach/detach from gprs network retrieve and set available operators retrieve signal strength retrieve network and device info socket abstraction secure sockets GNSS positioning RTC clock Listening sockets for TCP and UDP protocols are not implemented due to the nature of GSM networks. Moreover, UDP sockets must be connected or bound explicitly in the code to select which kind of function to perform (send vs sendto and recv vs recvfrom). NB IoT support is not ready yet. The communication with BG96 is performed via UART without hardware flow control at 115200 baud. This module provides the bg96Exception to signal errors related to the hardware initialization and management. init \u00b6 init ( serial , dtr , rts , power , reset , status , power_on = LOW , reset_on = LOW , status_on = HIGH ) Initialize the BG96 device given the following parameters: serial , the serial port connected to the BG96 ( SERIAL1 , SERIAL2 , etc\u2026) dtr , the DTR pin of BG96 rts , the RTS pin of BG96 power , the power up pin of BG96 reset , the reset pin of BG96 status , the status pin of BG96 power_on, the active level of the power up pin reset_on, the active level of the reset pin status_on , the value of status pin indicating successful power on (can be zero in some pcb designs) bypass \u00b6 bypass ( mode ) Bypass the modem driver to use the serial port directly. It has one parameter: mode , can be 1 (non-zero) to enter bypass mode, or 0 (zero) to exit. shutdown \u00b6 shutdown ( forced = False ) Power off the module by pulsing the power pin (clean power-down). If forced is given, use the reset pin (faster, do not detach from network). startup \u00b6 startup () Power on the module by pulsing the power pin. Network Time \u00b6 The BG96 has an internal Real Time Clock that is automatically synchronized with the Network Time. The current time can be retrieved with the following function: rtc \u00b6 rtc () Return a tuple of seven elements: current year current month (1-12) current day (1-31) current hour (0-23) current minute (0-59) current second (0-59) current timezone in minutes away from GMT 0 The returned time is always UTC time with a timezone indication. GNSS \u00b6 The BG96 has an integrated GNSS that can be activated and queried for location fixes, regardless of the network status. A separate module bg96gnss is also provided to parse NMEA senteces directly from the BG96 dedicated serial port. When using the BG96_GNSS class, do not also call the following methods to avoid conflicts. gnss_init \u00b6 gnss_init ( fix_rate = 1 , use_uart = 0 ) Initializes the GNSS subsystem, given the following parameters: fix_rate , configure GNSS fix or NMEA output rate in seconds use_uart , use the secondary serial port (UART3) of the BG96 to output NMEA sentences gnss_done \u00b6 gnss_done () Shutdown the GNSS subsystem. fix \u00b6 fix () Return a tuple of 10 elements: latitude in decimal format (-89.9999 - 89.9999) longitude in decimal format (-179.9999 - 179.9999) altitude in meters speed in Km/h course over ground as degrees from true north number of satellites for this fix horizontal dilution of precision (0.5 - 99.9) Not supported Not supported UTC time as a tuple (yyyy,MM,dd,hh,mm,ss) The function return None if a fix can\u2019t be obtained.","title":"BG96 Module"},{"location":"reference/libs/quectel/bg96/docs/bg96/#bg96-module","text":"This module implements the Zerynth driver for the Quectel BG96 LTE Cat-M1, LTE Cat-NB1 and EGPRS modem ( Product page ). The driver must be used together with the standard library GSM Module. The following functionalities are implemented: attach/detach from gprs network retrieve and set available operators retrieve signal strength retrieve network and device info socket abstraction secure sockets GNSS positioning RTC clock Listening sockets for TCP and UDP protocols are not implemented due to the nature of GSM networks. Moreover, UDP sockets must be connected or bound explicitly in the code to select which kind of function to perform (send vs sendto and recv vs recvfrom). NB IoT support is not ready yet. The communication with BG96 is performed via UART without hardware flow control at 115200 baud. This module provides the bg96Exception to signal errors related to the hardware initialization and management.","title":"BG96 Module"},{"location":"reference/libs/quectel/bg96/docs/bg96/#init","text":"init ( serial , dtr , rts , power , reset , status , power_on = LOW , reset_on = LOW , status_on = HIGH ) Initialize the BG96 device given the following parameters: serial , the serial port connected to the BG96 ( SERIAL1 , SERIAL2 , etc\u2026) dtr , the DTR pin of BG96 rts , the RTS pin of BG96 power , the power up pin of BG96 reset , the reset pin of BG96 status , the status pin of BG96 power_on, the active level of the power up pin reset_on, the active level of the reset pin status_on , the value of status pin indicating successful power on (can be zero in some pcb designs)","title":"init"},{"location":"reference/libs/quectel/bg96/docs/bg96/#bypass","text":"bypass ( mode ) Bypass the modem driver to use the serial port directly. It has one parameter: mode , can be 1 (non-zero) to enter bypass mode, or 0 (zero) to exit.","title":"bypass"},{"location":"reference/libs/quectel/bg96/docs/bg96/#shutdown","text":"shutdown ( forced = False ) Power off the module by pulsing the power pin (clean power-down). If forced is given, use the reset pin (faster, do not detach from network).","title":"shutdown"},{"location":"reference/libs/quectel/bg96/docs/bg96/#startup","text":"startup () Power on the module by pulsing the power pin.","title":"startup"},{"location":"reference/libs/quectel/bg96/docs/bg96/#network-time","text":"The BG96 has an internal Real Time Clock that is automatically synchronized with the Network Time. The current time can be retrieved with the following function:","title":"Network Time"},{"location":"reference/libs/quectel/bg96/docs/bg96/#rtc","text":"rtc () Return a tuple of seven elements: current year current month (1-12) current day (1-31) current hour (0-23) current minute (0-59) current second (0-59) current timezone in minutes away from GMT 0 The returned time is always UTC time with a timezone indication.","title":"rtc"},{"location":"reference/libs/quectel/bg96/docs/bg96/#gnss","text":"The BG96 has an integrated GNSS that can be activated and queried for location fixes, regardless of the network status. A separate module bg96gnss is also provided to parse NMEA senteces directly from the BG96 dedicated serial port. When using the BG96_GNSS class, do not also call the following methods to avoid conflicts.","title":"GNSS"},{"location":"reference/libs/quectel/bg96/docs/bg96/#gnss_init","text":"gnss_init ( fix_rate = 1 , use_uart = 0 ) Initializes the GNSS subsystem, given the following parameters: fix_rate , configure GNSS fix or NMEA output rate in seconds use_uart , use the secondary serial port (UART3) of the BG96 to output NMEA sentences","title":"gnss_init"},{"location":"reference/libs/quectel/bg96/docs/bg96/#gnss_done","text":"gnss_done () Shutdown the GNSS subsystem.","title":"gnss_done"},{"location":"reference/libs/quectel/bg96/docs/bg96/#fix","text":"fix () Return a tuple of 10 elements: latitude in decimal format (-89.9999 - 89.9999) longitude in decimal format (-179.9999 - 179.9999) altitude in meters speed in Km/h course over ground as degrees from true north number of satellites for this fix horizontal dilution of precision (0.5 - 99.9) Not supported Not supported UTC time as a tuple (yyyy,MM,dd,hh,mm,ss) The function return None if a fix can\u2019t be obtained.","title":"fix"},{"location":"reference/libs/quectel/bg96/docs/bg96gnss/","text":"BG96_GNSS Module \u00b6 This module implements the Zerynth driver for the Quectel BG96 GNSS functionality on its dedicated UART port ( Product page ). The following functionalities are implemented: retrieve the current location fix if present retrieve the current UTC time The driver starts a background thread continuously tracking the last available location fix. The frequency of fixes can be customized. The driver support serial mode only. Location fixes are obtained by parsing NMEA sentences of type RMC and GGA. Obtaining a fix or UTC time are thread safe operations. class BG96_GNSS \u00b6 class BG96_GNSS ( ifc , baud = 9600 ) Create an instance of the BG96_GNSS class. Arguments: ifc \u2013 serial interface to use (for example SERIAL1 , SERIAL2 , etc\u2026) baud \u2013 serial port baudrate Example: from quectel.bg96gnss import bg96gnss ... gnss = bg96gnss . BG96_GNSS ( SERIAL1 ) gnss . start () mpl . init () alt = mpl . get_alt () pres = mpl . get_pres () BG96_GNSS.start \u00b6 start () Start the BG96 GNSS and the receiver thread. Arguments: use_uart \u2013 1 if BG96\u2019s UART3 must be used, 0 otherwise Returns: True if receiver thread has been started, False if already active. BG96_GNSS.stop \u00b6 stop () Stop the BG96 GNSS and terminates the receiver thread. It can be restarted by calling start. Returns: True if receiver thread has been stopped, False if already inactive. BG96_GNSS.pause \u00b6 pause () Pause the BG96 GNSS by putting it into standby mode. It can be restarted by calling resume. BG96_GNSS.resume \u00b6 resume () Wake up the BG96_GNSS from standby mode. BG96_GNSS.set_rate \u00b6 set_rate ( rate = 1000 ) Set the frequency for location fix (100-10000 milliseconds is the available range). NMEA \u00b6 Additional methods from the base class nmea.NMEA_Receiver . BG96_GNSS.fix \u00b6 fix () Return the current fix or None if not available. A fix is a tuple with the following elements: latitude in decimal format (-89.9999 - 89.9999) longitude in decimal format (-179.9999 - 179.9999) altitude in meters speed in Km/h course over ground as degrees from true north number of satellites for this fix horizontal dilution of precision (0.5 - 99.9) vertical dilution of precision (0.5 - 99.9) positional dilution of precision (0.5 - 99.9) UTC time as a tuple (yyyy,MM,dd,hh,mm,ss,microseconds) BG96_GNSS.has_fix \u00b6 has_fix () Return True if a fix is available. BG96_GNSS.utc \u00b6 utc () Return the current UTC time or None if not available. A UTC time is a tuple of (yyyy,MM,dd,hh,mm,ss,microseconds). UTC time can be wrong if no fix has ever been obtained. BG96_GNSS.has_utc \u00b6 has_utc () Return True if a UTC time is available.","title":"BG96_GNSS Module"},{"location":"reference/libs/quectel/bg96/docs/bg96gnss/#bg96_gnss-module","text":"This module implements the Zerynth driver for the Quectel BG96 GNSS functionality on its dedicated UART port ( Product page ). The following functionalities are implemented: retrieve the current location fix if present retrieve the current UTC time The driver starts a background thread continuously tracking the last available location fix. The frequency of fixes can be customized. The driver support serial mode only. Location fixes are obtained by parsing NMEA sentences of type RMC and GGA. Obtaining a fix or UTC time are thread safe operations.","title":"BG96_GNSS Module"},{"location":"reference/libs/quectel/bg96/docs/bg96gnss/#class-bg96_gnss","text":"class BG96_GNSS ( ifc , baud = 9600 ) Create an instance of the BG96_GNSS class. Arguments: ifc \u2013 serial interface to use (for example SERIAL1 , SERIAL2 , etc\u2026) baud \u2013 serial port baudrate Example: from quectel.bg96gnss import bg96gnss ... gnss = bg96gnss . BG96_GNSS ( SERIAL1 ) gnss . start () mpl . init () alt = mpl . get_alt () pres = mpl . get_pres ()","title":"class BG96_GNSS"},{"location":"reference/libs/quectel/bg96/docs/bg96gnss/#bg96_gnssstart","text":"start () Start the BG96 GNSS and the receiver thread. Arguments: use_uart \u2013 1 if BG96\u2019s UART3 must be used, 0 otherwise Returns: True if receiver thread has been started, False if already active.","title":"BG96_GNSS.start"},{"location":"reference/libs/quectel/bg96/docs/bg96gnss/#bg96_gnssstop","text":"stop () Stop the BG96 GNSS and terminates the receiver thread. It can be restarted by calling start. Returns: True if receiver thread has been stopped, False if already inactive.","title":"BG96_GNSS.stop"},{"location":"reference/libs/quectel/bg96/docs/bg96gnss/#bg96_gnsspause","text":"pause () Pause the BG96 GNSS by putting it into standby mode. It can be restarted by calling resume.","title":"BG96_GNSS.pause"},{"location":"reference/libs/quectel/bg96/docs/bg96gnss/#bg96_gnssresume","text":"resume () Wake up the BG96_GNSS from standby mode.","title":"BG96_GNSS.resume"},{"location":"reference/libs/quectel/bg96/docs/bg96gnss/#bg96_gnssset_rate","text":"set_rate ( rate = 1000 ) Set the frequency for location fix (100-10000 milliseconds is the available range).","title":"BG96_GNSS.set_rate"},{"location":"reference/libs/quectel/bg96/docs/bg96gnss/#nmea","text":"Additional methods from the base class nmea.NMEA_Receiver .","title":"NMEA"},{"location":"reference/libs/quectel/bg96/docs/bg96gnss/#bg96_gnssfix","text":"fix () Return the current fix or None if not available. A fix is a tuple with the following elements: latitude in decimal format (-89.9999 - 89.9999) longitude in decimal format (-179.9999 - 179.9999) altitude in meters speed in Km/h course over ground as degrees from true north number of satellites for this fix horizontal dilution of precision (0.5 - 99.9) vertical dilution of precision (0.5 - 99.9) positional dilution of precision (0.5 - 99.9) UTC time as a tuple (yyyy,MM,dd,hh,mm,ss,microseconds)","title":"BG96_GNSS.fix"},{"location":"reference/libs/quectel/bg96/docs/bg96gnss/#bg96_gnsshas_fix","text":"has_fix () Return True if a fix is available.","title":"BG96_GNSS.has_fix"},{"location":"reference/libs/quectel/bg96/docs/bg96gnss/#bg96_gnssutc","text":"utc () Return the current UTC time or None if not available. A UTC time is a tuple of (yyyy,MM,dd,hh,mm,ss,microseconds). UTC time can be wrong if no fix has ever been obtained.","title":"BG96_GNSS.utc"},{"location":"reference/libs/quectel/bg96/docs/bg96gnss/#bg96_gnsshas_utc","text":"has_utc () Return True if a UTC time is available.","title":"BG96_GNSS.has_utc"},{"location":"reference/libs/quectel/bg96/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.quectel.bg96. Secure Socket \u00b6 A simple example showing how to connect with TLS sockets thanks to UG96 (configured with secure ciphersuites only). main.py ################################################################################ # Zerynth Secure Sockets # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams import json # import the gsm interface from wireless import gsm # import the http module import requests import ssl from quectel.bg96 import bg96 as bg96 streams . serial () try : print ( \"Initializing UG96...\" ) # init the ug96 # pins and serial port must be set according to your setup bg96 . init ( SERIAL2 , D42 , D42 , D42 , D42 , D34 , 0 , 1 , 1 ) bg96 . startup () # change APN name as needed print ( \"Establishing Link...\" ) gsm . attach ( \"YOUR-APN-HERE\" ) # let's try to connect to https://www.howsmyssl.com/a/check to get some info # on the SSL/TLS connection # retrieve the CA certificate used to sign the howsmyssl.com certificate cacert = __lookup ( SSL_CACERT_DST_ROOT_CA_X3 ) # create a SSL context to require server certificate verification ctx = ssl . create_ssl_context ( cacert = cacert , options = ssl . CERT_REQUIRED | ssl . SERVER_AUTH ) # NOTE: if the underlying SSL driver does not support certificate validation # uncomment the following line! # ctx = None for i in range ( 3 ): try : print ( \"Trying to connect...\" ) url = \"https://www.howsmyssl.com/a/check\" # url resolution and http protocol handling are hidden inside the requests module user_agent = { \"User-Agent\" : \"curl/7.53.1\" , \"Accept\" : \"*/*\" } # pass the ssl context together with the request response = requests . get ( url , headers = user_agent , ctx = ctx ) # if we get here, there has been no exception, exit the loop break except Exception as e : print ( e ) try : # check status and print the result if response . status == 200 : print ( \"Success!!\" ) print ( \"-------------\" ) # it's time to parse the json response js = json . loads ( response . content ) # super easy! for k , v in js . items (): if k == \"given_cipher_suites\" : print ( \"Supported Ciphers\" ) for cipher in v : print ( cipher ) print ( \"-----\" ) else : print ( k , \"::\" , v ) print ( \"-------------\" ) except Exception as e : print ( \"ooops, something very wrong! :(\" , e ) except Exception as e : print ( \"oops, exception!\" , e ) UDP Socket \u00b6 A simple project showing how to use UDP sockets with UG96 main.py ################################################################################ # Zerynth UDP Socket # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams import socket # import the gsm interface from wireless import gsm from quectel.ug96 import ug96 as ug96 # For this example to work, you need an UDP server somewhere on the public # internet. You can run this example (https://gist.github.com/Manouchehri/67b53ecdc767919dddf3ec4ea8098b20) # on your cloud instance on the port you prefer for the sake of this test streams . serial () # specify here the IP and port of your UDP server server_ip = \"0.0.0.0\" server_port = 7778 try : print ( \"Initializing UG96...\" ) # init the ug96 # pins and serial port must be set according to your setup bg96 . init ( SERIAL2 , D42 , D42 , D42 , D42 , D34 , 0 , 1 , 1 ) bg96 . startup () # use the wifi interface to link to the Access Point # change network name, security and password as needed print ( \"Establishing Link...\" ) gsm . attach ( \"your-apn-name\" ) print ( \"Trying UDP socket in connect mode\" ) # Let's open an udp socket with connect. # the socket will then be used with send and recv methods # without specifying the receiver address. # The socket will be able to send only to the address # specified in the connect method sock = socket . socket ( type = socket . SOCK_DGRAM , proto = socket . IPPROTO_UDP ) sock . connect (( server_ip , server_port )) for i in range ( 5 ): sock . send ( \"Hello \\n \" ) sleep ( 1000 ) sock . close () print ( \"Trying UDP socket in bind mode\" ) # Let's open an udp socket and configure with bind. # the socket will then be used with sendto and recvfrom methods # specifying the receiver address. # The socket will be able to send to any ip address sock = socket . socket ( type = socket . SOCK_DGRAM , proto = socket . IPPROTO_UDP ) # open the udp socket on port 5678 on the public facing ip # Note: you won't necessarily see the same origin port on the # UDP server since GSM networks are usually behind a NAT sock . bind (( \"0.0.0.0\" , 5678 )) for i in range ( 5 ): sock . sendto ( \"Hello \\n \" ,( server_ip , server_port )) sleep ( 1000 ) except Exception as e : print ( \"oops, exception!\" , e ) while True : print ( \".\" ) sleep ( 1000 )","title":"Examples"},{"location":"reference/libs/quectel/bg96/docs/examples/#examples","text":"The following are a list of examples for lib.quectel.bg96.","title":"Examples"},{"location":"reference/libs/quectel/bg96/docs/examples/#secure-socket","text":"A simple example showing how to connect with TLS sockets thanks to UG96 (configured with secure ciphersuites only). main.py ################################################################################ # Zerynth Secure Sockets # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams import json # import the gsm interface from wireless import gsm # import the http module import requests import ssl from quectel.bg96 import bg96 as bg96 streams . serial () try : print ( \"Initializing UG96...\" ) # init the ug96 # pins and serial port must be set according to your setup bg96 . init ( SERIAL2 , D42 , D42 , D42 , D42 , D34 , 0 , 1 , 1 ) bg96 . startup () # change APN name as needed print ( \"Establishing Link...\" ) gsm . attach ( \"YOUR-APN-HERE\" ) # let's try to connect to https://www.howsmyssl.com/a/check to get some info # on the SSL/TLS connection # retrieve the CA certificate used to sign the howsmyssl.com certificate cacert = __lookup ( SSL_CACERT_DST_ROOT_CA_X3 ) # create a SSL context to require server certificate verification ctx = ssl . create_ssl_context ( cacert = cacert , options = ssl . CERT_REQUIRED | ssl . SERVER_AUTH ) # NOTE: if the underlying SSL driver does not support certificate validation # uncomment the following line! # ctx = None for i in range ( 3 ): try : print ( \"Trying to connect...\" ) url = \"https://www.howsmyssl.com/a/check\" # url resolution and http protocol handling are hidden inside the requests module user_agent = { \"User-Agent\" : \"curl/7.53.1\" , \"Accept\" : \"*/*\" } # pass the ssl context together with the request response = requests . get ( url , headers = user_agent , ctx = ctx ) # if we get here, there has been no exception, exit the loop break except Exception as e : print ( e ) try : # check status and print the result if response . status == 200 : print ( \"Success!!\" ) print ( \"-------------\" ) # it's time to parse the json response js = json . loads ( response . content ) # super easy! for k , v in js . items (): if k == \"given_cipher_suites\" : print ( \"Supported Ciphers\" ) for cipher in v : print ( cipher ) print ( \"-----\" ) else : print ( k , \"::\" , v ) print ( \"-------------\" ) except Exception as e : print ( \"ooops, something very wrong! :(\" , e ) except Exception as e : print ( \"oops, exception!\" , e )","title":"Secure Socket"},{"location":"reference/libs/quectel/bg96/docs/examples/#udp-socket","text":"A simple project showing how to use UDP sockets with UG96 main.py ################################################################################ # Zerynth UDP Socket # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams import socket # import the gsm interface from wireless import gsm from quectel.ug96 import ug96 as ug96 # For this example to work, you need an UDP server somewhere on the public # internet. You can run this example (https://gist.github.com/Manouchehri/67b53ecdc767919dddf3ec4ea8098b20) # on your cloud instance on the port you prefer for the sake of this test streams . serial () # specify here the IP and port of your UDP server server_ip = \"0.0.0.0\" server_port = 7778 try : print ( \"Initializing UG96...\" ) # init the ug96 # pins and serial port must be set according to your setup bg96 . init ( SERIAL2 , D42 , D42 , D42 , D42 , D34 , 0 , 1 , 1 ) bg96 . startup () # use the wifi interface to link to the Access Point # change network name, security and password as needed print ( \"Establishing Link...\" ) gsm . attach ( \"your-apn-name\" ) print ( \"Trying UDP socket in connect mode\" ) # Let's open an udp socket with connect. # the socket will then be used with send and recv methods # without specifying the receiver address. # The socket will be able to send only to the address # specified in the connect method sock = socket . socket ( type = socket . SOCK_DGRAM , proto = socket . IPPROTO_UDP ) sock . connect (( server_ip , server_port )) for i in range ( 5 ): sock . send ( \"Hello \\n \" ) sleep ( 1000 ) sock . close () print ( \"Trying UDP socket in bind mode\" ) # Let's open an udp socket and configure with bind. # the socket will then be used with sendto and recvfrom methods # specifying the receiver address. # The socket will be able to send to any ip address sock = socket . socket ( type = socket . SOCK_DGRAM , proto = socket . IPPROTO_UDP ) # open the udp socket on port 5678 on the public facing ip # Note: you won't necessarily see the same origin port on the # UDP server since GSM networks are usually behind a NAT sock . bind (( \"0.0.0.0\" , 5678 )) for i in range ( 5 ): sock . sendto ( \"Hello \\n \" ,( server_ip , server_port )) sleep ( 1000 ) except Exception as e : print ( \"oops, exception!\" , e ) while True : print ( \".\" ) sleep ( 1000 )","title":"UDP Socket"},{"location":"reference/libs/quectel/l76/docs/","text":"Quectel L76 \u00b6 L76, the extremely compact GNSS module, is a concurrent GNSS receiver with multiple GNSS systems. It provides simultaneous GPS, GLONASS, BeiDou, Galileo and QZSS open service L1 reception capability. With 33 tracking channels, 99 acquisition channels, and 210 PRN channels, L76 can acquire and track any mix of multiple satellite signals. Features \u00b6 Compact size, 10.1mm \u00d7 9.7mm \u00d7 2.5mm Multi-GNSS engine for GPS, GLONASS, BeiDou, Galileo and QZSS EASY\u2122, an advanced AGPS technology without external memory Ultra low tracking power consumption, 18mA AlwaysLocate\u2122, an intelligent algorithm for power saving LOCUS, an embedded logger solution with no need for host and external flash High sensitivity, -165dBm @Tracking, -148dBm @Acquisition 99 acquisition/ 33 tracking channels and 210 PRN channels Support DGPS, SBAS (WAAS/ EGNOS/ MSAS/ GAGAN) Anti-Jamming, Multi-tone Active Interference Canceller Balloon mode, for high altitude up to 80km PPS VS. NMEA can be used for time service Contents: L76 Module NMEA Examples Fix GPS","title":"Quectel L76"},{"location":"reference/libs/quectel/l76/docs/#quectel-l76","text":"L76, the extremely compact GNSS module, is a concurrent GNSS receiver with multiple GNSS systems. It provides simultaneous GPS, GLONASS, BeiDou, Galileo and QZSS open service L1 reception capability. With 33 tracking channels, 99 acquisition channels, and 210 PRN channels, L76 can acquire and track any mix of multiple satellite signals.","title":"Quectel L76"},{"location":"reference/libs/quectel/l76/docs/#features","text":"Compact size, 10.1mm \u00d7 9.7mm \u00d7 2.5mm Multi-GNSS engine for GPS, GLONASS, BeiDou, Galileo and QZSS EASY\u2122, an advanced AGPS technology without external memory Ultra low tracking power consumption, 18mA AlwaysLocate\u2122, an intelligent algorithm for power saving LOCUS, an embedded logger solution with no need for host and external flash High sensitivity, -165dBm @Tracking, -148dBm @Acquisition 99 acquisition/ 33 tracking channels and 210 PRN channels Support DGPS, SBAS (WAAS/ EGNOS/ MSAS/ GAGAN) Anti-Jamming, Multi-tone Active Interference Canceller Balloon mode, for high altitude up to 80km PPS VS. NMEA can be used for time service Contents: L76 Module NMEA Examples Fix GPS","title":"Features"},{"location":"reference/libs/quectel/l76/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.quectel.l76. Fix \u00b6 A simple example showing how to handle L76 serial messages and fix GPS position. main.py # L76 # Created at 2019-03-26 09:45:18.145367 import streams from quectel.l76 import l76 streams . serial () try : gnss = l76 . L76 ( SERIAL4 ) print ( \"Starting...\" ) gnss . start ( D59 ) gnss . set_rate ( 1000 ) while True : #print(\".\") utc = gnss . utc () print ( \"UTC\" , utc ) if gnss . has_fix (): fix = gnss . fix () if fix : for x in fix : print ( \"Fix\" , x ) print ( \"Pausing\" ) gnss . pause () sleep ( 10000 ) print ( \"Resuming\" ) gnss . resume () sleep ( 1000 ) except Exception as e : print ( \"EXC!\" ) print ( e )","title":"Examples"},{"location":"reference/libs/quectel/l76/docs/examples/#examples","text":"The following are a list of examples for lib.quectel.l76.","title":"Examples"},{"location":"reference/libs/quectel/l76/docs/examples/#fix","text":"A simple example showing how to handle L76 serial messages and fix GPS position. main.py # L76 # Created at 2019-03-26 09:45:18.145367 import streams from quectel.l76 import l76 streams . serial () try : gnss = l76 . L76 ( SERIAL4 ) print ( \"Starting...\" ) gnss . start ( D59 ) gnss . set_rate ( 1000 ) while True : #print(\".\") utc = gnss . utc () print ( \"UTC\" , utc ) if gnss . has_fix (): fix = gnss . fix () if fix : for x in fix : print ( \"Fix\" , x ) print ( \"Pausing\" ) gnss . pause () sleep ( 10000 ) print ( \"Resuming\" ) gnss . resume () sleep ( 1000 ) except Exception as e : print ( \"EXC!\" ) print ( e )","title":"Fix"},{"location":"reference/libs/quectel/l76/docs/l76/","text":"L76 Module \u00b6 This module implements the Zerynth driver for the Quectel L76 GNSS chip ( Product page ). The following functionalities are implemented: retrieve the current location fix if present retrieve the current UTC time The driver starts a background thread continuously tracking the last available location fix. The frequency of fixes can be customized. The driver support serial mode only. Location fixes are obtained by parsing NMEA sentences of type RMC and GGA. Obtaining a fix or UTC time are thread safe operations. class L76 \u00b6 class L76 ( ifc , mode = SERIAL , baud = 9600 , clock = 400000 , addr = 0x00 , reset = None , reset_on = 0 ) Create an instance of the L76 class. Arguments: ifc \u2013 serial interface to use (for example SERIAL1 , SERIAL2 , etc\u2026) mode \u2013 one of SERIAL or I2C. Only SERIAL mode supported at the moment. baud \u2013 serial port baudrate clock \u2013 I2C clock frequency (not supported) addr \u2013 I2C address (not supported) reset \u2013 optional reset pin reset_on \u2013 reset pin active level Example: from quectel.l76 import l76 ... gnss = l76 . L76 ( SERIAL1 ) gnss . start () mpl . init () alt = mpl . get_alt () pres = mpl . get_pres () L76.start \u00b6 start () Start the L76 and the receiver thread. Returns: True if receiver thread has been started, False if already active. L76.stop \u00b6 stop () Stop the L76 by using the lowest power consumption mode and terminates the receiver thread. It can be restarted by calling start. Returns: True if receiver thread has been stopped, False if already inactive. L76.pause \u00b6 pause () Pause the L76 by putting it into standby mode. It can be restarted by calling resume. Refer to the L76 documentation for details here . L76.resume \u00b6 resume () Wake up the L76 from standby mode entered by calling resume. Refer to the L76 documentation for details here . L76.set_rate \u00b6 set_rate ( rate = 1000 ) Set the frequency for location fix (100-10000 milliseconds is the available range). NMEA \u00b6 Additional methods from the base class nmea.NMEA_Receiver . L76.fix \u00b6 fix () Return the current fix or None if not available. A fix is a tuple with the following elements: latitude in decimal format (-89.9999 - 89.9999) longitude in decimal format (-179.9999 - 179.9999) altitude in meters speed in Km/h course over ground as degrees from true north number of satellites for this fix horizontal dilution of precision (0.5 - 99.9) vertical dilution of precision (0.5 - 99.9) positional dilution of precision (0.5 - 99.9) UTC time as a tuple (yyyy,MM,dd,hh,mm,ss,microseconds) L76.has_fix \u00b6 has_fix () Return True if a fix is available. L76.utc \u00b6 utc () Return the current UTC time or None if not available. A UTC time is a tuple of (yyyy,MM,dd,hh,mm,ss,microseconds). UTC time can be wrong if no fix has ever been obtained. L76.has_utc \u00b6 has_utc () Return True if a UTC time is available.","title":"L76 Module"},{"location":"reference/libs/quectel/l76/docs/l76/#l76-module","text":"This module implements the Zerynth driver for the Quectel L76 GNSS chip ( Product page ). The following functionalities are implemented: retrieve the current location fix if present retrieve the current UTC time The driver starts a background thread continuously tracking the last available location fix. The frequency of fixes can be customized. The driver support serial mode only. Location fixes are obtained by parsing NMEA sentences of type RMC and GGA. Obtaining a fix or UTC time are thread safe operations.","title":"L76 Module"},{"location":"reference/libs/quectel/l76/docs/l76/#class-l76","text":"class L76 ( ifc , mode = SERIAL , baud = 9600 , clock = 400000 , addr = 0x00 , reset = None , reset_on = 0 ) Create an instance of the L76 class. Arguments: ifc \u2013 serial interface to use (for example SERIAL1 , SERIAL2 , etc\u2026) mode \u2013 one of SERIAL or I2C. Only SERIAL mode supported at the moment. baud \u2013 serial port baudrate clock \u2013 I2C clock frequency (not supported) addr \u2013 I2C address (not supported) reset \u2013 optional reset pin reset_on \u2013 reset pin active level Example: from quectel.l76 import l76 ... gnss = l76 . L76 ( SERIAL1 ) gnss . start () mpl . init () alt = mpl . get_alt () pres = mpl . get_pres ()","title":"class L76"},{"location":"reference/libs/quectel/l76/docs/l76/#l76start","text":"start () Start the L76 and the receiver thread. Returns: True if receiver thread has been started, False if already active.","title":"L76.start"},{"location":"reference/libs/quectel/l76/docs/l76/#l76stop","text":"stop () Stop the L76 by using the lowest power consumption mode and terminates the receiver thread. It can be restarted by calling start. Returns: True if receiver thread has been stopped, False if already inactive.","title":"L76.stop"},{"location":"reference/libs/quectel/l76/docs/l76/#l76pause","text":"pause () Pause the L76 by putting it into standby mode. It can be restarted by calling resume. Refer to the L76 documentation for details here .","title":"L76.pause"},{"location":"reference/libs/quectel/l76/docs/l76/#l76resume","text":"resume () Wake up the L76 from standby mode entered by calling resume. Refer to the L76 documentation for details here .","title":"L76.resume"},{"location":"reference/libs/quectel/l76/docs/l76/#l76set_rate","text":"set_rate ( rate = 1000 ) Set the frequency for location fix (100-10000 milliseconds is the available range).","title":"L76.set_rate"},{"location":"reference/libs/quectel/l76/docs/l76/#nmea","text":"Additional methods from the base class nmea.NMEA_Receiver .","title":"NMEA"},{"location":"reference/libs/quectel/l76/docs/l76/#l76fix","text":"fix () Return the current fix or None if not available. A fix is a tuple with the following elements: latitude in decimal format (-89.9999 - 89.9999) longitude in decimal format (-179.9999 - 179.9999) altitude in meters speed in Km/h course over ground as degrees from true north number of satellites for this fix horizontal dilution of precision (0.5 - 99.9) vertical dilution of precision (0.5 - 99.9) positional dilution of precision (0.5 - 99.9) UTC time as a tuple (yyyy,MM,dd,hh,mm,ss,microseconds)","title":"L76.fix"},{"location":"reference/libs/quectel/l76/docs/l76/#l76has_fix","text":"has_fix () Return True if a fix is available.","title":"L76.has_fix"},{"location":"reference/libs/quectel/l76/docs/l76/#l76utc","text":"utc () Return the current UTC time or None if not available. A UTC time is a tuple of (yyyy,MM,dd,hh,mm,ss,microseconds). UTC time can be wrong if no fix has ever been obtained.","title":"L76.utc"},{"location":"reference/libs/quectel/l76/docs/l76/#l76has_utc","text":"has_utc () Return True if a UTC time is available.","title":"L76.has_utc"},{"location":"reference/libs/quectel/m95/docs/","text":"Quectel M95 \u00b6 This module implements the Zerynth driver for the Quectel M95 2G chip ( Product page ). The driver must be used together with the standard library GSM Module. Contents: M95 Module Network Time Examples Secure Socket UDP Socket","title":"Quectel M95"},{"location":"reference/libs/quectel/m95/docs/#quectel-m95","text":"This module implements the Zerynth driver for the Quectel M95 2G chip ( Product page ). The driver must be used together with the standard library GSM Module. Contents: M95 Module Network Time Examples Secure Socket UDP Socket","title":"Quectel M95"},{"location":"reference/libs/quectel/m95/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.quectel.m95. Secure Socket \u00b6 A simple example showing how to connect with TLS sockets thanks to UG96 (configured with secure ciphersuites only). main.py ################################################################################ # Zerynth Secure Sockets # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams import json # import the gsm interface from wireless import gsm # import the http module import requests import ssl from quectel.ug96 import ug96 as ug96 streams . serial () try : print ( \"Initializing UG96...\" ) # init the ug96 # pins and serial port must be set according to your setup ug96 . init ( SERIAL3 , D12 , D13 , D67 , D60 , D37 , D38 , 0 ) # change APN name as needed print ( \"Establishing Link...\" ) gsm . attach ( \"YOUR-APN-HERE\" ) # let's try to connect to https://www.howsmyssl.com/a/check to get some info # on the SSL/TLS connection # retrieve the CA certificate used to sign the howsmyssl.com certificate cacert = __lookup ( SSL_CACERT_DST_ROOT_CA_X3 ) # create a SSL context to require server certificate verification ctx = ssl . create_ssl_context ( cacert = cacert , options = ssl . CERT_REQUIRED | ssl . SERVER_AUTH ) # NOTE: if the underlying SSL driver does not support certificate validation # uncomment the following line! # ctx = None for i in range ( 3 ): try : print ( \"Trying to connect...\" ) url = \"https://www.howsmyssl.com/a/check\" # url resolution and http protocol handling are hidden inside the requests module user_agent = { \"User-Agent\" : \"curl/7.53.1\" , \"Accept\" : \"*/*\" } # pass the ssl context together with the request response = requests . get ( url , headers = user_agent , ctx = ctx ) # if we get here, there has been no exception, exit the loop break except Exception as e : print ( e ) try : # check status and print the result if response . status == 200 : print ( \"Success!!\" ) print ( \"-------------\" ) # it's time to parse the json response js = json . loads ( response . content ) # super easy! for k , v in js . items (): if k == \"given_cipher_suites\" : print ( \"Supported Ciphers\" ) for cipher in v : print ( cipher ) print ( \"-----\" ) else : print ( k , \"::\" , v ) print ( \"-------------\" ) except Exception as e : print ( \"ooops, something very wrong! :(\" , e ) except Exception as e : print ( \"oops, exception!\" , e ) UDP Socket \u00b6 A simple project showing how to use UDP sockets with UG96. main.py ################################################################################ # Zerynth UDP Socket # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams import socket # import the gsm interface from wireless import gsm from quectel.ug96 import ug96 as ug96 # For this example to work, you need an UDP server somewhere on the public # internet. You can run this example (https://gist.github.com/Manouchehri/67b53ecdc767919dddf3ec4ea8098b20) # on your cloud instance on the port you prefer for the sake of this test streams . serial () # specify here the IP and port of your UDP server server_ip = \"0.0.0.0\" server_port = 7778 try : print ( \"Initializing UG96...\" ) # init the ug96 # pins and serial port must be set according to your setup ug96 . init ( SERIAL3 , D12 , D13 , D67 , D60 , D37 , D38 , 0 ) # use the wifi interface to link to the Access Point # change network name, security and password as needed print ( \"Establishing Link...\" ) gsm . attach ( \"your-apn-name\" ) print ( \"Trying UDP socket in connect mode\" ) # Let's open an udp socket with connect. # the socket will then be used with send and recv methods # without specifying the receiver address. # The socket will be able to send only to the address # specified in the connect method sock = socket . socket ( type = socket . SOCK_DGRAM , proto = socket . IPPROTO_UDP ) sock . connect (( server_ip , server_port )) for i in range ( 5 ): sock . send ( \"Hello \\n \" ) sleep ( 1000 ) sock . close () print ( \"Trying UDP socket in bind mode\" ) # Let's open an udp socket and configure with bind. # the socket will then be used with sendto and recvfrom methods # specifying the receiver address. # The socket will be able to send to any ip address sock = socket . socket ( type = socket . SOCK_DGRAM , proto = socket . IPPROTO_UDP ) # open the udp socket on port 5678 on the public facing ip # Note: you won't necessarily see the same origin port on the # UDP server since GSM networks are usually behind a NAT sock . bind (( \"0.0.0.0\" , 5678 )) for i in range ( 5 ): sock . sendto ( \"Hello \\n \" ,( server_ip , server_port )) sleep ( 1000 ) except Exception as e : print ( \"oops, exception!\" , e ) while True : print ( \".\" ) sleep ( 1000 )","title":"Examples"},{"location":"reference/libs/quectel/m95/docs/examples/#examples","text":"The following are a list of examples for lib.quectel.m95.","title":"Examples"},{"location":"reference/libs/quectel/m95/docs/examples/#secure-socket","text":"A simple example showing how to connect with TLS sockets thanks to UG96 (configured with secure ciphersuites only). main.py ################################################################################ # Zerynth Secure Sockets # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams import json # import the gsm interface from wireless import gsm # import the http module import requests import ssl from quectel.ug96 import ug96 as ug96 streams . serial () try : print ( \"Initializing UG96...\" ) # init the ug96 # pins and serial port must be set according to your setup ug96 . init ( SERIAL3 , D12 , D13 , D67 , D60 , D37 , D38 , 0 ) # change APN name as needed print ( \"Establishing Link...\" ) gsm . attach ( \"YOUR-APN-HERE\" ) # let's try to connect to https://www.howsmyssl.com/a/check to get some info # on the SSL/TLS connection # retrieve the CA certificate used to sign the howsmyssl.com certificate cacert = __lookup ( SSL_CACERT_DST_ROOT_CA_X3 ) # create a SSL context to require server certificate verification ctx = ssl . create_ssl_context ( cacert = cacert , options = ssl . CERT_REQUIRED | ssl . SERVER_AUTH ) # NOTE: if the underlying SSL driver does not support certificate validation # uncomment the following line! # ctx = None for i in range ( 3 ): try : print ( \"Trying to connect...\" ) url = \"https://www.howsmyssl.com/a/check\" # url resolution and http protocol handling are hidden inside the requests module user_agent = { \"User-Agent\" : \"curl/7.53.1\" , \"Accept\" : \"*/*\" } # pass the ssl context together with the request response = requests . get ( url , headers = user_agent , ctx = ctx ) # if we get here, there has been no exception, exit the loop break except Exception as e : print ( e ) try : # check status and print the result if response . status == 200 : print ( \"Success!!\" ) print ( \"-------------\" ) # it's time to parse the json response js = json . loads ( response . content ) # super easy! for k , v in js . items (): if k == \"given_cipher_suites\" : print ( \"Supported Ciphers\" ) for cipher in v : print ( cipher ) print ( \"-----\" ) else : print ( k , \"::\" , v ) print ( \"-------------\" ) except Exception as e : print ( \"ooops, something very wrong! :(\" , e ) except Exception as e : print ( \"oops, exception!\" , e )","title":"Secure Socket"},{"location":"reference/libs/quectel/m95/docs/examples/#udp-socket","text":"A simple project showing how to use UDP sockets with UG96. main.py ################################################################################ # Zerynth UDP Socket # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams import socket # import the gsm interface from wireless import gsm from quectel.ug96 import ug96 as ug96 # For this example to work, you need an UDP server somewhere on the public # internet. You can run this example (https://gist.github.com/Manouchehri/67b53ecdc767919dddf3ec4ea8098b20) # on your cloud instance on the port you prefer for the sake of this test streams . serial () # specify here the IP and port of your UDP server server_ip = \"0.0.0.0\" server_port = 7778 try : print ( \"Initializing UG96...\" ) # init the ug96 # pins and serial port must be set according to your setup ug96 . init ( SERIAL3 , D12 , D13 , D67 , D60 , D37 , D38 , 0 ) # use the wifi interface to link to the Access Point # change network name, security and password as needed print ( \"Establishing Link...\" ) gsm . attach ( \"your-apn-name\" ) print ( \"Trying UDP socket in connect mode\" ) # Let's open an udp socket with connect. # the socket will then be used with send and recv methods # without specifying the receiver address. # The socket will be able to send only to the address # specified in the connect method sock = socket . socket ( type = socket . SOCK_DGRAM , proto = socket . IPPROTO_UDP ) sock . connect (( server_ip , server_port )) for i in range ( 5 ): sock . send ( \"Hello \\n \" ) sleep ( 1000 ) sock . close () print ( \"Trying UDP socket in bind mode\" ) # Let's open an udp socket and configure with bind. # the socket will then be used with sendto and recvfrom methods # specifying the receiver address. # The socket will be able to send to any ip address sock = socket . socket ( type = socket . SOCK_DGRAM , proto = socket . IPPROTO_UDP ) # open the udp socket on port 5678 on the public facing ip # Note: you won't necessarily see the same origin port on the # UDP server since GSM networks are usually behind a NAT sock . bind (( \"0.0.0.0\" , 5678 )) for i in range ( 5 ): sock . sendto ( \"Hello \\n \" ,( server_ip , server_port )) sleep ( 1000 ) except Exception as e : print ( \"oops, exception!\" , e ) while True : print ( \".\" ) sleep ( 1000 )","title":"UDP Socket"},{"location":"reference/libs/quectel/m95/docs/m95/","text":"M95 Module \u00b6 This module implements the Zerynth driver for the Quectel M95 GSM/GPRS modem ( Product page ). The driver must be used together with the standard library GSM Module. The following functionalities are implemented: attach/detach from gprs network retrieve and set available operators retrieve signal strength retrieve network and device info socket abstraction secure sockets RTC clock SM SMS Listening sockets for TCP and UDP protocols are not implemented due to the nature of GSM networks. Moreover, UDP sockets must be connected or bind explicitly in the code to select which kind of function to perform (send vs sendto and recv vs recvfrom). The communication with M95 is performed via UART without hardware flow control at 115200 baud. This module provides the m95Exception to signal errors related to the hardware initialization and management. init \u00b6 init ( serial , dtr , rts , power , kill , status , power_on = LOW , kill_on = LOW , status_on = HIGH ) Initialize the M95 device given the following parameters: serial , the serial port connected to the M95 ( SERIAL1 , SERIAL2 , etc\u2026) dtr , the DTR pin of M95 (not used yet) rts , the RTS pin of M95 (not used yet) power , the power key pin of M95 kill , the emergency off (kill) pin of M95 status , the status pin of M95 power_on , the active level of the power pin (can be HIGH in some pcb designs) kill_on , the active level of the kill pin (can be HIGH in some pcb designs) status_on , the value of status pin indicating successful poweron (can be LOW in some pcb designs) bypass \u00b6 bypass ( mode ) Bypass the modem driver to use the serial port directly. It has one parameter: mode , can be 1 (non-zero) to enter bypass mode, or 0 (zero) to exit. shutdown \u00b6 shutdown ( forced = False ) Power off the module by pulsing the power pin (clean power-down). If forced is given, use emergency off (faster, do not detach from network). startup \u00b6 startup () Power on the module by pulsing the power pin. Network Time \u00b6 The M95 has an internal Real Time Clock that is automatically synchronized with the Network Time. The current time can be retrieved with the following function: rtc \u00b6 rtc () Return a tuple of seven elements: current year current month (1-12) current day (1-31) current hour (0-23) current minute (0-59) current second (0-59) current timezone in minutes away from GMT 0 The returned time is always UTC time with a timezone indication.","title":"M95 Module"},{"location":"reference/libs/quectel/m95/docs/m95/#m95-module","text":"This module implements the Zerynth driver for the Quectel M95 GSM/GPRS modem ( Product page ). The driver must be used together with the standard library GSM Module. The following functionalities are implemented: attach/detach from gprs network retrieve and set available operators retrieve signal strength retrieve network and device info socket abstraction secure sockets RTC clock SM SMS Listening sockets for TCP and UDP protocols are not implemented due to the nature of GSM networks. Moreover, UDP sockets must be connected or bind explicitly in the code to select which kind of function to perform (send vs sendto and recv vs recvfrom). The communication with M95 is performed via UART without hardware flow control at 115200 baud. This module provides the m95Exception to signal errors related to the hardware initialization and management.","title":"M95 Module"},{"location":"reference/libs/quectel/m95/docs/m95/#init","text":"init ( serial , dtr , rts , power , kill , status , power_on = LOW , kill_on = LOW , status_on = HIGH ) Initialize the M95 device given the following parameters: serial , the serial port connected to the M95 ( SERIAL1 , SERIAL2 , etc\u2026) dtr , the DTR pin of M95 (not used yet) rts , the RTS pin of M95 (not used yet) power , the power key pin of M95 kill , the emergency off (kill) pin of M95 status , the status pin of M95 power_on , the active level of the power pin (can be HIGH in some pcb designs) kill_on , the active level of the kill pin (can be HIGH in some pcb designs) status_on , the value of status pin indicating successful poweron (can be LOW in some pcb designs)","title":"init"},{"location":"reference/libs/quectel/m95/docs/m95/#bypass","text":"bypass ( mode ) Bypass the modem driver to use the serial port directly. It has one parameter: mode , can be 1 (non-zero) to enter bypass mode, or 0 (zero) to exit.","title":"bypass"},{"location":"reference/libs/quectel/m95/docs/m95/#shutdown","text":"shutdown ( forced = False ) Power off the module by pulsing the power pin (clean power-down). If forced is given, use emergency off (faster, do not detach from network).","title":"shutdown"},{"location":"reference/libs/quectel/m95/docs/m95/#startup","text":"startup () Power on the module by pulsing the power pin.","title":"startup"},{"location":"reference/libs/quectel/m95/docs/m95/#network-time","text":"The M95 has an internal Real Time Clock that is automatically synchronized with the Network Time. The current time can be retrieved with the following function:","title":"Network Time"},{"location":"reference/libs/quectel/m95/docs/m95/#rtc","text":"rtc () Return a tuple of seven elements: current year current month (1-12) current day (1-31) current hour (0-23) current minute (0-59) current second (0-59) current timezone in minutes away from GMT 0 The returned time is always UTC time with a timezone indication.","title":"rtc"},{"location":"reference/libs/quectel/nmea/docs/","text":"NMEA Module \u00b6 This module implements a Zerynth driver and parser for a generic NMEA GNSS receiver. The following functionalities are implemented: retrieve the current location fix if present retrieve the current UTC time The driver supports reading NMEA sentences from a serial port only. Location fixes are obtained by parsing NMEA sentences of type RMC and GGA, and optionally GSA. Obtaining a fix or UTC time are thread safe operations. Contents: NMEA Module","title":"NMEA Module"},{"location":"reference/libs/quectel/nmea/docs/#nmea-module","text":"This module implements a Zerynth driver and parser for a generic NMEA GNSS receiver. The following functionalities are implemented: retrieve the current location fix if present retrieve the current UTC time The driver supports reading NMEA sentences from a serial port only. Location fixes are obtained by parsing NMEA sentences of type RMC and GGA, and optionally GSA. Obtaining a fix or UTC time are thread safe operations. Contents: NMEA Module","title":"NMEA Module"},{"location":"reference/libs/quectel/nmea/docs/nmea/","text":"NMEA Module \u00b6 This module implements a Zerynth driver and parser for a generic NMEA GNSS receiver. The following functionalities are implemented: retrieve the current location fix if present retrieve the current UTC time The driver supports reading NMEA sentences from a serial port only. Location fixes are obtained by parsing NMEA sentences of type RMC and GGA, and optionally GSA. Obtaining a fix or UTC time are thread safe operations. readline \u00b6 readline ( serial , buffer , timeout = 5000 ) Wait for a full NMEA sentence from the specified serial interface and copy it to the specified buffer (bytearray), with optional timeout (in milliseconds). Returns the length of the NMEA sentence or a negative error code: -1 , if the line does not start with NMEA header (missing '$' ) -2 , if the line has incomplete NMEA sentence (missing '*' ) -3 , if the line has invalid or mismatching NMEA checksum parseline \u00b6 parseline ( buffer , length , tm , fix ) Parse the content of the specified line buffer (bytearray) up to length bytes and fill the two sequences tm and fix with date/time and fix data if available. Returned value is 0 if the line does not have valid data, or a combination (sum) of: 4 , if the tm sequence (7 items) has been filled (from RMC sentence) 1 , 2 or 3 , if the fix sequence (9 items) has been filled (from RMC, GGA or GSA respectively) class NMEA_Receiver \u00b6 class NMEA_Receiver () This class is meant to be used as a base class to provide a uniform interface for GNSS receivers. Instances of this class are fed with NMEA sentences using the parse method and can be queried for UTC time and location data. The parser can be disabled to clear acquired data and to prevent further updates until it is enabled again (to avoid stale data). NMEA_Receiver.fix \u00b6 fix () Return the current fix or None if not available. A fix is a tuple with the following elements: latitude in decimal format (-89.9999 - 89.9999) longitude in decimal format (-179.9999 - 179.9999) altitude in meters speed in Km/h course over ground as degrees from true north number of satellites for this fix horizontal dilution of precision (0.5 - 99.9) vertical dilution of precision (0.5 - 99.9) positional dilution of precision (0.5 - 99.9) UTC time as a tuple (yyyy,MM,dd,hh,mm,ss,microseconds) **has_fix() ** Return True if a fix is available. NMEA_Receiver.utc \u00b6 utc () Return the current UTC time or None if not available. A UTC time is a tuple of (yyyy,MM,dd,hh,mm,ss,microseconds). UTC time can be wrong if no fix has ever been obtained. NMEA_Receiver.has_utc \u00b6 has_utc () Return True if a UTC time is available. NMEA_Receiver.enable \u00b6 enable ( state ) Enable or disable the NMEA parser. Also clear any acquired position fix or UTC data when disabled. NMEA_Receiver.parse \u00b6 parse ( buffer , count ) Parse count bytes from the specified buffer (bytearray) and updates the internal state from valid NMEA sentences found (when enabled).","title":"NMEA Module"},{"location":"reference/libs/quectel/nmea/docs/nmea/#nmea-module","text":"This module implements a Zerynth driver and parser for a generic NMEA GNSS receiver. The following functionalities are implemented: retrieve the current location fix if present retrieve the current UTC time The driver supports reading NMEA sentences from a serial port only. Location fixes are obtained by parsing NMEA sentences of type RMC and GGA, and optionally GSA. Obtaining a fix or UTC time are thread safe operations.","title":"NMEA Module"},{"location":"reference/libs/quectel/nmea/docs/nmea/#readline","text":"readline ( serial , buffer , timeout = 5000 ) Wait for a full NMEA sentence from the specified serial interface and copy it to the specified buffer (bytearray), with optional timeout (in milliseconds). Returns the length of the NMEA sentence or a negative error code: -1 , if the line does not start with NMEA header (missing '$' ) -2 , if the line has incomplete NMEA sentence (missing '*' ) -3 , if the line has invalid or mismatching NMEA checksum","title":"readline"},{"location":"reference/libs/quectel/nmea/docs/nmea/#parseline","text":"parseline ( buffer , length , tm , fix ) Parse the content of the specified line buffer (bytearray) up to length bytes and fill the two sequences tm and fix with date/time and fix data if available. Returned value is 0 if the line does not have valid data, or a combination (sum) of: 4 , if the tm sequence (7 items) has been filled (from RMC sentence) 1 , 2 or 3 , if the fix sequence (9 items) has been filled (from RMC, GGA or GSA respectively)","title":"parseline"},{"location":"reference/libs/quectel/nmea/docs/nmea/#class-nmea_receiver","text":"class NMEA_Receiver () This class is meant to be used as a base class to provide a uniform interface for GNSS receivers. Instances of this class are fed with NMEA sentences using the parse method and can be queried for UTC time and location data. The parser can be disabled to clear acquired data and to prevent further updates until it is enabled again (to avoid stale data).","title":"class NMEA_Receiver"},{"location":"reference/libs/quectel/nmea/docs/nmea/#nmea_receiverfix","text":"fix () Return the current fix or None if not available. A fix is a tuple with the following elements: latitude in decimal format (-89.9999 - 89.9999) longitude in decimal format (-179.9999 - 179.9999) altitude in meters speed in Km/h course over ground as degrees from true north number of satellites for this fix horizontal dilution of precision (0.5 - 99.9) vertical dilution of precision (0.5 - 99.9) positional dilution of precision (0.5 - 99.9) UTC time as a tuple (yyyy,MM,dd,hh,mm,ss,microseconds) **has_fix() ** Return True if a fix is available.","title":"NMEA_Receiver.fix"},{"location":"reference/libs/quectel/nmea/docs/nmea/#nmea_receiverutc","text":"utc () Return the current UTC time or None if not available. A UTC time is a tuple of (yyyy,MM,dd,hh,mm,ss,microseconds). UTC time can be wrong if no fix has ever been obtained.","title":"NMEA_Receiver.utc"},{"location":"reference/libs/quectel/nmea/docs/nmea/#nmea_receiverhas_utc","text":"has_utc () Return True if a UTC time is available.","title":"NMEA_Receiver.has_utc"},{"location":"reference/libs/quectel/nmea/docs/nmea/#nmea_receiverenable","text":"enable ( state ) Enable or disable the NMEA parser. Also clear any acquired position fix or UTC data when disabled.","title":"NMEA_Receiver.enable"},{"location":"reference/libs/quectel/nmea/docs/nmea/#nmea_receiverparse","text":"parse ( buffer , count ) Parse count bytes from the specified buffer (bytearray) and updates the internal state from valid NMEA sentences found (when enabled).","title":"NMEA_Receiver.parse"},{"location":"reference/libs/quectel/ug96/docs/","text":"Quectel UG96 \u00b6 This module implements the Zerynth driver for the Quectel UG95/UG96 UMTS/HSPA chip ( Product page ). The driver must be used together with the standard library GSM Module . Contents: UG96 Module Network Time Examples Secure Socket UDP Socket","title":"Quectel UG96"},{"location":"reference/libs/quectel/ug96/docs/#quectel-ug96","text":"This module implements the Zerynth driver for the Quectel UG95/UG96 UMTS/HSPA chip ( Product page ). The driver must be used together with the standard library GSM Module . Contents: UG96 Module Network Time Examples Secure Socket UDP Socket","title":"Quectel UG96"},{"location":"reference/libs/quectel/ug96/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.quectel.ug96. Secure Socket \u00b6 A simple example showing how to connect with TLS sockets thanks to UG96 (configured with secure ciphersuites only). main.py ################################################################################ # Zerynth Secure Sockets # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams import json # import the gsm interface from wireless import gsm # import the http module import requests import ssl from quectel.ug96 import ug96 as ug96 streams . serial () try : print ( \"Initializing UG96...\" ) # init the ug96 # pins and serial port must be set according to your setup ug96 . init ( SERIAL3 , D12 , D13 , D67 , D60 , D37 , D38 , 0 ) # change APN name as needed print ( \"Establishing Link...\" ) gsm . attach ( \"YOUR-APN-HERE\" ) # let's try to connect to https://www.howsmyssl.com/a/check to get some info # on the SSL/TLS connection # retrieve the CA certificate used to sign the howsmyssl.com certificate cacert = __lookup ( SSL_CACERT_DST_ROOT_CA_X3 ) # create a SSL context to require server certificate verification ctx = ssl . create_ssl_context ( cacert = cacert , options = ssl . CERT_REQUIRED | ssl . SERVER_AUTH ) # NOTE: if the underlying SSL driver does not support certificate validation # uncomment the following line! # ctx = None for i in range ( 3 ): try : print ( \"Trying to connect...\" ) url = \"https://www.howsmyssl.com/a/check\" # url resolution and http protocol handling are hidden inside the requests module user_agent = { \"User-Agent\" : \"curl/7.53.1\" , \"Accept\" : \"*/*\" } # pass the ssl context together with the request response = requests . get ( url , headers = user_agent , ctx = ctx ) # if we get here, there has been no exception, exit the loop break except Exception as e : print ( e ) try : # check status and print the result if response . status == 200 : print ( \"Success!!\" ) print ( \"-------------\" ) # it's time to parse the json response js = json . loads ( response . content ) # super easy! for k , v in js . items (): if k == \"given_cipher_suites\" : print ( \"Supported Ciphers\" ) for cipher in v : print ( cipher ) print ( \"-----\" ) else : print ( k , \"::\" , v ) print ( \"-------------\" ) except Exception as e : print ( \"ooops, something very wrong! :(\" , e ) except Exception as e : print ( \"oops, exception!\" , e ) UDP Socket \u00b6 A simple project showing how to use UDP sockets with UG96. main.py ################################################################################ # Zerynth UDP Socket # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams import socket # import the gsm interface from wireless import gsm from quectel.ug96 import ug96 as ug96 # For this example to work, you need an UDP server somewhere on the public # internet. You can run this example (https://gist.github.com/Manouchehri/67b53ecdc767919dddf3ec4ea8098b20) # on your cloud instance on the port you prefer for the sake of this test streams . serial () # specify here the IP and port of your UDP server server_ip = \"0.0.0.0\" server_port = 7778 try : print ( \"Initializing UG96...\" ) # init the ug96 # pins and serial port must be set according to your setup ug96 . init ( SERIAL3 , D12 , D13 , D67 , D60 , D37 , D38 , 0 ) # use the wifi interface to link to the Access Point # change network name, security and password as needed print ( \"Establishing Link...\" ) gsm . attach ( \"your-apn-name\" ) print ( \"Trying UDP socket in connect mode\" ) # Let's open an udp socket with connect. # the socket will then be used with send and recv methods # without specifying the receiver address. # The socket will be able to send only to the address # specified in the connect method sock = socket . socket ( type = socket . SOCK_DGRAM , proto = socket . IPPROTO_UDP ) sock . connect (( server_ip , server_port )) for i in range ( 5 ): sock . send ( \"Hello \\n \" ) sleep ( 1000 ) sock . close () print ( \"Trying UDP socket in bind mode\" ) # Let's open an udp socket and configure with bind. # the socket will then be used with sendto and recvfrom methods # specifying the receiver address. # The socket will be able to send to any ip address sock = socket . socket ( type = socket . SOCK_DGRAM , proto = socket . IPPROTO_UDP ) # open the udp socket on port 5678 on the public facing ip # Note: you won't necessarily see the same origin port on the # UDP server since GSM networks are usually behind a NAT sock . bind (( \"0.0.0.0\" , 5678 )) for i in range ( 5 ): sock . sendto ( \"Hello \\n \" ,( server_ip , server_port )) sleep ( 1000 ) except Exception as e : print ( \"oops, exception!\" , e ) while True : print ( \".\" ) sleep ( 1000 )","title":"Examples"},{"location":"reference/libs/quectel/ug96/docs/examples/#examples","text":"The following are a list of examples for lib.quectel.ug96.","title":"Examples"},{"location":"reference/libs/quectel/ug96/docs/examples/#secure-socket","text":"A simple example showing how to connect with TLS sockets thanks to UG96 (configured with secure ciphersuites only). main.py ################################################################################ # Zerynth Secure Sockets # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams import json # import the gsm interface from wireless import gsm # import the http module import requests import ssl from quectel.ug96 import ug96 as ug96 streams . serial () try : print ( \"Initializing UG96...\" ) # init the ug96 # pins and serial port must be set according to your setup ug96 . init ( SERIAL3 , D12 , D13 , D67 , D60 , D37 , D38 , 0 ) # change APN name as needed print ( \"Establishing Link...\" ) gsm . attach ( \"YOUR-APN-HERE\" ) # let's try to connect to https://www.howsmyssl.com/a/check to get some info # on the SSL/TLS connection # retrieve the CA certificate used to sign the howsmyssl.com certificate cacert = __lookup ( SSL_CACERT_DST_ROOT_CA_X3 ) # create a SSL context to require server certificate verification ctx = ssl . create_ssl_context ( cacert = cacert , options = ssl . CERT_REQUIRED | ssl . SERVER_AUTH ) # NOTE: if the underlying SSL driver does not support certificate validation # uncomment the following line! # ctx = None for i in range ( 3 ): try : print ( \"Trying to connect...\" ) url = \"https://www.howsmyssl.com/a/check\" # url resolution and http protocol handling are hidden inside the requests module user_agent = { \"User-Agent\" : \"curl/7.53.1\" , \"Accept\" : \"*/*\" } # pass the ssl context together with the request response = requests . get ( url , headers = user_agent , ctx = ctx ) # if we get here, there has been no exception, exit the loop break except Exception as e : print ( e ) try : # check status and print the result if response . status == 200 : print ( \"Success!!\" ) print ( \"-------------\" ) # it's time to parse the json response js = json . loads ( response . content ) # super easy! for k , v in js . items (): if k == \"given_cipher_suites\" : print ( \"Supported Ciphers\" ) for cipher in v : print ( cipher ) print ( \"-----\" ) else : print ( k , \"::\" , v ) print ( \"-------------\" ) except Exception as e : print ( \"ooops, something very wrong! :(\" , e ) except Exception as e : print ( \"oops, exception!\" , e )","title":"Secure Socket"},{"location":"reference/libs/quectel/ug96/docs/examples/#udp-socket","text":"A simple project showing how to use UDP sockets with UG96. main.py ################################################################################ # Zerynth UDP Socket # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import streams import socket # import the gsm interface from wireless import gsm from quectel.ug96 import ug96 as ug96 # For this example to work, you need an UDP server somewhere on the public # internet. You can run this example (https://gist.github.com/Manouchehri/67b53ecdc767919dddf3ec4ea8098b20) # on your cloud instance on the port you prefer for the sake of this test streams . serial () # specify here the IP and port of your UDP server server_ip = \"0.0.0.0\" server_port = 7778 try : print ( \"Initializing UG96...\" ) # init the ug96 # pins and serial port must be set according to your setup ug96 . init ( SERIAL3 , D12 , D13 , D67 , D60 , D37 , D38 , 0 ) # use the wifi interface to link to the Access Point # change network name, security and password as needed print ( \"Establishing Link...\" ) gsm . attach ( \"your-apn-name\" ) print ( \"Trying UDP socket in connect mode\" ) # Let's open an udp socket with connect. # the socket will then be used with send and recv methods # without specifying the receiver address. # The socket will be able to send only to the address # specified in the connect method sock = socket . socket ( type = socket . SOCK_DGRAM , proto = socket . IPPROTO_UDP ) sock . connect (( server_ip , server_port )) for i in range ( 5 ): sock . send ( \"Hello \\n \" ) sleep ( 1000 ) sock . close () print ( \"Trying UDP socket in bind mode\" ) # Let's open an udp socket and configure with bind. # the socket will then be used with sendto and recvfrom methods # specifying the receiver address. # The socket will be able to send to any ip address sock = socket . socket ( type = socket . SOCK_DGRAM , proto = socket . IPPROTO_UDP ) # open the udp socket on port 5678 on the public facing ip # Note: you won't necessarily see the same origin port on the # UDP server since GSM networks are usually behind a NAT sock . bind (( \"0.0.0.0\" , 5678 )) for i in range ( 5 ): sock . sendto ( \"Hello \\n \" ,( server_ip , server_port )) sleep ( 1000 ) except Exception as e : print ( \"oops, exception!\" , e ) while True : print ( \".\" ) sleep ( 1000 )","title":"UDP Socket"},{"location":"reference/libs/quectel/ug96/docs/ug96/","text":"UG96 Module \u00b6 This module implements the Zerynth driver for the Quectel UG95/UG96 UMTS/HSPA modem ( Product page ). The driver must be used together with the standard library GSM Module . The following functionalities are implemented: attach/detach from gprs network retrieve and set available operators retrieve signal strength retrieve network and device info socket abstraction secure sockets RTC clock SM SMS Listening sockets for TCP and UDP protocols are not implemented due to the nature of GSM networks. Moreover, UDP sockets must be connected or bound explicitly in the code to select which kind of function to perform (send vs sendto and recv vs recvfrom). The communication with UG96 is performed via UART without hardware flow control at 115200 baud. This module provides the ug96Exception to signal errors related to the hardware initialization and management. init \u00b6 init ( serial , dtr , rts , power , kill , status , power_on = LOW , kill_on = LOW , status_on = HIGH ) Initialize the UG96 device given the following parameters: serial , the serial port connected to the UG96 ( SERIAL1 , SERIAL2 , etc\u2026) dtr , the DTR pin of UG96 (not used yet) rts , the RTS pin of UG96 (not used yet) power , the power up pin of UG96 kill , the emergency off (kill) pin of UG96 status , the status pin of UG96 power_on , the active level of the power up pin kill_on , the active level of the kill pin status_on , the value of status pin indicating successful power on (can be zero in some pcb designs) bypass \u00b6 bypass ( mode ) Bypass the modem driver to use the serial port directly. It has one parameter: mode , can be 1 (non-zero) to enter bypass mode, or 0 (zero) to exit. shutdown \u00b6 shutdown ( forced = False ) Power off the module by sending AT command (clean power-down). If forced is given, use emergency off (faster, do not detach from network). startup \u00b6 startup () Power on the module by pulsing the power pin. Network Time \u00b6 The UG96 has an internal Real Time Clock that is automatically synchronized with the Network Time. The current time can be retrieved with the following function: rtc \u00b6 rtc () Return a tuple of seven elements: current year current month (1-12) current day (1-31) current hour (0-23) current minute (0-59) current second (0-59) current timezone in minutes away from GMT 0 The returned time is always UTC time with a timezone indication.","title":"UG96 Module"},{"location":"reference/libs/quectel/ug96/docs/ug96/#ug96-module","text":"This module implements the Zerynth driver for the Quectel UG95/UG96 UMTS/HSPA modem ( Product page ). The driver must be used together with the standard library GSM Module . The following functionalities are implemented: attach/detach from gprs network retrieve and set available operators retrieve signal strength retrieve network and device info socket abstraction secure sockets RTC clock SM SMS Listening sockets for TCP and UDP protocols are not implemented due to the nature of GSM networks. Moreover, UDP sockets must be connected or bound explicitly in the code to select which kind of function to perform (send vs sendto and recv vs recvfrom). The communication with UG96 is performed via UART without hardware flow control at 115200 baud. This module provides the ug96Exception to signal errors related to the hardware initialization and management.","title":"UG96 Module"},{"location":"reference/libs/quectel/ug96/docs/ug96/#init","text":"init ( serial , dtr , rts , power , kill , status , power_on = LOW , kill_on = LOW , status_on = HIGH ) Initialize the UG96 device given the following parameters: serial , the serial port connected to the UG96 ( SERIAL1 , SERIAL2 , etc\u2026) dtr , the DTR pin of UG96 (not used yet) rts , the RTS pin of UG96 (not used yet) power , the power up pin of UG96 kill , the emergency off (kill) pin of UG96 status , the status pin of UG96 power_on , the active level of the power up pin kill_on , the active level of the kill pin status_on , the value of status pin indicating successful power on (can be zero in some pcb designs)","title":"init"},{"location":"reference/libs/quectel/ug96/docs/ug96/#bypass","text":"bypass ( mode ) Bypass the modem driver to use the serial port directly. It has one parameter: mode , can be 1 (non-zero) to enter bypass mode, or 0 (zero) to exit.","title":"bypass"},{"location":"reference/libs/quectel/ug96/docs/ug96/#shutdown","text":"shutdown ( forced = False ) Power off the module by sending AT command (clean power-down). If forced is given, use emergency off (faster, do not detach from network).","title":"shutdown"},{"location":"reference/libs/quectel/ug96/docs/ug96/#startup","text":"startup () Power on the module by pulsing the power pin.","title":"startup"},{"location":"reference/libs/quectel/ug96/docs/ug96/#network-time","text":"The UG96 has an internal Real Time Clock that is automatically synchronized with the Network Time. The current time can be retrieved with the following function:","title":"Network Time"},{"location":"reference/libs/quectel/ug96/docs/ug96/#rtc","text":"rtc () Return a tuple of seven elements: current year current month (1-12) current day (1-31) current hour (0-23) current minute (0-59) current second (0-59) current timezone in minutes away from GMT 0 The returned time is always UTC time with a timezone indication.","title":"rtc"},{"location":"reference/libs/riverdi/displays/docs/","text":"Riverdi Displays \u00b6 Riverdi Display Modules are high-quality cost-effective displays for use in consumer or industrial applications. Its displays are usually powered by graphics controllers. This library includes modules to be imported to automatically set the right configuration for a chosen display powered by a graphics controller supported by Zerynth. For example to start programming a Riverdi display mydisplay with controller mycontroller from producer myproducer , the following lines are sufficient: from riverdi.displays.mycontroller import mydisplay from myproducer.mycontroller import mycontroller Below a list of supported controllers and available displays: Bridgetek BT81x (bridgetek.bt81x) Riverdi Capacitive 5\u201d (ctp50) Riverdi Capacitive 7\u201d (ctp70) Riverdi Resistive 5\u201d (rtp50) Riverdi Resistive 7\u201d (rtp70)","title":"Index"},{"location":"reference/libs/riverdi/displays/docs/#riverdi-displays","text":"Riverdi Display Modules are high-quality cost-effective displays for use in consumer or industrial applications. Its displays are usually powered by graphics controllers. This library includes modules to be imported to automatically set the right configuration for a chosen display powered by a graphics controller supported by Zerynth. For example to start programming a Riverdi display mydisplay with controller mycontroller from producer myproducer , the following lines are sufficient: from riverdi.displays.mycontroller import mydisplay from myproducer.mycontroller import mycontroller Below a list of supported controllers and available displays: Bridgetek BT81x (bridgetek.bt81x) Riverdi Capacitive 5\u201d (ctp50) Riverdi Capacitive 7\u201d (ctp70) Riverdi Resistive 5\u201d (rtp50) Riverdi Resistive 7\u201d (rtp70)","title":"Riverdi Displays"},{"location":"reference/libs/semtech/sx1503/docs/","text":"Semtech SX1503 \u00b6 The SX1503 is a 16 channels General Purpose parallel Input/Output expander. More information at Semtech dedicated page . Technical Details \u00b6 16 channels of I/Os 1.2 V to 5.5 V independent operating voltage for all supply rails 400 kHz I2C interface Ultra low current consumption of typ. 1 uA Temperature range: -40 - +85 \u00b0C Here below, the Zerynth driver for the Semtech SX1503. Contents: SX1503 Module SX1503 class","title":"Semtech SX1503"},{"location":"reference/libs/semtech/sx1503/docs/#semtech-sx1503","text":"The SX1503 is a 16 channels General Purpose parallel Input/Output expander. More information at Semtech dedicated page .","title":"Semtech SX1503"},{"location":"reference/libs/semtech/sx1503/docs/#technical-details","text":"16 channels of I/Os 1.2 V to 5.5 V independent operating voltage for all supply rails 400 kHz I2C interface Ultra low current consumption of typ. 1 uA Temperature range: -40 - +85 \u00b0C Here below, the Zerynth driver for the Semtech SX1503. Contents: SX1503 Module SX1503 class","title":"Technical Details"},{"location":"reference/libs/semtech/sx1503/docs/sx1503/","text":"SX1503 Module \u00b6 This module contains the Zerynth driver for Semtech SX1503 low voltage General Purpose parallel Input/Output. The unit allows easy serial expansion of I/O through a standard 400kHz I2C interface. Interrupt handling and programmable logic functions are not implemented ( datasheet ). SX1503 class \u00b6 class SX1503(drvname, clk=400000)` Creates an intance of the SX1503 class. Arguments: drvname \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 clk \u2013 Clock speed, default 400kHz Example: from semtech.sx1503 import sx1503 ... port_expander = sx1503 . SX1503 ( I2C1 ) port_expander . pinMode ( 10 , INPUT_PULLUP ) state = port_expander . digitalRead ( 10 ) port_expander . pinMode ( 0 , OUTPUT ) port_expander . digitalWrite ( 0 , HIGH ) pinMode \u00b6 pinMode ( pin , mode ) Select a mode for a pin. Valid pin values are from 0 to 15 included. Available modes are: INPUT INPUT_PULLUP INPUT_PULLDOWN OUTPUT get_port \u00b6 get_port ( port ) Returns the state of all pins on port port . As a consequence of having 8 pins for port, returned value can be between 0 and 255 . port I/O bank pins 0 A 0 to 7 1 B 8 to 15 digitalRead \u00b6 digitalRead ( pin ) Returns the state of pin pin . The state can be 0 or 1 . digitalWrite \u00b6 digitalWrite ( pin , val ) Set pin pin to value val . Value can be 0 or 1 . set_port \u00b6 set_port ( port , val ) Set all pins on port port to value val . val MUST be between 0 and 255 . set_boost \u00b6 set_boost ( mode ) Set the boost mode (cfr. par 2.2.1 of the datasheet). mode boost mode 0 OFF 1 ON <!--stackedit_data: eyJoaXN0b3J5IjpbLTgxMDQyNDM0OV19 \u2192","title":"SX1503 Module"},{"location":"reference/libs/semtech/sx1503/docs/sx1503/#sx1503-module","text":"This module contains the Zerynth driver for Semtech SX1503 low voltage General Purpose parallel Input/Output. The unit allows easy serial expansion of I/O through a standard 400kHz I2C interface. Interrupt handling and programmable logic functions are not implemented ( datasheet ).","title":"SX1503 Module"},{"location":"reference/libs/semtech/sx1503/docs/sx1503/#sx1503-class","text":"class SX1503(drvname, clk=400000)` Creates an intance of the SX1503 class. Arguments: drvname \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 clk \u2013 Clock speed, default 400kHz Example: from semtech.sx1503 import sx1503 ... port_expander = sx1503 . SX1503 ( I2C1 ) port_expander . pinMode ( 10 , INPUT_PULLUP ) state = port_expander . digitalRead ( 10 ) port_expander . pinMode ( 0 , OUTPUT ) port_expander . digitalWrite ( 0 , HIGH )","title":"SX1503 class"},{"location":"reference/libs/semtech/sx1503/docs/sx1503/#pinmode","text":"pinMode ( pin , mode ) Select a mode for a pin. Valid pin values are from 0 to 15 included. Available modes are: INPUT INPUT_PULLUP INPUT_PULLDOWN OUTPUT","title":"pinMode"},{"location":"reference/libs/semtech/sx1503/docs/sx1503/#get_port","text":"get_port ( port ) Returns the state of all pins on port port . As a consequence of having 8 pins for port, returned value can be between 0 and 255 . port I/O bank pins 0 A 0 to 7 1 B 8 to 15","title":"get_port"},{"location":"reference/libs/semtech/sx1503/docs/sx1503/#digitalread","text":"digitalRead ( pin ) Returns the state of pin pin . The state can be 0 or 1 .","title":"digitalRead"},{"location":"reference/libs/semtech/sx1503/docs/sx1503/#digitalwrite","text":"digitalWrite ( pin , val ) Set pin pin to value val . Value can be 0 or 1 .","title":"digitalWrite"},{"location":"reference/libs/semtech/sx1503/docs/sx1503/#set_port","text":"set_port ( port , val ) Set all pins on port port to value val . val MUST be between 0 and 255 .","title":"set_port"},{"location":"reference/libs/semtech/sx1503/docs/sx1503/#set_boost","text":"set_boost ( mode ) Set the boost mode (cfr. par 2.2.1 of the datasheet). mode boost mode 0 OFF 1 ON <!--stackedit_data: eyJoaXN0b3J5IjpbLTgxMDQyNDM0OV19 \u2192","title":"set_boost"},{"location":"reference/libs/siemens/s7/docs/","text":"Siemens S7 Communication Protocol \u00b6 S7 (Communication) is a Siemens proprietary protocol that runs between Siemens programmable logic controllers (PLCs). It can be used to access data from and write data to PLCs. The Zerynth Siemens S7 Communication Protocol Library is based on the Snap7 Open Source Library. Contents: Siemens S7 Communication Protocol Library The Client class Library Functions Examples DB write and read","title":"Siemens S7 Communication Protocol"},{"location":"reference/libs/siemens/s7/docs/#siemens-s7-communication-protocol","text":"S7 (Communication) is a Siemens proprietary protocol that runs between Siemens programmable logic controllers (PLCs). It can be used to access data from and write data to PLCs. The Zerynth Siemens S7 Communication Protocol Library is based on the Snap7 Open Source Library. Contents: Siemens S7 Communication Protocol Library The Client class Library Functions Examples DB write and read","title":"Siemens S7 Communication Protocol"},{"location":"reference/libs/siemens/s7/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.siemens.s7. DB write and read \u00b6 Connect to an S7 server and start writing and reading from selected DB areas. main.py # DB write and read # Created at 2018-01-26 08:57:41.878149 import streams from espressif.esp32net import esp32wifi as wifi_driver from wireless import wifi from siemens.s7 import s7 streams . serial () wifi_driver . auto_init () s7 . init () print ( 'link' ) wifi . link ( \"SSID\" , wifi . WIFI_WPA2 , \"PSW\" ) print ( 'connect to s7 server' ) # N.B. ip is converted using underlying driver inet_aton, for esp32 needs third address part to contain three digits! # e.g. 192.168.1.1 is not considered valid, while 192.168.001.1 is accepted req , neg = s7 . client . connect ( '192.168.106.172' ) print ( 'connected! PDU req/neg: %i / %i ' % ( req , neg )) buff = s7 . client . readarea ( s7 . S7AreaDB , 1 , 0 , 10 ) print ( '-' . join ([ str ( xx ) for xx in buff ])) try : s7 . client . writearea ( s7 . S7AreaDB , 1 , 0 , bytes ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ])) except Exception as e : print ( e ) buff = s7 . client . readarea ( s7 . S7AreaDB , 1 , 0 , 10 ) print ( '-' . join ([ str ( xx ) for xx in buff ])) items = (( s7 . S7AreaDB , 1 , 16 , bytes ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ])), ( s7 . S7AreaDB , 2 , 16 , bytes ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ]))) s7 . client . writemultivars ( items ) items = (( s7 . S7AreaDB , 1 , 16 , 10 ), ( s7 . S7AreaDB , 2 , 16 , 10 )) bufs = s7 . client . readmultivars ( items ) print ( len ( bufs )) if len ( bufs ) > 1 : for buf in bufs : print ( len ( buf )) print ( '-' . join ([ str ( xx ) for xx in buf ]))","title":"Examples"},{"location":"reference/libs/siemens/s7/docs/examples/#examples","text":"The following are a list of examples for lib.siemens.s7.","title":"Examples"},{"location":"reference/libs/siemens/s7/docs/examples/#db-write-and-read","text":"Connect to an S7 server and start writing and reading from selected DB areas. main.py # DB write and read # Created at 2018-01-26 08:57:41.878149 import streams from espressif.esp32net import esp32wifi as wifi_driver from wireless import wifi from siemens.s7 import s7 streams . serial () wifi_driver . auto_init () s7 . init () print ( 'link' ) wifi . link ( \"SSID\" , wifi . WIFI_WPA2 , \"PSW\" ) print ( 'connect to s7 server' ) # N.B. ip is converted using underlying driver inet_aton, for esp32 needs third address part to contain three digits! # e.g. 192.168.1.1 is not considered valid, while 192.168.001.1 is accepted req , neg = s7 . client . connect ( '192.168.106.172' ) print ( 'connected! PDU req/neg: %i / %i ' % ( req , neg )) buff = s7 . client . readarea ( s7 . S7AreaDB , 1 , 0 , 10 ) print ( '-' . join ([ str ( xx ) for xx in buff ])) try : s7 . client . writearea ( s7 . S7AreaDB , 1 , 0 , bytes ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ])) except Exception as e : print ( e ) buff = s7 . client . readarea ( s7 . S7AreaDB , 1 , 0 , 10 ) print ( '-' . join ([ str ( xx ) for xx in buff ])) items = (( s7 . S7AreaDB , 1 , 16 , bytes ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ])), ( s7 . S7AreaDB , 2 , 16 , bytes ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ]))) s7 . client . writemultivars ( items ) items = (( s7 . S7AreaDB , 1 , 16 , 10 ), ( s7 . S7AreaDB , 2 , 16 , 10 )) bufs = s7 . client . readmultivars ( items ) print ( len ( bufs )) if len ( bufs ) > 1 : for buf in bufs : print ( len ( buf )) print ( '-' . join ([ str ( xx ) for xx in buf ]))","title":"DB write and read"},{"location":"reference/libs/siemens/s7/docs/s7/","text":"Siemens S7 Communication Protocol Library \u00b6 The Zerynth Siemens S7 Communication Protocol Library can be used to ease the connection to a Siemens Programmable Logic Controller (PLC) hosting an S7 Server instance. It allows to make your device act as an S7 client which can connect to the server and start interacting with it. Important Siemens S7 Communication Protocol Library is supported only for ESP32 devices. The library instantiates a Client() object when init() function is called, the object is then accessible through client variable: import s7 s7 . init () s7 . client . connect ( my_addr ) The Client class \u00b6 class Client \u00b6 class Client () Create an S7 client. Since only one client can be active, creation is automatically handled by init() module function. Client.connect \u00b6 connect ( addr , rack = 0 , slot = 2 ) Arguments: addr \u2013 S7 server address rack \u2013 S7 server rack slot \u2013 S7 server slot Connect to S7 server. Client.readarea \u00b6 readarea ( area , dbnumber , start , amount ) Arguments: area \u2013 S7 server area to read dbnumber \u2013 S7 server db to read, ignored if area != S7AreaDB start \u2013 read offset amount \u2013 read amount as number of words to read, note that different areas have different wordsize (automatically handled by the library) Read an S7 server area. Returns a bytes or a shorts object whether chosen area has a wordsize of a single byte or two bytes. Client.writearea \u00b6 writearea ( area , dbnumber , start , buf ) Arguments: area \u2013 S7 server area to read dbnumber \u2013 S7 server db to read, ignored if area != S7AreaDB start \u2013 write offset buf \u2013 buffer to write, must be a bytarray or a shortarray whether chosen area has a wordsize of a single byte or two bytes. Write buf to an S7 server area. Client.readmultivars \u00b6 readmultivars ( items ) Arguments: items \u2013 read descriptors. Perform multiple reads within a single call. A tuple of read descriptors must be passed, containing tuples describing each read step: items = (( s7 . S7AreaDB , 1 , 16 , 10 ), ( s7 . S7AreaDB , 2 , 16 , 10 )) bufs = s7 . client . readmultivars ( items ) The above example defines a tuple item containig two descriptors, the first one to read from DB area, from DB number 1, with an offset of 16, and amount of 10. The second to perform the same operation but on DB number 2. As it is clear in the example, descriptor params have to be placed in the same order (and with the same meaning) expected by readarea() method. Returns a tuple of bytes or shorts objects each corresponding to a single read result. Client.writemultivars \u00b6 writemultivars ( items ) Arguments: items \u2013 write descriptors. Perform multiple writes withing a single call. A tuple of write descriptors must be passed, containing tuples describing each write step: items = (( s7 . S7AreaDB , 1 , 16 , bytes ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ])), ( s7 . S7AreaDB , 2 , 16 , bytes ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ]))) s7 . client . writemultivars ( items ) The above example defines a tuple item containig two descriptors, the first one to write to DB area, DB number 1, with an offset of 16, the sequence of bytes [1,2,3,4,5,6,7,8] . The second to perform the same operation but on DB number 2. As it is clear in the example, descriptor params have to be placed in the same order (and with the same meaning) expected by writearea() method. Library Functions \u00b6 init \u00b6 init () Init module, after this call client global variable is available containing a Client() instance.","title":"Siemens S7 Communication Protocol Library"},{"location":"reference/libs/siemens/s7/docs/s7/#siemens-s7-communication-protocol-library","text":"The Zerynth Siemens S7 Communication Protocol Library can be used to ease the connection to a Siemens Programmable Logic Controller (PLC) hosting an S7 Server instance. It allows to make your device act as an S7 client which can connect to the server and start interacting with it. Important Siemens S7 Communication Protocol Library is supported only for ESP32 devices. The library instantiates a Client() object when init() function is called, the object is then accessible through client variable: import s7 s7 . init () s7 . client . connect ( my_addr )","title":"Siemens S7 Communication Protocol Library"},{"location":"reference/libs/siemens/s7/docs/s7/#the-client-class","text":"","title":"The Client class"},{"location":"reference/libs/siemens/s7/docs/s7/#class-client","text":"class Client () Create an S7 client. Since only one client can be active, creation is automatically handled by init() module function.","title":"class Client"},{"location":"reference/libs/siemens/s7/docs/s7/#clientconnect","text":"connect ( addr , rack = 0 , slot = 2 ) Arguments: addr \u2013 S7 server address rack \u2013 S7 server rack slot \u2013 S7 server slot Connect to S7 server.","title":"Client.connect"},{"location":"reference/libs/siemens/s7/docs/s7/#clientreadarea","text":"readarea ( area , dbnumber , start , amount ) Arguments: area \u2013 S7 server area to read dbnumber \u2013 S7 server db to read, ignored if area != S7AreaDB start \u2013 read offset amount \u2013 read amount as number of words to read, note that different areas have different wordsize (automatically handled by the library) Read an S7 server area. Returns a bytes or a shorts object whether chosen area has a wordsize of a single byte or two bytes.","title":"Client.readarea"},{"location":"reference/libs/siemens/s7/docs/s7/#clientwritearea","text":"writearea ( area , dbnumber , start , buf ) Arguments: area \u2013 S7 server area to read dbnumber \u2013 S7 server db to read, ignored if area != S7AreaDB start \u2013 write offset buf \u2013 buffer to write, must be a bytarray or a shortarray whether chosen area has a wordsize of a single byte or two bytes. Write buf to an S7 server area.","title":"Client.writearea"},{"location":"reference/libs/siemens/s7/docs/s7/#clientreadmultivars","text":"readmultivars ( items ) Arguments: items \u2013 read descriptors. Perform multiple reads within a single call. A tuple of read descriptors must be passed, containing tuples describing each read step: items = (( s7 . S7AreaDB , 1 , 16 , 10 ), ( s7 . S7AreaDB , 2 , 16 , 10 )) bufs = s7 . client . readmultivars ( items ) The above example defines a tuple item containig two descriptors, the first one to read from DB area, from DB number 1, with an offset of 16, and amount of 10. The second to perform the same operation but on DB number 2. As it is clear in the example, descriptor params have to be placed in the same order (and with the same meaning) expected by readarea() method. Returns a tuple of bytes or shorts objects each corresponding to a single read result.","title":"Client.readmultivars"},{"location":"reference/libs/siemens/s7/docs/s7/#clientwritemultivars","text":"writemultivars ( items ) Arguments: items \u2013 write descriptors. Perform multiple writes withing a single call. A tuple of write descriptors must be passed, containing tuples describing each write step: items = (( s7 . S7AreaDB , 1 , 16 , bytes ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ])), ( s7 . S7AreaDB , 2 , 16 , bytes ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ]))) s7 . client . writemultivars ( items ) The above example defines a tuple item containig two descriptors, the first one to write to DB area, DB number 1, with an offset of 16, the sequence of bytes [1,2,3,4,5,6,7,8] . The second to perform the same operation but on DB number 2. As it is clear in the example, descriptor params have to be placed in the same order (and with the same meaning) expected by writearea() method.","title":"Client.writemultivars"},{"location":"reference/libs/siemens/s7/docs/s7/#library-functions","text":"","title":"Library Functions"},{"location":"reference/libs/siemens/s7/docs/s7/#init","text":"init () Init module, after this call client global variable is available containing a Client() instance.","title":"init"},{"location":"reference/libs/solomon/ssd1306/docs/","text":"SOLOMON SSD1306 \u00b6 The SSD1306 is a CMOS OLED/PLED driver with controller for light emitting diode dot-matrix graphic display system. It consists of 128 segments and 64 commons. This IC is designed for Common Cathode type OLED panel. The SSD1306 embeds with contrast control, display RAM and oscillator, which reduces the number of external components and power consumption. It has 256-step brightness control. Data/Commands are sent from general MCU through the hardware selectable 6800/8000 series compatible SPI and I2C Interface. More information at Solomon dedicated page . Technical Details \u00b6 Supply Voltage (Vdd): from 1.65 V to 3.3 V Operation Temperature (Top): from -40 \u00b0C to 85 \u00b0C Resolution: 128 x 64 dot matrix panel Segment maximum source current: 100uA Common maximum sink current: 15mA 256 step brightness current control SPI interface I2C interface Here below, the Zerynth driver for the SOLOMON SSD1306. Contents: SSD1306 Module Examples fading image writing on bw oled","title":"SOLOMON SSD1306"},{"location":"reference/libs/solomon/ssd1306/docs/#solomon-ssd1306","text":"The SSD1306 is a CMOS OLED/PLED driver with controller for light emitting diode dot-matrix graphic display system. It consists of 128 segments and 64 commons. This IC is designed for Common Cathode type OLED panel. The SSD1306 embeds with contrast control, display RAM and oscillator, which reduces the number of external components and power consumption. It has 256-step brightness control. Data/Commands are sent from general MCU through the hardware selectable 6800/8000 series compatible SPI and I2C Interface. More information at Solomon dedicated page .","title":"SOLOMON SSD1306"},{"location":"reference/libs/solomon/ssd1306/docs/#technical-details","text":"Supply Voltage (Vdd): from 1.65 V to 3.3 V Operation Temperature (Top): from -40 \u00b0C to 85 \u00b0C Resolution: 128 x 64 dot matrix panel Segment maximum source current: 100uA Common maximum sink current: 15mA 256 step brightness current control SPI interface I2C interface Here below, the Zerynth driver for the SOLOMON SSD1306. Contents: SSD1306 Module Examples fading image writing on bw oled","title":"Technical Details"},{"location":"reference/libs/solomon/ssd1306/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.solomon.ssd1306. Draw a fading image \u00b6 Draw an image and set the contrast alternately from max to min and from min to max gradually for fading main.py ################################################################################ # Draw a fading image Example # # Created: 2017-08-28 11:26:15.598712 # ################################################################################ import streams streams . serial () print ( \"import\" ) sleep ( 1000 ) from solomon.ssd1306 import ssd1306 print ( \"start\" ) sleep ( 1000 ) import zLogo try : # Setup display # The ssd1306 can use either the spi or the i2c interface # the flag SSD1306SPI enables the spi interface # the flag SSD1306I2C enables the i2c interface # those two flags can't be set both to true ssd = None #-if SSD1306SPI # This setup is referred to ssd1306 mounted on slot A of a Flip n Click device ssd = ssd1306 . SSD1306 ( SPI0 , D17 , D16 , D6 ) #-else ##-if SSD1306I2C # This setup is referred to ssd1306 mounted on a XinaBox CW02 ssd = ssd1306 . SSD1306 ( I2C0 ) ##-endif #-endif ssd . init () ssd . on () ssd . clear () #draw zlogo ssd . draw_img ( zLogo . zz , 32 , 4 , 32 , 32 ) except Exception as e : print ( \"Error1\" , e ) while True : try : #fade the screen for i in range ( 0 , 256 ): ssd . set_contrast ( i ) sleep ( 2 ) for i in range ( 0 , 256 ): ssd . set_contrast ( 255 - i ) sleep ( 2 ) except Exception as e : print ( e ) Draw text on oled Display \u00b6 Print a string inside a text box on b/w oled display with different alignments. main.py ################################################################################ # Print string on bw oled display Example # # Created: 2017-08-28 12:21:52.459874 # ################################################################################ import streams streams . serial () print ( \"import\" ) sleep ( 1000 ) from solomon.ssd1306 import ssd1306 print ( \"start\" ) sleep ( 1000 ) try : # Setup display # The ssd1306 can use either the spi or the i2c interface # the flag SSD1306SPI enables the spi interface # the flag SSD1306I2C enables the i2c interface # those two flags can't be set both to true ssd = None #-if SSD1306SPI # This setup is referred to ssd1306 mounted on slot A of a Flip n Click device ssd = ssd1306 . SSD1306 ( SPI0 , D17 , D16 , D6 ) #-else ##-if SSD1306I2C # This setup is referred to ssd1306 mounted on a XinaBox CW02 ssd = ssd1306 . SSD1306 ( I2C0 ) ##-endif #-endif ssd . init () ssd . on () except Exception as e : print ( \"Error1\" , e ) while True : try : ssd . clear () sleep ( 1000 ) count = 0 for i in [ 3 , 2 , 1 ]: ssd . draw_text ( \"Zerynth\" , 0 , 14 * count , 96 , 12 , align = i ) sleep ( 1000 ) count += 1 ssd . fill_screen () sleep ( 1000 ) count = 0 for i in [ 1 , 2 , 3 ]: ssd . draw_text ( \"Hello Zerynth\" , 0 , 14 * count , 96 , 12 , align = i , fill = False ) sleep ( 1000 ) count += 1 ssd . invert () sleep ( 1000 ) ssd . normal () sleep ( 1000 ) except Exception as e : print ( e )","title":"Examples"},{"location":"reference/libs/solomon/ssd1306/docs/examples/#examples","text":"The following are a list of examples for lib.solomon.ssd1306.","title":"Examples"},{"location":"reference/libs/solomon/ssd1306/docs/examples/#draw-a-fading-image","text":"Draw an image and set the contrast alternately from max to min and from min to max gradually for fading main.py ################################################################################ # Draw a fading image Example # # Created: 2017-08-28 11:26:15.598712 # ################################################################################ import streams streams . serial () print ( \"import\" ) sleep ( 1000 ) from solomon.ssd1306 import ssd1306 print ( \"start\" ) sleep ( 1000 ) import zLogo try : # Setup display # The ssd1306 can use either the spi or the i2c interface # the flag SSD1306SPI enables the spi interface # the flag SSD1306I2C enables the i2c interface # those two flags can't be set both to true ssd = None #-if SSD1306SPI # This setup is referred to ssd1306 mounted on slot A of a Flip n Click device ssd = ssd1306 . SSD1306 ( SPI0 , D17 , D16 , D6 ) #-else ##-if SSD1306I2C # This setup is referred to ssd1306 mounted on a XinaBox CW02 ssd = ssd1306 . SSD1306 ( I2C0 ) ##-endif #-endif ssd . init () ssd . on () ssd . clear () #draw zlogo ssd . draw_img ( zLogo . zz , 32 , 4 , 32 , 32 ) except Exception as e : print ( \"Error1\" , e ) while True : try : #fade the screen for i in range ( 0 , 256 ): ssd . set_contrast ( i ) sleep ( 2 ) for i in range ( 0 , 256 ): ssd . set_contrast ( 255 - i ) sleep ( 2 ) except Exception as e : print ( e )","title":"Draw a fading image"},{"location":"reference/libs/solomon/ssd1306/docs/examples/#draw-text-on-oled-display","text":"Print a string inside a text box on b/w oled display with different alignments. main.py ################################################################################ # Print string on bw oled display Example # # Created: 2017-08-28 12:21:52.459874 # ################################################################################ import streams streams . serial () print ( \"import\" ) sleep ( 1000 ) from solomon.ssd1306 import ssd1306 print ( \"start\" ) sleep ( 1000 ) try : # Setup display # The ssd1306 can use either the spi or the i2c interface # the flag SSD1306SPI enables the spi interface # the flag SSD1306I2C enables the i2c interface # those two flags can't be set both to true ssd = None #-if SSD1306SPI # This setup is referred to ssd1306 mounted on slot A of a Flip n Click device ssd = ssd1306 . SSD1306 ( SPI0 , D17 , D16 , D6 ) #-else ##-if SSD1306I2C # This setup is referred to ssd1306 mounted on a XinaBox CW02 ssd = ssd1306 . SSD1306 ( I2C0 ) ##-endif #-endif ssd . init () ssd . on () except Exception as e : print ( \"Error1\" , e ) while True : try : ssd . clear () sleep ( 1000 ) count = 0 for i in [ 3 , 2 , 1 ]: ssd . draw_text ( \"Zerynth\" , 0 , 14 * count , 96 , 12 , align = i ) sleep ( 1000 ) count += 1 ssd . fill_screen () sleep ( 1000 ) count = 0 for i in [ 1 , 2 , 3 ]: ssd . draw_text ( \"Hello Zerynth\" , 0 , 14 * count , 96 , 12 , align = i , fill = False ) sleep ( 1000 ) count += 1 ssd . invert () sleep ( 1000 ) ssd . normal () sleep ( 1000 ) except Exception as e : print ( e )","title":"Draw text on oled Display"},{"location":"reference/libs/solomon/ssd1306/docs/ssd1306/","text":"SSD1306 Module \u00b6 This Module exposes all functionalities of Solomon SSD1306 OLED Display driver ( datasheet ). class SSD1306 \u00b6 class SSD1306 ( drv , cs , rst , dc , clock = 8000000 ) Creates an intance of a new SSD1306 using SPI. SSD1306SPI must be set to \u2018true\u2019 in the configuration yml. param spidrv: SPI Bus used \u2018( SPI0, \u2026 )\u2019 param cs: Chip Select param rst: Reset pin param dc: Data/Command control pin param clk: Clock speed, default 8MHz Example: from solomon.ssd1306 import ssd1306 ... oled = ssd1306 . SSD1306SPI ( SPI0 , D17 , D16 , D6 ) oled . init () oled . on () init \u00b6 SSD1306 . init ( screen_width = 96 , screen_height = 40 ) Initialize the SSD1306 setting all internal registers and the display dimensions in pixels. Arguments: screen_width \u2013 width in pixels of the display (max 128); default 96 screen_height \u2013 height in pixels of the display (max 64); default 40 SSD1306.on \u00b6 on () Turns on the display. SSD1306.off \u00b6 off () Turns off the display. SSD1306.invert \u00b6 invert () Sets the display in complementary mode. SSD1306.normal \u00b6 normal () Sets the display in normal mode. SSD1306.set_contrast \u00b6 set_contrast ( contrast = 0x7F ) Sets the contrast of the display. Arguments : contrast \u2013 value of the contrast to be set (from 0 to 255), default 0x7F. SSD1306.clear \u00b6 clear () Clears the display. SSD1306.fill_screen \u00b6 fill_screen () Fills the entire display (white screen in normal mode). SSD1306.fill_rect \u00b6 fill_rect ( x , y , w , h , fill = True ) Draws a filled rectangular area in the screen. Arguments: x \u2013 x-coordinate for left high corner of the rectangular area y \u2013 y-coordinate for left high corner of the rectangular area w \u2013 width of the rectangular area h \u2013 height of the rectangular area fill ( bool ) \u2013 flag for filling the rectagnular area. If True draws white area, otherwise black area (in normal mode); default True Note If the display is set in complementary mode (see invert() function), fill flag set to True will draw black area and set to False will draw a white area. SSD1306.draw_img \u00b6 draw_img ( image , x , y , w , h , fill = True ) Draws the image passed in bytearray format as argument. Arguments: bytes \u2013 bytearray composing the image to draw in the oled display x \u2013 x-coordinate for left high corner of the image y \u2013 y-coordinate for left high corner of the image w \u2013 width of the image h \u2013 height of the image fill ( bool ) \u2013 flag for filling the image. If True draws image in standard color, otherwise draws the image in inverted color (display in normal mode); default True. Note If the display is set in complementary mode (see invert() function), fill flag set to True will draw the image in inverted color and set to False will draw the image in normal color. Note To obtain a converted image in hex array format, you can go and use this online tool . After uploading your image, you can resize it setting the width and height fields; you can also choose the code format (HEX:0x recommended) and the color format (\u201cBlack/White for all draw image function\u201d recommended). Clicking on the \u201cGet C string\u201d button, the tool converts your image with your settings to a hex string that you can copy and paste inside a bytearray in your project and privide to this function. SSD1306.draw_pixel \u00b6 draw_pixel ( x , y , fill = True ) Draws a single pixel in the screen. Arguments: x \u2013 pixel x-coordinate y \u2013 pixel y-coordinate fill ( bool ) \u2013 flag for filling the pixel. If True draws white pixel, otherwise black pixel (in normal mode); default True. Note If the display is set in complementary mode (see invert() function), fill flag set to True will draw black pixel and set to False will draw a white pixel. SSD1306.draw_text \u00b6 draw_text ( text , x = None , y = None , w = None , h = None , align = None , fill = True ) Prints a string inside a text box in the screen. Arguments: text \u2013 string to be written in the display x \u2013 x-coordinate for left high corner of the text box; default None y \u2013 y-coordinate for left high corner of the text box; default None w \u2013 width of the text box; default None h \u2013 height of the text box; default None align \u2013 alignment of the text inside the text box (1 for left alignment, 2 for right alignment, 3 for center alignment); default None fill ( bool ) \u2013 flag for filling the text. If True draws white text in black background, othewise black text in white background (in normal mode); default True Note If the display is set in complementary mode (see invert() function), fill flag set to True will draw black text in white background and set to False will draw a white text in black background. Note If only text argument is provided, an automatic text box is created with the following values: x = 0 y = 0 w = min text width according to the font h = max char height according to the font align = 3 (centered horizontally) fill = True","title":"SSD1306 Module"},{"location":"reference/libs/solomon/ssd1306/docs/ssd1306/#ssd1306-module","text":"This Module exposes all functionalities of Solomon SSD1306 OLED Display driver ( datasheet ).","title":"SSD1306 Module"},{"location":"reference/libs/solomon/ssd1306/docs/ssd1306/#class-ssd1306","text":"class SSD1306 ( drv , cs , rst , dc , clock = 8000000 ) Creates an intance of a new SSD1306 using SPI. SSD1306SPI must be set to \u2018true\u2019 in the configuration yml. param spidrv: SPI Bus used \u2018( SPI0, \u2026 )\u2019 param cs: Chip Select param rst: Reset pin param dc: Data/Command control pin param clk: Clock speed, default 8MHz Example: from solomon.ssd1306 import ssd1306 ... oled = ssd1306 . SSD1306SPI ( SPI0 , D17 , D16 , D6 ) oled . init () oled . on ()","title":"class SSD1306"},{"location":"reference/libs/solomon/ssd1306/docs/ssd1306/#init","text":"SSD1306 . init ( screen_width = 96 , screen_height = 40 ) Initialize the SSD1306 setting all internal registers and the display dimensions in pixels. Arguments: screen_width \u2013 width in pixels of the display (max 128); default 96 screen_height \u2013 height in pixels of the display (max 64); default 40","title":"init"},{"location":"reference/libs/solomon/ssd1306/docs/ssd1306/#ssd1306on","text":"on () Turns on the display.","title":"SSD1306.on"},{"location":"reference/libs/solomon/ssd1306/docs/ssd1306/#ssd1306off","text":"off () Turns off the display.","title":"SSD1306.off"},{"location":"reference/libs/solomon/ssd1306/docs/ssd1306/#ssd1306invert","text":"invert () Sets the display in complementary mode.","title":"SSD1306.invert"},{"location":"reference/libs/solomon/ssd1306/docs/ssd1306/#ssd1306normal","text":"normal () Sets the display in normal mode.","title":"SSD1306.normal"},{"location":"reference/libs/solomon/ssd1306/docs/ssd1306/#ssd1306set_contrast","text":"set_contrast ( contrast = 0x7F ) Sets the contrast of the display. Arguments : contrast \u2013 value of the contrast to be set (from 0 to 255), default 0x7F.","title":"SSD1306.set_contrast"},{"location":"reference/libs/solomon/ssd1306/docs/ssd1306/#ssd1306clear","text":"clear () Clears the display.","title":"SSD1306.clear"},{"location":"reference/libs/solomon/ssd1306/docs/ssd1306/#ssd1306fill_screen","text":"fill_screen () Fills the entire display (white screen in normal mode).","title":"SSD1306.fill_screen"},{"location":"reference/libs/solomon/ssd1306/docs/ssd1306/#ssd1306fill_rect","text":"fill_rect ( x , y , w , h , fill = True ) Draws a filled rectangular area in the screen. Arguments: x \u2013 x-coordinate for left high corner of the rectangular area y \u2013 y-coordinate for left high corner of the rectangular area w \u2013 width of the rectangular area h \u2013 height of the rectangular area fill ( bool ) \u2013 flag for filling the rectagnular area. If True draws white area, otherwise black area (in normal mode); default True Note If the display is set in complementary mode (see invert() function), fill flag set to True will draw black area and set to False will draw a white area.","title":"SSD1306.fill_rect"},{"location":"reference/libs/solomon/ssd1306/docs/ssd1306/#ssd1306draw_img","text":"draw_img ( image , x , y , w , h , fill = True ) Draws the image passed in bytearray format as argument. Arguments: bytes \u2013 bytearray composing the image to draw in the oled display x \u2013 x-coordinate for left high corner of the image y \u2013 y-coordinate for left high corner of the image w \u2013 width of the image h \u2013 height of the image fill ( bool ) \u2013 flag for filling the image. If True draws image in standard color, otherwise draws the image in inverted color (display in normal mode); default True. Note If the display is set in complementary mode (see invert() function), fill flag set to True will draw the image in inverted color and set to False will draw the image in normal color. Note To obtain a converted image in hex array format, you can go and use this online tool . After uploading your image, you can resize it setting the width and height fields; you can also choose the code format (HEX:0x recommended) and the color format (\u201cBlack/White for all draw image function\u201d recommended). Clicking on the \u201cGet C string\u201d button, the tool converts your image with your settings to a hex string that you can copy and paste inside a bytearray in your project and privide to this function.","title":"SSD1306.draw_img"},{"location":"reference/libs/solomon/ssd1306/docs/ssd1306/#ssd1306draw_pixel","text":"draw_pixel ( x , y , fill = True ) Draws a single pixel in the screen. Arguments: x \u2013 pixel x-coordinate y \u2013 pixel y-coordinate fill ( bool ) \u2013 flag for filling the pixel. If True draws white pixel, otherwise black pixel (in normal mode); default True. Note If the display is set in complementary mode (see invert() function), fill flag set to True will draw black pixel and set to False will draw a white pixel.","title":"SSD1306.draw_pixel"},{"location":"reference/libs/solomon/ssd1306/docs/ssd1306/#ssd1306draw_text","text":"draw_text ( text , x = None , y = None , w = None , h = None , align = None , fill = True ) Prints a string inside a text box in the screen. Arguments: text \u2013 string to be written in the display x \u2013 x-coordinate for left high corner of the text box; default None y \u2013 y-coordinate for left high corner of the text box; default None w \u2013 width of the text box; default None h \u2013 height of the text box; default None align \u2013 alignment of the text inside the text box (1 for left alignment, 2 for right alignment, 3 for center alignment); default None fill ( bool ) \u2013 flag for filling the text. If True draws white text in black background, othewise black text in white background (in normal mode); default True Note If the display is set in complementary mode (see invert() function), fill flag set to True will draw black text in white background and set to False will draw a white text in black background. Note If only text argument is provided, an automatic text box is created with the following values: x = 0 y = 0 w = min text width according to the font h = max char height according to the font align = 3 (centered horizontally) fill = True","title":"SSD1306.draw_text"},{"location":"reference/libs/solomon/ssd1351/docs/","text":"SOLOMON SSD1351 \u00b6 The SSD1351 is a CMOS OLED/PLED driver with 384 segments and 128 commons output, supporting up to 128RGB x 128 dot matrix display. This chip is designed for Common Cathode type OLED/PLED panel. The SSD1351 has embedded Graphic Display Data RAM (GDDRAM). It supports with 8, 16, 18 bits 8080 / 6800 parallel interface, Serial Peripheral Interface. It has 256-step contrast and 262K color control, giving vivid color display on OLED panels. More information at Solomon dedicated page . Technical Details \u00b6 Supply Voltage (Vdd): from 2.4 V to 3.5 V Operation Temperature (Top): from -40 \u00b0C to 85 \u00b0C Resolution: 128 RGB x 128 dot matrix panel Segment maximum source current: 200uA Common maximum sink current: 70mA 256 step brightness current control for the each color component plus 16 step master current control SPI interface Here below, the Zerynth driver for the SOLOMON SSD1351. Contents: SSD1351 Module Examples blinking image print on oled display","title":"SOLOMON SSD1351"},{"location":"reference/libs/solomon/ssd1351/docs/#solomon-ssd1351","text":"The SSD1351 is a CMOS OLED/PLED driver with 384 segments and 128 commons output, supporting up to 128RGB x 128 dot matrix display. This chip is designed for Common Cathode type OLED/PLED panel. The SSD1351 has embedded Graphic Display Data RAM (GDDRAM). It supports with 8, 16, 18 bits 8080 / 6800 parallel interface, Serial Peripheral Interface. It has 256-step contrast and 262K color control, giving vivid color display on OLED panels. More information at Solomon dedicated page .","title":"SOLOMON SSD1351"},{"location":"reference/libs/solomon/ssd1351/docs/#technical-details","text":"Supply Voltage (Vdd): from 2.4 V to 3.5 V Operation Temperature (Top): from -40 \u00b0C to 85 \u00b0C Resolution: 128 RGB x 128 dot matrix panel Segment maximum source current: 200uA Common maximum sink current: 70mA 256 step brightness current control for the each color component plus 16 step master current control SPI interface Here below, the Zerynth driver for the SOLOMON SSD1351. Contents: SSD1351 Module Examples blinking image print on oled display","title":"Technical Details"},{"location":"reference/libs/solomon/ssd1351/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.solomon.ssd1351. Draw a blinking image \u00b6 Draw an image and set the contrast alternately to max and min values for blinking. main.py ################################################################################ # Draw a blinking image Example # # Created: 2017-03-10 15:12:44.433654 # ################################################################################ import streams streams . serial () print ( \"import\" ) sleep ( 1000 ) from solomon.ssd1351 import ssd1351 print ( \"start\" ) sleep ( 1000 ) import zLogo try : # Setup display # This setup is referred to ssd1351 mounted on Hexiwear device ssd = ssd1351 . SSD1351 ( SPI0 , D57 , D58 , D59 , D71 ) ssd . init ( 96 , 96 ) ssd . on () ssd . fill_screen ( color = 0x4471 , encode = False ) #draw zlogo ssd . draw_img ( zLogo . zz , 8 , 8 , 80 , 80 ) except Exception as e : print ( \"Error1\" , e ) while True : #blink the screen ssd . set_contrast ( 0 ) sleep ( 1000 ) ssd . set_contrast ( 255 ) sleep ( 1000 ) Print on oled Display \u00b6 Print a string inside a text box on color oled display with different alignments. main.py ################################################################################ # Print string on oled display Example # # Created: 2017-03-10 16:29:12.145521 # ################################################################################ import streams streams . serial () print ( \"import\" ) sleep ( 1000 ) from solomon.ssd1351 import ssd1351 print ( \"start\" ) sleep ( 1000 ) try : # Setup display # This setup is referred to ssd1351 mounted on Hexiwear device ssd = ssd1351 . SSD1351 ( SPI0 , D57 , D58 , D59 , D71 ) ssd . init ( 96 , 96 ) ssd . on () except Exception as e : print ( \"Error1\" , e ) while True : ssd . fill_screen ( color = 0xFFFF00 ) sleep ( 1000 ) ssd . draw_text ( \"Hello Zerynth\" , 0 , 0 , 96 , 24 , color = 0xFFFF , align = 3 , background = 0x4471 , encode = False ) sleep ( 1000 ) ssd . draw_text ( \"Hello Zerynth\" , 0 , 24 , 96 , 24 , color = 0x4471 , align = 1 , background = 0xFFFF , encode = False ) sleep ( 1000 ) ssd . draw_text ( \"Hello Zerynth\" , 0 , 48 , 96 , 24 , color = 0x4471 , align = 2 , background = 0x0000 , encode = False ) sleep ( 1000 ) ssd . draw_text ( \"Hello Zerynth\" , 0 , 72 , 96 , 24 , color = 0x0000 , align = 3 , background = 0x4471 , encode = False ) sleep ( 1000 )","title":"Examples"},{"location":"reference/libs/solomon/ssd1351/docs/examples/#examples","text":"The following are a list of examples for lib.solomon.ssd1351.","title":"Examples"},{"location":"reference/libs/solomon/ssd1351/docs/examples/#draw-a-blinking-image","text":"Draw an image and set the contrast alternately to max and min values for blinking. main.py ################################################################################ # Draw a blinking image Example # # Created: 2017-03-10 15:12:44.433654 # ################################################################################ import streams streams . serial () print ( \"import\" ) sleep ( 1000 ) from solomon.ssd1351 import ssd1351 print ( \"start\" ) sleep ( 1000 ) import zLogo try : # Setup display # This setup is referred to ssd1351 mounted on Hexiwear device ssd = ssd1351 . SSD1351 ( SPI0 , D57 , D58 , D59 , D71 ) ssd . init ( 96 , 96 ) ssd . on () ssd . fill_screen ( color = 0x4471 , encode = False ) #draw zlogo ssd . draw_img ( zLogo . zz , 8 , 8 , 80 , 80 ) except Exception as e : print ( \"Error1\" , e ) while True : #blink the screen ssd . set_contrast ( 0 ) sleep ( 1000 ) ssd . set_contrast ( 255 ) sleep ( 1000 )","title":"Draw a blinking image"},{"location":"reference/libs/solomon/ssd1351/docs/examples/#print-on-oled-display","text":"Print a string inside a text box on color oled display with different alignments. main.py ################################################################################ # Print string on oled display Example # # Created: 2017-03-10 16:29:12.145521 # ################################################################################ import streams streams . serial () print ( \"import\" ) sleep ( 1000 ) from solomon.ssd1351 import ssd1351 print ( \"start\" ) sleep ( 1000 ) try : # Setup display # This setup is referred to ssd1351 mounted on Hexiwear device ssd = ssd1351 . SSD1351 ( SPI0 , D57 , D58 , D59 , D71 ) ssd . init ( 96 , 96 ) ssd . on () except Exception as e : print ( \"Error1\" , e ) while True : ssd . fill_screen ( color = 0xFFFF00 ) sleep ( 1000 ) ssd . draw_text ( \"Hello Zerynth\" , 0 , 0 , 96 , 24 , color = 0xFFFF , align = 3 , background = 0x4471 , encode = False ) sleep ( 1000 ) ssd . draw_text ( \"Hello Zerynth\" , 0 , 24 , 96 , 24 , color = 0x4471 , align = 1 , background = 0xFFFF , encode = False ) sleep ( 1000 ) ssd . draw_text ( \"Hello Zerynth\" , 0 , 48 , 96 , 24 , color = 0x4471 , align = 2 , background = 0x0000 , encode = False ) sleep ( 1000 ) ssd . draw_text ( \"Hello Zerynth\" , 0 , 72 , 96 , 24 , color = 0x0000 , align = 3 , background = 0x4471 , encode = False ) sleep ( 1000 )","title":"Print on oled Display"},{"location":"reference/libs/solomon/ssd1351/docs/ssd1351/","text":"SSD1351 Module \u00b6 This Module exposes all functionalities of Solomon SSD1351 Color OLED Display driver ( datasheet ). Note Only 65k color depth is supported; 262k color depth will be available soon. class SSD1351(drv, cs, rst, dc, pwr, clock=8000000) \u00b6 class SSD1351 ( drv , cs , rst , dc , pwr , clock = 8000000 ) Creates an intance of a new SSD1351. spidrv: SPI Bus used '( SPI0, ... )' cs: Chip Select rst: Reset pin dc: Data/Command control pin pwr: Power On pin clk: Clock speed, default 8MHz init \u00b6 init ( screen_width = 128 , screen_height = 128 ) Initialize the SSD1351 setting all internal registers and the display dimensions in pixels. Arguments: screen_width \u2013 width in pixels of the display (max 128); default 12 screen_height \u2013 height in pixels of the display (max 128); default 128 SSD1351.on \u00b6 on () Turns on the display. SSD1351.off \u00b6 off () Turns off the display. SSD1351.set_contrast \u00b6 set_contrast ( contrast = 0x7F ) Sets the contrast of the display. Arguments: contrast \u2013 value of the contrast to be set (from 0 to 255), default 0x7F. SSD1351.clear \u00b6 clear () Clears the display. SSD1351.fill_screen \u00b6 fill_screen ( color , encode = True ) Fills the entire display with color code provided as argument. Arguments: color \u2013 hex color code for the screen encode ( bool ) \u2013 flag for enabling the color encoding; default True Note To be compatible with the 65k color format, if a stadard hex color code (24 bit) is provided it is necessary to encode it into a 16 bit format. If a 16 bit color code is provided, the encode flag must be set to False. SSD1351.fill_rect \u00b6 fill_rect ( x , y , w , h , color , encode = True ) Draws a rectangular area in the screen colored with the color code provided as argument. Arguments: x \u2013 x-coordinate for left high corner of the rectangular area y \u2013 y-coordinate for left high corner of the rectangular area w \u2013 width of the rectangular area h \u2013 height of the rectangular area color \u2013 hex color code for the rectangular area encode ( bool ) \u2013 flag for enabling the color encoding; default True Note To be compatible with the 65k color format, if a stadard hex color code (24 bit) is provided it is necessary to encode it into a 16 bit format. If a 16 bit color code is provided, the encode flag must be set to False. SSD1351.draw_img \u00b6 draw_img ( image , x , y , w , h ) Draws a rectangular area in the screen colored with the color code provided as argument. Arguments: image \u2013 image to draw in the oled display converted to hex array format and passed as bytearray x \u2013 x-coordinate for left high corner of the image y \u2013 y-coordinate for left high corner of the image w \u2013 width of the image h \u2013 height of the image Note To obtain a converted image in hex array format, you can go and use this online tool . After uploading your image, you can resize it setting the width and height fields; you can also choose the code format (HEX:0x recommended) and the color format (65K color recommended). Clicking on the \u201cGet C string\u201d button, the tool converts your image with your settings to a hex string that you can copy and paste inside a bytearray in your project and privide to this function. SSD1351.draw_pixel \u00b6 draw_pixel ( x , y , color , encode = True ) Draws a single pixel in the screen colored with the color code provided as argument. Arguments: x \u2013 pixel x-coordinate y \u2013 pixel y-coordinate color \u2013 hex color code for the pixel encode ( bool ) \u2013 flag for enabling the color encoding; default True Note To be compatible with the 65k color format, if a stadard hex color code (24 bit) is provided it is necessary to encode it into a 16 bit format. If a 16 bit color code is provided, the encode flag must be set to False. SSD1351.draw_text \u00b6 draw_text ( text , x = None , y = None , w = None , h = None , color = None , align = None , background = None , encode = True ) Prints a string inside a text box in the screen. Arguments: text \u2013 string to be written in the display x \u2013 x-coordinate for left high corner of the text box; default None y \u2013 y-coordinate for left high corner of the text box; default None w \u2013 width of the text box; default None h \u2013 height of the text box; default None color \u2013 hex color code for the font; default None align \u2013 alignment of the text inside the text box (1 for left alignment, 2 for right alignment, 3 for center alignment); default None background \u2013 hex color code for the background; default None encode ( bool ) \u2013 flag for enabling the color encoding of the font and background color; default True Note To be compatible with the 65k color format, so if a stadard hex color code (24 bit) is provided it is necessary to encode it into a 16 bit format. If a 16 bit color code is provided, the encode flag must be set to False. Note If only text argument is provided, an automatic text box is created with the following values: x = 0 y = 0 w = min text width according to the font h = max char height according to the font color = 0xFFFF align = 3 (centered horizontally) background = 0x4471","title":"SSD1351 Module"},{"location":"reference/libs/solomon/ssd1351/docs/ssd1351/#ssd1351-module","text":"This Module exposes all functionalities of Solomon SSD1351 Color OLED Display driver ( datasheet ). Note Only 65k color depth is supported; 262k color depth will be available soon.","title":"SSD1351 Module"},{"location":"reference/libs/solomon/ssd1351/docs/ssd1351/#class-ssd1351drv-cs-rst-dc-pwr-clock8000000","text":"class SSD1351 ( drv , cs , rst , dc , pwr , clock = 8000000 ) Creates an intance of a new SSD1351. spidrv: SPI Bus used '( SPI0, ... )' cs: Chip Select rst: Reset pin dc: Data/Command control pin pwr: Power On pin clk: Clock speed, default 8MHz","title":"class SSD1351(drv, cs, rst, dc, pwr, clock=8000000)"},{"location":"reference/libs/solomon/ssd1351/docs/ssd1351/#init","text":"init ( screen_width = 128 , screen_height = 128 ) Initialize the SSD1351 setting all internal registers and the display dimensions in pixels. Arguments: screen_width \u2013 width in pixels of the display (max 128); default 12 screen_height \u2013 height in pixels of the display (max 128); default 128","title":"init"},{"location":"reference/libs/solomon/ssd1351/docs/ssd1351/#ssd1351on","text":"on () Turns on the display.","title":"SSD1351.on"},{"location":"reference/libs/solomon/ssd1351/docs/ssd1351/#ssd1351off","text":"off () Turns off the display.","title":"SSD1351.off"},{"location":"reference/libs/solomon/ssd1351/docs/ssd1351/#ssd1351set_contrast","text":"set_contrast ( contrast = 0x7F ) Sets the contrast of the display. Arguments: contrast \u2013 value of the contrast to be set (from 0 to 255), default 0x7F.","title":"SSD1351.set_contrast"},{"location":"reference/libs/solomon/ssd1351/docs/ssd1351/#ssd1351clear","text":"clear () Clears the display.","title":"SSD1351.clear"},{"location":"reference/libs/solomon/ssd1351/docs/ssd1351/#ssd1351fill_screen","text":"fill_screen ( color , encode = True ) Fills the entire display with color code provided as argument. Arguments: color \u2013 hex color code for the screen encode ( bool ) \u2013 flag for enabling the color encoding; default True Note To be compatible with the 65k color format, if a stadard hex color code (24 bit) is provided it is necessary to encode it into a 16 bit format. If a 16 bit color code is provided, the encode flag must be set to False.","title":"SSD1351.fill_screen"},{"location":"reference/libs/solomon/ssd1351/docs/ssd1351/#ssd1351fill_rect","text":"fill_rect ( x , y , w , h , color , encode = True ) Draws a rectangular area in the screen colored with the color code provided as argument. Arguments: x \u2013 x-coordinate for left high corner of the rectangular area y \u2013 y-coordinate for left high corner of the rectangular area w \u2013 width of the rectangular area h \u2013 height of the rectangular area color \u2013 hex color code for the rectangular area encode ( bool ) \u2013 flag for enabling the color encoding; default True Note To be compatible with the 65k color format, if a stadard hex color code (24 bit) is provided it is necessary to encode it into a 16 bit format. If a 16 bit color code is provided, the encode flag must be set to False.","title":"SSD1351.fill_rect"},{"location":"reference/libs/solomon/ssd1351/docs/ssd1351/#ssd1351draw_img","text":"draw_img ( image , x , y , w , h ) Draws a rectangular area in the screen colored with the color code provided as argument. Arguments: image \u2013 image to draw in the oled display converted to hex array format and passed as bytearray x \u2013 x-coordinate for left high corner of the image y \u2013 y-coordinate for left high corner of the image w \u2013 width of the image h \u2013 height of the image Note To obtain a converted image in hex array format, you can go and use this online tool . After uploading your image, you can resize it setting the width and height fields; you can also choose the code format (HEX:0x recommended) and the color format (65K color recommended). Clicking on the \u201cGet C string\u201d button, the tool converts your image with your settings to a hex string that you can copy and paste inside a bytearray in your project and privide to this function.","title":"SSD1351.draw_img"},{"location":"reference/libs/solomon/ssd1351/docs/ssd1351/#ssd1351draw_pixel","text":"draw_pixel ( x , y , color , encode = True ) Draws a single pixel in the screen colored with the color code provided as argument. Arguments: x \u2013 pixel x-coordinate y \u2013 pixel y-coordinate color \u2013 hex color code for the pixel encode ( bool ) \u2013 flag for enabling the color encoding; default True Note To be compatible with the 65k color format, if a stadard hex color code (24 bit) is provided it is necessary to encode it into a 16 bit format. If a 16 bit color code is provided, the encode flag must be set to False.","title":"SSD1351.draw_pixel"},{"location":"reference/libs/solomon/ssd1351/docs/ssd1351/#ssd1351draw_text","text":"draw_text ( text , x = None , y = None , w = None , h = None , color = None , align = None , background = None , encode = True ) Prints a string inside a text box in the screen. Arguments: text \u2013 string to be written in the display x \u2013 x-coordinate for left high corner of the text box; default None y \u2013 y-coordinate for left high corner of the text box; default None w \u2013 width of the text box; default None h \u2013 height of the text box; default None color \u2013 hex color code for the font; default None align \u2013 alignment of the text inside the text box (1 for left alignment, 2 for right alignment, 3 for center alignment); default None background \u2013 hex color code for the background; default None encode ( bool ) \u2013 flag for enabling the color encoding of the font and background color; default True Note To be compatible with the 65k color format, so if a stadard hex color code (24 bit) is provided it is necessary to encode it into a 16 bit format. If a 16 bit color code is provided, the encode flag must be set to False. Note If only text argument is provided, an automatic text box is created with the following values: x = 0 y = 0 w = min text width according to the font h = max char height according to the font color = 0xFFFF align = 3 (centered horizontally) background = 0x4471","title":"SSD1351.draw_text"},{"location":"reference/libs/sony/cxd5602gnss/docs/","text":"CXD5602 GNSS \u00b6 The Sony CXD5602 chip mounted on Sony Spresense board features a Global Navigation Satellite System (GNSS) receiver that calculates its current position, velocity and time. To use this feature, you need to connect the GNSS chip to an antenna, such as the one on the Spresense Main Board. The embedded GNSS receiver on the Spresense board supports: The GPS and GLONASS, QZSS(Michibiki) GNSS systems. Below, Zerynth driver documentation for Sony CXD5602 GNSS. Contents: Sony CXD5602 GNSS Module Utils Examples GNSSData","title":"Index"},{"location":"reference/libs/sony/cxd5602gnss/docs/#cxd5602-gnss","text":"The Sony CXD5602 chip mounted on Sony Spresense board features a Global Navigation Satellite System (GNSS) receiver that calculates its current position, velocity and time. To use this feature, you need to connect the GNSS chip to an antenna, such as the one on the Spresense Main Board. The embedded GNSS receiver on the Spresense board supports: The GPS and GLONASS, QZSS(Michibiki) GNSS systems. Below, Zerynth driver documentation for Sony CXD5602 GNSS. Contents: Sony CXD5602 GNSS Module Utils Examples GNSSData","title":"CXD5602 GNSS"},{"location":"reference/libs/sony/cxd5602gnss/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.sony.cxd5602gnss. GNSS Data example \u00b6 Initializes the Sony CXD5602 GNSS and retrieves GNSS data. main.py ################################################################################ # GNSS Data # # Created by Zerynth Team 2019 CC # Author: L. Rizzello ############################################################################### import gc import streams from sony.cxd5602gnss import gnss # dictionary to convert from satellite type to string sattype2string = { gnss . SAT_GPS : \"GPS\" , gnss . SAT_GLONASS : \"GLONASS\" , gnss . SAT_SBAS : \"SBAS\" , gnss . SAT_QZ_L1CA : \"QZ_L1CA\" , gnss . SAT_IMES : \"IMES\" , gnss . SAT_QZ_L1S : \"QZ_L1S\" , gnss . SAT_BEIDOU : \"BEIDOU\" , gnss . SAT_GALILEO : \"GALILEO\" } streams . serial () print ( \"> GNSS init\" ) gnss . init () while True : gnss . wait () # filter data to keep only position, datetime and satellites' info data = gnss . read ( read_filter = ( gnss . FILTER_RECEIVER_POSITION | gnss . FILTER_RECEIVER_DATETIME | gnss . FILTER_SATS_DATA )) if data . receiver . position . pos_dataexist : print ( \"> POSITION:\" ) print ( \">> latitude:\" , data . receiver . position . latitude ) print ( \">> longitude:\" , data . receiver . position . longitude ) print ( \">> altitude:\" , data . receiver . position . altitude ) else : print ( \"> POSITION not available\" ) print ( \"> DATETIME:\" ) print ( \">> date.year:\" , data . receiver . datetime . date . year ) print ( \">> date.month:\" , data . receiver . datetime . date . month ) print ( \">> date.day:\" , data . receiver . datetime . date . day ) print ( \">> time.hour:\" , data . receiver . datetime . time . hour ) print ( \">> time.minute:\" , data . receiver . datetime . time . minute ) print ( \">> time.sec:\" , data . receiver . datetime . time . sec ) print ( \">> time.usec:\" , data . receiver . datetime . time . usec ) if data . sats : # at least one satellite available print ( \"> SATS:\" ) for sat_i , sat in enumerate ( data . sats ): print ( \">> sat[ %i ].type:\" % sat_i , sattype2string [ sat . type ]) print ( \">> sat[ %i ].siglevel:\" % sat_i , sat . siglevel )","title":"Examples"},{"location":"reference/libs/sony/cxd5602gnss/docs/examples/#examples","text":"The following are a list of examples for lib.sony.cxd5602gnss.","title":"Examples"},{"location":"reference/libs/sony/cxd5602gnss/docs/examples/#gnss-data-example","text":"Initializes the Sony CXD5602 GNSS and retrieves GNSS data. main.py ################################################################################ # GNSS Data # # Created by Zerynth Team 2019 CC # Author: L. Rizzello ############################################################################### import gc import streams from sony.cxd5602gnss import gnss # dictionary to convert from satellite type to string sattype2string = { gnss . SAT_GPS : \"GPS\" , gnss . SAT_GLONASS : \"GLONASS\" , gnss . SAT_SBAS : \"SBAS\" , gnss . SAT_QZ_L1CA : \"QZ_L1CA\" , gnss . SAT_IMES : \"IMES\" , gnss . SAT_QZ_L1S : \"QZ_L1S\" , gnss . SAT_BEIDOU : \"BEIDOU\" , gnss . SAT_GALILEO : \"GALILEO\" } streams . serial () print ( \"> GNSS init\" ) gnss . init () while True : gnss . wait () # filter data to keep only position, datetime and satellites' info data = gnss . read ( read_filter = ( gnss . FILTER_RECEIVER_POSITION | gnss . FILTER_RECEIVER_DATETIME | gnss . FILTER_SATS_DATA )) if data . receiver . position . pos_dataexist : print ( \"> POSITION:\" ) print ( \">> latitude:\" , data . receiver . position . latitude ) print ( \">> longitude:\" , data . receiver . position . longitude ) print ( \">> altitude:\" , data . receiver . position . altitude ) else : print ( \"> POSITION not available\" ) print ( \"> DATETIME:\" ) print ( \">> date.year:\" , data . receiver . datetime . date . year ) print ( \">> date.month:\" , data . receiver . datetime . date . month ) print ( \">> date.day:\" , data . receiver . datetime . date . day ) print ( \">> time.hour:\" , data . receiver . datetime . time . hour ) print ( \">> time.minute:\" , data . receiver . datetime . time . minute ) print ( \">> time.sec:\" , data . receiver . datetime . time . sec ) print ( \">> time.usec:\" , data . receiver . datetime . time . usec ) if data . sats : # at least one satellite available print ( \"> SATS:\" ) for sat_i , sat in enumerate ( data . sats ): print ( \">> sat[ %i ].type:\" % sat_i , sattype2string [ sat . type ]) print ( \">> sat[ %i ].siglevel:\" % sat_i , sat . siglevel )","title":"GNSS Data example"},{"location":"reference/libs/sony/cxd5602gnss/docs/gnss/","text":"Sony CXD5602 GNSS Module \u00b6 This module implements the Zerynth driver for the Sony CXD5602 GNSS. It allows configuring and retrieving data from the GNSS module mounted on the Sony Spresense board. init \u00b6 init ( start_mode = STMOD_HOT , sat_set = SAT_GPS | SAT_GLONASS , cycle = 1000 ) Arguments: start_mode \u2013 start mode sat_set \u2013 set of GNSS satellites cycle \u2013 positioning data evaluation cycle, must be multiple of 1000 Initializes and starts the GNSS system. start_mode can be one of (with TTFF meaning Time To First Fix ): STMOD_COLD : cold Start; STMOD_WARM : warm Start; STMOD_WARM_ACC2 : warm Start, better accuracy, less TTFF than WARM ; STMOD_HOT : hot Start; STMOD_HOT_ACC : hot Start, better accuracy, less TTFF than HOT ; STMOD_HOT_ACC2 : hot Start, better accuracy, less TTFF than ACC ; STMOD_HOT_ACC3 : optimized hot start, better TTFF than HOT ; For more details on the start mode to choose refer to the official documentation . sat_set is a bitmap containing the set of satellites to derive positioning data from. Supported satellites are: SAT_GPS : GPS SAT_GLONASS : Glonass SAT_SBAS : SBAS SAT_QZ_L1CA : L1CA SAT_IMES : IMES SAT_QZ_L1S : L1S SAT_BEIDOU : BeiDou SAT_GALILEO : Galileo Raises: UnsupportedError - when cycle is not a multiple of 1000. IOError - when initialization fails. deinit \u00b6 deinit () Stops and de-initializes the GNSS system. Raises: IOError - when de-initialization fails. wait \u00b6 wait () Waits for updated GNSS data to become available. Raises: IOError - when the operation fails. read \u00b6 read ( read_filter = FILTER_RECEIVER_POSITION | FILTER_RECEIVER_DATETIME ) Arguments: read_filter \u2013 bitmap to filter data to be read to save RAM. Reads GNSS data. To be called after wait() to be sure of reading updated data. Returns a GNSSData() object filled according to selected filters. Available filters are: FILTER_TIMESTAMP : fills GNSSData.timestamp FILTER_RECEIVER_SATS : fills GNSSData.receiver.sats FILTER_RECEIVER_POSITION : fills GNSSData.receiver.position , except for GNSSData.receiver.position.precision FILTER_RECEIVER_POSITION_PRECISION : fills GNSSData.receiver.position , including GNSSData.receiver.position.precision FILTER_RECEIVER_DATETIME : fills GNSSData.receiver.datetime FILTER_RECEIVER : fills GNSSData.receiver FILTER_SATS_DATA : fills GNSSData.sats Raises: IOError - when read fails, for example if read() is called immediately after init() without waiting proper initialization time calling wait() function. class GNSSData \u00b6 class GNSSData () Class to store GNSS data retrieved by read() calls. N.B. Each attribute might be filled depending on selected read filter. List of attributes: GNSSData.timestamp : integer timestamp GNSSData.receiver : Receiver() instance GNSSData.sats : tuple of SatelliteData() instances class Receiver \u00b6 class Receiver () Class to store Receiver info retrieved by read() calls. N.B. Each attribute might be filled depending on selected read filter. List of attributes: Receiver.sats : ReceiverSats() instance Receiver.position : ReceiverPosition() instance Receiver.datetime : ReceiverDatetime() instance class ReceiverSats \u00b6 class ReceiverSats () Class to store Receiver Satellites info retrieved by read() calls. N.B. Each attribute might be filled depending on selected read filter. List of attributes: ReceiverSats.numsv : number of visible satellites ReceiverSats.numsv_tracking : number of tracking satellites ReceiverSats.numsv_calcpos : number of satellites to calculate the position ReceiverSats.numsv_calcvel : number of satellites to calculate the velocity ReceiverSats.svtype : used sv system, bitfield. bit0:GPS , bit1:GLONASS , bit2:SBAS , bit3:QZSS_L1CA , bit4:IMES , bit5:QZSS_L1SAIF , bit6:Beidu , bit7:Galileo ReceiverSats.pos_svtype : used sv system to calculate position, bitfield ReceiverSats.vel_svtype : used sv system to calculate velocity, bitfield class ReceiverPosition \u00b6 class ReceiverPosition () Class to store Receiver Position info retrieved by read() calls. N.B. Each attribute might be filled depending on selected read filter. List of attributes: ReceiverPosition.type : position type. 0:Invalid , 1:GNSS , 2:IMES , 3:user set , 4:previous ReceiverPosition.dgps : 0:SGPS , 1:DGPS ReceiverPosition.pos_fixmode : 1:Invalid , 2:2D , 3:3D ReceiverPosition.vel_fixmode : 1:Invalid , 2:2D VZ , 3:2D Offset , 4:3D , 5:1D , 6:PRED ReceiverPosition.assist : bit field [7..5] Reserved [4] AEP Velocity [3] AEP Position [2] CEP Velocity [1] CEP Position , [0] user set ReceiverPosition.pos_dataexist : 0:none , 1:exist ReceiverPosition.possource : position source. 0:Invalid , 1:GNSS , 2:IMES , 3:user set , 4:previous ReceiverPosition.tcxo_offset : TCXO offset [Hz] ReceiverPosition.latitude : latitude [degree] ReceiverPosition.longitude : longitude [degree] ReceiverPosition.altitude : altitude [m] ReceiverPosition.geoid : geoid height [m] ReceiverPosition.velocity : velocity [m/s] ReceiverPosition.direction : direction [degree] ReceiverPosition.precision : ReceiverPositionPrecision() instance class ReceiverPositionPrecision \u00b6 class ReceiverPositionPrecision () ReceiverPositionPrecision.pos_dop : DOP() instance ReceiverPositionPrecision.vel_idx : DOP() instance ReceiverPositionPrecision.pos_accuracy : Variance() instance class DOP \u00b6 class DOP () Class to store Dilution of Precision. Dop.pdop : position DOP Dop.hdop : horizontal DOP Dop.vdop : vertical DOP Dop.tdop : time DOP Dop.ewdop : East-West DOP Dop.nsdop : North-South DOP Dop.majdop : Stdev of semi-major axis Dop.mindop : Stdev of semi-minor axis Dop.oridop : orientation of semi-major axis [deg] class Variance \u00b6 class Variance () Class to store Variance. Variance.hvar : horizontal variance Variance.vvar : vertical variance Utils \u00b6 double_to_dmf \u00b6 double_to_dmf ( x ) Arguments: x \u2013 double to convert. Converts from double format to degree-minute-frac format. Returns a tuple of four elements: (sign, degree, minute, frac) .","title":"Sony CXD5602 GNSS Module"},{"location":"reference/libs/sony/cxd5602gnss/docs/gnss/#sony-cxd5602-gnss-module","text":"This module implements the Zerynth driver for the Sony CXD5602 GNSS. It allows configuring and retrieving data from the GNSS module mounted on the Sony Spresense board.","title":"Sony CXD5602 GNSS Module"},{"location":"reference/libs/sony/cxd5602gnss/docs/gnss/#init","text":"init ( start_mode = STMOD_HOT , sat_set = SAT_GPS | SAT_GLONASS , cycle = 1000 ) Arguments: start_mode \u2013 start mode sat_set \u2013 set of GNSS satellites cycle \u2013 positioning data evaluation cycle, must be multiple of 1000 Initializes and starts the GNSS system. start_mode can be one of (with TTFF meaning Time To First Fix ): STMOD_COLD : cold Start; STMOD_WARM : warm Start; STMOD_WARM_ACC2 : warm Start, better accuracy, less TTFF than WARM ; STMOD_HOT : hot Start; STMOD_HOT_ACC : hot Start, better accuracy, less TTFF than HOT ; STMOD_HOT_ACC2 : hot Start, better accuracy, less TTFF than ACC ; STMOD_HOT_ACC3 : optimized hot start, better TTFF than HOT ; For more details on the start mode to choose refer to the official documentation . sat_set is a bitmap containing the set of satellites to derive positioning data from. Supported satellites are: SAT_GPS : GPS SAT_GLONASS : Glonass SAT_SBAS : SBAS SAT_QZ_L1CA : L1CA SAT_IMES : IMES SAT_QZ_L1S : L1S SAT_BEIDOU : BeiDou SAT_GALILEO : Galileo Raises: UnsupportedError - when cycle is not a multiple of 1000. IOError - when initialization fails.","title":"init"},{"location":"reference/libs/sony/cxd5602gnss/docs/gnss/#deinit","text":"deinit () Stops and de-initializes the GNSS system. Raises: IOError - when de-initialization fails.","title":"deinit"},{"location":"reference/libs/sony/cxd5602gnss/docs/gnss/#wait","text":"wait () Waits for updated GNSS data to become available. Raises: IOError - when the operation fails.","title":"wait"},{"location":"reference/libs/sony/cxd5602gnss/docs/gnss/#read","text":"read ( read_filter = FILTER_RECEIVER_POSITION | FILTER_RECEIVER_DATETIME ) Arguments: read_filter \u2013 bitmap to filter data to be read to save RAM. Reads GNSS data. To be called after wait() to be sure of reading updated data. Returns a GNSSData() object filled according to selected filters. Available filters are: FILTER_TIMESTAMP : fills GNSSData.timestamp FILTER_RECEIVER_SATS : fills GNSSData.receiver.sats FILTER_RECEIVER_POSITION : fills GNSSData.receiver.position , except for GNSSData.receiver.position.precision FILTER_RECEIVER_POSITION_PRECISION : fills GNSSData.receiver.position , including GNSSData.receiver.position.precision FILTER_RECEIVER_DATETIME : fills GNSSData.receiver.datetime FILTER_RECEIVER : fills GNSSData.receiver FILTER_SATS_DATA : fills GNSSData.sats Raises: IOError - when read fails, for example if read() is called immediately after init() without waiting proper initialization time calling wait() function.","title":"read"},{"location":"reference/libs/sony/cxd5602gnss/docs/gnss/#class-gnssdata","text":"class GNSSData () Class to store GNSS data retrieved by read() calls. N.B. Each attribute might be filled depending on selected read filter. List of attributes: GNSSData.timestamp : integer timestamp GNSSData.receiver : Receiver() instance GNSSData.sats : tuple of SatelliteData() instances","title":"class GNSSData"},{"location":"reference/libs/sony/cxd5602gnss/docs/gnss/#class-receiver","text":"class Receiver () Class to store Receiver info retrieved by read() calls. N.B. Each attribute might be filled depending on selected read filter. List of attributes: Receiver.sats : ReceiverSats() instance Receiver.position : ReceiverPosition() instance Receiver.datetime : ReceiverDatetime() instance","title":"class Receiver"},{"location":"reference/libs/sony/cxd5602gnss/docs/gnss/#class-receiversats","text":"class ReceiverSats () Class to store Receiver Satellites info retrieved by read() calls. N.B. Each attribute might be filled depending on selected read filter. List of attributes: ReceiverSats.numsv : number of visible satellites ReceiverSats.numsv_tracking : number of tracking satellites ReceiverSats.numsv_calcpos : number of satellites to calculate the position ReceiverSats.numsv_calcvel : number of satellites to calculate the velocity ReceiverSats.svtype : used sv system, bitfield. bit0:GPS , bit1:GLONASS , bit2:SBAS , bit3:QZSS_L1CA , bit4:IMES , bit5:QZSS_L1SAIF , bit6:Beidu , bit7:Galileo ReceiverSats.pos_svtype : used sv system to calculate position, bitfield ReceiverSats.vel_svtype : used sv system to calculate velocity, bitfield","title":"class ReceiverSats"},{"location":"reference/libs/sony/cxd5602gnss/docs/gnss/#class-receiverposition","text":"class ReceiverPosition () Class to store Receiver Position info retrieved by read() calls. N.B. Each attribute might be filled depending on selected read filter. List of attributes: ReceiverPosition.type : position type. 0:Invalid , 1:GNSS , 2:IMES , 3:user set , 4:previous ReceiverPosition.dgps : 0:SGPS , 1:DGPS ReceiverPosition.pos_fixmode : 1:Invalid , 2:2D , 3:3D ReceiverPosition.vel_fixmode : 1:Invalid , 2:2D VZ , 3:2D Offset , 4:3D , 5:1D , 6:PRED ReceiverPosition.assist : bit field [7..5] Reserved [4] AEP Velocity [3] AEP Position [2] CEP Velocity [1] CEP Position , [0] user set ReceiverPosition.pos_dataexist : 0:none , 1:exist ReceiverPosition.possource : position source. 0:Invalid , 1:GNSS , 2:IMES , 3:user set , 4:previous ReceiverPosition.tcxo_offset : TCXO offset [Hz] ReceiverPosition.latitude : latitude [degree] ReceiverPosition.longitude : longitude [degree] ReceiverPosition.altitude : altitude [m] ReceiverPosition.geoid : geoid height [m] ReceiverPosition.velocity : velocity [m/s] ReceiverPosition.direction : direction [degree] ReceiverPosition.precision : ReceiverPositionPrecision() instance","title":"class ReceiverPosition"},{"location":"reference/libs/sony/cxd5602gnss/docs/gnss/#class-receiverpositionprecision","text":"class ReceiverPositionPrecision () ReceiverPositionPrecision.pos_dop : DOP() instance ReceiverPositionPrecision.vel_idx : DOP() instance ReceiverPositionPrecision.pos_accuracy : Variance() instance","title":"class ReceiverPositionPrecision"},{"location":"reference/libs/sony/cxd5602gnss/docs/gnss/#class-dop","text":"class DOP () Class to store Dilution of Precision. Dop.pdop : position DOP Dop.hdop : horizontal DOP Dop.vdop : vertical DOP Dop.tdop : time DOP Dop.ewdop : East-West DOP Dop.nsdop : North-South DOP Dop.majdop : Stdev of semi-major axis Dop.mindop : Stdev of semi-minor axis Dop.oridop : orientation of semi-major axis [deg]","title":"class DOP"},{"location":"reference/libs/sony/cxd5602gnss/docs/gnss/#class-variance","text":"class Variance () Class to store Variance. Variance.hvar : horizontal variance Variance.vvar : vertical variance","title":"class Variance"},{"location":"reference/libs/sony/cxd5602gnss/docs/gnss/#utils","text":"","title":"Utils"},{"location":"reference/libs/sony/cxd5602gnss/docs/gnss/#double_to_dmf","text":"double_to_dmf ( x ) Arguments: x \u2013 double to convert. Converts from double format to degree-minute-frac format. Returns a tuple of four elements: (sign, degree, minute, frac) .","title":"double_to_dmf"},{"location":"reference/libs/stm/f4eth/docs/","text":"STM F4 Ethernet Driver \u00b6 This module implements the Zerynth driver for the STM32 F4 family Ethernet. This module supports SSL/TLS. Contents: STM32F4 Native Ethernet Module","title":"STM F4 Ethernet Driver"},{"location":"reference/libs/stm/f4eth/docs/#stm-f4-ethernet-driver","text":"This module implements the Zerynth driver for the STM32 F4 family Ethernet. This module supports SSL/TLS. Contents: STM32F4 Native Ethernet Module","title":"STM F4 Ethernet Driver"},{"location":"reference/libs/stm/f4eth/docs/f4eth/","text":"STM32F4 Native Ethernet Module \u00b6 This module implements the Zerynth driver for the STM32 F4 family Ethernet. This module supports SSL/TLS To use it: import streams from stm.f4eth import f4eth as eth streams . serial () print ( \"...\" ) eth . auto_init () eth . link () print ( eth . link_info ()) init \u00b6 init () Initializes the Ethernet chip connected to the device. The Ethernet chip is setup and can be managed using the Ethernet Module of the Zerynth Standard Library.","title":"STM32F4 Native Ethernet Module"},{"location":"reference/libs/stm/f4eth/docs/f4eth/#stm32f4-native-ethernet-module","text":"This module implements the Zerynth driver for the STM32 F4 family Ethernet. This module supports SSL/TLS To use it: import streams from stm.f4eth import f4eth as eth streams . serial () print ( \"...\" ) eth . auto_init () eth . link () print ( eth . link_info ())","title":"STM32F4 Native Ethernet Module"},{"location":"reference/libs/stm/f4eth/docs/f4eth/#init","text":"init () Initializes the Ethernet chip connected to the device. The Ethernet chip is setup and can be managed using the Ethernet Module of the Zerynth Standard Library.","title":"init"},{"location":"reference/libs/stm/hts221/docs/","text":"STM HTS221 \u00b6 The HTS221 is an ultra-compact sensor for relative humidity and temperature. It includes a sensing element and a mixed signal ASIC to provide the measurement information through digital serial interfaces. The sensing element consists of a polymer dielectric planar capacitor structure capable of detecting relative humidity variations and is manufactured using a dedicated ST process; more information at STMicroelectronics dedicated page . Technical Details \u00b6 Supply Voltage (Vdd): from 1.7 V to 3.6 V Operation Temperature (Top): from -40 \u00b0C to 120 \u00b0C Temperature Accuracy: \u00b1 0.5 \u00b0C, 15 to +40 \u00b0C Low Power Consumption: 2 uA @ 1 Hz ODR Selectable ODR: from 1 Hz to 12.5 Hz High rH Sensitivity: 0.004% rH/LSB Humidity Accuracy: \u00b1 3.5% rH, 20 to +80% rH Embedded 16-bit ADC SPI and I\u00b2C interfaces Here below, the Zerynth driver for the STMicroelectronics HTS221. Contents: HTS221 Module","title":"STM HTS221"},{"location":"reference/libs/stm/hts221/docs/#stm-hts221","text":"The HTS221 is an ultra-compact sensor for relative humidity and temperature. It includes a sensing element and a mixed signal ASIC to provide the measurement information through digital serial interfaces. The sensing element consists of a polymer dielectric planar capacitor structure capable of detecting relative humidity variations and is manufactured using a dedicated ST process; more information at STMicroelectronics dedicated page .","title":"STM HTS221"},{"location":"reference/libs/stm/hts221/docs/#technical-details","text":"Supply Voltage (Vdd): from 1.7 V to 3.6 V Operation Temperature (Top): from -40 \u00b0C to 120 \u00b0C Temperature Accuracy: \u00b1 0.5 \u00b0C, 15 to +40 \u00b0C Low Power Consumption: 2 uA @ 1 Hz ODR Selectable ODR: from 1 Hz to 12.5 Hz High rH Sensitivity: 0.004% rH/LSB Humidity Accuracy: \u00b1 3.5% rH, 20 to +80% rH Embedded 16-bit ADC SPI and I\u00b2C interfaces Here below, the Zerynth driver for the STMicroelectronics HTS221. Contents: HTS221 Module","title":"Technical Details"},{"location":"reference/libs/stm/hts221/docs/hts221/","text":"HTS221 Module \u00b6 This module contains the driver for STMicroelectronics HTS221 temperature and relative humidity sensor. Its highlight is that it outputs its measurement in a 16-bit resolution and has a high rH sensitivity of 0.004% ( datasheet ). class HTS221 \u00b6 class HTS221 ( drvsel , int_pin , address = 0x5F , clk = 400000 ) Creates an intance of a new HTS221. Arguments: drvsel \u2013 I2C Bus used ( I2C0, I2C0 ) int_pin \u2013 Interrupt pin used for events address \u2013 Slave address, default 0x5f clk \u2013 Clock speed, default 400kHz Example: from stm.hts221 import hts221 temp_hum = hts221 . HTS221 ( I2C1 , D31 ) temp , hum = temp_hum . get_temp_humidity () HTS221.get_temp_humidity \u00b6 get_temp_humidity () Retrieves both temperature and humidity in one call. Returns temp, humidity","title":"HTS221 Module"},{"location":"reference/libs/stm/hts221/docs/hts221/#hts221-module","text":"This module contains the driver for STMicroelectronics HTS221 temperature and relative humidity sensor. Its highlight is that it outputs its measurement in a 16-bit resolution and has a high rH sensitivity of 0.004% ( datasheet ).","title":"HTS221 Module"},{"location":"reference/libs/stm/hts221/docs/hts221/#class-hts221","text":"class HTS221 ( drvsel , int_pin , address = 0x5F , clk = 400000 ) Creates an intance of a new HTS221. Arguments: drvsel \u2013 I2C Bus used ( I2C0, I2C0 ) int_pin \u2013 Interrupt pin used for events address \u2013 Slave address, default 0x5f clk \u2013 Clock speed, default 400kHz Example: from stm.hts221 import hts221 temp_hum = hts221 . HTS221 ( I2C1 , D31 ) temp , hum = temp_hum . get_temp_humidity ()","title":"class HTS221"},{"location":"reference/libs/stm/hts221/docs/hts221/#hts221get_temp_humidity","text":"get_temp_humidity () Retrieves both temperature and humidity in one call. Returns temp, humidity","title":"HTS221.get_temp_humidity"},{"location":"reference/libs/stm/iis3dwb/docs/","text":"IIS3DWB \u00b6 The IIS3DWB is a system-in-package featuring a 3-axis digital vibration sensor with low noise over an ultra-wide and flat frequency range. The wide bandwidth, low noise, very stable and repeatable sensitivity, together with the capability of operating over an extended temperature range (up to +105 \u00b0C), make the device particularly suitable for vibration monitoring in industrial applications. The high performance delivered at low power consumption together with the digital output and the embedded digital features like the FIFO and the interrupts are enabling features for battery-operated industrial wireless sensor nodes. The IIS3DWB has a selectable full-scale acceleration range of \u00b12/\u00b14/\u00b18/\u00b116 g and is capable of measuring accelerations with a bandwidth up to 6 kHz with an output data rate of 26.7 kHz. A 3 kB first-in, first-out (FIFO) buffer is integrated in the device to avoid any data loss and to limit intervention of the host processor. The IIS3DWB has a self-test capability which allows checking the functioning of the sensor in the final application. More information at STMicroelectronics dedicated page Technical Details \u00b6 Wide supply voltage, 2.1 V to 3.6 V Ultra-low power consumption \u00b12g/\u00b14g/\u00b18g/\u00b116g full-scale 3D Accelerometer Ultra-wide and flat frequency response range: from dc to 6 kHz (\u00b13 dB point) Ultra-low noise density: down to 75 \u00b5g/\u221aHz in 3-axis mode / 60 \u00b5g/\u221aHz in single-axis mode I2C/SPI digital output interface 16-bit data output Extended temperature range from -40 to +105 \u00b0C Below, Zerynth driver documentation for STM IIS3DWB chip. Contents: IIS3DWB Module Example get data","title":"IIS3DWB"},{"location":"reference/libs/stm/iis3dwb/docs/#iis3dwb","text":"The IIS3DWB is a system-in-package featuring a 3-axis digital vibration sensor with low noise over an ultra-wide and flat frequency range. The wide bandwidth, low noise, very stable and repeatable sensitivity, together with the capability of operating over an extended temperature range (up to +105 \u00b0C), make the device particularly suitable for vibration monitoring in industrial applications. The high performance delivered at low power consumption together with the digital output and the embedded digital features like the FIFO and the interrupts are enabling features for battery-operated industrial wireless sensor nodes. The IIS3DWB has a selectable full-scale acceleration range of \u00b12/\u00b14/\u00b18/\u00b116 g and is capable of measuring accelerations with a bandwidth up to 6 kHz with an output data rate of 26.7 kHz. A 3 kB first-in, first-out (FIFO) buffer is integrated in the device to avoid any data loss and to limit intervention of the host processor. The IIS3DWB has a self-test capability which allows checking the functioning of the sensor in the final application. More information at STMicroelectronics dedicated page","title":"IIS3DWB"},{"location":"reference/libs/stm/iis3dwb/docs/#technical-details","text":"Wide supply voltage, 2.1 V to 3.6 V Ultra-low power consumption \u00b12g/\u00b14g/\u00b18g/\u00b116g full-scale 3D Accelerometer Ultra-wide and flat frequency response range: from dc to 6 kHz (\u00b13 dB point) Ultra-low noise density: down to 75 \u00b5g/\u221aHz in 3-axis mode / 60 \u00b5g/\u221aHz in single-axis mode I2C/SPI digital output interface 16-bit data output Extended temperature range from -40 to +105 \u00b0C Below, Zerynth driver documentation for STM IIS3DWB chip. Contents: IIS3DWB Module Example get data","title":"Technical Details"},{"location":"reference/libs/stm/iis3dwb/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.stm.iis3dwb. Read Vibrometer and Temperature data from IIS3DWB \u00b6 Basic example to read the current values of acceleration, and temperature from STM sensor IIS3DWB. main.py ################################################################################ # Get Data Example # # Created: 2020-03-31 16:23:12.973495 # ################################################################################ import streams from stm.iis3dwb import iis3dwb streams . serial () try : # Setup sensor print ( \"start...\" ) vibro = iis3dwb . IIS3DWB ( SPI0 , D86 ) print ( \"Ready!\" ) print ( \"--------------------------------------------------------\" ) except Exception as e : print ( \"Error: \" , e ) try : while True : raw_acc = vibro . get_acc_data ( raw = True ) print ( \"Raw Acc:\" , raw_acc ) acc = vibro . get_acc_data () str = \"Acc: %.2f ,\" % acc [ 0 ] str = str + \" %.2f ,\" % acc [ 1 ] str = str + \" %.2f ,\" % acc [ 2 ] print ( str ) raw_temp = vibro . get_temp_data ( raw = True ) print ( \"Raw Temperature:\" , raw_temp ) temp = vibro . get_temp_data () print ( \"TEMP:\" , temp ) print ( \"--------------------------------------------------------\" ) print ( \"========================================================\" ) print ( \"Fast Read:\" ) data = vibro . get_fast () print ( \"TEMP: \" , data [ 0 ]) str = \"Acc: %.2f ,\" % data [ 1 ] str = str + \" %.2f ,\" % data [ 2 ] str = str + \" %.2f ,\" % data [ 3 ] print ( str ) print ( \"========================================================\" ) print ( \"--------------------------------------------------------\" ) sleep ( 5000 ) except Exception as e : print ( \"Error2: \" , e )","title":"Examples"},{"location":"reference/libs/stm/iis3dwb/docs/examples/#examples","text":"The following are a list of examples for lib.stm.iis3dwb.","title":"Examples"},{"location":"reference/libs/stm/iis3dwb/docs/examples/#read-vibrometer-and-temperature-data-from-iis3dwb","text":"Basic example to read the current values of acceleration, and temperature from STM sensor IIS3DWB. main.py ################################################################################ # Get Data Example # # Created: 2020-03-31 16:23:12.973495 # ################################################################################ import streams from stm.iis3dwb import iis3dwb streams . serial () try : # Setup sensor print ( \"start...\" ) vibro = iis3dwb . IIS3DWB ( SPI0 , D86 ) print ( \"Ready!\" ) print ( \"--------------------------------------------------------\" ) except Exception as e : print ( \"Error: \" , e ) try : while True : raw_acc = vibro . get_acc_data ( raw = True ) print ( \"Raw Acc:\" , raw_acc ) acc = vibro . get_acc_data () str = \"Acc: %.2f ,\" % acc [ 0 ] str = str + \" %.2f ,\" % acc [ 1 ] str = str + \" %.2f ,\" % acc [ 2 ] print ( str ) raw_temp = vibro . get_temp_data ( raw = True ) print ( \"Raw Temperature:\" , raw_temp ) temp = vibro . get_temp_data () print ( \"TEMP:\" , temp ) print ( \"--------------------------------------------------------\" ) print ( \"========================================================\" ) print ( \"Fast Read:\" ) data = vibro . get_fast () print ( \"TEMP: \" , data [ 0 ]) str = \"Acc: %.2f ,\" % data [ 1 ] str = str + \" %.2f ,\" % data [ 2 ] str = str + \" %.2f ,\" % data [ 3 ] print ( str ) print ( \"========================================================\" ) print ( \"--------------------------------------------------------\" ) sleep ( 5000 ) except Exception as e : print ( \"Error2: \" , e )","title":"Read Vibrometer and Temperature data from IIS3DWB"},{"location":"reference/libs/stm/iis3dwb/docs/iis3dwb/","text":"IIS3DWB Module \u00b6 This module contains the driver for STMicroelectronics IIS3DWB 3-axis digital vibration sensor with low noise over an ultra-wide and flat frequency range. In the IIS3DWB, the sensing elements of the accelerometer are implemented on the same silicon die, thus guaranteeing superior stability and robustness. ( datasheet ). class IIS3DWB \u00b6 class IIS3DWB ( spidrv , pin_cs , clk = 5000000 ) Class which provides a simple interface to IIS3DWB features. Creates an instance of IIS3DWB class, using the specified SPI settings and initial device configuration. Arguments: spidrv \u2013 the SPI driver to use (SPI0, \u2026) pin_cs \u2013 Chip select pin to access the IIS3DWB chip clk \u2013 Clock speed, default 500 kHz Example: from stm.iis3dwb import iis3dwb ... vibro = iis3dwb . IIS3DWB ( SPI0 , D10 ) acc = vibro . get_acc_data () IIS3DWB.reset \u00b6 reset () Reset the device using the internal register flag. IIS3DWB.enable \u00b6 enable ( odr = IIS3DWB_ODR_26k7Hz , fs = 0 ) Sets the device\u2019s configuration registers for accelerometer. Parameters: odr : sets the Output Data Rate of the device. Available values are: Value Output Data Rate Constant Name 0x00 OFF IIS3DWB_ODR_OFF 0x05 26.7 KHz IIS3DWB_ODR_26k7Hz fs : sets the Device Full Scale. Available values are: Value Full Scale Costant Name in mg/LSB 0x00 \u00b12g IIS3DWB_ACC_SENS_FS_2G 0.061 mg/LSB 0x01 \u00b14g IIS3DWB_ACC_SENS_FS_4G 0.122 mg/LSB 0x02 \u00b18g IIS3DWB_ACC_SENS_FS_8G 0.244 mg/LSB 0x03 \u00b116g IIS3DWB_ACC_SENS_FS_16G 0.488 mg/LSB Returns True if configuration is successful, False otherwise. IIS3DWB.disable \u00b6 disable () Disables the accelerator sensor. Returns True if configuration is successful, False otherwise. IIS3DWB.whoami \u00b6 whoami () Value of the IIS3DWB_WHO_AM_I register (0x6B). IIS3DWB.get_acc_data \u00b6 get_acc_data ( ms2 = True , raw = False ) Retrieves accelerometer data in one call. Arguments: ms2 \u2013 If ms2 flag is True, returns data converted in m/s^2; otherwise in mg (default True) raw \u2013 If raw flag is True, returns raw register values (default False) Returns acc_x, acc_y, acc_z. IIS3DWB.get_temp \u00b6 get_temp () Retrieves temperature in one call; if raw flag is enabled, returns raw register values. Returns temp. IIS3DWB.get_fast \u00b6 get_fast () Retrieves all data sensors in one call in fast way (c-code acquisition). Temperature in \u00b0C Acceleration in m/s^2 Returns temp, acc_x, acc_y, acc_z. IIS3DWB.set_event_interrupt \u00b6 set_event_interrupt ( pin_int , enable ) Enables the interrupt pins. When data from sensor will be ready, the related interrupt pin configured will be set to high. Arguments: pin_int \u2013 ID of the interrupt pin to be enabled/disabled. Available values are 1 o 2. enable \u2013 If enable flag is True, interrupt pin will be enabled, otherwise will be disabled. Returns True if configuration is successful, False otherwise.","title":"IIS3DWB Module"},{"location":"reference/libs/stm/iis3dwb/docs/iis3dwb/#iis3dwb-module","text":"This module contains the driver for STMicroelectronics IIS3DWB 3-axis digital vibration sensor with low noise over an ultra-wide and flat frequency range. In the IIS3DWB, the sensing elements of the accelerometer are implemented on the same silicon die, thus guaranteeing superior stability and robustness. ( datasheet ).","title":"IIS3DWB Module"},{"location":"reference/libs/stm/iis3dwb/docs/iis3dwb/#class-iis3dwb","text":"class IIS3DWB ( spidrv , pin_cs , clk = 5000000 ) Class which provides a simple interface to IIS3DWB features. Creates an instance of IIS3DWB class, using the specified SPI settings and initial device configuration. Arguments: spidrv \u2013 the SPI driver to use (SPI0, \u2026) pin_cs \u2013 Chip select pin to access the IIS3DWB chip clk \u2013 Clock speed, default 500 kHz Example: from stm.iis3dwb import iis3dwb ... vibro = iis3dwb . IIS3DWB ( SPI0 , D10 ) acc = vibro . get_acc_data ()","title":"class IIS3DWB"},{"location":"reference/libs/stm/iis3dwb/docs/iis3dwb/#iis3dwbreset","text":"reset () Reset the device using the internal register flag.","title":"IIS3DWB.reset"},{"location":"reference/libs/stm/iis3dwb/docs/iis3dwb/#iis3dwbenable","text":"enable ( odr = IIS3DWB_ODR_26k7Hz , fs = 0 ) Sets the device\u2019s configuration registers for accelerometer. Parameters: odr : sets the Output Data Rate of the device. Available values are: Value Output Data Rate Constant Name 0x00 OFF IIS3DWB_ODR_OFF 0x05 26.7 KHz IIS3DWB_ODR_26k7Hz fs : sets the Device Full Scale. Available values are: Value Full Scale Costant Name in mg/LSB 0x00 \u00b12g IIS3DWB_ACC_SENS_FS_2G 0.061 mg/LSB 0x01 \u00b14g IIS3DWB_ACC_SENS_FS_4G 0.122 mg/LSB 0x02 \u00b18g IIS3DWB_ACC_SENS_FS_8G 0.244 mg/LSB 0x03 \u00b116g IIS3DWB_ACC_SENS_FS_16G 0.488 mg/LSB Returns True if configuration is successful, False otherwise.","title":"IIS3DWB.enable"},{"location":"reference/libs/stm/iis3dwb/docs/iis3dwb/#iis3dwbdisable","text":"disable () Disables the accelerator sensor. Returns True if configuration is successful, False otherwise.","title":"IIS3DWB.disable"},{"location":"reference/libs/stm/iis3dwb/docs/iis3dwb/#iis3dwbwhoami","text":"whoami () Value of the IIS3DWB_WHO_AM_I register (0x6B).","title":"IIS3DWB.whoami"},{"location":"reference/libs/stm/iis3dwb/docs/iis3dwb/#iis3dwbget_acc_data","text":"get_acc_data ( ms2 = True , raw = False ) Retrieves accelerometer data in one call. Arguments: ms2 \u2013 If ms2 flag is True, returns data converted in m/s^2; otherwise in mg (default True) raw \u2013 If raw flag is True, returns raw register values (default False) Returns acc_x, acc_y, acc_z.","title":"IIS3DWB.get_acc_data"},{"location":"reference/libs/stm/iis3dwb/docs/iis3dwb/#iis3dwbget_temp","text":"get_temp () Retrieves temperature in one call; if raw flag is enabled, returns raw register values. Returns temp.","title":"IIS3DWB.get_temp"},{"location":"reference/libs/stm/iis3dwb/docs/iis3dwb/#iis3dwbget_fast","text":"get_fast () Retrieves all data sensors in one call in fast way (c-code acquisition). Temperature in \u00b0C Acceleration in m/s^2 Returns temp, acc_x, acc_y, acc_z.","title":"IIS3DWB.get_fast"},{"location":"reference/libs/stm/iis3dwb/docs/iis3dwb/#iis3dwbset_event_interrupt","text":"set_event_interrupt ( pin_int , enable ) Enables the interrupt pins. When data from sensor will be ready, the related interrupt pin configured will be set to high. Arguments: pin_int \u2013 ID of the interrupt pin to be enabled/disabled. Available values are 1 o 2. enable \u2013 If enable flag is True, interrupt pin will be enabled, otherwise will be disabled. Returns True if configuration is successful, False otherwise.","title":"IIS3DWB.set_event_interrupt"},{"location":"reference/libs/stm/ism330dhcx/docs/","text":"ISM330DHCX \u00b6 The ISM330DHCX is a system-in-package featuring a high-performance 3D digital accelerometer and 3D digital gyroscope tailored for Industry 4.0 applications. The ISM330DHCX has a full-scale acceleration range of \u00b12/\u00b14/\u00b18/\u00b116 g and a wide angular rate range of \u00b1125/\u00b1250/\u00b1500/\u00b11000/\u00b12000/\u00b14000 dps that enable its usage in a broad range of applications. All the design aspects and the calibration of the ISM330DHCX have been optimized to reach superior accuracy, stability, extremely low noise and full data synchronization. An unmatched set of embedded features (Machine Learning Core, programmable FSM, FIFO, sensor hub, event decoding and interrupts) are enablers for implementing smart and complex sensor nodes which deliver high performance at very low power. The ISM330DHCX is available in a 14-lead plastic land grid array (LGA) package. More information at STMicroelectronics dedicated page Technical Details \u00b6 Wide supply voltage, 1.71 V to 3.6 V Ultra-low power consumption \u00b12g/\u00b14g/\u00b18g/\u00b116g full-scale 3D Accelerometer \u00b1125/\u00b1250/\u00b1500/\u00b11000/\u00b12000/\u00b14000 dps full-scale 3D Gyroscope I2C/SPI digital output interface 16-bit data output Extended temperature range from -40 to +105 \u00b0C Below, Zerynth driver documentation for STM ISM330DHCX chip. Contents: ISM330DHCX Module Examples get data","title":"ISM330DHCX"},{"location":"reference/libs/stm/ism330dhcx/docs/#ism330dhcx","text":"The ISM330DHCX is a system-in-package featuring a high-performance 3D digital accelerometer and 3D digital gyroscope tailored for Industry 4.0 applications. The ISM330DHCX has a full-scale acceleration range of \u00b12/\u00b14/\u00b18/\u00b116 g and a wide angular rate range of \u00b1125/\u00b1250/\u00b1500/\u00b11000/\u00b12000/\u00b14000 dps that enable its usage in a broad range of applications. All the design aspects and the calibration of the ISM330DHCX have been optimized to reach superior accuracy, stability, extremely low noise and full data synchronization. An unmatched set of embedded features (Machine Learning Core, programmable FSM, FIFO, sensor hub, event decoding and interrupts) are enablers for implementing smart and complex sensor nodes which deliver high performance at very low power. The ISM330DHCX is available in a 14-lead plastic land grid array (LGA) package. More information at STMicroelectronics dedicated page","title":"ISM330DHCX"},{"location":"reference/libs/stm/ism330dhcx/docs/#technical-details","text":"Wide supply voltage, 1.71 V to 3.6 V Ultra-low power consumption \u00b12g/\u00b14g/\u00b18g/\u00b116g full-scale 3D Accelerometer \u00b1125/\u00b1250/\u00b1500/\u00b11000/\u00b12000/\u00b14000 dps full-scale 3D Gyroscope I2C/SPI digital output interface 16-bit data output Extended temperature range from -40 to +105 \u00b0C Below, Zerynth driver documentation for STM ISM330DHCX chip. Contents: ISM330DHCX Module Examples get data","title":"Technical Details"},{"location":"reference/libs/stm/ism330dhcx/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.stm.ism330dhcx. Read Accelerometer, Gyroscope and Temperature data from ISM330DHCX \u00b6 Basic example to read the current values of acceleration, angular velocity, and temperature from STM sensor ISM330DHCX. main.py ################################################################################ # Get Data Example # # Created: 2020-03-31 16:23:12.973495 # ################################################################################ import streams from stm.ism330dhcx import ism330dhcx streams . serial () try : # Setup sensor print ( \"start...\" ) accgyro = ism330dhcx . ISM330DHCX ( SPI0 , D86 ) print ( \"Ready!\" ) print ( \"--------------------------------------------------------\" ) except Exception as e : print ( \"Error: \" , e ) try : while True : raw_acc = accgyro . get_acc_data ( raw = True ) print ( \"Raw Acc:\" , raw_acc ) acc = accgyro . get_acc_data () str = \"Acc: %.2f ,\" % acc [ 0 ] str = str + \" %.2f ,\" % acc [ 1 ] str = str + \" %.2f ,\" % acc [ 2 ] print ( str ) raw_gyro = accgyro . get_gyro_data ( raw = True ) print ( \"Raw Gyro:\" , raw_gyro ) gyro = accgyro . get_gyro_data () # print(\"Gyro:\", gyro) str = \"Gyro: %.2f ,\" % ( gyro [ 0 ] / 1000.0 ) str = str + \" %.2f ,\" % ( gyro [ 1 ] / 1000.0 ) str = str + \" %.2f ,\" % ( gyro [ 2 ] / 1000.0 ) print ( str ) raw_temp = accgyro . get_temp_data ( raw = True ) print ( \"Raw Temperature:\" , raw_temp ) temp = accgyro . get_temp_data () print ( \"Temperature:\" , temp ) print ( \"--------------------------------------------------------\" ) print ( \"========================================================\" ) print ( \"Fast Read:\" ) data = accgyro . get_fast () print ( \"TEMP: \" , data [ 0 ]) str = \"Acc: %.2f ,\" % data [ 1 ] str = str + \" %.2f ,\" % data [ 2 ] str = str + \" %.2f ,\" % data [ 3 ] print ( str ) str = \"Gyro: %.2f ,\" % ( data [ 4 ]) str = str + \" %.2f ,\" % ( data [ 5 ]) str = str + \" %.2f ,\" % ( data [ 6 ]) print ( str ) print ( \"========================================================\" ) print ( \"--------------------------------------------------------\" ) sleep ( 5000 ) except Exception as e : print ( \"Error2: \" , e )","title":"Examples"},{"location":"reference/libs/stm/ism330dhcx/docs/examples/#examples","text":"The following are a list of examples for lib.stm.ism330dhcx.","title":"Examples"},{"location":"reference/libs/stm/ism330dhcx/docs/examples/#read-accelerometer-gyroscope-and-temperature-data-from-ism330dhcx","text":"Basic example to read the current values of acceleration, angular velocity, and temperature from STM sensor ISM330DHCX. main.py ################################################################################ # Get Data Example # # Created: 2020-03-31 16:23:12.973495 # ################################################################################ import streams from stm.ism330dhcx import ism330dhcx streams . serial () try : # Setup sensor print ( \"start...\" ) accgyro = ism330dhcx . ISM330DHCX ( SPI0 , D86 ) print ( \"Ready!\" ) print ( \"--------------------------------------------------------\" ) except Exception as e : print ( \"Error: \" , e ) try : while True : raw_acc = accgyro . get_acc_data ( raw = True ) print ( \"Raw Acc:\" , raw_acc ) acc = accgyro . get_acc_data () str = \"Acc: %.2f ,\" % acc [ 0 ] str = str + \" %.2f ,\" % acc [ 1 ] str = str + \" %.2f ,\" % acc [ 2 ] print ( str ) raw_gyro = accgyro . get_gyro_data ( raw = True ) print ( \"Raw Gyro:\" , raw_gyro ) gyro = accgyro . get_gyro_data () # print(\"Gyro:\", gyro) str = \"Gyro: %.2f ,\" % ( gyro [ 0 ] / 1000.0 ) str = str + \" %.2f ,\" % ( gyro [ 1 ] / 1000.0 ) str = str + \" %.2f ,\" % ( gyro [ 2 ] / 1000.0 ) print ( str ) raw_temp = accgyro . get_temp_data ( raw = True ) print ( \"Raw Temperature:\" , raw_temp ) temp = accgyro . get_temp_data () print ( \"Temperature:\" , temp ) print ( \"--------------------------------------------------------\" ) print ( \"========================================================\" ) print ( \"Fast Read:\" ) data = accgyro . get_fast () print ( \"TEMP: \" , data [ 0 ]) str = \"Acc: %.2f ,\" % data [ 1 ] str = str + \" %.2f ,\" % data [ 2 ] str = str + \" %.2f ,\" % data [ 3 ] print ( str ) str = \"Gyro: %.2f ,\" % ( data [ 4 ]) str = str + \" %.2f ,\" % ( data [ 5 ]) str = str + \" %.2f ,\" % ( data [ 6 ]) print ( str ) print ( \"========================================================\" ) print ( \"--------------------------------------------------------\" ) sleep ( 5000 ) except Exception as e : print ( \"Error2: \" , e )","title":"Read Accelerometer, Gyroscope and Temperature data from ISM330DHCX"},{"location":"reference/libs/stm/ism330dhcx/docs/ism330dhcx/","text":"ISM330DHCX Module \u00b6 This module contains the driver for STMicroelectronics ISM330DHCX 3-axis accelerometer and gyroscope. In the ISM330DHCX, the sensing elements of the accelerometer and of the gyroscope are implemented on the same silicon die, thus guaranteeing superior stability and robustness. ( datasheet ). class ISM330DHCX \u00b6 class ISM330DHCX ( spidrv , pin_cs , clk = 5000000 ) Class which provides a simple interface to ISM330DHCX features. Creates an instance of ISM330DHCX class, using the specified SPI settings and initial device configuration Arguments: spidrv \u2013 the SPI driver to use (SPI0, \u2026) pin_cs \u2013 Chip select pin to access the ISM330DHCX chip clk \u2013 Clock speed, default 500 kHz Example: from stm.ism330dhcx import ism330dhcx ... accgyro = ism330dhcx . ISM330DHCX ( SPI0 , D10 ) acc = accgyro . get_acc_data () gyro = accgyro . get_gyro_data () ISM330DHCX.reset \u00b6 reset () Reset the device using the internal register flag. ISM330DHCX.enable_acc \u00b6 enable_acc ( odr = ISM330DHCX_ODR_417Hz , fs = 0 ) Sets the device\u2019s configuration registers for accelerometer. Parameters: odr : sets the Output Data Rate of the device. Available values are: Value Output Data Rate Constant Name 0x00 OFF ISM330DHCX_ODR_OFF 0x01 12.5 Hz ISM330DHCX_ODR_12Hz5 0x02 26 Hz ISM330DHCX_ODR_26Hz 0x03 52 Hz ISM330DHCX_ODR_52Hz 0x04 104 Hz ISM330DHCX_ODR_104Hz 0x05 208 Hz ISM330DHCX_ODR_208Hz 0x06 417 Hz ISM330DHCX_ODR_417Hz 0x07 833 Hz ISM330DHCX_ODR_833Hz 0x08 1.667 KHz ISM330DHCX_ODR_1667Hz 0x09 3.333 KHz ISM330DHCX_ODR_3333Hz 0x0A 6.667 KHz ISM330DHCX_ODR_6667Hz 0x0B 6.5 Hz ISM330DHCX_ODR_6Hz5 fs : sets the Device Full Scale. Available values are: Value Full Scale Costant Name in mg/LSB 0x00 \u00b12g ISM330DHCX_ACC_SENS_FS_2G 0.061 mg/LSB 0x01 \u00b14g ISM330DHCX_ACC_SENS_FS_4G 0.122 mg/LSB 0x02 \u00b18g ISM330DHCX_ACC_SENS_FS_8G 0.244 mg/LSB 0x03 \u00b116g ISM330DHCX_ACC_SENS_FS_16G 0.488 mg/LSB Returns True if configuration is successful, False otherwise. ISM330DHCX.disable_acc \u00b6 disable_acc () Disables the accelerator sensor. Returns True if configuration is successful, False otherwise. ISM330DHCX.enable_gyro \u00b6 enable_gyro ( odr = ISM330DHCX_ODR_417Hz , fs = 0 ) Sets the device\u2019s configuration registers for gyroscope. Parameters: odr : sets the Output Data Rate of the device. Available values are: Value Output Data Rate Constant Name 0x00 OFF ISM330DHCX_ODR_OFF 0x01 12.5 Hz ISM330DHCX_ODR_12Hz5 0x02 26 Hz ISM330DHCX_ODR_26Hz 0x03 52 Hz ISM330DHCX_ODR_52Hz 0x04 104 Hz ISM330DHCX_ODR_104Hz 0x05 208 Hz ISM330DHCX_ODR_208Hz 0x06 417 Hz ISM330DHCX_ODR_417Hz 0x07 833 Hz ISM330DHCX_ODR_833Hz 0x08 1.667 KHz ISM330DHCX_ODR_1667Hz 0x09 3.333 KHz ISM330DHCX_ODR_3333Hz 0x0A 6.667 KHz ISM330DHCX_ODR_6667Hz fs : sets the Device Full Scale. Available values are: Value Full Scale Costant Name in mdps/LSB 0x00 \u00b1125 dps ISM330DHCX_GYRO_SENS_FS_125DPS 4.375 mdps/LSB 0x01 \u00b1250 dps ISM330DHCX_GYRO_SENS_FS_250DPS 8.750 mdps/LSB 0x02 \u00b1500 dps ISM330DHCX_GYRO_SENS_FS_500DPS 17.500 mdps/LSB 0x03 \u00b11000 dps ISM330DHCX_GYRO_SENS_FS_1000DPS 35.000 mdps/LSB 0x04 \u00b12000 dps ISM330DHCX_GYRO_SENS_FS_2000DPS 70.000 mdps/LSB 0x05 \u00b14000 dps ISM330DHCX_GYRO_SENS_FS_4000DPS 140.000 mdps/LSB Returns True if configuration is successful, False otherwise. ISM330DHCX.disable_gyro \u00b6 disable_gyro () Disables the gyroscope sensor. Returns True if configuration is successful, False otherwise. ISM330DHCX.whoami \u00b6 whoami () Value of the ISM330DHCX_WHO_AM_I register (0x6B). ISM330DHCX.get_acc_data \u00b6 get_acc_data ( ms2 = True , raw = False ) Retrieves accelerometer data in one call. Arguments: ms2 \u2013 If ms2 flag is True, returns data converted in m/s^2; otherwise in mg (default True) raw \u2013 If raw flag is True, returns raw register values (default False) Returns acc_x, acc_y, acc_z. ISM330DHCX.get_gyro_data \u00b6 get_gyro_data ( dps = True , raw = False ) Retrieves gyroscope data in one call. Arguments: dps \u2013 If dps flag is True, returns data converted in dps; otherwise in mdps (default True) raw \u2013 If raw flag is True, returns raw register values (default False) Returns gyro_x, gyro_y, gyro_z. ISM330DHCX.get_temp \u00b6 get_temp () Retrieves temperature in one call; if raw flag is enabled, returns raw register values. Returns temp. ISM330DHCX.get_fast \u00b6 get_fast () Retrieves all data sensors in one call in fast way (c-code acquisition). Temperature in \u00b0C Acceleration in m/s^2 Angular Velocity in dps (degrees per second) Returns temp, acc_x, acc_y, acc_z, gyro_x, gyro_y, gyro_z. ISM330DHCX.set_event_interrupt \u00b6 set_event_interrupt ( pin_int , sensor , enable ) Enables the interrupt pins. When data from sensor selected will be ready, the related interrupt pin configured will be set to high. Arguments: pin_int \u2013 ID of the interrupt pin to be enabled/disabled. Available values are 1 o 2. sensor \u2013 Data Ready flag selector. Available values are \u201cacc\u201d or \u201cgyro\u201d. enable \u2013 If enable flag is True, interrupt pin will be enabled, otherwise will be disabled. Returns True if configuration is successful, False otherwise.","title":"ISM330DHCX Module"},{"location":"reference/libs/stm/ism330dhcx/docs/ism330dhcx/#ism330dhcx-module","text":"This module contains the driver for STMicroelectronics ISM330DHCX 3-axis accelerometer and gyroscope. In the ISM330DHCX, the sensing elements of the accelerometer and of the gyroscope are implemented on the same silicon die, thus guaranteeing superior stability and robustness. ( datasheet ).","title":"ISM330DHCX Module"},{"location":"reference/libs/stm/ism330dhcx/docs/ism330dhcx/#class-ism330dhcx","text":"class ISM330DHCX ( spidrv , pin_cs , clk = 5000000 ) Class which provides a simple interface to ISM330DHCX features. Creates an instance of ISM330DHCX class, using the specified SPI settings and initial device configuration Arguments: spidrv \u2013 the SPI driver to use (SPI0, \u2026) pin_cs \u2013 Chip select pin to access the ISM330DHCX chip clk \u2013 Clock speed, default 500 kHz Example: from stm.ism330dhcx import ism330dhcx ... accgyro = ism330dhcx . ISM330DHCX ( SPI0 , D10 ) acc = accgyro . get_acc_data () gyro = accgyro . get_gyro_data ()","title":"class ISM330DHCX"},{"location":"reference/libs/stm/ism330dhcx/docs/ism330dhcx/#ism330dhcxreset","text":"reset () Reset the device using the internal register flag.","title":"ISM330DHCX.reset"},{"location":"reference/libs/stm/ism330dhcx/docs/ism330dhcx/#ism330dhcxenable_acc","text":"enable_acc ( odr = ISM330DHCX_ODR_417Hz , fs = 0 ) Sets the device\u2019s configuration registers for accelerometer. Parameters: odr : sets the Output Data Rate of the device. Available values are: Value Output Data Rate Constant Name 0x00 OFF ISM330DHCX_ODR_OFF 0x01 12.5 Hz ISM330DHCX_ODR_12Hz5 0x02 26 Hz ISM330DHCX_ODR_26Hz 0x03 52 Hz ISM330DHCX_ODR_52Hz 0x04 104 Hz ISM330DHCX_ODR_104Hz 0x05 208 Hz ISM330DHCX_ODR_208Hz 0x06 417 Hz ISM330DHCX_ODR_417Hz 0x07 833 Hz ISM330DHCX_ODR_833Hz 0x08 1.667 KHz ISM330DHCX_ODR_1667Hz 0x09 3.333 KHz ISM330DHCX_ODR_3333Hz 0x0A 6.667 KHz ISM330DHCX_ODR_6667Hz 0x0B 6.5 Hz ISM330DHCX_ODR_6Hz5 fs : sets the Device Full Scale. Available values are: Value Full Scale Costant Name in mg/LSB 0x00 \u00b12g ISM330DHCX_ACC_SENS_FS_2G 0.061 mg/LSB 0x01 \u00b14g ISM330DHCX_ACC_SENS_FS_4G 0.122 mg/LSB 0x02 \u00b18g ISM330DHCX_ACC_SENS_FS_8G 0.244 mg/LSB 0x03 \u00b116g ISM330DHCX_ACC_SENS_FS_16G 0.488 mg/LSB Returns True if configuration is successful, False otherwise.","title":"ISM330DHCX.enable_acc"},{"location":"reference/libs/stm/ism330dhcx/docs/ism330dhcx/#ism330dhcxdisable_acc","text":"disable_acc () Disables the accelerator sensor. Returns True if configuration is successful, False otherwise.","title":"ISM330DHCX.disable_acc"},{"location":"reference/libs/stm/ism330dhcx/docs/ism330dhcx/#ism330dhcxenable_gyro","text":"enable_gyro ( odr = ISM330DHCX_ODR_417Hz , fs = 0 ) Sets the device\u2019s configuration registers for gyroscope. Parameters: odr : sets the Output Data Rate of the device. Available values are: Value Output Data Rate Constant Name 0x00 OFF ISM330DHCX_ODR_OFF 0x01 12.5 Hz ISM330DHCX_ODR_12Hz5 0x02 26 Hz ISM330DHCX_ODR_26Hz 0x03 52 Hz ISM330DHCX_ODR_52Hz 0x04 104 Hz ISM330DHCX_ODR_104Hz 0x05 208 Hz ISM330DHCX_ODR_208Hz 0x06 417 Hz ISM330DHCX_ODR_417Hz 0x07 833 Hz ISM330DHCX_ODR_833Hz 0x08 1.667 KHz ISM330DHCX_ODR_1667Hz 0x09 3.333 KHz ISM330DHCX_ODR_3333Hz 0x0A 6.667 KHz ISM330DHCX_ODR_6667Hz fs : sets the Device Full Scale. Available values are: Value Full Scale Costant Name in mdps/LSB 0x00 \u00b1125 dps ISM330DHCX_GYRO_SENS_FS_125DPS 4.375 mdps/LSB 0x01 \u00b1250 dps ISM330DHCX_GYRO_SENS_FS_250DPS 8.750 mdps/LSB 0x02 \u00b1500 dps ISM330DHCX_GYRO_SENS_FS_500DPS 17.500 mdps/LSB 0x03 \u00b11000 dps ISM330DHCX_GYRO_SENS_FS_1000DPS 35.000 mdps/LSB 0x04 \u00b12000 dps ISM330DHCX_GYRO_SENS_FS_2000DPS 70.000 mdps/LSB 0x05 \u00b14000 dps ISM330DHCX_GYRO_SENS_FS_4000DPS 140.000 mdps/LSB Returns True if configuration is successful, False otherwise.","title":"ISM330DHCX.enable_gyro"},{"location":"reference/libs/stm/ism330dhcx/docs/ism330dhcx/#ism330dhcxdisable_gyro","text":"disable_gyro () Disables the gyroscope sensor. Returns True if configuration is successful, False otherwise.","title":"ISM330DHCX.disable_gyro"},{"location":"reference/libs/stm/ism330dhcx/docs/ism330dhcx/#ism330dhcxwhoami","text":"whoami () Value of the ISM330DHCX_WHO_AM_I register (0x6B).","title":"ISM330DHCX.whoami"},{"location":"reference/libs/stm/ism330dhcx/docs/ism330dhcx/#ism330dhcxget_acc_data","text":"get_acc_data ( ms2 = True , raw = False ) Retrieves accelerometer data in one call. Arguments: ms2 \u2013 If ms2 flag is True, returns data converted in m/s^2; otherwise in mg (default True) raw \u2013 If raw flag is True, returns raw register values (default False) Returns acc_x, acc_y, acc_z.","title":"ISM330DHCX.get_acc_data"},{"location":"reference/libs/stm/ism330dhcx/docs/ism330dhcx/#ism330dhcxget_gyro_data","text":"get_gyro_data ( dps = True , raw = False ) Retrieves gyroscope data in one call. Arguments: dps \u2013 If dps flag is True, returns data converted in dps; otherwise in mdps (default True) raw \u2013 If raw flag is True, returns raw register values (default False) Returns gyro_x, gyro_y, gyro_z.","title":"ISM330DHCX.get_gyro_data"},{"location":"reference/libs/stm/ism330dhcx/docs/ism330dhcx/#ism330dhcxget_temp","text":"get_temp () Retrieves temperature in one call; if raw flag is enabled, returns raw register values. Returns temp.","title":"ISM330DHCX.get_temp"},{"location":"reference/libs/stm/ism330dhcx/docs/ism330dhcx/#ism330dhcxget_fast","text":"get_fast () Retrieves all data sensors in one call in fast way (c-code acquisition). Temperature in \u00b0C Acceleration in m/s^2 Angular Velocity in dps (degrees per second) Returns temp, acc_x, acc_y, acc_z, gyro_x, gyro_y, gyro_z.","title":"ISM330DHCX.get_fast"},{"location":"reference/libs/stm/ism330dhcx/docs/ism330dhcx/#ism330dhcxset_event_interrupt","text":"set_event_interrupt ( pin_int , sensor , enable ) Enables the interrupt pins. When data from sensor selected will be ready, the related interrupt pin configured will be set to high. Arguments: pin_int \u2013 ID of the interrupt pin to be enabled/disabled. Available values are 1 o 2. sensor \u2013 Data Ready flag selector. Available values are \u201cacc\u201d or \u201cgyro\u201d. enable \u2013 If enable flag is True, interrupt pin will be enabled, otherwise will be disabled. Returns True if configuration is successful, False otherwise.","title":"ISM330DHCX.set_event_interrupt"},{"location":"reference/libs/stm/lis2hh12/docs/","text":"LIST2HH12 \u00b6 The LIS2HH12 is an 3-axis linear accelerometer belonging to the \u201cpico\u201d family. The LIS2HH12 has full scales of \u00b12g/\u00b14g/\u00b18g and is capable of measuring accelerations with output data rates from 10 Hz to 800 Hz. The self-test capability allows the user to check the functioning of the sensor in the final application. The LIS2HH12 has an integrated first-in, first-out (FIFO) buffer allowing the user to store data in order to limit intervention by the host processor. The LIS2HH12 is available in a small thin plastic land grid array package (LGA) and it is guaranteed to operate over an extended temperature range from -40 \u00b0C to +85 \u00b0C Technical Details \u00b6 Wide supply voltage, 1.71 V to 3.6 V Independent IOs supply (1.8 V) and supply voltage compatible Ultra-low power consumption \u00b12g/\u00b14g/\u00b18g full-scale I2C/SPI digital output interface 16-bit data output Below, Zerynth driver documentation for STM LIS2HH12 chip. Contents: LIS2HH12 Module","title":"LIST2HH12"},{"location":"reference/libs/stm/lis2hh12/docs/#list2hh12","text":"The LIS2HH12 is an 3-axis linear accelerometer belonging to the \u201cpico\u201d family. The LIS2HH12 has full scales of \u00b12g/\u00b14g/\u00b18g and is capable of measuring accelerations with output data rates from 10 Hz to 800 Hz. The self-test capability allows the user to check the functioning of the sensor in the final application. The LIS2HH12 has an integrated first-in, first-out (FIFO) buffer allowing the user to store data in order to limit intervention by the host processor. The LIS2HH12 is available in a small thin plastic land grid array package (LGA) and it is guaranteed to operate over an extended temperature range from -40 \u00b0C to +85 \u00b0C","title":"LIST2HH12"},{"location":"reference/libs/stm/lis2hh12/docs/#technical-details","text":"Wide supply voltage, 1.71 V to 3.6 V Independent IOs supply (1.8 V) and supply voltage compatible Ultra-low power consumption \u00b12g/\u00b14g/\u00b18g full-scale I2C/SPI digital output interface 16-bit data output Below, Zerynth driver documentation for STM LIS2HH12 chip. Contents: LIS2HH12 Module","title":"Technical Details"},{"location":"reference/libs/stm/lis2hh12/docs/lis2hh12/","text":"LIS2HH12 Module \u00b6 This module contains the driver for STMicroelectronics LIS2HH12 3-axis accelerometer. class LIS2HH12 \u00b6 class LIS2HH12 () Class which provides a simple interface to LIS2HH12 features. LIS2HH12. init \u00b6 __init__ ( spidrv , pin_cs , clk = 5000000 , odr = ODR_100HZ , fs = FS_2G , sf = SF_SI ) Creates an instance of LIS2HH12 class, using the specified SPI settings and initial device configuration. Arguments: spidrv \u2013 the SPI driver to use (SPI0, \u2026) pin_cs \u2013 Chip select pin to access the NCV7240 chip clk \u2013 Clock speed, default 5 MHz odr \u2013 Device output data rate, default 100 Hz sf \u2013 Scaling factor, one of SF_G (unit=g) or SF_SI (unit=m/s^2 default) LIS2HH12.acceleration \u00b6 acceleration () Acceleration measured by the sensor. Returns: By default will return a 3-tuple of X, Y, Z axis acceleration values in m/s^2 . Will return values in g if constructor was provided sf=SF_G parameter. LIS2HH12.temperature \u00b6 temperature () Temperature measured by the sensor. Returns: Die temperature in Celsius degrees. LIS2HH12.whoami \u00b6 whoami () Value of the WHO_AM_I register (0x41).","title":"LIS2HH12 Module"},{"location":"reference/libs/stm/lis2hh12/docs/lis2hh12/#lis2hh12-module","text":"This module contains the driver for STMicroelectronics LIS2HH12 3-axis accelerometer.","title":"LIS2HH12 Module"},{"location":"reference/libs/stm/lis2hh12/docs/lis2hh12/#class-lis2hh12","text":"class LIS2HH12 () Class which provides a simple interface to LIS2HH12 features.","title":"class LIS2HH12"},{"location":"reference/libs/stm/lis2hh12/docs/lis2hh12/#lis2hh12init","text":"__init__ ( spidrv , pin_cs , clk = 5000000 , odr = ODR_100HZ , fs = FS_2G , sf = SF_SI ) Creates an instance of LIS2HH12 class, using the specified SPI settings and initial device configuration. Arguments: spidrv \u2013 the SPI driver to use (SPI0, \u2026) pin_cs \u2013 Chip select pin to access the NCV7240 chip clk \u2013 Clock speed, default 5 MHz odr \u2013 Device output data rate, default 100 Hz sf \u2013 Scaling factor, one of SF_G (unit=g) or SF_SI (unit=m/s^2 default)","title":"LIS2HH12.init"},{"location":"reference/libs/stm/lis2hh12/docs/lis2hh12/#lis2hh12acceleration","text":"acceleration () Acceleration measured by the sensor. Returns: By default will return a 3-tuple of X, Y, Z axis acceleration values in m/s^2 . Will return values in g if constructor was provided sf=SF_G parameter.","title":"LIS2HH12.acceleration"},{"location":"reference/libs/stm/lis2hh12/docs/lis2hh12/#lis2hh12temperature","text":"temperature () Temperature measured by the sensor. Returns: Die temperature in Celsius degrees.","title":"LIS2HH12.temperature"},{"location":"reference/libs/stm/lis2hh12/docs/lis2hh12/#lis2hh12whoami","text":"whoami () Value of the WHO_AM_I register (0x41).","title":"LIS2HH12.whoami"},{"location":"reference/libs/stm/mfx/docs/","text":"STM MFX \u00b6 The STM-MFX is a port expander use on stm boards like the STM32746G-EVAL2. Contents: MFX Module MFX class","title":"STM MFX"},{"location":"reference/libs/stm/mfx/docs/#stm-mfx","text":"The STM-MFX is a port expander use on stm boards like the STM32746G-EVAL2. Contents: MFX Module MFX class","title":"STM MFX"},{"location":"reference/libs/stm/mfx/docs/mfx/","text":"MFX Module \u00b6 MFX class \u00b6 class MFX \u00b6 class MFX () Creates an intance of the MFX class. Example: from stm.mfx import MFX ... port_expander = mfx . MFX () port_expander . pinMode ( 10 , INPUT_PULLUP ) state = port_expander . digitalRead ( 10 ) port_expander . pinMode ( 0 , OUTPUT ) port_expander . digitalWrite ( 0 , HIGH ) MFX.pinMode \u00b6 pinMode ( pin , mode ) Select a mode for a pin. Valid pin values are from 0 to 15 included. Available modes are: INPUT INPUT_PULLUP INPUT_PULLDOWN OUTPUT MFX.digitalRead \u00b6 digitalRead ( pin ) Returns the state of pin pin . The state can be 0 or 1 . MFX.digitalWrite \u00b6 digitalWrite ( pin , val ) Set pin pin to value val . Value can be 0 or 1 . MFX.pinToggle \u00b6 pinToggle ( pin ) Toggle the value of the pin pin .","title":"MFX Module"},{"location":"reference/libs/stm/mfx/docs/mfx/#mfx-module","text":"","title":"MFX Module"},{"location":"reference/libs/stm/mfx/docs/mfx/#mfx-class","text":"","title":"MFX class"},{"location":"reference/libs/stm/mfx/docs/mfx/#class-mfx","text":"class MFX () Creates an intance of the MFX class. Example: from stm.mfx import MFX ... port_expander = mfx . MFX () port_expander . pinMode ( 10 , INPUT_PULLUP ) state = port_expander . digitalRead ( 10 ) port_expander . pinMode ( 0 , OUTPUT ) port_expander . digitalWrite ( 0 , HIGH )","title":"class MFX"},{"location":"reference/libs/stm/mfx/docs/mfx/#mfxpinmode","text":"pinMode ( pin , mode ) Select a mode for a pin. Valid pin values are from 0 to 15 included. Available modes are: INPUT INPUT_PULLUP INPUT_PULLDOWN OUTPUT","title":"MFX.pinMode"},{"location":"reference/libs/stm/mfx/docs/mfx/#mfxdigitalread","text":"digitalRead ( pin ) Returns the state of pin pin . The state can be 0 or 1 .","title":"MFX.digitalRead"},{"location":"reference/libs/stm/mfx/docs/mfx/#mfxdigitalwrite","text":"digitalWrite ( pin , val ) Set pin pin to value val . Value can be 0 or 1 .","title":"MFX.digitalWrite"},{"location":"reference/libs/stm/mfx/docs/mfx/#mfxpintoggle","text":"pinToggle ( pin ) Toggle the value of the pin pin .","title":"MFX.pinToggle"},{"location":"reference/libs/stm/spwf01sa/docs/","text":"STM SPWF01SA \u00b6 The SPWF01SA is an intelligent Wi-Fi module representing a plug-and-play and standalone 802.11 b/g/n solution for easy integration of wireless Internet connectivity features into existing or new products. Configured around a single-chip 802.11 transceiver with integrated PA and comprehensive power management subsystem, and an STM32 microcontroller with an extensive GPIO suite, the module also incorporates timing clocks and voltage regulators. The SW package also includes an AT command layer interface for user-friendly access to the stack functionalities via the UART serial port. After the initial configuration is set, the SPWF01SA can be connected to a network and send/receive serial data over the UART interface from the Host controller; more information at STM dedicated page . Technical Details \u00b6 Supply Voltage (Vdd): from 3.1 V to 3.6 V Operation Temperature (Top): from -40 \u00b0C to 85 \u00b0C Advanced low-power modes: 243 mA typical @ 10 dBm (TX traffic) 2.4 GHz IEEE 802.11 b/g/n transceiver Simple AT command set host interface through UART Here below, the Zerynth driver for the STM SPWF01SA. Contents: SPWF01SA Module Examples find and set baud connect","title":"STM SPWF01SA"},{"location":"reference/libs/stm/spwf01sa/docs/#stm-spwf01sa","text":"The SPWF01SA is an intelligent Wi-Fi module representing a plug-and-play and standalone 802.11 b/g/n solution for easy integration of wireless Internet connectivity features into existing or new products. Configured around a single-chip 802.11 transceiver with integrated PA and comprehensive power management subsystem, and an STM32 microcontroller with an extensive GPIO suite, the module also incorporates timing clocks and voltage regulators. The SW package also includes an AT command layer interface for user-friendly access to the stack functionalities via the UART serial port. After the initial configuration is set, the SPWF01SA can be connected to a network and send/receive serial data over the UART interface from the Host controller; more information at STM dedicated page .","title":"STM SPWF01SA"},{"location":"reference/libs/stm/spwf01sa/docs/#technical-details","text":"Supply Voltage (Vdd): from 3.1 V to 3.6 V Operation Temperature (Top): from -40 \u00b0C to 85 \u00b0C Advanced low-power modes: 243 mA typical @ 10 dBm (TX traffic) 2.4 GHz IEEE 802.11 b/g/n transceiver Simple AT command set host interface through UART Here below, the Zerynth driver for the STM SPWF01SA. Contents: SPWF01SA Module Examples find and set baud connect","title":"Technical Details"},{"location":"reference/libs/stm/spwf01sa/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.stm.spwf01sa. Find and Set Baud \u00b6 This example scans the serial port linked to the SPWF01SA chip finding the internal baud rate and sets the new one. main.py ################################################################################ # Find and Set Baud Example # # Created: 2018-02-08 16:44:15.135468 # Author: M. Cipriani ################################################################################ import streams from stm.spwf01sa import spwf01sa as wifi_driver streams . serial () print ( \"scanning serial bauds\" ) # This setup is referred to spwf01sa mounted on Wi-Fi 4 Click in slot A of a Flip n Click device #DEFINES ser = SERIAL1 # serial of the spwf01sa rst = D16 # reset pin of the spwf01sa tobaud = 9600 # baud rate to be set end = False def waiting (): while True : if not end : print ( \".\" ) sleep ( 1000 ) thread ( waiting ) try : baud = wifi_driver . get_baud ( ser , rst ) print ( \"found baud\" , baud ) if baud != tobaud : wifi_driver . set_baud ( ser , rst , baud , tobaud ) print ( \"baud set to\" , tobaud ) else : print ( \"baud already set to\" , baud ) end = True except Exception as e : print ( e ) Connect \u00b6 This example inits and links to a network using the stm-spwf01sa library. main.py import streams from wireless import wifi from stm.spwf01sa import spwf01sa as wifi_driver streams . serial () SSID = \"<SSID>\" PASSWORD = \"<PASSWORD>\" try : # Wifi 4 Click on slot B (specify which serial port will be used and which RST pin wifi_driver . init ( SERIAL1 , D16 , baud = 9600 ) except Exception as e : print ( e ) for i in range ( 0 , 5 ): try : # connect to the wifi network (Set your SSID and password below) wifi . link ( SSID , wifi . WIFI_WPA2 , PASSWORD ) print ( \"Connect\" ) break except Exception as e : print ( \"Can't link\" , e ) else : print ( \"Impossible to link!\" ) while True : sleep ( 1000 )","title":"Examples"},{"location":"reference/libs/stm/spwf01sa/docs/examples/#examples","text":"The following are a list of examples for lib.stm.spwf01sa.","title":"Examples"},{"location":"reference/libs/stm/spwf01sa/docs/examples/#find-and-set-baud","text":"This example scans the serial port linked to the SPWF01SA chip finding the internal baud rate and sets the new one. main.py ################################################################################ # Find and Set Baud Example # # Created: 2018-02-08 16:44:15.135468 # Author: M. Cipriani ################################################################################ import streams from stm.spwf01sa import spwf01sa as wifi_driver streams . serial () print ( \"scanning serial bauds\" ) # This setup is referred to spwf01sa mounted on Wi-Fi 4 Click in slot A of a Flip n Click device #DEFINES ser = SERIAL1 # serial of the spwf01sa rst = D16 # reset pin of the spwf01sa tobaud = 9600 # baud rate to be set end = False def waiting (): while True : if not end : print ( \".\" ) sleep ( 1000 ) thread ( waiting ) try : baud = wifi_driver . get_baud ( ser , rst ) print ( \"found baud\" , baud ) if baud != tobaud : wifi_driver . set_baud ( ser , rst , baud , tobaud ) print ( \"baud set to\" , tobaud ) else : print ( \"baud already set to\" , baud ) end = True except Exception as e : print ( e )","title":"Find and Set Baud"},{"location":"reference/libs/stm/spwf01sa/docs/examples/#connect","text":"This example inits and links to a network using the stm-spwf01sa library. main.py import streams from wireless import wifi from stm.spwf01sa import spwf01sa as wifi_driver streams . serial () SSID = \"<SSID>\" PASSWORD = \"<PASSWORD>\" try : # Wifi 4 Click on slot B (specify which serial port will be used and which RST pin wifi_driver . init ( SERIAL1 , D16 , baud = 9600 ) except Exception as e : print ( e ) for i in range ( 0 , 5 ): try : # connect to the wifi network (Set your SSID and password below) wifi . link ( SSID , wifi . WIFI_WPA2 , PASSWORD ) print ( \"Connect\" ) break except Exception as e : print ( \"Can't link\" , e ) else : print ( \"Impossible to link!\" ) while True : sleep ( 1000 )","title":"Connect"},{"location":"reference/libs/stm/spwf01sa/docs/spwf01sa/","text":"SPWF01SA Module \u00b6 This Zerynth module supports one tcp socket at a time (multiple sockets in future updates) in client and server mode ( datasheet ). No select support is provided. For WIFI security, only WPA2 is currently supported. Usage example: import streams from wireless import wifi from stm.spwf01sa import spwf01sa streams . serial () # connect to a wifi network try : spwf01sa . init ( SERIAL1 , D16 ) # specify which serial port will be used and which RST pin print ( \"Establishing Link...\" ) wifi . link ( \"Network SSID\" , wifi . WIFI_WPA2 , \"Password\" ) print ( \"Ok!\" ) except Exception as e : print ( e )","title":"SPWF01SA Module"},{"location":"reference/libs/stm/spwf01sa/docs/spwf01sa/#spwf01sa-module","text":"This Zerynth module supports one tcp socket at a time (multiple sockets in future updates) in client and server mode ( datasheet ). No select support is provided. For WIFI security, only WPA2 is currently supported. Usage example: import streams from wireless import wifi from stm.spwf01sa import spwf01sa streams . serial () # connect to a wifi network try : spwf01sa . init ( SERIAL1 , D16 ) # specify which serial port will be used and which RST pin print ( \"Establishing Link...\" ) wifi . link ( \"Network SSID\" , wifi . WIFI_WPA2 , \"Password\" ) print ( \"Ok!\" ) except Exception as e : print ( e )","title":"SPWF01SA Module"},{"location":"reference/libs/stm/stts751/docs/","text":"STM STTS751 \u00b6 The STTS751 is a digital temperature sensor which communicates over a 2-wire SMBus 2.0 compatible bus. The temperature is measured with a user-configurable resolution between 9 and 12 bits. At 9 bits, the smallest step size is 0.5 \u00b0C, and at 12 bits, it is 0.0625 \u00b0C. At the default resolution (10 bits, 0.25 \u00b0C/LSB), the conversion time is nominally 21 milliseconds. The open-drain EVENT output is used to indicate an alarm condition in which the measured temperature has exceeded the user-programmed high limit or fallen below the low limit. When the EVENT pin is asserted, the host can respond using the SMBus Alert Response Address (ARA) protocol to which the STTS751 will respond by sending its slave address. The STTS751 is a 6-pin device that supports user-configurable slave addresses. Via the pull-up resistor on the Addr/Therm pin, one of four different slave addresses can be specified. Two order numbers (STTS751-0 and STTS751-1) provide two different sets of slave addresses bringing the total available to eight. Thus, up to eight devices can share the same 2-wire SMBus without ambiguity, thereby allowing monitoring of multiple temperature zones in an application. The two-wire interface can support transfer rates up to 400 kHz.; more information at STMicroelectronics dedicated page . Technical Details \u00b6 Supply Voltage (Vdd): from 2.25 V to 3.6 V Operation Temperature (Top): from -40 \u00b0C to 125 \u00b0C Temperature Accuracy: \u00b10.5 \u00b0C (typ) 0 \u00b0C to +85 \u00b0C Low Power Consumption: \u00b10.5 \u00b0C (typ) 0 \u00b0C to +85 \u00b0C Selectable ODR: from 1 Hz to 500 MHz Fast conversion time 21 ms (typ) 10-bit Embedded 9-bit to 12-bit configurable ADC I\u00b2C interfaces Here below, the Zerynth driver for the STMicroelectronics STTS751. Contents: STTS751 Module Examples get temperature","title":"STM STTS751"},{"location":"reference/libs/stm/stts751/docs/#stm-stts751","text":"The STTS751 is a digital temperature sensor which communicates over a 2-wire SMBus 2.0 compatible bus. The temperature is measured with a user-configurable resolution between 9 and 12 bits. At 9 bits, the smallest step size is 0.5 \u00b0C, and at 12 bits, it is 0.0625 \u00b0C. At the default resolution (10 bits, 0.25 \u00b0C/LSB), the conversion time is nominally 21 milliseconds. The open-drain EVENT output is used to indicate an alarm condition in which the measured temperature has exceeded the user-programmed high limit or fallen below the low limit. When the EVENT pin is asserted, the host can respond using the SMBus Alert Response Address (ARA) protocol to which the STTS751 will respond by sending its slave address. The STTS751 is a 6-pin device that supports user-configurable slave addresses. Via the pull-up resistor on the Addr/Therm pin, one of four different slave addresses can be specified. Two order numbers (STTS751-0 and STTS751-1) provide two different sets of slave addresses bringing the total available to eight. Thus, up to eight devices can share the same 2-wire SMBus without ambiguity, thereby allowing monitoring of multiple temperature zones in an application. The two-wire interface can support transfer rates up to 400 kHz.; more information at STMicroelectronics dedicated page .","title":"STM STTS751"},{"location":"reference/libs/stm/stts751/docs/#technical-details","text":"Supply Voltage (Vdd): from 2.25 V to 3.6 V Operation Temperature (Top): from -40 \u00b0C to 125 \u00b0C Temperature Accuracy: \u00b10.5 \u00b0C (typ) 0 \u00b0C to +85 \u00b0C Low Power Consumption: \u00b10.5 \u00b0C (typ) 0 \u00b0C to +85 \u00b0C Selectable ODR: from 1 Hz to 500 MHz Fast conversion time 21 ms (typ) 10-bit Embedded 9-bit to 12-bit configurable ADC I\u00b2C interfaces Here below, the Zerynth driver for the STMicroelectronics STTS751. Contents: STTS751 Module Examples get temperature","title":"Technical Details"},{"location":"reference/libs/stm/stts751/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.stm.stts751. Read temperature values from STTS751 \u00b6 Basic example to read the current values of temperature from STM sensor STTS751. main.py ################################################################################ # Temperature Example # # Created: 2020-03-20 11:47:18.498321 # ################################################################################ import streams from stm.stts751 import stts751 streams . serial () try : # Setup sensor print ( \"start...\" ) stts = stts751 . STTS751 ( I2C0 ) print ( \"Ready!\" ) product_id , manufacturer_id , revision_id = stts . get_sensor_id () print ( \"Product ID \" , product_id ) print ( \"Manufacturer ID\" , manufacturer_id ) print ( \"Revision ID \" , revision_id ) print ( \"--------------------------------------------------------\" ) except Exception as e : print ( \"Error: \" , e ) try : while True : raw_temp = stts . get_temp ( raw = True ) print ( \"Raw Temperature:\" , raw_temp ) temp = stts . get_temp () print ( \"Temperature:\" , temp ) print ( \"--------------------------------------------------------\" ) sleep ( 5000 ) except Exception as e : print ( \"Error2: \" , e )","title":"Examples"},{"location":"reference/libs/stm/stts751/docs/examples/#examples","text":"The following are a list of examples for lib.stm.stts751.","title":"Examples"},{"location":"reference/libs/stm/stts751/docs/examples/#read-temperature-values-from-stts751","text":"Basic example to read the current values of temperature from STM sensor STTS751. main.py ################################################################################ # Temperature Example # # Created: 2020-03-20 11:47:18.498321 # ################################################################################ import streams from stm.stts751 import stts751 streams . serial () try : # Setup sensor print ( \"start...\" ) stts = stts751 . STTS751 ( I2C0 ) print ( \"Ready!\" ) product_id , manufacturer_id , revision_id = stts . get_sensor_id () print ( \"Product ID \" , product_id ) print ( \"Manufacturer ID\" , manufacturer_id ) print ( \"Revision ID \" , revision_id ) print ( \"--------------------------------------------------------\" ) except Exception as e : print ( \"Error: \" , e ) try : while True : raw_temp = stts . get_temp ( raw = True ) print ( \"Raw Temperature:\" , raw_temp ) temp = stts . get_temp () print ( \"Temperature:\" , temp ) print ( \"--------------------------------------------------------\" ) sleep ( 5000 ) except Exception as e : print ( \"Error2: \" , e )","title":"Read temperature values from STTS751"},{"location":"reference/libs/stm/stts751/docs/stts751/","text":"STTS751 Module \u00b6 This module contains the driver for STMicroelectronics STTS751 temperature sensor. Its highlight is that it outputs its measurement in a 9-bit to 12-bit (configurable) resolution. ( datasheet ). class STTS751 \u00b6 class STTS751 ( drvsel , address = 0x48 , clk = 400000 ) Creates an intance of a new STTS751. Arguments: drvsel \u2013 I2C Bus used ( I2C0 ) address \u2013 Slave address, default 0x48 clk \u2013 Clock speed, default 400kHz Example: from stm.stts751 import stts751 temp_sens = stts751 . STTS751 ( I2C0 ) temp = temp_sens . get_temp () STTS751.enable \u00b6 enable ( odr = ODR_AVAILABLE [ \"ODR_125mHz\" ], resolution = STTS751_RES_12 ) Sets the device\u2019s configuration registers. Parameters: odr : sets the Output Data Rate of the device. Available values are: Value Output Data Rate Constant Name 0x00 62,5 Mhz ODR_AVAILABLE[\u201cODR_62mHz5\u201d] 0x01 125 MHz ODR_AVAILABLE[\u201cODR_125mHz\u201d] 0x02 250 MHz ODR_AVAILABLE[\u201cODR_250mHz\u201d] 0x03 500 MHz ODR_AVAILABLE[\u201cODR_500mHz\u201d] 0x04 1 Hz ODR_AVAILABLE[\u201cODR_1Hz\u201d] 0x05 2 Hz ODR_AVAILABLE[\u201cODR_2Hz\u201d] 0x06 4 Hz ODR_AVAILABLE[\u201cODR_4Hz\u201d] 0x07 8 Hz ODR_AVAILABLE[\u201cODR_8Hz\u201d] 0x08 16 Hz ODR_AVAILABLE[\u201cODR_16Hz\u201d] 0x09 32 Hz ODR_AVAILABLE[\u201cODR_32Hz\u201d] 0x80 OFF ODR_AVAILABLE[\u201cODR_OFF\u201d] 0x90 ONE SHOT ODR_AVAILABLE[\u201cODR_ONE_SHOT\u201d] resolution : sets the Resolution in bit of the conversion. Available values are: Value N bit Costant Name in \u00b0C/LSB 0x08 9 STTS751_RES_9 0.5 \u00b0C/LSB 0x00 10 STTS751_RES_10 0.25 \u00b0C/LSB 0x04 11 STTS751_RES_11 0.125 \u00b0C/LSB 0x0c 12 STTS751_RES_12 0.0625 \u00b0C/LSB Returns True if configuration is successful, False otherwise. STTS751.disable \u00b6 disable () Disables the sensor. Returns True if configuration is successful, False otherwise. STTS751.get_status \u00b6 get_status () Retrieves the sensor flag status. Returns a dictionary with following key/value pairs: Key Note busy If True, Sensor is Busy t_low If True, Temp under threshold t_high If True, Temp over threshold therm If True, High internal Temp STTS751.get_sensor_id \u00b6 get_sensor_id () Retrieves product_id, manufacturer_id, revision_id in one call. Returns product_id, manufacturer_id, revision_id. STTS751.get_temp \u00b6 get_temp ( raw = False ) Retrieves temperature in one call; if raw flag is enabled, returns raw register values. Returns temp. STTS751.set_low_temp_threshold \u00b6 set_low_temp_threshold ( level ) Sets the low temperature threshold. When real temperature goes down the low temperature level, if interrupt is enabled, the sensor send an interrupt signal in its interrupt pin. STTS751.set_high_temp_threshold \u00b6 set_high_temp_threshold ( level ) Sets the high temperature threshold. When real temperature goes up the high temperature level, if interrupt is enabled, the sensor send an interrupt signal in its interrupt pin. STTS751.set_event_interrupt \u00b6 set_event_interrupt ( enable ) Enables the interrupt pin. Available values for \u2018enable\u2019 flag are \u2018True\u2019 or \u2018False\u2019. STTS751.set_therm_limit \u00b6 set_therm_limit ( level ) Sets the Thermal threshold. Whenever the temperature exceeds the value of the therm limit, the Addr/Therm output will be asserted (low) Available \u2018level\u2019 values are from -127 to 127 range. STTS751.set_therm_hysteresis_limit \u00b6 set_therm_hysteresis_limit ( level ) Sets the Thermal hysteresis threshold. Once Therm output has asserted, it will not de-assert until the temperature has fallen below the respective therm limit minus the therm hysteresis value. Available \u2018level\u2019 values are from -127 to 127 range. STTS751.set_timeout \u00b6 set_timeout ( enable ) Enables the timeout for the sensor readings (from 25 to 35 ms). Available values for \u2018enable\u2019 flag are \u2018True\u2019 or \u2018False\u2019.","title":"STTS751 Module"},{"location":"reference/libs/stm/stts751/docs/stts751/#stts751-module","text":"This module contains the driver for STMicroelectronics STTS751 temperature sensor. Its highlight is that it outputs its measurement in a 9-bit to 12-bit (configurable) resolution. ( datasheet ).","title":"STTS751 Module"},{"location":"reference/libs/stm/stts751/docs/stts751/#class-stts751","text":"class STTS751 ( drvsel , address = 0x48 , clk = 400000 ) Creates an intance of a new STTS751. Arguments: drvsel \u2013 I2C Bus used ( I2C0 ) address \u2013 Slave address, default 0x48 clk \u2013 Clock speed, default 400kHz Example: from stm.stts751 import stts751 temp_sens = stts751 . STTS751 ( I2C0 ) temp = temp_sens . get_temp ()","title":"class STTS751"},{"location":"reference/libs/stm/stts751/docs/stts751/#stts751enable","text":"enable ( odr = ODR_AVAILABLE [ \"ODR_125mHz\" ], resolution = STTS751_RES_12 ) Sets the device\u2019s configuration registers. Parameters: odr : sets the Output Data Rate of the device. Available values are: Value Output Data Rate Constant Name 0x00 62,5 Mhz ODR_AVAILABLE[\u201cODR_62mHz5\u201d] 0x01 125 MHz ODR_AVAILABLE[\u201cODR_125mHz\u201d] 0x02 250 MHz ODR_AVAILABLE[\u201cODR_250mHz\u201d] 0x03 500 MHz ODR_AVAILABLE[\u201cODR_500mHz\u201d] 0x04 1 Hz ODR_AVAILABLE[\u201cODR_1Hz\u201d] 0x05 2 Hz ODR_AVAILABLE[\u201cODR_2Hz\u201d] 0x06 4 Hz ODR_AVAILABLE[\u201cODR_4Hz\u201d] 0x07 8 Hz ODR_AVAILABLE[\u201cODR_8Hz\u201d] 0x08 16 Hz ODR_AVAILABLE[\u201cODR_16Hz\u201d] 0x09 32 Hz ODR_AVAILABLE[\u201cODR_32Hz\u201d] 0x80 OFF ODR_AVAILABLE[\u201cODR_OFF\u201d] 0x90 ONE SHOT ODR_AVAILABLE[\u201cODR_ONE_SHOT\u201d] resolution : sets the Resolution in bit of the conversion. Available values are: Value N bit Costant Name in \u00b0C/LSB 0x08 9 STTS751_RES_9 0.5 \u00b0C/LSB 0x00 10 STTS751_RES_10 0.25 \u00b0C/LSB 0x04 11 STTS751_RES_11 0.125 \u00b0C/LSB 0x0c 12 STTS751_RES_12 0.0625 \u00b0C/LSB Returns True if configuration is successful, False otherwise.","title":"STTS751.enable"},{"location":"reference/libs/stm/stts751/docs/stts751/#stts751disable","text":"disable () Disables the sensor. Returns True if configuration is successful, False otherwise.","title":"STTS751.disable"},{"location":"reference/libs/stm/stts751/docs/stts751/#stts751get_status","text":"get_status () Retrieves the sensor flag status. Returns a dictionary with following key/value pairs: Key Note busy If True, Sensor is Busy t_low If True, Temp under threshold t_high If True, Temp over threshold therm If True, High internal Temp","title":"STTS751.get_status"},{"location":"reference/libs/stm/stts751/docs/stts751/#stts751get_sensor_id","text":"get_sensor_id () Retrieves product_id, manufacturer_id, revision_id in one call. Returns product_id, manufacturer_id, revision_id.","title":"STTS751.get_sensor_id"},{"location":"reference/libs/stm/stts751/docs/stts751/#stts751get_temp","text":"get_temp ( raw = False ) Retrieves temperature in one call; if raw flag is enabled, returns raw register values. Returns temp.","title":"STTS751.get_temp"},{"location":"reference/libs/stm/stts751/docs/stts751/#stts751set_low_temp_threshold","text":"set_low_temp_threshold ( level ) Sets the low temperature threshold. When real temperature goes down the low temperature level, if interrupt is enabled, the sensor send an interrupt signal in its interrupt pin.","title":"STTS751.set_low_temp_threshold"},{"location":"reference/libs/stm/stts751/docs/stts751/#stts751set_high_temp_threshold","text":"set_high_temp_threshold ( level ) Sets the high temperature threshold. When real temperature goes up the high temperature level, if interrupt is enabled, the sensor send an interrupt signal in its interrupt pin.","title":"STTS751.set_high_temp_threshold"},{"location":"reference/libs/stm/stts751/docs/stts751/#stts751set_event_interrupt","text":"set_event_interrupt ( enable ) Enables the interrupt pin. Available values for \u2018enable\u2019 flag are \u2018True\u2019 or \u2018False\u2019.","title":"STTS751.set_event_interrupt"},{"location":"reference/libs/stm/stts751/docs/stts751/#stts751set_therm_limit","text":"set_therm_limit ( level ) Sets the Thermal threshold. Whenever the temperature exceeds the value of the therm limit, the Addr/Therm output will be asserted (low) Available \u2018level\u2019 values are from -127 to 127 range.","title":"STTS751.set_therm_limit"},{"location":"reference/libs/stm/stts751/docs/stts751/#stts751set_therm_hysteresis_limit","text":"set_therm_hysteresis_limit ( level ) Sets the Thermal hysteresis threshold. Once Therm output has asserted, it will not de-assert until the temperature has fallen below the respective therm limit minus the therm hysteresis value. Available \u2018level\u2019 values are from -127 to 127 range.","title":"STTS751.set_therm_hysteresis_limit"},{"location":"reference/libs/stm/stts751/docs/stts751/#stts751set_timeout","text":"set_timeout ( enable ) Enables the timeout for the sensor readings (from 25 to 35 ms). Available values for \u2018enable\u2019 flag are \u2018True\u2019 or \u2018False\u2019.","title":"STTS751.set_timeout"},{"location":"reference/libs/stm/teseoliv3f/docs/","text":"STM Teseo Liv3F \u00b6 The Teseo-LIV3F module is an easy to use Global Navigation Satellite System (GNSS) standalone module, embedding TeseoIII single die standalone positioning receiver IC working simultaneously on multiple constellations (GPS/Galileo/Glonass/BeiDou/QZSS). Thanks to the embedded 16 Mbit flash Teseo-LIV3F offers many extra features such as data logging, 7 days autonomous assisted GNSS, FW reconfigurability as well as FW upgrades. Teseo-LIV3F provides also the Autonomous Assisted GNSS able to predict satellite data based on previous observation of satellite. Features \u00b6 Simultaneously multiconstellation -163 dBm navigation sensitivity 1.5 m CEP accuracy positioning 16 Mbit embedded Flash for data logging and FW upgrade 2.1 V to 4.3 V supply voltage range Tiny LCC 18 pin package (9.7x10.1) Operating temperature (-40\u00b0, 85\u00b0C) Free FW configuration 17 \u03bcW standby current and 75 mW tracking power consumption Contents: TeseoLiv3F Module Examples Fix GPS","title":"STM Teseo Liv3F"},{"location":"reference/libs/stm/teseoliv3f/docs/#stm-teseo-liv3f","text":"The Teseo-LIV3F module is an easy to use Global Navigation Satellite System (GNSS) standalone module, embedding TeseoIII single die standalone positioning receiver IC working simultaneously on multiple constellations (GPS/Galileo/Glonass/BeiDou/QZSS). Thanks to the embedded 16 Mbit flash Teseo-LIV3F offers many extra features such as data logging, 7 days autonomous assisted GNSS, FW reconfigurability as well as FW upgrades. Teseo-LIV3F provides also the Autonomous Assisted GNSS able to predict satellite data based on previous observation of satellite.","title":"STM Teseo Liv3F"},{"location":"reference/libs/stm/teseoliv3f/docs/#features","text":"Simultaneously multiconstellation -163 dBm navigation sensitivity 1.5 m CEP accuracy positioning 16 Mbit embedded Flash for data logging and FW upgrade 2.1 V to 4.3 V supply voltage range Tiny LCC 18 pin package (9.7x10.1) Operating temperature (-40\u00b0, 85\u00b0C) Free FW configuration 17 \u03bcW standby current and 75 mW tracking power consumption Contents: TeseoLiv3F Module Examples Fix GPS","title":"Features"},{"location":"reference/libs/stm/teseoliv3f/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.stm.teseoliv3f. Fix \u00b6 A simple example showing how to handle Teseo-liv3F serial messages and fix GPS position. main.py # TeseoLiv3F # Created at 2019-03-26 09:45:18.145367 import streams from stm.teseoliv3f import teseoliv3f streams . serial () try : gnss = teseoliv3f . TeseoLiv3F ( SERIAL4 ) print ( \"Starting...\" ) gnss . start ( D59 ) gnss . set_rate ( 1000 ) while True : #print(\".\") utc = gnss . utc () print ( \"UTC\" , utc ) if gnss . has_fix (): fix = gnss . fix () if fix : for x in fix : print ( \"Fix\" , x ) print ( \"Pausing\" ) gnss . pause () sleep ( 10000 ) print ( \"Resuming\" ) gnss . resume () sleep ( 1000 ) except Exception as e : print ( \"EXC!\" ) print ( e )","title":"Examples"},{"location":"reference/libs/stm/teseoliv3f/docs/examples/#examples","text":"The following are a list of examples for lib.stm.teseoliv3f.","title":"Examples"},{"location":"reference/libs/stm/teseoliv3f/docs/examples/#fix","text":"A simple example showing how to handle Teseo-liv3F serial messages and fix GPS position. main.py # TeseoLiv3F # Created at 2019-03-26 09:45:18.145367 import streams from stm.teseoliv3f import teseoliv3f streams . serial () try : gnss = teseoliv3f . TeseoLiv3F ( SERIAL4 ) print ( \"Starting...\" ) gnss . start ( D59 ) gnss . set_rate ( 1000 ) while True : #print(\".\") utc = gnss . utc () print ( \"UTC\" , utc ) if gnss . has_fix (): fix = gnss . fix () if fix : for x in fix : print ( \"Fix\" , x ) print ( \"Pausing\" ) gnss . pause () sleep ( 10000 ) print ( \"Resuming\" ) gnss . resume () sleep ( 1000 ) except Exception as e : print ( \"EXC!\" ) print ( e )","title":"Fix"},{"location":"reference/libs/stm/teseoliv3f/docs/teseoliv3f/","text":"TeseoLiv3F Module \u00b6 This module implements the Zerynth driver for the STM Teseo Liv3F GNSS chip ( Product page ). The following functionalities are implemented: retrieve the current location fix if present retrieve the current UTC time The driver starts a background thread continuously tracking the last available location fix. The frequency of fixes can be customized. The driver support serial mode only. Location fixes are obtained by parsing NMEA sentences of type RMC and GGA. Obtaining a fix or UTC time are thread safe operations. class Teseo \u00b6 class Teseo ( ifc , mode = SERIAL , baud = 9600 , clock = 400000 , addr = 0x00 ) Creates an intance of TeseoLiv3F. Arguments: ifc \u2013 interface used. One of SERIAL0, SERIAL1, \u2026 mode \u2013 one of SERIAL or I2C. Only SERIAL mode supported at the moment. baud \u2013 serial speed clock \u2013 I2C clock frequency (not supported) addr \u2013 I2C address (not supported) Example: from teseoliv3f import TeseoLiv3F ... gnss = TeseoLiv3F . TeseoLiv3F ( SERIAL1 ) gnss . start () mpl . init () alt = mpl . get_alt () pres = mpl . get_pres () Teseo.start \u00b6 start ( rstpin = None , rstval = 0 ) Start the TeseoLiv3F. Arguments: rstpin \u2013 if given, uses rstpin as the reset pin of Teseo Liv3F rstval \u2013 the value to move rstpin to Teseo.stop \u00b6 stop () Stop the TeseoLiv3F by putting it into backup mode. It can be restarted only by setting the FORCE_ON pin to high. Refer to the Teseo Liv3F documentation for details here . Teseo.pause \u00b6 pause () Stop the Teseo Liv3F by putting it into standby mode. It can be restarted by calling resume. Refer to the Teseo Liv3F documentation for details here . Teseo.resume \u00b6 resume () Wake up the Teseo Liv3F from standby mode. Refer to the Teseo Liv3F documentation for details here . set_rate(rate=1000)` Set the frequency for location fix (100-10000 milliseconds is the available range). Teseo.fix \u00b6 fix () Return the current fix or None if no fix is available. A fix is a tuple with the following elements: latitude in decimal format (-89.9999 - 89.9999) longitude in decimal format (-179.9999 - 179.9999) altitude in meters speed in Km/h course over ground as degrees from true north number of satellites for this fix horizontal dilution of precision (0.5 - 99.9) vertical dilution of precision (0.5 - 99.9) positional dilution of precision (0.5 - 99.9) UTC time as a tuple (yyyy,MM,dd,hh,mm,ss,microseconds) Teseo.has_fix \u00b6 has_fix () Return True if a fix is available. Teseo.utc \u00b6 utc () Return the current UTC time or None if no UTC time is available. A UTC time is a tuple of (yyyy,MM,dd,hh,mm,ss,microseconds). UTC time can be wrong if no fix has ever been obtained. Teseo.has_utc \u00b6 has_utc () Return True if a UTC time is available.","title":"TeseoLiv3F Module"},{"location":"reference/libs/stm/teseoliv3f/docs/teseoliv3f/#teseoliv3f-module","text":"This module implements the Zerynth driver for the STM Teseo Liv3F GNSS chip ( Product page ). The following functionalities are implemented: retrieve the current location fix if present retrieve the current UTC time The driver starts a background thread continuously tracking the last available location fix. The frequency of fixes can be customized. The driver support serial mode only. Location fixes are obtained by parsing NMEA sentences of type RMC and GGA. Obtaining a fix or UTC time are thread safe operations.","title":"TeseoLiv3F Module"},{"location":"reference/libs/stm/teseoliv3f/docs/teseoliv3f/#class-teseo","text":"class Teseo ( ifc , mode = SERIAL , baud = 9600 , clock = 400000 , addr = 0x00 ) Creates an intance of TeseoLiv3F. Arguments: ifc \u2013 interface used. One of SERIAL0, SERIAL1, \u2026 mode \u2013 one of SERIAL or I2C. Only SERIAL mode supported at the moment. baud \u2013 serial speed clock \u2013 I2C clock frequency (not supported) addr \u2013 I2C address (not supported) Example: from teseoliv3f import TeseoLiv3F ... gnss = TeseoLiv3F . TeseoLiv3F ( SERIAL1 ) gnss . start () mpl . init () alt = mpl . get_alt () pres = mpl . get_pres ()","title":"class Teseo"},{"location":"reference/libs/stm/teseoliv3f/docs/teseoliv3f/#teseostart","text":"start ( rstpin = None , rstval = 0 ) Start the TeseoLiv3F. Arguments: rstpin \u2013 if given, uses rstpin as the reset pin of Teseo Liv3F rstval \u2013 the value to move rstpin to","title":"Teseo.start"},{"location":"reference/libs/stm/teseoliv3f/docs/teseoliv3f/#teseostop","text":"stop () Stop the TeseoLiv3F by putting it into backup mode. It can be restarted only by setting the FORCE_ON pin to high. Refer to the Teseo Liv3F documentation for details here .","title":"Teseo.stop"},{"location":"reference/libs/stm/teseoliv3f/docs/teseoliv3f/#teseopause","text":"pause () Stop the Teseo Liv3F by putting it into standby mode. It can be restarted by calling resume. Refer to the Teseo Liv3F documentation for details here .","title":"Teseo.pause"},{"location":"reference/libs/stm/teseoliv3f/docs/teseoliv3f/#teseoresume","text":"resume () Wake up the Teseo Liv3F from standby mode. Refer to the Teseo Liv3F documentation for details here . set_rate(rate=1000)` Set the frequency for location fix (100-10000 milliseconds is the available range).","title":"Teseo.resume"},{"location":"reference/libs/stm/teseoliv3f/docs/teseoliv3f/#teseofix","text":"fix () Return the current fix or None if no fix is available. A fix is a tuple with the following elements: latitude in decimal format (-89.9999 - 89.9999) longitude in decimal format (-179.9999 - 179.9999) altitude in meters speed in Km/h course over ground as degrees from true north number of satellites for this fix horizontal dilution of precision (0.5 - 99.9) vertical dilution of precision (0.5 - 99.9) positional dilution of precision (0.5 - 99.9) UTC time as a tuple (yyyy,MM,dd,hh,mm,ss,microseconds)","title":"Teseo.fix"},{"location":"reference/libs/stm/teseoliv3f/docs/teseoliv3f/#teseohas_fix","text":"has_fix () Return True if a fix is available.","title":"Teseo.has_fix"},{"location":"reference/libs/stm/teseoliv3f/docs/teseoliv3f/#teseoutc","text":"utc () Return the current UTC time or None if no UTC time is available. A UTC time is a tuple of (yyyy,MM,dd,hh,mm,ss,microseconds). UTC time can be wrong if no fix has ever been obtained.","title":"Teseo.utc"},{"location":"reference/libs/stm/teseoliv3f/docs/teseoliv3f/#teseohas_utc","text":"has_utc () Return True if a UTC time is available.","title":"Teseo.has_utc"},{"location":"reference/libs/texas/ads1015/docs/","text":"TI ADS1015 \u00b6 The ADS101x devices are Delta-Sigma 12-bit Analog-to-Digital converters with I2C interface. The ADS101x devices incorporate a voltage reference and an oscillator. The ADS1014 and ADS1015 also incorporate a programmable gain amplifier and a digital comparator. More information at Texas Instruments dedicated page . Technical Details \u00b6 12-bit resolution 4 input channels 4 single-ended or two differential inputs (ADS1015) Supply Voltage from 2.0 V to 5.5 V Programmable data rates: 128 SPS to 3.3 kSPS High-speed mode I2C interface Temperature range: -40 - +125 \u00b0C Here below, the Zerynth driver for the Texas Instruments ADS1015. Contents: ADS1015 Module ADS1015 class","title":"TI ADS1015"},{"location":"reference/libs/texas/ads1015/docs/#ti-ads1015","text":"The ADS101x devices are Delta-Sigma 12-bit Analog-to-Digital converters with I2C interface. The ADS101x devices incorporate a voltage reference and an oscillator. The ADS1014 and ADS1015 also incorporate a programmable gain amplifier and a digital comparator. More information at Texas Instruments dedicated page .","title":"TI ADS1015"},{"location":"reference/libs/texas/ads1015/docs/#technical-details","text":"12-bit resolution 4 input channels 4 single-ended or two differential inputs (ADS1015) Supply Voltage from 2.0 V to 5.5 V Programmable data rates: 128 SPS to 3.3 kSPS High-speed mode I2C interface Temperature range: -40 - +125 \u00b0C Here below, the Zerynth driver for the Texas Instruments ADS1015. Contents: ADS1015 Module ADS1015 class","title":"Technical Details"},{"location":"reference/libs/texas/ads1015/docs/ads1015/","text":"ADS1015 Module \u00b6 This module contains the Zerynth driver for Texas Instruments ADS101x precision Analog-to-Digital Converters with I2C interface ( datasheet ). Example: from texas.ads1015 import ADS1015 ... ads = ads1015 . ADS1015 ( I2C0 , addr = 0x49 , clk = 400000 ) ads . set ( ch = 4 , pga = 1 ) value1 = ads . get_raw_data () ads . set ( ch = 3 , pga = 4 ) value2 = ads . get_raw_data () ADS1015 class \u00b6 class ADS1015 \u00b6 class ADS1015 ( i2cdrv , addr = 0x48 , clk = 100000 ) Creates an instance of the ADS1015 class. This class allows the control of all ADS1013, ADS1014, and ADS1015 devices. Arguments: i2cdrv \u2013 I2C Bus used \u2018(I2C0, \u2026)\u2019 addr \u2013 Slave address, default 0x48 clk \u2013 Clock speed, default 100 kHz ADS1015.set \u00b6 set ( os = 0 , ch = 4 , pga = 2 , mode = 0 , sps = 4 , cmode = 0 , cpol = 0 , clat = 0 , cque = 3 ) Sets the device\u2019s configuration register. Parameters: os : sets the Operational Status od the device. It can only be written when in power-down state and has no effect when a conversion is ongoing, available values are: 0 : No effect 1 : Start a single conversion (when in power-down state) ch : (ADS1015 only) Configure the input multiplexer. ch positive channel negative channel 0 AIN0 AIN1 1 AIN0 AIN3 2 AIN1 AIN3 3 AIN2 AIN3 4 AIN0 GND 5 AIN1 GND 6 AIN2 GND 7 AIN3 GND pga : (ADS1014 and ADS1015 only) PGA Gain selection. pga Gain ADC full-scale range 0 \u2153 \u00b1 6.144 V 1 \u00bd \u00b1 4.096 V 2 1 \u00b1 2.048 V 3 2 \u00b1 1.024 V 4 4 \u00b1 0.512 V 5 8 \u00b1 0.256 V 6 8 \u00b1 0.256 V 7 8 \u00b1 0.256 V mode : sets the device operating mode. Available values are: 0 : Continuous-conversion mode. 1 : Single-shot mode or power-down state sps : Data rate setting. sps Samples per second 0 128 1 250 2 490 3 920 4 1600 5 2400 6 3300 7 3300 cmode : (ADS1014 and ADS1015 only) Comparator operating mode. 0 : Traditional comparator. 1 : Window comparator. cpol : (ADS1014 and ADS1015 only) Set the polarity of the ALERT/RDY pin. 0 : Active low. 1 : Active high. clat : (ADS1014 and ADS1015 only) Controls whether the ALERT/RDY pin latches. 0 : Nonlatching comparator. 1 : Latching comparator. cque : (ADS1014 and ADS1015 only) Comparator queue and disable. cque effect 0 Assert ALERT/RDY pin after one conversion exceeding the threshold 1 Assert ALERT/RDY pin after two conversion exceeding the threshold 2 Assert ALERT/RDY pin after four conversion exceeding the threshold 3 Disable comparator and set ALERT/RDY pin to high-impedance ADS1015.set_threshold \u00b6 set_threshold ( low , high ) Set the upper and lower threshold values used by the comparator. The comparator is implemented as a digital comparator; therefore, the valuese must be updated whenever the PGA settings are changed. Available values for both low and high parameters are 12-bit signed intergers, from -2048 to 2047. ADS1015.get_raw_data \u00b6 get_raw_data () Return the conversion result as an 12-bit signed integer. A positive full-scale input produces an output of 2047, a negative full-scale input produces an output of -2048.","title":"ADS1015 Module"},{"location":"reference/libs/texas/ads1015/docs/ads1015/#ads1015-module","text":"This module contains the Zerynth driver for Texas Instruments ADS101x precision Analog-to-Digital Converters with I2C interface ( datasheet ). Example: from texas.ads1015 import ADS1015 ... ads = ads1015 . ADS1015 ( I2C0 , addr = 0x49 , clk = 400000 ) ads . set ( ch = 4 , pga = 1 ) value1 = ads . get_raw_data () ads . set ( ch = 3 , pga = 4 ) value2 = ads . get_raw_data ()","title":"ADS1015 Module"},{"location":"reference/libs/texas/ads1015/docs/ads1015/#ads1015-class","text":"","title":"ADS1015 class"},{"location":"reference/libs/texas/ads1015/docs/ads1015/#class-ads1015","text":"class ADS1015 ( i2cdrv , addr = 0x48 , clk = 100000 ) Creates an instance of the ADS1015 class. This class allows the control of all ADS1013, ADS1014, and ADS1015 devices. Arguments: i2cdrv \u2013 I2C Bus used \u2018(I2C0, \u2026)\u2019 addr \u2013 Slave address, default 0x48 clk \u2013 Clock speed, default 100 kHz","title":"class ADS1015"},{"location":"reference/libs/texas/ads1015/docs/ads1015/#ads1015set","text":"set ( os = 0 , ch = 4 , pga = 2 , mode = 0 , sps = 4 , cmode = 0 , cpol = 0 , clat = 0 , cque = 3 ) Sets the device\u2019s configuration register. Parameters: os : sets the Operational Status od the device. It can only be written when in power-down state and has no effect when a conversion is ongoing, available values are: 0 : No effect 1 : Start a single conversion (when in power-down state) ch : (ADS1015 only) Configure the input multiplexer. ch positive channel negative channel 0 AIN0 AIN1 1 AIN0 AIN3 2 AIN1 AIN3 3 AIN2 AIN3 4 AIN0 GND 5 AIN1 GND 6 AIN2 GND 7 AIN3 GND pga : (ADS1014 and ADS1015 only) PGA Gain selection. pga Gain ADC full-scale range 0 \u2153 \u00b1 6.144 V 1 \u00bd \u00b1 4.096 V 2 1 \u00b1 2.048 V 3 2 \u00b1 1.024 V 4 4 \u00b1 0.512 V 5 8 \u00b1 0.256 V 6 8 \u00b1 0.256 V 7 8 \u00b1 0.256 V mode : sets the device operating mode. Available values are: 0 : Continuous-conversion mode. 1 : Single-shot mode or power-down state sps : Data rate setting. sps Samples per second 0 128 1 250 2 490 3 920 4 1600 5 2400 6 3300 7 3300 cmode : (ADS1014 and ADS1015 only) Comparator operating mode. 0 : Traditional comparator. 1 : Window comparator. cpol : (ADS1014 and ADS1015 only) Set the polarity of the ALERT/RDY pin. 0 : Active low. 1 : Active high. clat : (ADS1014 and ADS1015 only) Controls whether the ALERT/RDY pin latches. 0 : Nonlatching comparator. 1 : Latching comparator. cque : (ADS1014 and ADS1015 only) Comparator queue and disable. cque effect 0 Assert ALERT/RDY pin after one conversion exceeding the threshold 1 Assert ALERT/RDY pin after two conversion exceeding the threshold 2 Assert ALERT/RDY pin after four conversion exceeding the threshold 3 Disable comparator and set ALERT/RDY pin to high-impedance","title":"ADS1015.set"},{"location":"reference/libs/texas/ads1015/docs/ads1015/#ads1015set_threshold","text":"set_threshold ( low , high ) Set the upper and lower threshold values used by the comparator. The comparator is implemented as a digital comparator; therefore, the valuese must be updated whenever the PGA settings are changed. Available values for both low and high parameters are 12-bit signed intergers, from -2048 to 2047.","title":"ADS1015.set_threshold"},{"location":"reference/libs/texas/ads1015/docs/ads1015/#ads1015get_raw_data","text":"get_raw_data () Return the conversion result as an 12-bit signed integer. A positive full-scale input produces an output of 2047, a negative full-scale input produces an output of -2048.","title":"ADS1015.get_raw_data"},{"location":"reference/libs/texas/cc3000/docs/","text":"TI CC3000 \u00b6 The SimpleLink CC3000 Wi-Fi module permits to reduce development time, lower manufacturing costs, save device space, ease certification, and minimize the amount of RF expertise required. Additionally it is provided as a complete platform solution including software drivers, sample applications, an API guide, user documentation and a world-class support community. User guides and platform information are available on the CC3000\u2019s Wiki . Technical Details \u00b6 Supply Voltage (Vdd): from 2.9 V to 4.8 V Operation Temperature (Top): from -20 \u00b0C to 70 \u00b0C Wireless Network Processor: IEEE 802.11 b/g (2.4 GHz) TX Power: +18.0 dBm at 11 Mbps, CCK RX Sensitivity: \u201388 dBm, 8% PER, 11 Mbps Host Interface: SPI at 16MHz Here below, the Zerynth driver for the Texas Instruments CC3000. Contents: CC3000 Module CC3000 Tiny","title":"TI CC3000"},{"location":"reference/libs/texas/cc3000/docs/#ti-cc3000","text":"The SimpleLink CC3000 Wi-Fi module permits to reduce development time, lower manufacturing costs, save device space, ease certification, and minimize the amount of RF expertise required. Additionally it is provided as a complete platform solution including software drivers, sample applications, an API guide, user documentation and a world-class support community. User guides and platform information are available on the CC3000\u2019s Wiki .","title":"TI CC3000"},{"location":"reference/libs/texas/cc3000/docs/#technical-details","text":"Supply Voltage (Vdd): from 2.9 V to 4.8 V Operation Temperature (Top): from -20 \u00b0C to 70 \u00b0C Wireless Network Processor: IEEE 802.11 b/g (2.4 GHz) TX Power: +18.0 dBm at 11 Mbps, CCK RX Sensitivity: \u201388 dBm, 8% PER, 11 Mbps Host Interface: SPI at 16MHz Here below, the Zerynth driver for the Texas Instruments CC3000. Contents: CC3000 Module CC3000 Tiny","title":"Technical Details"},{"location":"reference/libs/texas/cc3000/docs/cc3000/","text":"CC3000 Module \u00b6 This module implements the cc3000 wifi driver. At the moment some functionalities are missing: smart config ping For low resource devices please consider the stripped down module cc3000_tiny . It can be used for every kind of cc3000 breakout, going from the Adafruit shield to the CC3000 on the Particle Core. It is important to remark that Texas Instrument itself has deprecated the CC3000 chip, and recommends CC3200. Also, CC3000 low level drivers are not fully compliant with the BSD socket standard, therefore some functionalities may be absent or different. The CC3000 is based on spi and also needs two additional pins to function; one which is called WEN (Wireless Enable) used as turn on/shutdown; one which is called IRQ and is used by the CC3000 to signal that data is ready. The CC3000 has an onboard firmware which is currently at version 1.14. This modules supports CC3000 firmwares from version 1.13 (included) only. Refer to your CC3000 product instructions to update the CC3000 firmware if needed ( Wiki ). CC3000 based products: Adafruit HUZZAH Breakout Adafruit HUZZAH Shield SparkFun WiFi Breakout SparkFun WiFi Shield auto_init \u00b6 auto_init () Tries to automatically init the CC3000 driver by looking at the device type. The automatic configuration is possible for all the Arduino compatible devices and for the Particle Core. Otherwise an exception is raised. init \u00b6 init ( spi , nss , wen , irq ) Tries to init the CC3000 driver. spi is the name of the spi driver the CC3000 is connected to. nss is the pin used as Chip Select (CS). wen is the pin used as Wireless Enable. irq is the pin used by the CC3000 to generate an interrupt.","title":"CC3000 Module"},{"location":"reference/libs/texas/cc3000/docs/cc3000/#cc3000-module","text":"This module implements the cc3000 wifi driver. At the moment some functionalities are missing: smart config ping For low resource devices please consider the stripped down module cc3000_tiny . It can be used for every kind of cc3000 breakout, going from the Adafruit shield to the CC3000 on the Particle Core. It is important to remark that Texas Instrument itself has deprecated the CC3000 chip, and recommends CC3200. Also, CC3000 low level drivers are not fully compliant with the BSD socket standard, therefore some functionalities may be absent or different. The CC3000 is based on spi and also needs two additional pins to function; one which is called WEN (Wireless Enable) used as turn on/shutdown; one which is called IRQ and is used by the CC3000 to signal that data is ready. The CC3000 has an onboard firmware which is currently at version 1.14. This modules supports CC3000 firmwares from version 1.13 (included) only. Refer to your CC3000 product instructions to update the CC3000 firmware if needed ( Wiki ). CC3000 based products: Adafruit HUZZAH Breakout Adafruit HUZZAH Shield SparkFun WiFi Breakout SparkFun WiFi Shield","title":"CC3000 Module"},{"location":"reference/libs/texas/cc3000/docs/cc3000/#auto_init","text":"auto_init () Tries to automatically init the CC3000 driver by looking at the device type. The automatic configuration is possible for all the Arduino compatible devices and for the Particle Core. Otherwise an exception is raised.","title":"auto_init"},{"location":"reference/libs/texas/cc3000/docs/cc3000/#init","text":"init ( spi , nss , wen , irq ) Tries to init the CC3000 driver. spi is the name of the spi driver the CC3000 is connected to. nss is the pin used as Chip Select (CS). wen is the pin used as Wireless Enable. irq is the pin used by the CC3000 to generate an interrupt.","title":"init"},{"location":"reference/libs/texas/cc3000/docs/cc3000_tiny/","text":"CC3000 Tiny \u00b6 This module implements the cc3000 wifi driver with stripped down functionalities for low resource devices. The following funtionalities are missing: wifi network scanning ping smart_config Refer to cc3000 for usage info. auto_init \u00b6 auto_init () Tries to automatically init the CC3000 driver by looking at the device type. The automatic configuration is possible for all the Arduino compatible devices and for the Particle Core. Otherwise an exception is raised. init \u00b6 init ( spi , nss , wen , irq ) Tries to init the CC3000 driver. spi is the name of the spi driver the CC3000 is connected to. nss is the pin used as Chip Select (CS). wen is the pin used as Wireless Enable. irq is the pin used by the CC3000 to generate an interrupt.","title":"CC3000 Tiny"},{"location":"reference/libs/texas/cc3000/docs/cc3000_tiny/#cc3000-tiny","text":"This module implements the cc3000 wifi driver with stripped down functionalities for low resource devices. The following funtionalities are missing: wifi network scanning ping smart_config Refer to cc3000 for usage info.","title":"CC3000 Tiny"},{"location":"reference/libs/texas/cc3000/docs/cc3000_tiny/#auto_init","text":"auto_init () Tries to automatically init the CC3000 driver by looking at the device type. The automatic configuration is possible for all the Arduino compatible devices and for the Particle Core. Otherwise an exception is raised.","title":"auto_init"},{"location":"reference/libs/texas/cc3000/docs/cc3000_tiny/#init","text":"init ( spi , nss , wen , irq ) Tries to init the CC3000 driver. spi is the name of the spi driver the CC3000 is connected to. nss is the pin used as Chip Select (CS). wen is the pin used as Wireless Enable. irq is the pin used by the CC3000 to generate an interrupt.","title":"init"},{"location":"reference/libs/texas/pca9536/docs/","text":"TI PCA9536 \u00b6 PCA9536 is a 4-bit bidirectional I/O expander utilizing I2C and designed for 2.3-V to 5.5-V VCC operation. It provides general-purpose remote I/O expansion for most microcontroller families via the I2C interface [serial clock (SCL), serial data (SDA)]. Technical Details \u00b6 4-bit I2C-bus Output Channels Polarity Inversion register Low standby current No glitch on power-up Internal power-on reset 0 Hz to 400 kHz I2C-bus clock frequency ESD protection exceeds 2000 V HBM per JESD22-A114, 200 V MM per JESD22-A115 and 1000 V CDM per JESD22-C101 Contents: PCA9536 Module PCA9536 class Examples toggle outputs remote control wolkabout weather monitor","title":"TI PCA9536"},{"location":"reference/libs/texas/pca9536/docs/#ti-pca9536","text":"PCA9536 is a 4-bit bidirectional I/O expander utilizing I2C and designed for 2.3-V to 5.5-V VCC operation. It provides general-purpose remote I/O expansion for most microcontroller families via the I2C interface [serial clock (SCL), serial data (SDA)].","title":"TI PCA9536"},{"location":"reference/libs/texas/pca9536/docs/#technical-details","text":"4-bit I2C-bus Output Channels Polarity Inversion register Low standby current No glitch on power-up Internal power-on reset 0 Hz to 400 kHz I2C-bus clock frequency ESD protection exceeds 2000 V HBM per JESD22-A114, 200 V MM per JESD22-A115 and 1000 V CDM per JESD22-C101 Contents: PCA9536 Module PCA9536 class Examples toggle outputs remote control wolkabout weather monitor","title":"Technical Details"},{"location":"reference/libs/texas/pca9536/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.texas.pca9536. Toggle outputs on OC01 \u00b6 This is a basic example to toggle the outputs on the OC01 xChip. main.py ############################################## # This is example for the pca9536 library # # Each output is toggled at 500ms ############################################## # imports from texas.pca9536 import pca9536 as OC01 # sleep time DELAY = 500 # create an instance of PCA9536 class OC01 = OC01 . PCA9536 ( I2C0 ) # OC01 pins OUT0 = OC01 . OUT0 OUT1 = OC01 . OUT1 OUT2 = OC01 . OUT2 OUT3 = OC01 . OUT3 # initialize OC01 OC01 . init () # infinite loop while True : # Switch OUT0 On OC01 . writePin ( OUT0 , True ) sleep ( DELAY ) # Switch OUT1 On OC01 . writePin ( OUT1 , True ) sleep ( DELAY ) # Switch OUT2 On OC01 . writePin ( OUT2 , True ) sleep ( DELAY ) # Switch OUT3 On OC01 . writePin ( OUT3 , True ) sleep ( DELAY ) # Switch OUT0 off OC01 . writePin ( OUT0 , False ) sleep ( DELAY ) # Switch OUT1 off OC01 . writePin ( OUT1 , False ) sleep ( DELAY ) # Switch OUT2 off OC01 . writePin ( OUT2 , False ) sleep ( DELAY ) # Switch OUT3 off OC01 . writePin ( OUT3 , False ) sleep ( DELAY ) Control OC01 xChip (PCA9536) remotely \u00b6 This is an advanced example utilizing BME280, PCA9536 and the WolkAbout IoT Platform. BME280 data consisting of ambient temperature, humidity and pressure is sent to WolkAbout Platform. OC01 outputs can be controlled from within the dashboad. Upload the CW02-SW01-OC01-deviceTemplate.json to WolkAbout IoT Platfrom. main.py ####################################################### # This example sends BME280 data to the WolkAbout cloud. # PCA9536 outputs can also be controlled from within the # WolkAbout dashboard. # # Upload the device template to the WolkAbout platform. ######################################################## # imports import streams from texas.pca9536 import pca9536 as OC01 from wolkabout.iot import iot from wireless import wifi from bosch.bme280 import bme280 from espressif.esp32net import esp32wifi as wifi_driver # wifi details wifi_ssid = \"WiFi Username\" wifi_pass = \"WiFi Password\" wifi_secu = wifi . WIFI_WPA2 # rgb pins RED = D25 GREEN = D26 BLUE = D27 # enable console streams . serial () # wolkabout project details device_key = \"wolkabout_device_key\" device_password = \"wolkabout_device_password\" actuator_references = [ \"0\" , \"1\" , \"2\" , \"3\" ] # rgb pins set as output pinMode ( RED , OUTPUT ) pinMode ( GREEN , OUTPUT ) pinMode ( BLUE , OUTPUT ) # xChip instances SW01 = bme280 . BME280 ( I2C0 , 0x76 , 100000 ) OC01 = OC01 . PCA9536 ( I2C0 ) # initialize sensors SW01 . start () OC01 . init () # OC01 pins OUT0 = OC01 . OUT0 OUT1 = OC01 . OUT1 OUT2 = OC01 . OUT2 OUT3 = OC01 . OUT3 # init the wifi driver wifi_driver . auto_init () # method that establishes a wifi connection def wifi_connect (): for retry in range ( 10 ): try : print ( \"Establishing Link...\" ) wifi . link ( wifi_ssid , wifi_secu , wifi_pass ) print ( \"Link Established\" ) digitalWrite ( GREEN , HIGH ) break except Exception as e : print ( \"ooops, something wrong while linking :(\" , e ) digitalWrite ( GREEN , LOW ) digitalWrite ( RED , HIGH ) sleep ( 1000 ) digitalWrite ( RED , LOW ) sleep ( 1000 ) # connect to wifi wifi_connect () # establish a connection between device and wolkabout iot platform try : device = iot . Device ( device_key , device_password , actuator_references ) except Exception as e : print ( \"Something went wrong while creating the device: \" , e ) # Provide implementation of a way to read and modify actuator state class ActuatorStatusProviderImpl ( iot . ActuatorStatusProvider ): def get_actuator_status ( reference ): if reference == actuator_references [ 0 ]: value = OC01 . getStatus () & 0x01 print ( value ) if value == 0x01 : return iot . ACTUATOR_STATE_READY , True else : return iot . ACTUATOR_STATE_READY , False if reference == actuator_references [ 1 ]: value = OC01 . getStatus () & 0x02 print ( value ) if value == 0x02 : return iot . ACTUATOR_STATE_READY , True else : return iot . ACTUATOR_STATE_READY , False if reference == actuator_references [ 2 ]: value = OC01 . getStatus () & 0x04 print ( value ) if value == 0x04 : return iot . ACTUATOR_STATE_READY , True else : return iot . ACTUATOR_STATE_READY , False if reference == actuator_references [ 3 ]: value = OC01 . getStatus () & 0x08 print ( value ) if value == 0x08 : return iot . ACTUATOR_STATE_READY , True else : return iot . ACTUATOR_STATE_READY , False class ActuationHandlerImpl ( iot . ActuationHandler ): def handle_actuation ( reference , value ): print ( \"Setting actuator \" + reference + \" to value: \" + str ( value )) if reference == actuator_references [ 0 ]: if value is False : OC01 . writePin ( OUT0 , False ) else : if value is True : OC01 . writePin ( OUT0 , True ) if reference == actuator_references [ 1 ]: if value is False : OC01 . writePin ( OUT1 , False ) else : if value is True : OC01 . writePin ( OUT1 , True ) if reference == actuator_references [ 2 ]: if value is False : OC01 . writePin ( OUT2 , False ) else : if value is True : OC01 . writePin ( OUT2 , True ) if reference == actuator_references [ 3 ]: if value is False : OC01 . writePin ( OUT3 , False ) else : if value is True : OC01 . writePin ( OUT3 , True ) try : wolk = iot . Wolk ( device , actuation_handler = ActuationHandlerImpl , actuator_status_provider = ActuatorStatusProviderImpl , ) except Exception as e : print ( \"Something went wrong while creating the Wolk instance: \" , e ) # Establish a connection to the WolkAbout IoT Platform try : print ( \"Connecting to WolkAbout IoT Platform\" ) wolk . connect () print ( \"Done\" ) except Exception as e : print ( \"Something went wrong while connecting: \" , e ) publish_period = 5000 wolk . publish_actuator_status ( \"0\" ) wolk . publish_actuator_status ( \"1\" ) wolk . publish_actuator_status ( \"2\" ) wolk . publish_actuator_status ( \"3\" ) try : while True : if not wifi . is_linked (): wifi_connect () sleep ( publish_period ) print ( \"Publishing sensor readings\" ) temperature = SW01 . get_temp () humidity = SW01 . get_hum () pressure = SW01 . get_press () print ( \"T\" , temperature , \"H\" , humidity , \"P\" , pressure ) wolk . add_sensor_reading ( \"T\" , temperature ) wolk . add_sensor_reading ( \"H\" , humidity ) wolk . add_sensor_reading ( \"P\" , pressure ) wolk . publish () except Exception as e : print ( \"Something went wrong: \" , e )","title":"Examples"},{"location":"reference/libs/texas/pca9536/docs/examples/#examples","text":"The following are a list of examples for lib.texas.pca9536.","title":"Examples"},{"location":"reference/libs/texas/pca9536/docs/examples/#toggle-outputs-on-oc01","text":"This is a basic example to toggle the outputs on the OC01 xChip. main.py ############################################## # This is example for the pca9536 library # # Each output is toggled at 500ms ############################################## # imports from texas.pca9536 import pca9536 as OC01 # sleep time DELAY = 500 # create an instance of PCA9536 class OC01 = OC01 . PCA9536 ( I2C0 ) # OC01 pins OUT0 = OC01 . OUT0 OUT1 = OC01 . OUT1 OUT2 = OC01 . OUT2 OUT3 = OC01 . OUT3 # initialize OC01 OC01 . init () # infinite loop while True : # Switch OUT0 On OC01 . writePin ( OUT0 , True ) sleep ( DELAY ) # Switch OUT1 On OC01 . writePin ( OUT1 , True ) sleep ( DELAY ) # Switch OUT2 On OC01 . writePin ( OUT2 , True ) sleep ( DELAY ) # Switch OUT3 On OC01 . writePin ( OUT3 , True ) sleep ( DELAY ) # Switch OUT0 off OC01 . writePin ( OUT0 , False ) sleep ( DELAY ) # Switch OUT1 off OC01 . writePin ( OUT1 , False ) sleep ( DELAY ) # Switch OUT2 off OC01 . writePin ( OUT2 , False ) sleep ( DELAY ) # Switch OUT3 off OC01 . writePin ( OUT3 , False ) sleep ( DELAY )","title":"Toggle outputs on OC01"},{"location":"reference/libs/texas/pca9536/docs/examples/#control-oc01-xchip-pca9536-remotely","text":"This is an advanced example utilizing BME280, PCA9536 and the WolkAbout IoT Platform. BME280 data consisting of ambient temperature, humidity and pressure is sent to WolkAbout Platform. OC01 outputs can be controlled from within the dashboad. Upload the CW02-SW01-OC01-deviceTemplate.json to WolkAbout IoT Platfrom. main.py ####################################################### # This example sends BME280 data to the WolkAbout cloud. # PCA9536 outputs can also be controlled from within the # WolkAbout dashboard. # # Upload the device template to the WolkAbout platform. ######################################################## # imports import streams from texas.pca9536 import pca9536 as OC01 from wolkabout.iot import iot from wireless import wifi from bosch.bme280 import bme280 from espressif.esp32net import esp32wifi as wifi_driver # wifi details wifi_ssid = \"WiFi Username\" wifi_pass = \"WiFi Password\" wifi_secu = wifi . WIFI_WPA2 # rgb pins RED = D25 GREEN = D26 BLUE = D27 # enable console streams . serial () # wolkabout project details device_key = \"wolkabout_device_key\" device_password = \"wolkabout_device_password\" actuator_references = [ \"0\" , \"1\" , \"2\" , \"3\" ] # rgb pins set as output pinMode ( RED , OUTPUT ) pinMode ( GREEN , OUTPUT ) pinMode ( BLUE , OUTPUT ) # xChip instances SW01 = bme280 . BME280 ( I2C0 , 0x76 , 100000 ) OC01 = OC01 . PCA9536 ( I2C0 ) # initialize sensors SW01 . start () OC01 . init () # OC01 pins OUT0 = OC01 . OUT0 OUT1 = OC01 . OUT1 OUT2 = OC01 . OUT2 OUT3 = OC01 . OUT3 # init the wifi driver wifi_driver . auto_init () # method that establishes a wifi connection def wifi_connect (): for retry in range ( 10 ): try : print ( \"Establishing Link...\" ) wifi . link ( wifi_ssid , wifi_secu , wifi_pass ) print ( \"Link Established\" ) digitalWrite ( GREEN , HIGH ) break except Exception as e : print ( \"ooops, something wrong while linking :(\" , e ) digitalWrite ( GREEN , LOW ) digitalWrite ( RED , HIGH ) sleep ( 1000 ) digitalWrite ( RED , LOW ) sleep ( 1000 ) # connect to wifi wifi_connect () # establish a connection between device and wolkabout iot platform try : device = iot . Device ( device_key , device_password , actuator_references ) except Exception as e : print ( \"Something went wrong while creating the device: \" , e ) # Provide implementation of a way to read and modify actuator state class ActuatorStatusProviderImpl ( iot . ActuatorStatusProvider ): def get_actuator_status ( reference ): if reference == actuator_references [ 0 ]: value = OC01 . getStatus () & 0x01 print ( value ) if value == 0x01 : return iot . ACTUATOR_STATE_READY , True else : return iot . ACTUATOR_STATE_READY , False if reference == actuator_references [ 1 ]: value = OC01 . getStatus () & 0x02 print ( value ) if value == 0x02 : return iot . ACTUATOR_STATE_READY , True else : return iot . ACTUATOR_STATE_READY , False if reference == actuator_references [ 2 ]: value = OC01 . getStatus () & 0x04 print ( value ) if value == 0x04 : return iot . ACTUATOR_STATE_READY , True else : return iot . ACTUATOR_STATE_READY , False if reference == actuator_references [ 3 ]: value = OC01 . getStatus () & 0x08 print ( value ) if value == 0x08 : return iot . ACTUATOR_STATE_READY , True else : return iot . ACTUATOR_STATE_READY , False class ActuationHandlerImpl ( iot . ActuationHandler ): def handle_actuation ( reference , value ): print ( \"Setting actuator \" + reference + \" to value: \" + str ( value )) if reference == actuator_references [ 0 ]: if value is False : OC01 . writePin ( OUT0 , False ) else : if value is True : OC01 . writePin ( OUT0 , True ) if reference == actuator_references [ 1 ]: if value is False : OC01 . writePin ( OUT1 , False ) else : if value is True : OC01 . writePin ( OUT1 , True ) if reference == actuator_references [ 2 ]: if value is False : OC01 . writePin ( OUT2 , False ) else : if value is True : OC01 . writePin ( OUT2 , True ) if reference == actuator_references [ 3 ]: if value is False : OC01 . writePin ( OUT3 , False ) else : if value is True : OC01 . writePin ( OUT3 , True ) try : wolk = iot . Wolk ( device , actuation_handler = ActuationHandlerImpl , actuator_status_provider = ActuatorStatusProviderImpl , ) except Exception as e : print ( \"Something went wrong while creating the Wolk instance: \" , e ) # Establish a connection to the WolkAbout IoT Platform try : print ( \"Connecting to WolkAbout IoT Platform\" ) wolk . connect () print ( \"Done\" ) except Exception as e : print ( \"Something went wrong while connecting: \" , e ) publish_period = 5000 wolk . publish_actuator_status ( \"0\" ) wolk . publish_actuator_status ( \"1\" ) wolk . publish_actuator_status ( \"2\" ) wolk . publish_actuator_status ( \"3\" ) try : while True : if not wifi . is_linked (): wifi_connect () sleep ( publish_period ) print ( \"Publishing sensor readings\" ) temperature = SW01 . get_temp () humidity = SW01 . get_hum () pressure = SW01 . get_press () print ( \"T\" , temperature , \"H\" , humidity , \"P\" , pressure ) wolk . add_sensor_reading ( \"T\" , temperature ) wolk . add_sensor_reading ( \"H\" , humidity ) wolk . add_sensor_reading ( \"P\" , pressure ) wolk . publish () except Exception as e : print ( \"Something went wrong: \" , e )","title":"Control OC01 xChip (PCA9536) remotely"},{"location":"reference/libs/texas/pca9536/docs/pca9536/","text":"PCA9536 Module \u00b6 This is a Module for the PCA9536 I/O expander by Texas Instruments. The Module implements the PCA9536 as an output device utilizing the OC01 xChip . The board uses I2C for communication. Data Sheets: PCA9536 PCA9536 class \u00b6 class PCA9536 \u00b6 class PCA9536 ( self , drvname , addr = 0x41 , clk = 100000 ) Create an instance of the PCA9536 class. Arguments: drvname \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x41 clk \u2013 Clock speed, default 100kHz PCA9536.init \u00b6 init ( self , pins = PCA9536_ALL_OUTPUTS_OFF ) Configures PCA9536 and sets all outputs False by default. Arguments: pins \u2013 gives the pins an initial state. PCA9536.writePin \u00b6 writePin ( self , pin , state ) Determines the status of the output. Arguments: pin \u2013 accepts one of four output pins on PCA9536 (1, 2, 4, 8) state \u2013 accepts the state at which selected pin should be (True or False) PCA9536.getStatus \u00b6 getStatus ( self ) Reads the status of the output port. To read a single bit/pin mask the return value with the pin number. | Eg. getStatus()& OUT0 returns the status of the output port.","title":"PCA9536 Module"},{"location":"reference/libs/texas/pca9536/docs/pca9536/#pca9536-module","text":"This is a Module for the PCA9536 I/O expander by Texas Instruments. The Module implements the PCA9536 as an output device utilizing the OC01 xChip . The board uses I2C for communication. Data Sheets: PCA9536","title":"PCA9536 Module"},{"location":"reference/libs/texas/pca9536/docs/pca9536/#pca9536-class","text":"","title":"PCA9536 class"},{"location":"reference/libs/texas/pca9536/docs/pca9536/#class-pca9536","text":"class PCA9536 ( self , drvname , addr = 0x41 , clk = 100000 ) Create an instance of the PCA9536 class. Arguments: drvname \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x41 clk \u2013 Clock speed, default 100kHz","title":"class PCA9536"},{"location":"reference/libs/texas/pca9536/docs/pca9536/#pca9536init","text":"init ( self , pins = PCA9536_ALL_OUTPUTS_OFF ) Configures PCA9536 and sets all outputs False by default. Arguments: pins \u2013 gives the pins an initial state.","title":"PCA9536.init"},{"location":"reference/libs/texas/pca9536/docs/pca9536/#pca9536writepin","text":"writePin ( self , pin , state ) Determines the status of the output. Arguments: pin \u2013 accepts one of four output pins on PCA9536 (1, 2, 4, 8) state \u2013 accepts the state at which selected pin should be (True or False)","title":"PCA9536.writePin"},{"location":"reference/libs/texas/pca9536/docs/pca9536/#pca9536getstatus","text":"getStatus ( self ) Reads the status of the output port. To read a single bit/pin mask the return value with the pin number. | Eg. getStatus()& OUT0 returns the status of the output port.","title":"PCA9536.getStatus"},{"location":"reference/libs/texas/tmp112/docs/","text":"TI TMP112 \u00b6 The TMP112 device is a digital temperature sensor ideal for NTC/PTC thermistor replacement where high accuracy is required. The device offers an accuracy of \u00b10.5\u00b0C without requiring calibration or external component signal conditioning. IC temperature sensors are highly linear and do not require complex calculations or lookup tables to derive the temperature. The on-chip 12-bit ADC offers resolutions down to 0.0625\u00b0C. The TMP112 device features SMBus, two-wire and I2C interface compatibility, and allows up to four devices on one bus. The device also features an SMBus alert function. The TMP112 is ideal for extended temperature measurement in communication, computer, consumer, environmental, industrial, and instrumentation applications; more information at Texas Instruments dedicated page . Technical Details \u00b6 Supply Voltage (Vcc): from 1.4 V to 3.6 V Operation Temperature (Top): from -40 \u00b0C to 125 \u00b0C Resolution: 12 Bits Low Quiescent Current: 10 uA active (max) and 1 uA shutdown (max) Accuracy without calibration: 0.5 \u00b0C (max) from 0 \u00b0C to 65 \u00b0C 1.0 \u00b0C (max) from -40 \u00b0C to 125 \u00b0C Here below, the Zerynth driver for the Texas Instruments TMP112. Contents: TMP112 Module TMP112 class","title":"Index"},{"location":"reference/libs/texas/tmp112/docs/#ti-tmp112","text":"The TMP112 device is a digital temperature sensor ideal for NTC/PTC thermistor replacement where high accuracy is required. The device offers an accuracy of \u00b10.5\u00b0C without requiring calibration or external component signal conditioning. IC temperature sensors are highly linear and do not require complex calculations or lookup tables to derive the temperature. The on-chip 12-bit ADC offers resolutions down to 0.0625\u00b0C. The TMP112 device features SMBus, two-wire and I2C interface compatibility, and allows up to four devices on one bus. The device also features an SMBus alert function. The TMP112 is ideal for extended temperature measurement in communication, computer, consumer, environmental, industrial, and instrumentation applications; more information at Texas Instruments dedicated page .","title":"TI TMP112"},{"location":"reference/libs/texas/tmp112/docs/#technical-details","text":"Supply Voltage (Vcc): from 1.4 V to 3.6 V Operation Temperature (Top): from -40 \u00b0C to 125 \u00b0C Resolution: 12 Bits Low Quiescent Current: 10 uA active (max) and 1 uA shutdown (max) Accuracy without calibration: 0.5 \u00b0C (max) from 0 \u00b0C to 65 \u00b0C 1.0 \u00b0C (max) from -40 \u00b0C to 125 \u00b0C Here below, the Zerynth driver for the Texas Instruments TMP112. Contents: TMP112 Module TMP112 class","title":"Technical Details"},{"location":"reference/libs/texas/tmp112/docs/tmp112/","text":"TMP112 Module \u00b6 The TMP112 is device is a digital temperature sensor with high accuracy from Texas Instrument ( datasheet ). The default communication protocol is I2C. To use this module create a TMP112 instance by passing the I2C peripheral name to which it is connected to. Using the module is simple: from texas.tmp112 import tmp112 import streams streams . serial () tmp = tmp112 . TMP112 ( I2C0 ) while True : print ( \"Temperature:\" , tmp . temperature ()) sleep ( 1000 ) class TMP112 \u00b6 class TMP112 ( drvname , clock = 100000 , addr = 0x49 ) Creates a TMP112 instance using the MCU I2C circuitry drvname (one of I2C0, I2C1, \u2026 check pinmap for details). The created instance is configured and ready to communicate. clock is configured by default in slow mode. TMP112 inherits from i2c.I2C, therefore the method start() must be called to setup the I2C channel before any temperature can be read. The TMP112 can have 4 different I2C addresses determined by the wiring: A0 connected to GND: 0x48 A0 connected to Vdd: 0x49 A0 connected to SDA: 0x4A A0 connected to SCL: 0x4B TMP112.temperature \u00b6 temperature () Returns the object temperature in Celsius.","title":"TMP112 Module"},{"location":"reference/libs/texas/tmp112/docs/tmp112/#tmp112-module","text":"The TMP112 is device is a digital temperature sensor with high accuracy from Texas Instrument ( datasheet ). The default communication protocol is I2C. To use this module create a TMP112 instance by passing the I2C peripheral name to which it is connected to. Using the module is simple: from texas.tmp112 import tmp112 import streams streams . serial () tmp = tmp112 . TMP112 ( I2C0 ) while True : print ( \"Temperature:\" , tmp . temperature ()) sleep ( 1000 )","title":"TMP112 Module"},{"location":"reference/libs/texas/tmp112/docs/tmp112/#class-tmp112","text":"class TMP112 ( drvname , clock = 100000 , addr = 0x49 ) Creates a TMP112 instance using the MCU I2C circuitry drvname (one of I2C0, I2C1, \u2026 check pinmap for details). The created instance is configured and ready to communicate. clock is configured by default in slow mode. TMP112 inherits from i2c.I2C, therefore the method start() must be called to setup the I2C channel before any temperature can be read. The TMP112 can have 4 different I2C addresses determined by the wiring: A0 connected to GND: 0x48 A0 connected to Vdd: 0x49 A0 connected to SDA: 0x4A A0 connected to SCL: 0x4B","title":"class TMP112"},{"location":"reference/libs/texas/tmp112/docs/tmp112/#tmp112temperature","text":"temperature () Returns the object temperature in Celsius.","title":"TMP112.temperature"},{"location":"reference/libs/ubidots/iot/docs/","text":"Ubidots \u00b6 Ubidots is an IoT platform to connect, monitor and control Internet of Things devices: Ubidots IoT platform . Here below, the Zerynth Library to manage your devices thanks to Ubidots: Contents: Ubidots Library The Device class Examples Controlled publish period","title":"Index"},{"location":"reference/libs/ubidots/iot/docs/#ubidots","text":"Ubidots is an IoT platform to connect, monitor and control Internet of Things devices: Ubidots IoT platform . Here below, the Zerynth Library to manage your devices thanks to Ubidots: Contents: Ubidots Library The Device class Examples Controlled publish period","title":"Ubidots"},{"location":"reference/libs/ubidots/iot/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.ubidots.iot. Controlled Publish Period \u00b6 Connect your device to Ubidots IoT platform and start publishing at a default period, waiting for period updates requested as changes to period variable. main.py # Ubidots Controlled publish period # Created at 2017-10-03 08:49:48.182639 import streams import json from wireless import wifi # choose a wifi chip supporting secure sockets from espressif.esp32net import esp32wifi as wifi_driver # import ubidots iot module from ubidots.iot import iot # import helpers functions to easily device configuration import helpers # SET DEVICE CONFIGURATION INSIDE THE FOLLOWING JSON FILE new_resource ( 'device.conf.json' ) # define a callback for period updates def period_callback ( value ): global publish_period print ( 'requested publish period:' , int ( value )) publish_period = int ( value ) streams . serial () wifi_driver . auto_init () print ( 'connecting to wifi...' ) # place here your wifi configuration wifi . link ( \"SSID\" , wifi . WIFI_WPA2 , \"PSW\" ) device_conf = helpers . load_device_conf () publish_period = 3000 # create ubidots iot device instance, connect to mqtt broker, set variable update callback and start mqtt reception loop device = iot . Device ( device_conf [ 'device_label' ], device_conf [ 'user_type' ], device_conf [ 'api_token' ]) print ( 'connecting to mqtt broker...' ) device . mqtt . connect () device . on_variable_update ( device_conf [ 'device_label' ], 'publish_period' , period_callback , json = False ) device . mqtt . loop () while True : print ( 'publish random sample...' ) device . publish ({ 'value' : random ( 0 , 10 ) }, variable = 'temperature' ) sleep ( publish_period )","title":"Examples"},{"location":"reference/libs/ubidots/iot/docs/examples/#examples","text":"The following are a list of examples for lib.ubidots.iot.","title":"Examples"},{"location":"reference/libs/ubidots/iot/docs/examples/#controlled-publish-period","text":"Connect your device to Ubidots IoT platform and start publishing at a default period, waiting for period updates requested as changes to period variable. main.py # Ubidots Controlled publish period # Created at 2017-10-03 08:49:48.182639 import streams import json from wireless import wifi # choose a wifi chip supporting secure sockets from espressif.esp32net import esp32wifi as wifi_driver # import ubidots iot module from ubidots.iot import iot # import helpers functions to easily device configuration import helpers # SET DEVICE CONFIGURATION INSIDE THE FOLLOWING JSON FILE new_resource ( 'device.conf.json' ) # define a callback for period updates def period_callback ( value ): global publish_period print ( 'requested publish period:' , int ( value )) publish_period = int ( value ) streams . serial () wifi_driver . auto_init () print ( 'connecting to wifi...' ) # place here your wifi configuration wifi . link ( \"SSID\" , wifi . WIFI_WPA2 , \"PSW\" ) device_conf = helpers . load_device_conf () publish_period = 3000 # create ubidots iot device instance, connect to mqtt broker, set variable update callback and start mqtt reception loop device = iot . Device ( device_conf [ 'device_label' ], device_conf [ 'user_type' ], device_conf [ 'api_token' ]) print ( 'connecting to mqtt broker...' ) device . mqtt . connect () device . on_variable_update ( device_conf [ 'device_label' ], 'publish_period' , period_callback , json = False ) device . mqtt . loop () while True : print ( 'publish random sample...' ) device . publish ({ 'value' : random ( 0 , 10 ) }, variable = 'temperature' ) sleep ( publish_period )","title":"Controlled Publish Period"},{"location":"reference/libs/ubidots/iot/docs/iot/","text":"Ubidots Library \u00b6 The Zerynth Ubidots Library can be used to ease the connection to the Ubidots IoT platform . It allows to make your device act as an Ubidots Device which can be created through Ubidots dashboard. The Device class \u00b6 class Device \u00b6 class Device ( device_label , user_type , api_token ) Create a Device instance representing an Ubidots Device. The Device object will contain an mqtt client instance pointing to Ubidots MQTT broker located at things.ubidots.com or industrial.api.ubidots.com depending on user_type , a string which can be \"educational\" or \"business\" . The client is configured wit device_label as MQTT id and is able to connect securely through TLS and to authenticate setting api_token as client username. The client is accessible through mqtt instance attribute and exposes all Zerynth MQTT Client methods so that it is possible, for example, to setup custom callback on MQTT commands (though the Device class already exposes high-level methods to setup Ubidots specific callbacks). The only difference concerns mqtt.connect method which does not require broker url and ssl context, taking them from Device configuration: my_device = iot . Device ( 'my_label' , 'business' , 'my_api_token' ) my_device . mqtt . connect () ... my_device . mqtt . loop () Device.publish \u00b6 publish ( data , variable = None ) Publish data dictionary to device or device variable variable . Data dictionary should follow valid Ubidots data format . on_variable_update(device, variable, callback, json=True)` Set a callback to respond to variable updates from device device . callback will be called passing a dictionary or a float value, containing variable updates, respectively for a True or False json parameter value: def noise_callback ( data ): noise_level = data [ 'value' ] noise_location = data [ 'context' ] print ( noise_level , noise_location ) device . on_variable_update ( 'noise-listener' , 'noise-level' , noise_callback )","title":"Ubidots Library"},{"location":"reference/libs/ubidots/iot/docs/iot/#ubidots-library","text":"The Zerynth Ubidots Library can be used to ease the connection to the Ubidots IoT platform . It allows to make your device act as an Ubidots Device which can be created through Ubidots dashboard.","title":"Ubidots Library"},{"location":"reference/libs/ubidots/iot/docs/iot/#the-device-class","text":"","title":"The Device class"},{"location":"reference/libs/ubidots/iot/docs/iot/#class-device","text":"class Device ( device_label , user_type , api_token ) Create a Device instance representing an Ubidots Device. The Device object will contain an mqtt client instance pointing to Ubidots MQTT broker located at things.ubidots.com or industrial.api.ubidots.com depending on user_type , a string which can be \"educational\" or \"business\" . The client is configured wit device_label as MQTT id and is able to connect securely through TLS and to authenticate setting api_token as client username. The client is accessible through mqtt instance attribute and exposes all Zerynth MQTT Client methods so that it is possible, for example, to setup custom callback on MQTT commands (though the Device class already exposes high-level methods to setup Ubidots specific callbacks). The only difference concerns mqtt.connect method which does not require broker url and ssl context, taking them from Device configuration: my_device = iot . Device ( 'my_label' , 'business' , 'my_api_token' ) my_device . mqtt . connect () ... my_device . mqtt . loop ()","title":"class Device"},{"location":"reference/libs/ubidots/iot/docs/iot/#devicepublish","text":"publish ( data , variable = None ) Publish data dictionary to device or device variable variable . Data dictionary should follow valid Ubidots data format . on_variable_update(device, variable, callback, json=True)` Set a callback to respond to variable updates from device device . callback will be called passing a dictionary or a float value, containing variable updates, respectively for a True or False json parameter value: def noise_callback ( data ): noise_level = data [ 'value' ] noise_location = data [ 'context' ] print ( noise_level , noise_location ) device . on_variable_update ( 'noise-listener' , 'noise-level' , noise_callback )","title":"Device.publish"},{"location":"reference/libs/ublox/g350/docs/","text":"Ublox G350 \u00b6 The Ublox SARA-G3 series of GSM/GPRS modules feature extremely low power consumption and a miniature LGA form factor. SARA-G3 modules are interchangeable, and have been designed with the diverse needs of M2M customers in mind. Different functionalities and feature sets are available to meet different customer and application requirements. SARA-G350 is full-feature GSM/GPRS module with a comprehensive feature set, including an extensive set of internet protocols (TCP, UDP, HTTP, FTP and SMTP). It has fully integrated access to u-blox GNSS positioning chips and modules, along with embedded A-GNSS (AssistNow Online and AssistNow Offline) functionality. SARA-G350 is the quad-band version for global connectivity; more information at Ublox dedicated page . Technical Details \u00b6 Supply Voltage (Vcc): from 3.0 V to 4.5 V Operation Temperature (Top): from -40 \u00b0C to 85 \u00b0C Active Current: 250 mA (max) Standby Current: 0.90 mA (max) Protocols: Embedded TCP/IP, UDP/IP, HTTP/FTP, SSL and TLS 1.2 support Here below, the Zerynth driver for the Ublox G350 and some examples to better understand how to use it. Contents: G350 Module Technical Details G350 Module Examples","title":"Ublox G350"},{"location":"reference/libs/ublox/g350/docs/#ublox-g350","text":"The Ublox SARA-G3 series of GSM/GPRS modules feature extremely low power consumption and a miniature LGA form factor. SARA-G3 modules are interchangeable, and have been designed with the diverse needs of M2M customers in mind. Different functionalities and feature sets are available to meet different customer and application requirements. SARA-G350 is full-feature GSM/GPRS module with a comprehensive feature set, including an extensive set of internet protocols (TCP, UDP, HTTP, FTP and SMTP). It has fully integrated access to u-blox GNSS positioning chips and modules, along with embedded A-GNSS (AssistNow Online and AssistNow Offline) functionality. SARA-G350 is the quad-band version for global connectivity; more information at Ublox dedicated page .","title":"Ublox G350"},{"location":"reference/libs/ublox/g350/docs/#technical-details","text":"Supply Voltage (Vcc): from 3.0 V to 4.5 V Operation Temperature (Top): from -40 \u00b0C to 85 \u00b0C Active Current: 250 mA (max) Standby Current: 0.90 mA (max) Protocols: Embedded TCP/IP, UDP/IP, HTTP/FTP, SSL and TLS 1.2 support Here below, the Zerynth driver for the Ublox G350 and some examples to better understand how to use it. Contents: G350 Module Technical Details G350 Module Examples","title":"Technical Details"},{"location":"reference/libs/ublox/g350/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.ublox.g350. GSM HTTP \u00b6 Simple http request via cellular network (based on Particle Electron). main.py ################################################################################ # HTTP Time GSM Example # # Created: 2016-07-27 11:00:55.020628 # ################################################################################ # the classic wifi requests example, with very little changes can access # the net through a gsm connection! # import our gsm chip specific driver from ublox.g350 import g350 # and the generic gsm module from wireless import gsm import streams import requests import json streams . serial () try : # init the gsm driver! # The driver automatically registers itself to the gsm interface # with the correct configuration for the selected device # NOTE: change this line to g350.init(...) with correct parameters # if not running the example on a Particle Electron board g350 . auto_init () print ( \"Registering to the network...\" ) # connect to our APN for i in range ( 20 ): try : # set here the APN name gsm . attach ( 'spark.telefonica.com' ) break except g350Exception : print ( \"Something wrong on the G350\" ) except TimeoutError : print ( \"Can't register to network, took too long\" ) sleep ( 2000 ) else : print ( \"ooops, can't register at all!\" ) while True : sleep ( 1000 ) print ( \"Signal Strength:\" , gsm . rssi ()) print ( \"Link info\" , gsm . link_info ()) print ( \"Network info\" , gsm . network_info ()) print ( \"Device info\" , gsm . mobile_info ()) # from now on everything is exactly identical to wifi HTTP Time Example ;) # let's try to connect to timeapi.org to get the current UTC time for i in range ( 3 ): try : print ( \"Trying to connect...\" ) # go get that time! # url resolution and http protocol handling are hidden inside the requests module response = requests . get ( \"http://now.zerynth.com/\" ) # let's check the http response status: if different than 200, something went wrong print ( \"Http Status:\" , response . status ) # if we get here, there has been no exception, exit the loop break except Exception as e : print ( e ) try : # check status and print the result if response . status == 200 : print ( \"Success!!\" ) print ( \"-------------\" ) print ( \"Headers are:\" , response . headers ) print ( \"-------------\" ) print ( \"And the result is:\" , response . content ) print ( \"-------------\" ) js = json . loads ( response . content ) print ( \"Date:\" , js [ \"now\" ][ \"rfc2822\" ][: 16 ]) print ( \"Time:\" , js [ \"now\" ][ \"rfc2822\" ][ 17 :]) except Exception as e : print ( \"ooops, something very wrong! :(\" , e ) except Exception as e : print ( \"Something bad happened\" , e )","title":"Examples"},{"location":"reference/libs/ublox/g350/docs/examples/#examples","text":"The following are a list of examples for lib.ublox.g350.","title":"Examples"},{"location":"reference/libs/ublox/g350/docs/examples/#gsm-http","text":"Simple http request via cellular network (based on Particle Electron). main.py ################################################################################ # HTTP Time GSM Example # # Created: 2016-07-27 11:00:55.020628 # ################################################################################ # the classic wifi requests example, with very little changes can access # the net through a gsm connection! # import our gsm chip specific driver from ublox.g350 import g350 # and the generic gsm module from wireless import gsm import streams import requests import json streams . serial () try : # init the gsm driver! # The driver automatically registers itself to the gsm interface # with the correct configuration for the selected device # NOTE: change this line to g350.init(...) with correct parameters # if not running the example on a Particle Electron board g350 . auto_init () print ( \"Registering to the network...\" ) # connect to our APN for i in range ( 20 ): try : # set here the APN name gsm . attach ( 'spark.telefonica.com' ) break except g350Exception : print ( \"Something wrong on the G350\" ) except TimeoutError : print ( \"Can't register to network, took too long\" ) sleep ( 2000 ) else : print ( \"ooops, can't register at all!\" ) while True : sleep ( 1000 ) print ( \"Signal Strength:\" , gsm . rssi ()) print ( \"Link info\" , gsm . link_info ()) print ( \"Network info\" , gsm . network_info ()) print ( \"Device info\" , gsm . mobile_info ()) # from now on everything is exactly identical to wifi HTTP Time Example ;) # let's try to connect to timeapi.org to get the current UTC time for i in range ( 3 ): try : print ( \"Trying to connect...\" ) # go get that time! # url resolution and http protocol handling are hidden inside the requests module response = requests . get ( \"http://now.zerynth.com/\" ) # let's check the http response status: if different than 200, something went wrong print ( \"Http Status:\" , response . status ) # if we get here, there has been no exception, exit the loop break except Exception as e : print ( e ) try : # check status and print the result if response . status == 200 : print ( \"Success!!\" ) print ( \"-------------\" ) print ( \"Headers are:\" , response . headers ) print ( \"-------------\" ) print ( \"And the result is:\" , response . content ) print ( \"-------------\" ) js = json . loads ( response . content ) print ( \"Date:\" , js [ \"now\" ][ \"rfc2822\" ][: 16 ]) print ( \"Time:\" , js [ \"now\" ][ \"rfc2822\" ][ 17 :]) except Exception as e : print ( \"ooops, something very wrong! :(\" , e ) except Exception as e : print ( \"Something bad happened\" , e )","title":"GSM HTTP"},{"location":"reference/libs/ublox/g350/docs/g350/","text":"G350 Module \u00b6 This module implements the Zerynth driver for the Ublox G350 (or U260) gsm/gprs chip ( System Integration Manual ). The driver must be used together with the standard library GSM Module. The following functionalities are implemented: attach/detach from gprs network retrieve and set available operators retrieve signal strength retrieve network and device info socket abstraction (and secure socket if available on the model). Listening sockets for TCP and UDP protocols are not implemented due to the nature of GSM networks. The communication with G350 is performed via UART without hardware flow control. This module provides the g350Exception to signal errors related to the hardware initialization and management.","title":"G350 Module"},{"location":"reference/libs/ublox/g350/docs/g350/#g350-module","text":"This module implements the Zerynth driver for the Ublox G350 (or U260) gsm/gprs chip ( System Integration Manual ). The driver must be used together with the standard library GSM Module. The following functionalities are implemented: attach/detach from gprs network retrieve and set available operators retrieve signal strength retrieve network and device info socket abstraction (and secure socket if available on the model). Listening sockets for TCP and UDP protocols are not implemented due to the nature of GSM networks. The communication with G350 is performed via UART without hardware flow control. This module provides the g350Exception to signal errors related to the hardware initialization and management.","title":"G350 Module"},{"location":"reference/libs/vishay/vcnl4200/docs/","text":"Vishay VCNL4200 \u00b6 VCNL4200 integrates a high sensitivity long distance proximity sensor (PS), ambient light sensor (ALS), and 940 nm IRED into one small package More information at Vishay dedicated page . Proximity Function \u00b6 Immunity to red glow (940 nm IRED) Intelligent background light cancellation Smart persistence scheme to reduce PS response time Proximity distance up to 1.5 m Ambient Light Function \u00b6 Fluorescent light flicker immunity Spectrum close to real human eye responses Here below, the Zerynth driver for the Vishay VCNL4200. Contents: VCNL4200 Module VCNL4200 class Examples get distance","title":"Vishay VCNL4200"},{"location":"reference/libs/vishay/vcnl4200/docs/#vishay-vcnl4200","text":"VCNL4200 integrates a high sensitivity long distance proximity sensor (PS), ambient light sensor (ALS), and 940 nm IRED into one small package More information at Vishay dedicated page .","title":"Vishay VCNL4200"},{"location":"reference/libs/vishay/vcnl4200/docs/#proximity-function","text":"Immunity to red glow (940 nm IRED) Intelligent background light cancellation Smart persistence scheme to reduce PS response time Proximity distance up to 1.5 m","title":"Proximity Function"},{"location":"reference/libs/vishay/vcnl4200/docs/#ambient-light-function","text":"Fluorescent light flicker immunity Spectrum close to real human eye responses Here below, the Zerynth driver for the Vishay VCNL4200. Contents: VCNL4200 Module VCNL4200 class Examples get distance","title":"Ambient Light Function"},{"location":"reference/libs/vishay/vcnl4200/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.vishay.vcnl4200 Read distance from VCNL4200 \u00b6 Basic example to read the current values of distance and ambient light from sensor. main.py ################################################################################ # Read distance and ambient light from VCNL4200 # # Created: 2019-09-03 16:53 ################################################################################ import streams from vishay.vcnl4200 import vcnl4200 streams . serial () # Initialize sensor object on I2C0 sensor = vcnl4200 . VCNL4200 ( I2C0 ) # Read data and print it in loop while True : distance = sensor . get_distance () light = sensor . get_ambient_light () print ( 'Distance:' , distance , 'Light:' , light ) sleep ( 100 )","title":"Examples"},{"location":"reference/libs/vishay/vcnl4200/docs/examples/#examples","text":"The following are a list of examples for lib.vishay.vcnl4200","title":"Examples"},{"location":"reference/libs/vishay/vcnl4200/docs/examples/#read-distance-from-vcnl4200","text":"Basic example to read the current values of distance and ambient light from sensor. main.py ################################################################################ # Read distance and ambient light from VCNL4200 # # Created: 2019-09-03 16:53 ################################################################################ import streams from vishay.vcnl4200 import vcnl4200 streams . serial () # Initialize sensor object on I2C0 sensor = vcnl4200 . VCNL4200 ( I2C0 ) # Read data and print it in loop while True : distance = sensor . get_distance () light = sensor . get_ambient_light () print ( 'Distance:' , distance , 'Light:' , light ) sleep ( 100 )","title":"Read distance from VCNL4200"},{"location":"reference/libs/vishay/vcnl4200/docs/main/","text":"","title":"Main"},{"location":"reference/libs/vishay/vcnl4200/docs/vcnl4200/","text":"VCNL4200 Module \u00b6 This module contains the Zerynth driver for Vishay VCNL4200. The unit integrates a high sensitivity long distance proximity sensor (PS), ambient light sensor (ALS), and 940 nm IRED into one small package. Communication with this unit is done using I2C. VCNL4200 class \u00b6 class VCNL4200 \u00b6 class VCNL4200 ( drvsel , ps = True , als = True , address = DEFAULT_I2C_ADDR , clk = 400000 ) Initialize an object representing the VCNL4200 board. The I2C communication is started, and enabled sensors are configured with a stanrdard configuration. Note Default settings enable proximity sensor high definition and faster duty time, this results in more accuracy at the cost of more power usage. Refer to sensor datasheet and use configure_proximity_sensor(), configure_ambient_light_sensor() methods for more advanced settings. Arguments: drvsel \u2013 The I2C port to be used. (e.g. I2C0) ps \u2013 Boolean for enabling the proximity sensor on board (Default: True) als \u2013 Boolean for enabling the ambient light sensor on board (Default: True) address \u2013 Byte for selecting the I2C address to be used. (Default: sensor default) clk \u2013 I2C clock speed to be used (100000 or 400000). (Default: 400000) VCNL4200.get_distance \u00b6 get_distance () Returns an integer representing the proximity read from the sensor. VCNL4200.get_ambient_light \u00b6 get_ambient_light () Returns an integer in range 0-65535 representing the ambient light level read from the sensor. VCNL4200.configure_proximity_sensor \u00b6 configure_proximity_sensor ( conf1 , conf2 , conf3 ) Write settings for proximity sensor in registers PS_CONF1, PS_CONF2, and PS_CONF3. Refer to datasheet for all the available settings. Arguments: onf1 \u2013 Byte to be written in PS_CONF1 register. conf2 \u2013 Byte to be written in PS_CONF2 register. conf3 \u2013 Byte to be written in PS_CONF3 register. VCNL4200.configure_ambient_light_sensor \u00b6 configure_ambient_light_sensor ( conf ) Write settings for ambient light sensor in register ALS_CONF. Refer to datasheet for all the available settings. Arguments: conf \u2013 Byte to be written in ALS_CONF register.","title":"VCNL4200 Module"},{"location":"reference/libs/vishay/vcnl4200/docs/vcnl4200/#vcnl4200-module","text":"This module contains the Zerynth driver for Vishay VCNL4200. The unit integrates a high sensitivity long distance proximity sensor (PS), ambient light sensor (ALS), and 940 nm IRED into one small package. Communication with this unit is done using I2C.","title":"VCNL4200 Module"},{"location":"reference/libs/vishay/vcnl4200/docs/vcnl4200/#vcnl4200-class","text":"","title":"VCNL4200 class"},{"location":"reference/libs/vishay/vcnl4200/docs/vcnl4200/#class-vcnl4200","text":"class VCNL4200 ( drvsel , ps = True , als = True , address = DEFAULT_I2C_ADDR , clk = 400000 ) Initialize an object representing the VCNL4200 board. The I2C communication is started, and enabled sensors are configured with a stanrdard configuration. Note Default settings enable proximity sensor high definition and faster duty time, this results in more accuracy at the cost of more power usage. Refer to sensor datasheet and use configure_proximity_sensor(), configure_ambient_light_sensor() methods for more advanced settings. Arguments: drvsel \u2013 The I2C port to be used. (e.g. I2C0) ps \u2013 Boolean for enabling the proximity sensor on board (Default: True) als \u2013 Boolean for enabling the ambient light sensor on board (Default: True) address \u2013 Byte for selecting the I2C address to be used. (Default: sensor default) clk \u2013 I2C clock speed to be used (100000 or 400000). (Default: 400000)","title":"class VCNL4200"},{"location":"reference/libs/vishay/vcnl4200/docs/vcnl4200/#vcnl4200get_distance","text":"get_distance () Returns an integer representing the proximity read from the sensor.","title":"VCNL4200.get_distance"},{"location":"reference/libs/vishay/vcnl4200/docs/vcnl4200/#vcnl4200get_ambient_light","text":"get_ambient_light () Returns an integer in range 0-65535 representing the ambient light level read from the sensor.","title":"VCNL4200.get_ambient_light"},{"location":"reference/libs/vishay/vcnl4200/docs/vcnl4200/#vcnl4200configure_proximity_sensor","text":"configure_proximity_sensor ( conf1 , conf2 , conf3 ) Write settings for proximity sensor in registers PS_CONF1, PS_CONF2, and PS_CONF3. Refer to datasheet for all the available settings. Arguments: onf1 \u2013 Byte to be written in PS_CONF1 register. conf2 \u2013 Byte to be written in PS_CONF2 register. conf3 \u2013 Byte to be written in PS_CONF3 register.","title":"VCNL4200.configure_proximity_sensor"},{"location":"reference/libs/vishay/vcnl4200/docs/vcnl4200/#vcnl4200configure_ambient_light_sensor","text":"configure_ambient_light_sensor ( conf ) Write settings for ambient light sensor in register ALS_CONF. Refer to datasheet for all the available settings. Arguments: conf \u2013 Byte to be written in ALS_CONF register.","title":"VCNL4200.configure_ambient_light_sensor"},{"location":"reference/libs/wolkabout/iot/docs/","text":"WolkAbout IoT Platform \u00b6 WolkAbout IoT Platform is an IoT application enablement platform that allows users to easily and securely connect, manage, monitor and control disparate devices, transform real-time readings into meaningful data and combine different devices and services into a complete IoT solution: WolkAbout IoT Platform . The Zerynth WolkAbout IoT Library can be used to ease the connection to the WolkAbout IoT Platform. Contents: WolkAbout IoT Platform Library Dependencies MQTT Connectivity Service Outbound Message Queue Outbound Message Factory Inbound Message Factory Wolk class Device Actuation Handler Actuator Status Provider Configuration Handler Configuration Provider Examples Controlled publish period Full feature set","title":"Index"},{"location":"reference/libs/wolkabout/iot/docs/#wolkabout-iot-platform","text":"WolkAbout IoT Platform is an IoT application enablement platform that allows users to easily and securely connect, manage, monitor and control disparate devices, transform real-time readings into meaningful data and combine different devices and services into a complete IoT solution: WolkAbout IoT Platform . The Zerynth WolkAbout IoT Library can be used to ease the connection to the WolkAbout IoT Platform. Contents: WolkAbout IoT Platform Library Dependencies MQTT Connectivity Service Outbound Message Queue Outbound Message Factory Inbound Message Factory Wolk class Device Actuation Handler Actuator Status Provider Configuration Handler Configuration Provider Examples Controlled publish period Full feature set","title":"WolkAbout IoT Platform"},{"location":"reference/libs/wolkabout/iot/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.wolkabout.iot. Controlled publish period \u00b6 Connects your device to the WolkAbout IoT Platform and publishes data at a default period. Sends random temperature sensor readings. Import Simple-example-deviceTemplate.json on the platform to be able to quickly create a device with this sensor. main.py # Copyright 2018 WolkAbout Technology s.r.o. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import streams from wolkabout.iot import iot from wireless import wifi # uncomment one of the following lines depending on used board(e.g. Particle Photon, esp8266 or esp32 based board) # from broadcom.bcm43362 import bcm43362 as wifi_driver # from espressif.esp32net import esp32wifi as wifi_driver # from espressif.esp8266wifi import esp8266wifi as wifi_driver from stm.spwf01sa import spwf01sa as wifi_driver # Insert your WiFi credentials network_SSID = \"INSERT_YOUR_WIFI_SSID\" network_SECURITY = wifi . WIFI_WPA2 # wifi.WIFI_OPEN , wifi.WIFI_WEP, wifi.WIFI_WPA, wifi.WIFI_WPA2 network_password = \"INSERT_YOUR_WIFI_PASSWORD\" # Insert the device credentials received from WolkAbout IoT Platform when creating the device device_key = \"device_key\" device_password = \"some_password\" publish_period_milliseconds = 5000 streams . serial () # Enable debug printing by setting flag to True iot . debug_mode = False # Connect to WiFi network try : print ( \"Initializing WiFi driver..\" ) # This setup refers to spwf01sa wi-fi chip mounted on flip n click device slot A # For other wi-fi chips auto_init method is available, wifi_driver.auto_init() wifi_driver . init ( SERIAL1 , D16 ) print ( \"Establishing connection with WiFi network...\" ) wifi . link ( network_SSID , network_SECURITY , network_password ) print ( \"Done\" ) except Exception as e : print ( \"Something went wrong while linking to WiFi network: \" , e ) try : device = iot . Device ( device_key , device_password ) except Exception as e : print ( \"Something went wrong while creating the device: \" , e ) try : wolk = iot . Wolk ( device ) except Exception as e : print ( \"Something went wrong while creating the Wolk instance: \" , e ) try : print ( \"Connecting to WolkAbout IoT Platform\" ) wolk . connect () print ( \"Done\" ) except Exception as e : print ( \"Something went wrong while connecting to the platform: \" , e ) try : while True : temperature = random ( 15 , 40 ) print ( \"Publishing sensor reading T: \" + str ( temperature ) + \" C\" ) # Adds a sensor reading to the queue wolk . add_sensor_reading ( \"T\" , temperature ) # Publishes all stored sensor readings from the queue to the WolkAbout IoT Platform wolk . publish () sleep ( publish_period_milliseconds ) except Exception as e : print ( \"Something went wrong: \" , e ) Full feature set \u00b6 Connects your device to the WolkAbout IoT Platform and publishes data at a default period. Sends random temperature, pressure, humidity, and accelerometer sensor readings. If the random humidity value exceeds 60, an alarm will be sent to the platform. Has a switch and slider actuator allowing controlling the state from the platform. Also includes four configuration options that are meant for managing device behavior. Import Full-example-deviceTemplate.json on the platform to be able to quickly create a device. main.py # Copyright 2018 WolkAbout Technology s.r.o. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import streams from wolkabout.iot import iot from wireless import wifi # uncomment one of the following lines depending on used board(e.g. Particle Photon, esp8266 or esp32 based board) # from broadcom.bcm43362 import bcm43362 as wifi_driver # from espressif.esp32net import esp32wifi as wifi_driver # from espressif.esp8266wifi import esp8266wifi as wifi_driver from stm.spwf01sa import spwf01sa as wifi_driver # Insert your WiFi credentials network_SSID = \"INSERT_YOUR_WIFI_SSID\" network_SECURITY = wifi . WIFI_WPA2 # wifi.WIFI_OPEN , wifi.WIFI_WEP, wifi.WIFI_WPA, wifi.WIFI_WPA2 network_password = \"INSERT_YOUR_WIFI_PASSWORD\" # Insert the device credentials received from WolkAbout IoT Platform when creating the device device_key = \"device_key\" device_password = \"some_password\" actuator_references = [ \"SW\" , \"SL\" ] publish_period_milliseconds = 5000 streams . serial () # Enable debug printing by setting flag to True iot . debug_mode = False class ActuatorSimulator : def __init__ ( self , value ): self . value = value switch_simulator = ActuatorSimulator ( False ) slider_simulator = ActuatorSimulator ( 0 ) class ActuatorStatusProviderImpl ( iot . ActuatorStatusProvider ): def get_actuator_status ( self , reference ): if reference == \"SW\" : return iot . ACTUATOR_STATE_READY , switch_simulator . value if reference == \"SL\" : return iot . ACTUATOR_STATE_READY , slider_simulator . value class ActuationHandlerImpl ( iot . ActuationHandler ): def handle_actuation ( self , reference , value ): if reference == \"SL\" : slider_simulator . value = value if reference == \"SW\" : switch_simulator . value = value class ConfigurationSimulator : def __init__ ( self , value ): self . value = value config1_simulator = ConfigurationSimulator ( 0 ) config2_simulator = ConfigurationSimulator ( False ) config3_simulator = ConfigurationSimulator ( \"\" ) config4_simulator = ConfigurationSimulator (( \"\" , \"\" , \"\" )) class ConfigurationProviderImpl ( iot . ConfigurationProvider ): def get_configuration ( self ): configurations = dict () configurations [ \"config_1\" ] = config1_simulator . value configurations [ \"config_2\" ] = config2_simulator . value configurations [ \"config_3\" ] = config3_simulator . value configurations [ \"config_4\" ] = config4_simulator . value return configurations class ConfigurationHandlerImpl ( iot . ConfigurationHandler ): def handle_configuration ( self , configuration ): for config_reference , config_value in configuration . items (): if config_reference == \"config_1\" : config1_simulator . value = config_value if config_reference == \"config_2\" : config2_simulator . value = config_value if config_reference == \"config_3\" : config3_simulator . value = config_value if config_reference == \"config_4\" : config4_simulator . value = config_value # Connect to WiFi network try : print ( \"Initializing WiFi driver..\" ) # This setup refers to spwf01sa wi-fi chip mounted on flip n click device slot A # For other wi-fi chips auto_init method is available, wifi_driver.auto_init() wifi_driver . init ( SERIAL1 , D16 ) print ( \"Establishing connection with WiFi network...\" ) wifi . link ( network_SSID , network_SECURITY , network_password ) print ( \"Done\" ) except Exception as e : print ( \"Something went wrong while linking to WiFi network: \" , e ) try : device = iot . Device ( device_key , device_password , actuator_references ) except Exception as e : print ( \"Something went wrong while creating the device: \" , e ) try : wolk = iot . Wolk ( device , host = \"api-demo.wolkabout.com\" , port = 1883 , actuation_handler = ActuationHandlerImpl (), actuator_status_provider = ActuatorStatusProviderImpl (), outbound_message_queue = iot . ZerynthOutboundMessageQueue ( 200 ), configuration_handler = ConfigurationHandlerImpl (), configuration_provider = ConfigurationProviderImpl (), ) except Exception as e : print ( \"Something went wrong while creating the Wolk instance: \" , e ) try : print ( \"Connecting to WolkAbout IoT Platform\" ) wolk . connect () print ( \"Done\" ) except Exception as e : print ( \"Something went wrong while connecting to the platform: \" , e ) # Initial state of actuators and configuration must be delivered to the platform # in order to be able to change their values from the platform wolk . publish_actuator_status ( \"SW\" ) wolk . publish_actuator_status ( \"SL\" ) wolk . publish_configuration () try : while True : temperature = random ( 15 , 40 ) pressure = random ( 980 , 1020 ) humidity = random ( 20 , 70 ) acceleration = ( random ( 0 , 10 ), random ( 0 , 10 ), random ( 0 , 10 )) if humidity >= 60 : wolk . add_alarm ( \"HH\" , True ) else : wolk . add_alarm ( \"HH\" , False ) print ( \"Publishing readings\" + \" T: \" + str ( temperature ) + \" P: \" + str ( pressure ) + \" H: \" + str ( humidity ) + \" ACL: \" + str ( acceleration ) ) # Adds a sensor reading to the queue wolk . add_sensor_reading ( \"T\" , temperature ) wolk . add_sensor_reading ( \"P\" , pressure ) wolk . add_sensor_reading ( \"H\" , humidity ) wolk . add_sensor_reading ( \"ACL\" , acceleration ) # Publishes all stored sensor readings and alarms # from the queue to WolkAbout IoT Platform wolk . publish () sleep ( publish_period_milliseconds ) except Exception as e : print ( \"Something went wrong: \" , e )","title":"Examples"},{"location":"reference/libs/wolkabout/iot/docs/examples/#examples","text":"The following are a list of examples for lib.wolkabout.iot.","title":"Examples"},{"location":"reference/libs/wolkabout/iot/docs/examples/#controlled-publish-period","text":"Connects your device to the WolkAbout IoT Platform and publishes data at a default period. Sends random temperature sensor readings. Import Simple-example-deviceTemplate.json on the platform to be able to quickly create a device with this sensor. main.py # Copyright 2018 WolkAbout Technology s.r.o. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import streams from wolkabout.iot import iot from wireless import wifi # uncomment one of the following lines depending on used board(e.g. Particle Photon, esp8266 or esp32 based board) # from broadcom.bcm43362 import bcm43362 as wifi_driver # from espressif.esp32net import esp32wifi as wifi_driver # from espressif.esp8266wifi import esp8266wifi as wifi_driver from stm.spwf01sa import spwf01sa as wifi_driver # Insert your WiFi credentials network_SSID = \"INSERT_YOUR_WIFI_SSID\" network_SECURITY = wifi . WIFI_WPA2 # wifi.WIFI_OPEN , wifi.WIFI_WEP, wifi.WIFI_WPA, wifi.WIFI_WPA2 network_password = \"INSERT_YOUR_WIFI_PASSWORD\" # Insert the device credentials received from WolkAbout IoT Platform when creating the device device_key = \"device_key\" device_password = \"some_password\" publish_period_milliseconds = 5000 streams . serial () # Enable debug printing by setting flag to True iot . debug_mode = False # Connect to WiFi network try : print ( \"Initializing WiFi driver..\" ) # This setup refers to spwf01sa wi-fi chip mounted on flip n click device slot A # For other wi-fi chips auto_init method is available, wifi_driver.auto_init() wifi_driver . init ( SERIAL1 , D16 ) print ( \"Establishing connection with WiFi network...\" ) wifi . link ( network_SSID , network_SECURITY , network_password ) print ( \"Done\" ) except Exception as e : print ( \"Something went wrong while linking to WiFi network: \" , e ) try : device = iot . Device ( device_key , device_password ) except Exception as e : print ( \"Something went wrong while creating the device: \" , e ) try : wolk = iot . Wolk ( device ) except Exception as e : print ( \"Something went wrong while creating the Wolk instance: \" , e ) try : print ( \"Connecting to WolkAbout IoT Platform\" ) wolk . connect () print ( \"Done\" ) except Exception as e : print ( \"Something went wrong while connecting to the platform: \" , e ) try : while True : temperature = random ( 15 , 40 ) print ( \"Publishing sensor reading T: \" + str ( temperature ) + \" C\" ) # Adds a sensor reading to the queue wolk . add_sensor_reading ( \"T\" , temperature ) # Publishes all stored sensor readings from the queue to the WolkAbout IoT Platform wolk . publish () sleep ( publish_period_milliseconds ) except Exception as e : print ( \"Something went wrong: \" , e )","title":"Controlled publish period"},{"location":"reference/libs/wolkabout/iot/docs/examples/#full-feature-set","text":"Connects your device to the WolkAbout IoT Platform and publishes data at a default period. Sends random temperature, pressure, humidity, and accelerometer sensor readings. If the random humidity value exceeds 60, an alarm will be sent to the platform. Has a switch and slider actuator allowing controlling the state from the platform. Also includes four configuration options that are meant for managing device behavior. Import Full-example-deviceTemplate.json on the platform to be able to quickly create a device. main.py # Copyright 2018 WolkAbout Technology s.r.o. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import streams from wolkabout.iot import iot from wireless import wifi # uncomment one of the following lines depending on used board(e.g. Particle Photon, esp8266 or esp32 based board) # from broadcom.bcm43362 import bcm43362 as wifi_driver # from espressif.esp32net import esp32wifi as wifi_driver # from espressif.esp8266wifi import esp8266wifi as wifi_driver from stm.spwf01sa import spwf01sa as wifi_driver # Insert your WiFi credentials network_SSID = \"INSERT_YOUR_WIFI_SSID\" network_SECURITY = wifi . WIFI_WPA2 # wifi.WIFI_OPEN , wifi.WIFI_WEP, wifi.WIFI_WPA, wifi.WIFI_WPA2 network_password = \"INSERT_YOUR_WIFI_PASSWORD\" # Insert the device credentials received from WolkAbout IoT Platform when creating the device device_key = \"device_key\" device_password = \"some_password\" actuator_references = [ \"SW\" , \"SL\" ] publish_period_milliseconds = 5000 streams . serial () # Enable debug printing by setting flag to True iot . debug_mode = False class ActuatorSimulator : def __init__ ( self , value ): self . value = value switch_simulator = ActuatorSimulator ( False ) slider_simulator = ActuatorSimulator ( 0 ) class ActuatorStatusProviderImpl ( iot . ActuatorStatusProvider ): def get_actuator_status ( self , reference ): if reference == \"SW\" : return iot . ACTUATOR_STATE_READY , switch_simulator . value if reference == \"SL\" : return iot . ACTUATOR_STATE_READY , slider_simulator . value class ActuationHandlerImpl ( iot . ActuationHandler ): def handle_actuation ( self , reference , value ): if reference == \"SL\" : slider_simulator . value = value if reference == \"SW\" : switch_simulator . value = value class ConfigurationSimulator : def __init__ ( self , value ): self . value = value config1_simulator = ConfigurationSimulator ( 0 ) config2_simulator = ConfigurationSimulator ( False ) config3_simulator = ConfigurationSimulator ( \"\" ) config4_simulator = ConfigurationSimulator (( \"\" , \"\" , \"\" )) class ConfigurationProviderImpl ( iot . ConfigurationProvider ): def get_configuration ( self ): configurations = dict () configurations [ \"config_1\" ] = config1_simulator . value configurations [ \"config_2\" ] = config2_simulator . value configurations [ \"config_3\" ] = config3_simulator . value configurations [ \"config_4\" ] = config4_simulator . value return configurations class ConfigurationHandlerImpl ( iot . ConfigurationHandler ): def handle_configuration ( self , configuration ): for config_reference , config_value in configuration . items (): if config_reference == \"config_1\" : config1_simulator . value = config_value if config_reference == \"config_2\" : config2_simulator . value = config_value if config_reference == \"config_3\" : config3_simulator . value = config_value if config_reference == \"config_4\" : config4_simulator . value = config_value # Connect to WiFi network try : print ( \"Initializing WiFi driver..\" ) # This setup refers to spwf01sa wi-fi chip mounted on flip n click device slot A # For other wi-fi chips auto_init method is available, wifi_driver.auto_init() wifi_driver . init ( SERIAL1 , D16 ) print ( \"Establishing connection with WiFi network...\" ) wifi . link ( network_SSID , network_SECURITY , network_password ) print ( \"Done\" ) except Exception as e : print ( \"Something went wrong while linking to WiFi network: \" , e ) try : device = iot . Device ( device_key , device_password , actuator_references ) except Exception as e : print ( \"Something went wrong while creating the device: \" , e ) try : wolk = iot . Wolk ( device , host = \"api-demo.wolkabout.com\" , port = 1883 , actuation_handler = ActuationHandlerImpl (), actuator_status_provider = ActuatorStatusProviderImpl (), outbound_message_queue = iot . ZerynthOutboundMessageQueue ( 200 ), configuration_handler = ConfigurationHandlerImpl (), configuration_provider = ConfigurationProviderImpl (), ) except Exception as e : print ( \"Something went wrong while creating the Wolk instance: \" , e ) try : print ( \"Connecting to WolkAbout IoT Platform\" ) wolk . connect () print ( \"Done\" ) except Exception as e : print ( \"Something went wrong while connecting to the platform: \" , e ) # Initial state of actuators and configuration must be delivered to the platform # in order to be able to change their values from the platform wolk . publish_actuator_status ( \"SW\" ) wolk . publish_actuator_status ( \"SL\" ) wolk . publish_configuration () try : while True : temperature = random ( 15 , 40 ) pressure = random ( 980 , 1020 ) humidity = random ( 20 , 70 ) acceleration = ( random ( 0 , 10 ), random ( 0 , 10 ), random ( 0 , 10 )) if humidity >= 60 : wolk . add_alarm ( \"HH\" , True ) else : wolk . add_alarm ( \"HH\" , False ) print ( \"Publishing readings\" + \" T: \" + str ( temperature ) + \" P: \" + str ( pressure ) + \" H: \" + str ( humidity ) + \" ACL: \" + str ( acceleration ) ) # Adds a sensor reading to the queue wolk . add_sensor_reading ( \"T\" , temperature ) wolk . add_sensor_reading ( \"P\" , pressure ) wolk . add_sensor_reading ( \"H\" , humidity ) wolk . add_sensor_reading ( \"ACL\" , acceleration ) # Publishes all stored sensor readings and alarms # from the queue to WolkAbout IoT Platform wolk . publish () sleep ( publish_period_milliseconds ) except Exception as e : print ( \"Something went wrong: \" , e )","title":"Full feature set"},{"location":"reference/libs/wolkabout/iot/docs/iot/","text":"WolkAbout IoT Platform Library \u00b6 WolkAbout Python Connector library for connecting Zerynth devices to WolkAbout IoT Platform . The Wolk class depends upon interfaces, making it possible to provide different implementations. The section Dependencies contains the documentation of the default implementations, followed by the Wolk section that contains everything necessary to connect and publish data to the WolkAbout IoT Platform. Dependencies \u00b6 The following classes are implementations of interfaces on which the Wolk class depends. MQTT Connectivity Service \u00b6 class ZerynthMQTTConnectivityService \u00b6 class ZerynthMQTTConnectivityService ( ConnectivityService . ConnectivityService ) This class provides the connection to the WolkAbout IoT Platform by implementing the ConnectivityService interface. device : Contains device key, device password and actuator references host : Address of the WolkAbout IoT Platform instance port : Port of WolkAbout IoT Platform instance qos : Quality of Service for MQTT connection (0,1,2), defaults to 0 ZerynthMQTTConnectivityService.set_inbound_message_listener \u00b6 set_inbound_message_listener ( on_inbound_message ) Sets the callback method to handle inbound messages. on_inbound_message : The method that handles inbound messages ZerynthMQTTConnectivityService.on_mqtt_message \u00b6 on_mqtt_message ( client , data ) Method that serializes inbound messages and passes them to the inbound message listener. client : The client that received the message data : The message received ZerynthMQTTConnectivityService.connect \u00b6 connect () This method establishes the connection to the WolkAbout IoT platform. If there are actuators it will subscribe to topics that will contain actuator commands and also starts a loop to handle inbound messages. Raises an exception if the connection failed. ZerynthMQTTConnectivityService.disconnect \u00b6 disconnect () Disconnects the device from the WolkAbout IoT Platform. ZerynthMQTTConnectivityService.connected \u00b6 connected () Returns the current status of the connection. ZerynthMQTTConnectivityService.publish \u00b6 publish ( outbound_message ) Publishes the outbound_message to the WolkAbout IoT Platform. Outbound Message Queue \u00b6 class ZerynthOutboundMessageQueue \u00b6 class ZerynthOutboundMessageQueue ( OutboundMessageQueue . OutboundMessageQueue ) This class provides the means of storing messages before they are sent to the WolkAbout IoT Platform. maxsize : Int - The maximum size of the queue, effectively limiting the number of messages to persist in memory. ZerynthOutboundMessageQueue.put \u00b6 put ( message ) Adds the message to self.queue . ZerynthOutboundMessageQueue.get \u00b6 get () Takes the first message from self.queue . ZerynthOutboundMessageQueue.peek \u00b6 peek () Returns the first message from self.queue without removing it from the queue. Outbound Message Factory \u00b6 class ZerynthOutboundMessageFactory \u00b6 class ZerynthOutboundMessageFactory ( OutboundMessageFactory . OutboundMessageFactory ) This class serializes sensor readings, alarms and actuator statuses so that they can be properly sent to the WolkAbout IoT Platform. device_key - The key used to serialize messages. ZerynthOutboundMessageFactory.make_from_sensor_reading \u00b6 make_from_sensor_reading ( reading ) Serializes the reading to be sent to the WolkAbout IoT Platform. reading : Sensor reading to be serialized. ZerynthOutboundMessageFactory.make_from_alarm \u00b6 make_from_alarm ( alarm ) Serializes the alarm to be sent to the WolkAbout IoT Platform. alarm : Alarm event to be serialized. ZerynthOutboundMessageFactory.make_from_actuator_status \u00b6 make_from_actuator_status ( actuator ) Serializes the actuator to be sent to the WolkAbout IoT . actuator : Actuator status to be serialized. ZerynthOutboundMessageFactory.make_from_configuration \u00b6 make_from_configuration ( self , configuration ) Serializes the device\u2019s configuration to be sent to the platform. configuration : Configuration to be serialized. Inbound Message Factory \u00b6 class ZerynthInboundMessageDeserializer \u00b6 class ZerynthInboundMessageDeserializer ( InboundMessageDeserializer . InboundMessageDeserializer ) This class deserializes messages that the device receives from the WolkAbout IoT Platform from the topics it is subscribed to. ZerynthInboundMessageDeserializer.deserialize_actuator_command \u00b6 deserialize_actuator_command ( message ) Deserializes the message that was received from the WolkAbout IoT Platform. message : The message to be deserialized. ZerynthInboundMessageDeserializer.deserialize_configuration_command \u00b6 deserialize_configuration_command ( message ) Deserializes the message that was received from the WolkAbout IoT Platform. message The message to be deserialized. Wolk class \u00b6 class Wolk \u00b6 class Wolk () This class is a wrapper for the WolkCore class that passes the Zerynth compatible implementation of interfaces to the constructor device : Contains device key and password, and actuator references host : The address of the WolkAbout IoT Platform, defaults to the Demo instance port : The port to which to send messages, defaults to 1883 actuation_handler : Implementation of the ActuationHandler interface actuator_status_provider : Implementation of the ActuatorStatusProvider interface outbound_message_queue : Implementation of the OutboundMessageQueue interface configuration_handler : Implementation of the ConfigurationHandler interface configuration_provider : Implementation of the ConfigurationProvider interface Wolk.connect \u00b6 connect () Connects the device to the WolkAbout IoT Platform by calling the provided connectivity_service\u2019s connect method. Wolk.disconnect \u00b6 disconnect () Disconnects the device from the WolkAbout IoT Platform by calling the provided connectivity_service\u2019s disconnect method. Wolk.add_sensor_reading \u00b6 add_sensor_reading ( reference , value , timestamp = None ) Publish a sensor reading to the platform. reference : String - The reference of the sensor value : Int, Float - The value of the sensor reading timestamp : (optional) Unix timestamp - if not provided, platform will assign one upon reception Wolk.add_alarm \u00b6 add_alarm ( reference , active , timestamp = None ) Publish an alarm to the platform reference : String - The reference of the alarm active : Bool - Current state of the alarm timestamp : (optional) Unix timestamp - if not provided, platform will assign one upon reception Wolk.publish \u00b6 publish () Publishes all currently stored messages and current actuator statuses to the platform. Wolk.publish_actuator_status \u00b6 publish_actuator_status ( reference ) Publish the current actuator status to the platform. reference : String - The reference of the actuator. Wolk._on_inbound_message \u00b6 _on_inbound_message ( message ) Callback method to handle inbound messages. Note Pass this method to the implementation of ConnectivityService interface. message : The message received from the platform. Wolk.publish_configuration \u00b6 publish_configuration () Publishes the current device configuration to the platform. Device \u00b6 class Device \u00b6 class Device () The Device class contains all the required information for connecting to the WolkAbout IoT Platform. key - The device key obtained when creating the device on WolkAbout IoT platform password - The device password obtained when creating the device on WolkAbout IoT platform actuator_references - A list of actuator references defined in the device template on WolkAbout IoT Platform Actuation Handler \u00b6 class .ActuationHandler \u00b6 class ActuationHandler () This interface must be implemented in order to execute actuation commands issued from WolkAbout IoT Platform. ActuationHandler.handle_actuation \u00b6 handle_actuation ( reference , value ) This method will try to set the actuator, identified by reference , to the value specified by WolkAbout IoT Platform. Actuator Status Provider \u00b6 class ActuatorStatusProvider \u00b6 class ActuatorStatusProvider () This interface must be implemented in order to provide information about the current status of the actuator to the WolkAbout IoT Platform. ActuatorStatusProvider.get_actuator_status \u00b6 get_actuator_status ( reference ) This method will return the current actuator state and value , identified by reference , to the WolkAbout IoT Platform. The possible states are: iot . ACTUATOR_STATE_READY iot . ACTUATOR_STATE_BUSY iot . ACTUATOR_STATE_ERROR The method should return something like this: return ( iot . ACTUATOR_STATE_READY , value ) Configuration Handler \u00b6 class ConfigurationHandler \u00b6 class ConfigurationHandler () This interface must be implemented in order to handle configuration commands issued from WolkAbout IoT Platform. ConfigurationHandler.handle_configuration \u00b6 handle_configuration ( configuration ) This method should update device configuration with received configuration values. configuration - Dictionary that containes reference:value pairs. Configuration Provider \u00b6 class ConfigurationProvider \u00b6 class ConfigurationProvider () This interface must be implemented to provide information about the current configuration settings to the WolkAbout IoT Platform. ConfigurationProvider.get_configuration \u00b6 get_configuration () Reads current device configuration and returns it as a dictionary with device configuration reference as the key, and device configuration value as the value.","title":"WolkAbout IoT Platform Library"},{"location":"reference/libs/wolkabout/iot/docs/iot/#wolkabout-iot-platform-library","text":"WolkAbout Python Connector library for connecting Zerynth devices to WolkAbout IoT Platform . The Wolk class depends upon interfaces, making it possible to provide different implementations. The section Dependencies contains the documentation of the default implementations, followed by the Wolk section that contains everything necessary to connect and publish data to the WolkAbout IoT Platform.","title":"WolkAbout IoT Platform Library"},{"location":"reference/libs/wolkabout/iot/docs/iot/#dependencies","text":"The following classes are implementations of interfaces on which the Wolk class depends.","title":"Dependencies"},{"location":"reference/libs/wolkabout/iot/docs/iot/#mqtt-connectivity-service","text":"","title":"MQTT Connectivity Service"},{"location":"reference/libs/wolkabout/iot/docs/iot/#class-zerynthmqttconnectivityservice","text":"class ZerynthMQTTConnectivityService ( ConnectivityService . ConnectivityService ) This class provides the connection to the WolkAbout IoT Platform by implementing the ConnectivityService interface. device : Contains device key, device password and actuator references host : Address of the WolkAbout IoT Platform instance port : Port of WolkAbout IoT Platform instance qos : Quality of Service for MQTT connection (0,1,2), defaults to 0","title":"class ZerynthMQTTConnectivityService"},{"location":"reference/libs/wolkabout/iot/docs/iot/#zerynthmqttconnectivityserviceset_inbound_message_listener","text":"set_inbound_message_listener ( on_inbound_message ) Sets the callback method to handle inbound messages. on_inbound_message : The method that handles inbound messages","title":"ZerynthMQTTConnectivityService.set_inbound_message_listener"},{"location":"reference/libs/wolkabout/iot/docs/iot/#zerynthmqttconnectivityserviceon_mqtt_message","text":"on_mqtt_message ( client , data ) Method that serializes inbound messages and passes them to the inbound message listener. client : The client that received the message data : The message received","title":"ZerynthMQTTConnectivityService.on_mqtt_message"},{"location":"reference/libs/wolkabout/iot/docs/iot/#zerynthmqttconnectivityserviceconnect","text":"connect () This method establishes the connection to the WolkAbout IoT platform. If there are actuators it will subscribe to topics that will contain actuator commands and also starts a loop to handle inbound messages. Raises an exception if the connection failed.","title":"ZerynthMQTTConnectivityService.connect"},{"location":"reference/libs/wolkabout/iot/docs/iot/#zerynthmqttconnectivityservicedisconnect","text":"disconnect () Disconnects the device from the WolkAbout IoT Platform.","title":"ZerynthMQTTConnectivityService.disconnect"},{"location":"reference/libs/wolkabout/iot/docs/iot/#zerynthmqttconnectivityserviceconnected","text":"connected () Returns the current status of the connection.","title":"ZerynthMQTTConnectivityService.connected"},{"location":"reference/libs/wolkabout/iot/docs/iot/#zerynthmqttconnectivityservicepublish","text":"publish ( outbound_message ) Publishes the outbound_message to the WolkAbout IoT Platform.","title":"ZerynthMQTTConnectivityService.publish"},{"location":"reference/libs/wolkabout/iot/docs/iot/#outbound-message-queue","text":"","title":"Outbound Message Queue"},{"location":"reference/libs/wolkabout/iot/docs/iot/#class-zerynthoutboundmessagequeue","text":"class ZerynthOutboundMessageQueue ( OutboundMessageQueue . OutboundMessageQueue ) This class provides the means of storing messages before they are sent to the WolkAbout IoT Platform. maxsize : Int - The maximum size of the queue, effectively limiting the number of messages to persist in memory.","title":"class ZerynthOutboundMessageQueue"},{"location":"reference/libs/wolkabout/iot/docs/iot/#zerynthoutboundmessagequeueput","text":"put ( message ) Adds the message to self.queue .","title":"ZerynthOutboundMessageQueue.put"},{"location":"reference/libs/wolkabout/iot/docs/iot/#zerynthoutboundmessagequeueget","text":"get () Takes the first message from self.queue .","title":"ZerynthOutboundMessageQueue.get"},{"location":"reference/libs/wolkabout/iot/docs/iot/#zerynthoutboundmessagequeuepeek","text":"peek () Returns the first message from self.queue without removing it from the queue.","title":"ZerynthOutboundMessageQueue.peek"},{"location":"reference/libs/wolkabout/iot/docs/iot/#outbound-message-factory","text":"","title":"Outbound Message Factory"},{"location":"reference/libs/wolkabout/iot/docs/iot/#class-zerynthoutboundmessagefactory","text":"class ZerynthOutboundMessageFactory ( OutboundMessageFactory . OutboundMessageFactory ) This class serializes sensor readings, alarms and actuator statuses so that they can be properly sent to the WolkAbout IoT Platform. device_key - The key used to serialize messages.","title":"class ZerynthOutboundMessageFactory"},{"location":"reference/libs/wolkabout/iot/docs/iot/#zerynthoutboundmessagefactorymake_from_sensor_reading","text":"make_from_sensor_reading ( reading ) Serializes the reading to be sent to the WolkAbout IoT Platform. reading : Sensor reading to be serialized.","title":"ZerynthOutboundMessageFactory.make_from_sensor_reading"},{"location":"reference/libs/wolkabout/iot/docs/iot/#zerynthoutboundmessagefactorymake_from_alarm","text":"make_from_alarm ( alarm ) Serializes the alarm to be sent to the WolkAbout IoT Platform. alarm : Alarm event to be serialized.","title":"ZerynthOutboundMessageFactory.make_from_alarm"},{"location":"reference/libs/wolkabout/iot/docs/iot/#zerynthoutboundmessagefactorymake_from_actuator_status","text":"make_from_actuator_status ( actuator ) Serializes the actuator to be sent to the WolkAbout IoT . actuator : Actuator status to be serialized.","title":"ZerynthOutboundMessageFactory.make_from_actuator_status"},{"location":"reference/libs/wolkabout/iot/docs/iot/#zerynthoutboundmessagefactorymake_from_configuration","text":"make_from_configuration ( self , configuration ) Serializes the device\u2019s configuration to be sent to the platform. configuration : Configuration to be serialized.","title":"ZerynthOutboundMessageFactory.make_from_configuration"},{"location":"reference/libs/wolkabout/iot/docs/iot/#inbound-message-factory","text":"","title":"Inbound Message Factory"},{"location":"reference/libs/wolkabout/iot/docs/iot/#class-zerynthinboundmessagedeserializer","text":"class ZerynthInboundMessageDeserializer ( InboundMessageDeserializer . InboundMessageDeserializer ) This class deserializes messages that the device receives from the WolkAbout IoT Platform from the topics it is subscribed to.","title":"class ZerynthInboundMessageDeserializer"},{"location":"reference/libs/wolkabout/iot/docs/iot/#zerynthinboundmessagedeserializerdeserialize_actuator_command","text":"deserialize_actuator_command ( message ) Deserializes the message that was received from the WolkAbout IoT Platform. message : The message to be deserialized.","title":"ZerynthInboundMessageDeserializer.deserialize_actuator_command"},{"location":"reference/libs/wolkabout/iot/docs/iot/#zerynthinboundmessagedeserializerdeserialize_configuration_command","text":"deserialize_configuration_command ( message ) Deserializes the message that was received from the WolkAbout IoT Platform. message The message to be deserialized.","title":"ZerynthInboundMessageDeserializer.deserialize_configuration_command"},{"location":"reference/libs/wolkabout/iot/docs/iot/#wolk-class","text":"","title":"Wolk class"},{"location":"reference/libs/wolkabout/iot/docs/iot/#class-wolk","text":"class Wolk () This class is a wrapper for the WolkCore class that passes the Zerynth compatible implementation of interfaces to the constructor device : Contains device key and password, and actuator references host : The address of the WolkAbout IoT Platform, defaults to the Demo instance port : The port to which to send messages, defaults to 1883 actuation_handler : Implementation of the ActuationHandler interface actuator_status_provider : Implementation of the ActuatorStatusProvider interface outbound_message_queue : Implementation of the OutboundMessageQueue interface configuration_handler : Implementation of the ConfigurationHandler interface configuration_provider : Implementation of the ConfigurationProvider interface","title":"class Wolk"},{"location":"reference/libs/wolkabout/iot/docs/iot/#wolkconnect","text":"connect () Connects the device to the WolkAbout IoT Platform by calling the provided connectivity_service\u2019s connect method.","title":"Wolk.connect"},{"location":"reference/libs/wolkabout/iot/docs/iot/#wolkdisconnect","text":"disconnect () Disconnects the device from the WolkAbout IoT Platform by calling the provided connectivity_service\u2019s disconnect method.","title":"Wolk.disconnect"},{"location":"reference/libs/wolkabout/iot/docs/iot/#wolkadd_sensor_reading","text":"add_sensor_reading ( reference , value , timestamp = None ) Publish a sensor reading to the platform. reference : String - The reference of the sensor value : Int, Float - The value of the sensor reading timestamp : (optional) Unix timestamp - if not provided, platform will assign one upon reception","title":"Wolk.add_sensor_reading"},{"location":"reference/libs/wolkabout/iot/docs/iot/#wolkadd_alarm","text":"add_alarm ( reference , active , timestamp = None ) Publish an alarm to the platform reference : String - The reference of the alarm active : Bool - Current state of the alarm timestamp : (optional) Unix timestamp - if not provided, platform will assign one upon reception","title":"Wolk.add_alarm"},{"location":"reference/libs/wolkabout/iot/docs/iot/#wolkpublish","text":"publish () Publishes all currently stored messages and current actuator statuses to the platform.","title":"Wolk.publish"},{"location":"reference/libs/wolkabout/iot/docs/iot/#wolkpublish_actuator_status","text":"publish_actuator_status ( reference ) Publish the current actuator status to the platform. reference : String - The reference of the actuator.","title":"Wolk.publish_actuator_status"},{"location":"reference/libs/wolkabout/iot/docs/iot/#wolk_on_inbound_message","text":"_on_inbound_message ( message ) Callback method to handle inbound messages. Note Pass this method to the implementation of ConnectivityService interface. message : The message received from the platform.","title":"Wolk._on_inbound_message"},{"location":"reference/libs/wolkabout/iot/docs/iot/#wolkpublish_configuration","text":"publish_configuration () Publishes the current device configuration to the platform.","title":"Wolk.publish_configuration"},{"location":"reference/libs/wolkabout/iot/docs/iot/#device","text":"","title":"Device"},{"location":"reference/libs/wolkabout/iot/docs/iot/#class-device","text":"class Device () The Device class contains all the required information for connecting to the WolkAbout IoT Platform. key - The device key obtained when creating the device on WolkAbout IoT platform password - The device password obtained when creating the device on WolkAbout IoT platform actuator_references - A list of actuator references defined in the device template on WolkAbout IoT Platform","title":"class Device"},{"location":"reference/libs/wolkabout/iot/docs/iot/#actuation-handler","text":"","title":"Actuation Handler"},{"location":"reference/libs/wolkabout/iot/docs/iot/#class-actuationhandler","text":"class ActuationHandler () This interface must be implemented in order to execute actuation commands issued from WolkAbout IoT Platform.","title":"class .ActuationHandler"},{"location":"reference/libs/wolkabout/iot/docs/iot/#actuationhandlerhandle_actuation","text":"handle_actuation ( reference , value ) This method will try to set the actuator, identified by reference , to the value specified by WolkAbout IoT Platform.","title":"ActuationHandler.handle_actuation"},{"location":"reference/libs/wolkabout/iot/docs/iot/#actuator-status-provider","text":"","title":"Actuator Status Provider"},{"location":"reference/libs/wolkabout/iot/docs/iot/#class-actuatorstatusprovider","text":"class ActuatorStatusProvider () This interface must be implemented in order to provide information about the current status of the actuator to the WolkAbout IoT Platform.","title":"class ActuatorStatusProvider"},{"location":"reference/libs/wolkabout/iot/docs/iot/#actuatorstatusproviderget_actuator_status","text":"get_actuator_status ( reference ) This method will return the current actuator state and value , identified by reference , to the WolkAbout IoT Platform. The possible states are: iot . ACTUATOR_STATE_READY iot . ACTUATOR_STATE_BUSY iot . ACTUATOR_STATE_ERROR The method should return something like this: return ( iot . ACTUATOR_STATE_READY , value )","title":"ActuatorStatusProvider.get_actuator_status"},{"location":"reference/libs/wolkabout/iot/docs/iot/#configuration-handler","text":"","title":"Configuration Handler"},{"location":"reference/libs/wolkabout/iot/docs/iot/#class-configurationhandler","text":"class ConfigurationHandler () This interface must be implemented in order to handle configuration commands issued from WolkAbout IoT Platform.","title":"class ConfigurationHandler"},{"location":"reference/libs/wolkabout/iot/docs/iot/#configurationhandlerhandle_configuration","text":"handle_configuration ( configuration ) This method should update device configuration with received configuration values. configuration - Dictionary that containes reference:value pairs.","title":"ConfigurationHandler.handle_configuration"},{"location":"reference/libs/wolkabout/iot/docs/iot/#configuration-provider","text":"","title":"Configuration Provider"},{"location":"reference/libs/wolkabout/iot/docs/iot/#class-configurationprovider","text":"class ConfigurationProvider () This interface must be implemented to provide information about the current configuration settings to the WolkAbout IoT Platform.","title":"class ConfigurationProvider"},{"location":"reference/libs/wolkabout/iot/docs/iot/#configurationproviderget_configuration","text":"get_configuration () Reads current device configuration and returns it as a dictionary with device configuration reference as the key, and device configuration value as the value.","title":"ConfigurationProvider.get_configuration"},{"location":"reference/libs/worldsemi/ws2812/docs/","text":"Worldsemi WS2812 RGB LEDs \u00b6 The Worldsemi WS2812 Integrated Light Source \u2014 or NeoPixel in Adafruit parlance \u2014 is the latest advance in the quest for a simple, scalable and affordable full-color LED. RGB LEDs are integrated alongside a driver chip into a tiny surface-mount package piloted through a single-wire control protocol. They can be used individually, chained into longer strings or assembled into still more interesting form-factors; some product example can be found at Adafruit dedicated page . Technical Details (for single WS2812 RGB LED) \u00b6 Power Supply Voltage (Vdd): from 4.5 V to 5.5 V Input Voltage (Vi): from -0.5V to Vdd+0.5 V Operation Temperature: from -25 \u00b0C to 80 \u00b0C Data Transmission Rate: 400 Kbps (duty ratio 50%) LED Characteristic Parameter Emitting Color Wavelenght (nm) Current (mA) Voltage (V) Red 620-630 20 1.8-2.2 Green 515-530 20 3.0-3.2 Blue 465-475 20 3.2-3.4 Here below, the Zerynth driver for the Worldsemi WS2812 led strips and some examples to better understand how to use them. Contents: WS2812 RGB Led Module LedStrip class Examples LED Strips LED Strips Advanced","title":"Worldsemi WS2812 RGB LEDs"},{"location":"reference/libs/worldsemi/ws2812/docs/#worldsemi-ws2812-rgb-leds","text":"The Worldsemi WS2812 Integrated Light Source \u2014 or NeoPixel in Adafruit parlance \u2014 is the latest advance in the quest for a simple, scalable and affordable full-color LED. RGB LEDs are integrated alongside a driver chip into a tiny surface-mount package piloted through a single-wire control protocol. They can be used individually, chained into longer strings or assembled into still more interesting form-factors; some product example can be found at Adafruit dedicated page .","title":"Worldsemi WS2812 RGB LEDs"},{"location":"reference/libs/worldsemi/ws2812/docs/#technical-details-for-single-ws2812-rgb-led","text":"Power Supply Voltage (Vdd): from 4.5 V to 5.5 V Input Voltage (Vi): from -0.5V to Vdd+0.5 V Operation Temperature: from -25 \u00b0C to 80 \u00b0C Data Transmission Rate: 400 Kbps (duty ratio 50%) LED Characteristic Parameter Emitting Color Wavelenght (nm) Current (mA) Voltage (V) Red 620-630 20 1.8-2.2 Green 515-530 20 3.0-3.2 Blue 465-475 20 3.2-3.4 Here below, the Zerynth driver for the Worldsemi WS2812 led strips and some examples to better understand how to use them. Contents: WS2812 RGB Led Module LedStrip class Examples LED Strips LED Strips Advanced","title":"Technical Details (for single WS2812 RGB LED)"},{"location":"reference/libs/worldsemi/ws2812/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.worldsemi.ws2812. WS2812 RGB LEDs strip Basics and Animations \u00b6 A simple example that shows how a button is used to change the colour of a WS2812 RGB LEDs strip \u2014 or NeoPixel in Adafruit parlance \u2014 and how a simple fade-like animation is played on the LEDs. main.py ################################################################################ # WS2812 LED Strips # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ # Be sure to open the serial console, otherwise the program will halt if the console buffer is full. import streams from worldsemi.ws2812 import ledstrips as pixel streams . serial () num_leds = 16 # adjust this to match the number of LEDs on your strip led_pin = D9 # this should match the data pin of the LED strip switch_pin = D2 # this should match the pin to which the button is connected leds = pixel . LedStrip ( led_pin , num_leds ) # create a new WS2812 RGB LED strip composed of <num_leds> LEDs and connected to pin led_pin leds . set_fading ( 100 , 0 , 0 ) # create a fade effect that starts from red=100 and goes to RGB=0,0,0 # along all the available strip LEDs. This is a static setup of the LEDs pos = 0 def touch (): #function to be called when a button is touched r = random ( 20 , 100 ) # choose a random colour for RED g = random ( 20 , 100 ) # choose a random colour for GREEN b = random ( 20 , 100 ) # choose a random colour for BLUE print ( r , g , b ) leds . set_fading ( r , g , b , num_leds - 1 - pos ) # attach a button to pin <switch_pin> and set an interrupt to call the touched function. The button should connect the pin to Vcc. pinMode ( switch_pin , INPUT_PULLDOWN ) onPinRise ( switch_pin , touch ) while True : leds . on () # refresh the LEDs colour imposed by the animation leds . lshift () # shift the LED colours of one position towards pos = ( pos + 1 ) % num_leds sleep ( 500 ) LED Strips Advanced \u00b6 An advanced example showing some awesome features of Zerynth and the ledstrip module to drive WS2812 RGB Led strip \u2014 or NeoPixel in Adafruit parlance. A complex animation (a pulsating background and two \"snakes\" moving in opposing directions) is performed with indipendent layers animated by threads. Before any ledstrip update (the on() function) the layers are merged together to obtain the correct animation frame. To avoid conflicts between threads, a lock is needed during layer modification phase. main.py ################################################################################ # WS2812 LED Strips Advanced # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import threading from worldsemi.ws2812 import ledstrips as pixel # create all the needed layers leds = pixel . LedStrip ( D6 , 16 ) layer0 = pixel . LedStrip ( D6 , 16 ) layer1 = pixel . LedStrip ( D6 , 16 ) layer2 = pixel . LedStrip ( D6 , 16 ) # fill layers with their initial values leds . clear () layer0 [ 0 ] = ( 100 , 0 , 0 ) layer0 [ 1 ] = ( 100 , 0 , 0 ) layer0 [ 2 ] = ( 100 , 0 , 0 ) layer1 [ 0 ] = ( 0 , 100 , 0 ) layer1 [ 1 ] = ( 0 , 100 , 0 ) layer1 [ 2 ] = ( 0 , 100 , 0 ) layer2 . clear () # let's define some coefficients for smooth animation (half a sinus wave) animation_coefficients = [ 0 , 0.2588190451 , 0.5 , 0.7071067812 , 0.8660254038 , 0.9659258263 , 1 , 0.9659258263 , 0.8660254038 , 0.7071067812 , 0.5 , 0.2588190451 ] # A Lock is needed to prevent conflicts between threads lock = threading . Lock () # Create a function to handle background animation def animate_background ( delay ): step = 0 while True : lock . acquire () layer2 . setall ( 0 , 0 , int ( 50 * animation_coefficients [ step ])) lock . release () step += 1 if step >= len ( animation_coefficients ): step = 0 sleep ( delay ) def animate_foreground ( delay ): while True : lock . acquire () layer0 . lshift () layer1 . rshift () lock . release () sleep ( delay ) # start the background animation thread thread ( animate_background , 500 ) # start the foreground animation thread thread ( animate_foreground , 50 ) while True : # clear leds leds . clear () # now, acquire the lock lock . acquire () # merge the first and second layer leds . merge ( layer0 ) leds . merge ( layer1 ) # merge the background layer only where leds is transparent (0,0,0) leds . merge ( layer2 , pixel . first_color ) # release the lock lock . release () # and light it up! leds . on () sleep ( 10 )","title":"Examples"},{"location":"reference/libs/worldsemi/ws2812/docs/examples/#examples","text":"The following are a list of examples for lib.worldsemi.ws2812.","title":"Examples"},{"location":"reference/libs/worldsemi/ws2812/docs/examples/#ws2812-rgb-leds-strip-basics-and-animations","text":"A simple example that shows how a button is used to change the colour of a WS2812 RGB LEDs strip \u2014 or NeoPixel in Adafruit parlance \u2014 and how a simple fade-like animation is played on the LEDs. main.py ################################################################################ # WS2812 LED Strips # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ # Be sure to open the serial console, otherwise the program will halt if the console buffer is full. import streams from worldsemi.ws2812 import ledstrips as pixel streams . serial () num_leds = 16 # adjust this to match the number of LEDs on your strip led_pin = D9 # this should match the data pin of the LED strip switch_pin = D2 # this should match the pin to which the button is connected leds = pixel . LedStrip ( led_pin , num_leds ) # create a new WS2812 RGB LED strip composed of <num_leds> LEDs and connected to pin led_pin leds . set_fading ( 100 , 0 , 0 ) # create a fade effect that starts from red=100 and goes to RGB=0,0,0 # along all the available strip LEDs. This is a static setup of the LEDs pos = 0 def touch (): #function to be called when a button is touched r = random ( 20 , 100 ) # choose a random colour for RED g = random ( 20 , 100 ) # choose a random colour for GREEN b = random ( 20 , 100 ) # choose a random colour for BLUE print ( r , g , b ) leds . set_fading ( r , g , b , num_leds - 1 - pos ) # attach a button to pin <switch_pin> and set an interrupt to call the touched function. The button should connect the pin to Vcc. pinMode ( switch_pin , INPUT_PULLDOWN ) onPinRise ( switch_pin , touch ) while True : leds . on () # refresh the LEDs colour imposed by the animation leds . lshift () # shift the LED colours of one position towards pos = ( pos + 1 ) % num_leds sleep ( 500 )","title":"WS2812 RGB LEDs strip Basics and Animations"},{"location":"reference/libs/worldsemi/ws2812/docs/examples/#led-strips-advanced","text":"An advanced example showing some awesome features of Zerynth and the ledstrip module to drive WS2812 RGB Led strip \u2014 or NeoPixel in Adafruit parlance. A complex animation (a pulsating background and two \"snakes\" moving in opposing directions) is performed with indipendent layers animated by threads. Before any ledstrip update (the on() function) the layers are merged together to obtain the correct animation frame. To avoid conflicts between threads, a lock is needed during layer modification phase. main.py ################################################################################ # WS2812 LED Strips Advanced # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ import threading from worldsemi.ws2812 import ledstrips as pixel # create all the needed layers leds = pixel . LedStrip ( D6 , 16 ) layer0 = pixel . LedStrip ( D6 , 16 ) layer1 = pixel . LedStrip ( D6 , 16 ) layer2 = pixel . LedStrip ( D6 , 16 ) # fill layers with their initial values leds . clear () layer0 [ 0 ] = ( 100 , 0 , 0 ) layer0 [ 1 ] = ( 100 , 0 , 0 ) layer0 [ 2 ] = ( 100 , 0 , 0 ) layer1 [ 0 ] = ( 0 , 100 , 0 ) layer1 [ 1 ] = ( 0 , 100 , 0 ) layer1 [ 2 ] = ( 0 , 100 , 0 ) layer2 . clear () # let's define some coefficients for smooth animation (half a sinus wave) animation_coefficients = [ 0 , 0.2588190451 , 0.5 , 0.7071067812 , 0.8660254038 , 0.9659258263 , 1 , 0.9659258263 , 0.8660254038 , 0.7071067812 , 0.5 , 0.2588190451 ] # A Lock is needed to prevent conflicts between threads lock = threading . Lock () # Create a function to handle background animation def animate_background ( delay ): step = 0 while True : lock . acquire () layer2 . setall ( 0 , 0 , int ( 50 * animation_coefficients [ step ])) lock . release () step += 1 if step >= len ( animation_coefficients ): step = 0 sleep ( delay ) def animate_foreground ( delay ): while True : lock . acquire () layer0 . lshift () layer1 . rshift () lock . release () sleep ( delay ) # start the background animation thread thread ( animate_background , 500 ) # start the foreground animation thread thread ( animate_foreground , 50 ) while True : # clear leds leds . clear () # now, acquire the lock lock . acquire () # merge the first and second layer leds . merge ( layer0 ) leds . merge ( layer1 ) # merge the background layer only where leds is transparent (0,0,0) leds . merge ( layer2 , pixel . first_color ) # release the lock lock . release () # and light it up! leds . on () sleep ( 10 )","title":"LED Strips Advanced"},{"location":"reference/libs/worldsemi/ws2812/docs/ledstrips/","text":"WS2812 RGB Led Module \u00b6 This module implements the Zerynth driver for the Worldsemi WS2812 Intelligent Control RGB Led assembled in any form, ledstrip, or ring. ( datasheet ). add_color \u00b6 add_color ( r1 , g1 , b1 , r2 , g2 , b2 ) Returns a tuple (r,g,b) where r=r1+r2, g=g1+g2, b=b1+b2. In case of overflow, components are capped to 255 first_color \u00b6 first_color ( r1 , g1 , b1 , r2 , g2 , b2 ) Always returns (r1,g1,b1) unless all the components are zero. In that case it returns (r2,g2,b2) second_color \u00b6 second_color ( r1 , g1 , b1 , r2 , g2 , b2 ) Always returns (r2,g2,b2) unless all the components are zero. In that case it returns (r1,g1,b1) LedStrip class \u00b6 class LedStrip \u00b6 class LedStrip ( pin , nleds ) This class abstracts a ledstrip. It needs to know which pin the ledstrip is wired to and how many leds it is composed of ( nleds ). The pin is automatically set to the correct mode and initially set to zero. on \u00b6 on () Turns on the ledstrip, colouring each led with the configuration set with methods like set() . set \u00b6 set ( n , r , g , b ) Sets the nth led of the strip to the r , g , b color specified. The led will change color only after the next call to on() . An equivalent and valid syntax is ledstrip[n]=(r,g,b). setall \u00b6 setall ( r , g , b ) Sets all the leds of the strip to the r , g , b color specified. The led will change color only after the next call to on() . clear \u00b6 clear () Sets all the leds of the strip to off. The leds will turn off after the next call to on() . lshift \u00b6 lshift () Shifts to the left all the leds by one. The leds will change color only after the next call to on() . rshift \u00b6 rshift () Shifts to the right all the leds by one. The leds will change color only after the next call to on() . brightness \u00b6 brightness ( brt ) Multiplies all the led color by brt , a float between 0 and 1. The leds will change color only after the next call to on() . merge \u00b6 merge ( lstrip , fun = add_color ) Merges lstrip with the current strip ( self ). The resulting colors are calculated by applying fun to every corresponding pair of leds in the ledstrips. The signature of fun must be fun(r1,g1,b1,r2,b2,g2) where r1,g1,b1 are the color components of the first strip and r2,g2,b2 are the color components of the second strip. The default add_color sums colors component by component. Merging strips is very useful for animations. Indeed one can build different layers on different strips, animate them separately and merge them in one single strip to be showed.","title":"WS2812 RGB Led Module"},{"location":"reference/libs/worldsemi/ws2812/docs/ledstrips/#ws2812-rgb-led-module","text":"This module implements the Zerynth driver for the Worldsemi WS2812 Intelligent Control RGB Led assembled in any form, ledstrip, or ring. ( datasheet ).","title":"WS2812 RGB Led Module"},{"location":"reference/libs/worldsemi/ws2812/docs/ledstrips/#add_color","text":"add_color ( r1 , g1 , b1 , r2 , g2 , b2 ) Returns a tuple (r,g,b) where r=r1+r2, g=g1+g2, b=b1+b2. In case of overflow, components are capped to 255","title":"add_color"},{"location":"reference/libs/worldsemi/ws2812/docs/ledstrips/#first_color","text":"first_color ( r1 , g1 , b1 , r2 , g2 , b2 ) Always returns (r1,g1,b1) unless all the components are zero. In that case it returns (r2,g2,b2)","title":"first_color"},{"location":"reference/libs/worldsemi/ws2812/docs/ledstrips/#second_color","text":"second_color ( r1 , g1 , b1 , r2 , g2 , b2 ) Always returns (r2,g2,b2) unless all the components are zero. In that case it returns (r1,g1,b1)","title":"second_color"},{"location":"reference/libs/worldsemi/ws2812/docs/ledstrips/#ledstrip-class","text":"","title":"LedStrip class"},{"location":"reference/libs/worldsemi/ws2812/docs/ledstrips/#class-ledstrip","text":"class LedStrip ( pin , nleds ) This class abstracts a ledstrip. It needs to know which pin the ledstrip is wired to and how many leds it is composed of ( nleds ). The pin is automatically set to the correct mode and initially set to zero.","title":"class LedStrip"},{"location":"reference/libs/worldsemi/ws2812/docs/ledstrips/#on","text":"on () Turns on the ledstrip, colouring each led with the configuration set with methods like set() .","title":"on"},{"location":"reference/libs/worldsemi/ws2812/docs/ledstrips/#set","text":"set ( n , r , g , b ) Sets the nth led of the strip to the r , g , b color specified. The led will change color only after the next call to on() . An equivalent and valid syntax is ledstrip[n]=(r,g,b).","title":"set"},{"location":"reference/libs/worldsemi/ws2812/docs/ledstrips/#setall","text":"setall ( r , g , b ) Sets all the leds of the strip to the r , g , b color specified. The led will change color only after the next call to on() .","title":"setall"},{"location":"reference/libs/worldsemi/ws2812/docs/ledstrips/#clear","text":"clear () Sets all the leds of the strip to off. The leds will turn off after the next call to on() .","title":"clear"},{"location":"reference/libs/worldsemi/ws2812/docs/ledstrips/#lshift","text":"lshift () Shifts to the left all the leds by one. The leds will change color only after the next call to on() .","title":"lshift"},{"location":"reference/libs/worldsemi/ws2812/docs/ledstrips/#rshift","text":"rshift () Shifts to the right all the leds by one. The leds will change color only after the next call to on() .","title":"rshift"},{"location":"reference/libs/worldsemi/ws2812/docs/ledstrips/#brightness","text":"brightness ( brt ) Multiplies all the led color by brt , a float between 0 and 1. The leds will change color only after the next call to on() .","title":"brightness"},{"location":"reference/libs/worldsemi/ws2812/docs/ledstrips/#merge","text":"merge ( lstrip , fun = add_color ) Merges lstrip with the current strip ( self ). The resulting colors are calculated by applying fun to every corresponding pair of leds in the ledstrips. The signature of fun must be fun(r1,g1,b1,r2,b2,g2) where r1,g1,b1 are the color components of the first strip and r2,g2,b2 are the color components of the second strip. The default add_color sums colors component by component. Merging strips is very useful for animations. Indeed one can build different layers on different strips, animate them separately and merge them in one single strip to be showed.","title":"merge"},{"location":"reference/libs/xinabox/ah01/docs/","text":"XinaBox AH01 \u00b6 Microchip ATECCx08A crypto elements family provides a series of HW accelerated cryptographic functions, most notably ECDH (508A/608A only) and ECDSA. Product pages: ATECC108A ATECC508A ATECC608A Technical Details \u00b6 Operating Voltage Range: from 2.0 V to 5.5 V Operating Temperature Range: from -40 \u00b0C to 85 \u00b0C Interface Type: Single Wire; I2C Operating Current Typical: 1 mA Below, Zerynth driver documentation for Microchip ATECCx80A crypto elements. Contents: ATECCx08A library Auxiliary methods [ATECC508A class] https://docs.zerynth.com/latest/official/lib.xinabox.ah01/docs/official_lib.xinabox.ah01_ah01.html#atecc508a-class ) Internal methods Public methods Commands ATECC608A class Zerynth HWCrypto Interface [Examples]( https://docs.zerynth.com/latest/official/lib.xinabox.ah01/examples/examples.html ping","title":"Index"},{"location":"reference/libs/xinabox/ah01/docs/#xinabox-ah01","text":"Microchip ATECCx08A crypto elements family provides a series of HW accelerated cryptographic functions, most notably ECDH (508A/608A only) and ECDSA. Product pages: ATECC108A ATECC508A ATECC608A","title":"XinaBox AH01"},{"location":"reference/libs/xinabox/ah01/docs/#technical-details","text":"Operating Voltage Range: from 2.0 V to 5.5 V Operating Temperature Range: from -40 \u00b0C to 85 \u00b0C Interface Type: Single Wire; I2C Operating Current Typical: 1 mA Below, Zerynth driver documentation for Microchip ATECCx80A crypto elements. Contents: ATECCx08A library Auxiliary methods [ATECC508A class] https://docs.zerynth.com/latest/official/lib.xinabox.ah01/docs/official_lib.xinabox.ah01_ah01.html#atecc508a-class ) Internal methods Public methods Commands ATECC608A class Zerynth HWCrypto Interface [Examples]( https://docs.zerynth.com/latest/official/lib.xinabox.ah01/examples/examples.html ping","title":"Technical Details"},{"location":"reference/libs/xinabox/ah01/docs/ah01/","text":"ATECCx08A library \u00b6 This module exports classes for Microchip ATECCx08A chip family and some utilities functions. Furthermore an interface to allow the use of chip-related functionalities from other Zerynth hybrid C/Python libraries is made available. Auxiliary methods \u00b6 crc16 \u00b6 crc16 ( data : bytes ) Compute the CRC16 checksum for some bytes. The CRC is calculated using 0x8005 as polynomial and starting with the registry set as 0x00. Arguments: data (bytes) \u2013 bytes to be checksummed. ** Returns:** 2 bytes, representing the computed checksum. Return type: bytes ATECC508A class \u00b6 class ATECC508A \u00b6 class ATECC508A ( i2c . I2C ) Class for controlling the ATECC508A chip. Members: device_awake : Boolean. If True the device is running a multiple commands sequence. ATECC508A. init \u00b6 __init__ ( drvname , addr = DEFAULT_ADDR , clk = 100000 ) Connect to a device and start I2C protocol. Arguments: drvname \u2013 Interface for I2C communication (e.g. I2C0) addr ( int [0-255] ) \u2013 Address of the I2C chip. (Default value = 0x60 for ATECC508A) clk ( int ) \u2013 Clock rate of the I2C communication in kHz. (Default value = 100000). Internal methods \u00b6 _send_cmd \u00b6 _send_cmd ( self , opcode , param1 , param2 : bytes , data = bytes ()) Send a command packet to the device. Output packet structure: [ 0x03 ][ length ][ opcode ][ p1 ][ p2 ][ \u2026data\u2026 ][ crc ] * 0x03 is a constant defined in WORD_ADDRS at the beginning of this module. * length includes every bytes except the first 0x03 byte. * p1 is byte of length 1. (mandatory) * p2 is bytes of length 2. (mandatory) * data is optional and can have arbitraty length. * crc is a 2 byte checksum (calculated using `ecc508a.crc16()`). Arguments: opcode ( int ) \u2013 The code representing the selected command. Check OPCODES at the beginning of this module. param1 ( int ) \u2013 The first mandatory parameter. 1 byte long. param2 ( bytes ) \u2013 The second mandatory parameter. 2 bytes long. data ( bytes ) \u2013 Other optional data. (Default value = bytes()) _read_result \u00b6 _read_result () Read, verify checksum, and extract data of a packet from the device. Input packet structure: [ length ][ \u2026data\u2026 ][ crc ] Returns: the extracted data bytes. Return type: bytes Note: Length includes itself (1 byte), data (n bytes), and crc16 (2 bytes). Public methods \u00b6 start_cmd_sequence \u00b6 start_cmd_sequence () Call this function before a command sequence to wake up device from idle mode. This is done by keeping SDA low for more than 60 microseconds. Note At this moment a 0x00 byte is written as a normal I2C transaction, ignoring the exception raised. This workaround won\u2019t work at higher clock rates (more than ~100 kHz)! end_cmd_sequence \u00b6 end_cmd_sequence () Call this function at the end of a command sequence to put the device in idle mode. This must be done in order to avoid hitting the watchdog timeout (~1 second) which will put the device in idle mode no matter what. send_and_read \u00b6 send_and_read ( * args ) Send a command and return the result data. Note If start_cmd_sequence() was not invoked before this method, the device is automatically woke up and put again in idle mode after the command execution. (Default value = 50) Arguments: ** args* \u2013 All arguments are passed to _send_cmd() method. Commands \u00b6 The functions names are the lowercase command name followed by _cmd. Parameters are command specific. A command usually return some bytes as the result of the command execution, or a status code. checkmac_cmd \u00b6 checkmac_cmd ( tempkey_as_message_source : bool , tempkey_as_first_block : bool , source_flag : int , key_id : bytes , challenge : bytes , response : bytes , other_data : bytes ) Verify a MAC calculated on another CryptoAuthentication device. Arguments: tempkey_as_message_source ( bool ) \u2013 If False the second 32 bytes of the SHA message are taken from challenge parameter, otherwise they are taken from TempKey. tempkey_as_first_block ( bool ) \u2013 If False Slot in first SHA block is used, otherwise TempKey is. source_flag ( int ) \u2013 Single bit. If tempkey_as_message_source or tempkey_as_first_block are set to True, then the value of this bit must match the value in TempKey.SourceFlag or the command will return an error. The fag is the fourth bit returned by info_cmd(\u2018State\u2019). key_id ( bytes ) \u2013 Internal key used to generate the response. All except last four bits are ignored. challenge ( bytes ) \u2013 32 bytes, challenge sent to client. If tempkey_as_message_source is True, this parameter will be ignored. response ( bytes ) \u2013 32 bytes, response generated by the client. other_data ( bytes ) \u2013 13 bytes, remaining constant data needed for response calculation. Returns: True if response matches the computed digest, False otherwise. Return type: bool read_counter_cmd \u00b6 read_counter_cmd ( key_id ) Read one of the two monotonic counters. Arguments: key_id ( int ) \u2013 The specified counter. Can be 0 or 1. Returns: 4 bytes representing the current value of the counter, or 1 byte representing a status code. Return type: bytes inc_counter_cmd \u00b6 inc_counter_cmd ( key_id ) Increment one of the two monotonic counters. The maximum value that the counter may have is 2,097,151. Any attempt to count beyond this value will result in an error code. Arguments: key_id ( int ) \u2013 The specified counter. Can be 0 or 1. Returns: 4 bytes representing the current value of the counter, or 1 byte representing a status code. Return type: bytes derivekey_cmd \u00b6 derivekey_cmd ( source_flag : int , target_key : bytes , mac = bytes ()) The device combines the current value of a key with the nonce stored in TempKey using SHA-256 and places the result into the target key slot. Prior to execution of this command, nonce_cmd() must have been run to create a valid nonce in TempKey. For full documentation check datasheet at pages 63-64. Arguments: source_flag ( int ) \u2013 Single bit (1 or 0). The value of this bit must match the value in TempKey.SourceFlag or the command will return an error. The flag is the fourth bit returned by info_cmd() . target_key ( bytes ) \u2013 2 bytes. Key slot to be written. mac (**bytes*) \u2013 MAC used to validate the operation. (Default value = bytes()) Returns: True if the operation completed successfully. Return type: bool ecdh_cmd \u00b6 ecdh_cmd ( key_id : bytes , x_comp : bytes , y_comp : bytes ) Generate an ECDH master secret using stored private key and input public key. Arguments: key_id ( bytes ) \u2013 The private key to be used in the ECDH calculation. x_comp ( bytes ) \u2013 The X component of the public key to be used for ECDH calculation. y_comp ( bytes ) \u2013 The Y component of the public key to be used for ECDH calculation. Returns: If any error occured, the error code. If specified by SlotConfig.ReadKey<3>, the shared secret. Otherwise the success code 0x00. Return type: bytes gendig_cmd \u00b6 gendig_cmd ( self , zone : int , key_id : bytes , other_data = bytes ()) Generate a data digest from a random or input seed and a key. See datasheet page 66-69 for full usage details. Arguments: zone ( int ) \u2013 Possible values are numbers between 0 and 5 (included). If 0x00 (Config), then use key_id to specify any of the four 256-bit blocks of the Configuration zone. If key_id has a value greater than three, the command will return an error. If 0x01 (OTP), use key_id to specify either the first or second 256-bit block of the OTP zone. If 0x02 (Data), then key_id specifies a slot in the Data zone or a transport key in the hardware array. If 0x03 (Shared Nonce), then key_id specifies the location of the input value in the message generation. If 0x04 (Counter), then key_id specifies the monotonic counter ID to be included in the message generation. If 0x05 (Key Config), then key_id specifies the slot for which the configuration information is to be included in the message generation. key_id ( bytes ) \u2013 Identification number of the key to be used, selection of which OTP block or message order for Shared Nonce mode. other_data ( bytes ) \u2013 4 bytes of data for SHA calculation when using a NoMac key, 32 bytes for \u201cShared Nonce\u201d mode, otherwise ignored. (Default value = bytes()) Returns: True if the operation completed successfully. Return type: bool gen_private_key \u00b6 gen_private_key ( self , key_slot : int , create_digest = False , other_data = bytes ( 3 ) Generate an ECC private key. Arguments: key_slot ( bytes ) \u2013 Specifies the slot where the private ECC key is generated. create_digest ( bool ) \u2013 If True the device creates a PubKey digest based on the private key in KeyID and places it in TempKey (ignored if create_digest is False). other_data ( bytes ) \u2013 3 bytes, used in the creation of the message used as input for the digest algorithm. Returns: 64 bytes representing public key X and Y coordinates or 1 byte representing a status code if an error occured. Return type: bytes gen_public_key \u00b6 gen_public_key ( self , key_slot : int , create_digest = False , other_data = bytes ( 3 )) Generate the ECC public key starting from a private key. Arguments: key_slot ( int ) \u2013 Specifies the slot where the private ECC key is. create_digest ( bool ) \u2013 If True the device creates a PubKey digest based on the private key in KeyID and places it in TempKey (ignored if create_digest is False). other_data ( bytes ) \u2013 3 bytes, used in the creation of the message used as input for the digest algorithm. Returns: 64 bytes representing public key X and Y coordinates or 1 byte representing a status code if an error occured. Return type: bytes gen_digest_cmd \u00b6 gen_digest_cmd ( self , key_id : bytes , other_data : bytes ) Generate a digest and store it in TempKey, using key_id as public key. Arguments: key_id ( bytes ) \u2013 Specifies the slot where the public ECC key is. other_data ( bytes ) \u2013 3 bytes, used in the creation of the message used as input for the digest algorithm. Returns: 64 bytes representing public key X and Y coordinates or 1 byte representing a status code if an error occured. Return type: bytes hmac_cmd \u00b6 hmac_cmd ( self , source_flag : int , key_id : bytes , include_sn : bool ) Calculate response from key and other internal data using HMAC/SHA-256. Arguments: source_flag ( int ) \u2013 Single bit. The value of this bit must match the value in TempKey.SourceFlag (1 = True, 0 = False) or the command will return an error. The flag is the fourth bit returned by info_cmd(\u2018State\u2019). key_id ( bytes ) \u2013 Specifies the slot where the key is. Note that while only last four bits are used to select a slot, all the two bytes will be included in the digest message. include_sn ( bool ) \u2013 If True, 48 bits from Configuration Zone are included in the digest message. Returns: 32 bytes, the computed HMAC digest. Return type: bytes info_cmd \u00b6 info_cmd ( self , mode : str , param = bytes ( 2 )) Return device state information. The information read can be static or dynamic. Arguments: zone ( str ) \u2013 Zone to read byte from. The value is case insensitive and can be one of Revision, KeyValid, State, GPIO. param (**bytes*) \u2013 Second parameter (Default value = bytes(2)) Returns: 4 bytes read from the device or 1 byte status code Return type: bytes lock_config_zone_cmd(self, checksum: bytes=None) ** Prevent further modifications to the Config zone of the device. Arguments: checksum ( bytes ) \u2013 2 bytes representing a CRC summary of the zone. If set the checksum is verified from the device prior locking. (Default value = None) Returns: Single byte 0 if the operation completed successfully. Return type: bytes lock_data_zone_cmd \u00b6 lock_data_zone_cmd ( checksum : bytes = None ) Prevent further modifications to the Data and OTP zones of the device. Arguments: checksum ( bytes ) \u2013 2 bytes representing a CRC summary of the zone. If set the checksum is verified from the device prior locking. (Default value = None) Returns: Single byte 0 if the operation completed successfully. Return type: bytes lock_single_slot_cmd \u00b6 lock_single_slot_cmd ( self , slot_number : int ) Prevent further modifications to a single slot of the device. Arguments: slot_number ( int ) \u2013 Slot ID to be locked, valid values are the numbers in range 0-15 (included). Returns: Single byte 0 if the operation completed successfully. Return type: bytes mac_cmd \u00b6 mac_cmd ( self , key_id : bytes , use_tempkey : bool , include_sn : bool , source_flag : int = 0 , challenge : bytes = bytes ()) Compute a SHA-256 digest from key and other internal data using SHA-256. The normal command flow to use this command is as follows: Run Nonce command to load input challenge and optionally combine it with a generated random number. The result of this operation is a nonce stored internally on the device. Optionally, run GenDig command to combine one or more stored EEPROM locations in the device with the nonce. The result is stored internally in the device. This capability permits two or more keys to be used as part of the response generation. Run this MAC command to combine the output of step one (and step two if desired) with an EEPROM key to generate an output response (i.e. digest). Note source_flag MUST be specified if use_tempkey is True or a challenge is used. Arguments: key_id ( bytes ) \u2013 2 bytes. Specifies the slot where the key is. Note that while only last four bits are used to select a slot, all the two bytes will be included in the digest message. use_tempkey ( bool ) \u2013 If False the first 32 bytes of the SHA message are loaded from one of the data slots. Otherwise the first 32 bytes are filled with TempKey (and source_flag must be used). include_sn ( bool ) \u2013 If True, 48 bits from Configuration Zone are included in the digest message. source_flag ( int ) \u2013 Single bit. The value of this bit must match the value in TempKey.SourceFlag (1 = True, 0 = False) or the command will return an error. The flag is the fourth bit returned by info_cmd(\u2018State\u2019). (Default value = 0) challenge ( bytes ) \u2013 32 bytes. If specified, it will be used in the input of the algorithm. (Default value = bytes()) Returns: 32 bytes, the computed SHA-256 digest. Return type: bytes nonce_cmd \u00b6 nonce_cmd ( self , use_tempkey : bool , num_in : bytes , force_no_eeprom_update : bool = False ) Generate a 32-byte random number and an internally stored Nonce. The body used to create the nonce is stored internally in TempKey. Arguments: use_tempkey ( bool ) \u2013 TempKey is used instead of the RNG in the hash calculation input (message). TempKey is also returned by this command. TempKey must be valid prior to execution of this command and the values of the remaining TempKey flags remain unchanged. num_in ( bytes ) \u2013 20 bytes, the input parameter. force_no_eeprom_update ( bool ) \u2013 If True, the EEPROM is not updated before the RNG generation (the existing EEPROM is used, not recommended) (Default value = False) Returns: TempKey (32 bytes) if use_tempkey is True. Otherwise the RNG output. Return type: bytes nonce_passthrough_cmd \u00b6 nonce_passthrough_cmd ( self , num_in : bytes ) Pass-through mode of the Nonce command. TempKey is loaded with NumIn. No SHA-256 calculation is performed, and TempKey.SourceFlag is set to Input. (No data is returned to the system in this mode). Arguments: num_in ( bytes ) \u2013 32 bytes, input parameter. Returns: Single byte 0 if the operation completed successfully. Return type: bytes privwrite_cmd \u00b6 privwrite_cmd ( self , encrypt_input : bool , key_id : bytes , value : bytes , mac : bytes ) Write an ECC private key into a slot in the Data zone. For best security, PrivWrite should not be used, and private keys should be internally generated from the RNG using gen_private_key command. The slot indicated by this command must be configured via KeyConfig.Private to contain an ECC private key, and SlotConfig.IsSecret must be set to one. See datasheet page 80 for full details. Arguments: encrypt_input ( bool ) \u2013 If True, the input data is encrypt using TempKey. Otherwise, the input data is not encrypted - this is valid only when Data zone is unlocked. key_id ( bytes ) \u2013 2 bytes, slot id to be written. value ( bytes ) \u2013 36 bytes integer. Information to be written to the slot, first 4 bytes should be zero. mac ( bytes ) \u2013 32 bytes. Message Authentication Code to validate EEPROM Write operation. Returns: Single byte 0 if the operation completed successfully. Return type: bytes random_cmd \u00b6 random_cmd ( self , force_no_eeprom_update = False ) Generate a random number. The number is generated using a seed stored in the EEPROM and a hardware RNG. Arguments: force_no_eeprom_update ( bool ) \u2013 If True, the EEPROM is not updated before the RNG generation (the existing EEPROM is used, not recommended). (Default value = False) Returns: 32 bytes, output of RNG. Prior to the configuration zone being locked, the RNG produces a value of 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00 to facilitate testing. Return type: bytes read_cmd \u00b6 read_cmd ( self , zone : str , address : bytes , read_32_bytes : bool ) Read bytes from the device. This command can read bytes from an address of one of the memory zones See datasheet page 10 for zones details. Arguments: zone ( str ) \u2013 Select the source zone. Must be one of Config, OTP or Data. address ( bytes ) \u2013 2 bytes address of the first word to be read. See datasheet page 58 for correct formats. read_32_bytes ( bool ) \u2013 If True, 32 bytes are read and returned. Otherwise 4 bytes are read and returned. Returns: A single word (4 bytes) or a 8-words block (32 bytes), depending on the read_32_bytes parameter. The bytes can be encrypted depending on the zone and the device status. See datasheet page 81 for usage details. Return type: bytes sha_start_cmd \u00b6 sha_start_cmd ( self ) Start a SHA-256 digest computation. This command must be run before sha_end_cmd(). Returns: Single byte 0 if the operation completed correctly. Return type: bytes sha_hmacstart_cmd \u00b6 sha_hmacstart_cmd ( self , key_id : bytes ) Start a HMAC digest computation. This command must be run before sha_hmacend_cmd() . Arguments: key_id ( bytes ) \u2013 Id of the HMAC key. Returns: Single byte 0 if the operation completed correctly. Return type: bytes sha_update_cmd \u00b6 sha_update_cmd ( self , message : bytes ) Add 64 bytes in the message parameter to the SHA context. This command must be run after sha_start_cmd() or sha_hmacstart_cmd() . Arguments: message ( bytes ) \u2013 64 bytes, to be added in the SHA context. Returns: Single byte 0 if the operation completed correctly. Return type: bytes sha_public_cmd \u00b6 sha_public_cmd ( self , key_id : bytes ) Add 64 bytes of a public key stored in one of the Data zone slots to the SHA context. Arguments: key_id ( bytes ) \u2013 The slot id of the public key. Returns: Single byte 0 if the operation completed successfully, or an error if the slot contains anything other than a public key. Return type: bytes sha_end_cmd \u00b6 sha_end_cmd ( message : bytes ) Complete the SHA-256 computation and load the digest into TempKey and the output buffer. Up to 63 message bytes are accepted (Length must be 0 through 63 inclusive.) This command must be run after sha_start_cmd() and eventually after some sha_update_cmd(). Arguments: message ( bytes ) \u2013 0-63 bytes to be added in the SHA context before the final computation. Returns: 32 bytes representing the SHA256 digest. Return type: bytes sha_hmacend_cmd \u00b6 sha_hmacend_cmd ( message : bytes ) Complete the HMAC computation and load the digest into TempKey and the output buffer. Up to 63 message bytes are accepted (length must be 0 through 63 inclusive). This command must be run after sha_hmacstart_cmd() and eventually after some sha_update_cmd(). Arguments: message ( bytes ) \u2013 0-63 bytes to be added in the SHA context before the final computation. Returns: 32 bytes representing the SHA256 digest. Return type: bytes sign_cmd(key_id: bytes, include_sn: bool, use_tempkey: bool, is_verify_invalidate: bool = False)` ECDSA signature calculation from an internal private key. Arguments: key_id ( bytes ) \u2013 Internal private key used to generate the signature. include_sn ( bool ) \u2013 If True, 48 bits from Configuration Zone are included in the digest message. use_tempkey ( bool ) \u2013 If True, the message to be signed is in TempKey.Otherwise the message is internally generated (see datasheet page 86). is_verify_invalidate ( bool ) \u2013 This flag must be set to True if the command is being used by verify(invalidate) (Default value = False). Returns: 64 bytes representing the signature composed of R and S, or an error code. Return type: bytes updateextra_cmd \u00b6 updateextra_cmd ( update_byte : int , new_value : int ) Update bytes 84 or 85 within the Configuration zone after the Configuration zone has been locked. Arguments: update_byte ( int ) \u2013 Select the byte to be updated, can be one of 84 or 85. new_value ( int ) \u2013 New value to be written in the selected byte. update_byte \u2013 int: new_value \u2013 int: Returns: 0 if the operation succeded, or an error status code. Return type: bytes updateextra_decr_cmd \u00b6 updateextra_decr_cmd ( key_id ) Decrement the limited use counter associated with the key in slot after the Configuration zone has been locked. If the slot indicated by the \u201cNewValue\u201d param does not contain a key for which limited use is implemented or enabled, then the command returns without taking any action. If the indicated slot contains a limited use key, which does not have any uses remaining, then the command returns an error. Arguments: key_id ( bytes ) \u2013 2 bytes, the slot id of the key to be decremented. Returns: 0 if the operation succeded, or an error status code. Return type: bytes verify_external_cmd \u00b6 verify_external_cmd ( curve_type : int , r_comp : bytes , s_comp : bytes , x_comp : bytes , y_comp : bytes ) Takes an ECDSA signature and verifies that it is correctly generated from a given message and public key. In this mode the public key is an external input. Prior to this command being run, the message should be written to TempKey using the Nonce command. Arguments: curve_type ( int ) \u2013 Curve type to be used to verify the signature: 0b100 = P256 NIST ECC key 0b111 = Not an ECC key The value in this field is encoded identically to the KeyType field in the KeyConfig words within the Configuration zone. r_comp ( bytes ) \u2013 32 bytes, the R component of the ECDSA signature to be verified. s_comp ( bytes ) \u2013 32 bytes, the S component of the ECDSA signature to be verified. x_comp ( bytes ) \u2013 32 bytes, the X component of the public key to be used. y_comp ( bytes ) \u2013 32 bytes, the X component of the public key to be used. Returns: 0 if the signature match. 1 if the signature doesn\u2019t match. An error status code if an error occured. Return type: bytes verify_stored_cmd(key_id: bytes, r_comp: bytes, s_comp: bytes)` Takes an ECDSA signature and verifies that it is correctly generated from a given message and public key. In this mode the public key to be used is found in the KeyID EEPROM slot. The contents of TempKey should contain the SHA-256 digest of the message. Arguments: key_id ( bytes ) \u2013 2 bytes, the slot id containing the public key to be used. The key type is determined by KeyConfig.KeyType. r_comp ( bytes ) \u2013 32 bytes, the R component of the ECDSA signature to be verified. s_comp ( bytes ) \u2013 32 bytes, the S component of the ECDSA signature to be verified. Returns: 0 if the signature match. 1 if the signature doesn\u2019t match. An error status code if something went wrong. Return type: bytes verify_validate_cmd \u00b6 verify_validate_cmd ( key_id : bytes , r_comp : bytes , s_comp : bytes , other_data : bytes , invalidate : bool = False ) The Validate and Invalidate modes are used to validate or invalidate the public key stored in the EEPROM. The contents of TempKey should contain a digest of the PublicKey at key_id. It must have been generated using genkey_cmd over the key_id slot. Arguments: key_id ( bytes ) \u2013 Slot id of the key to be (in)validated. The parent key to be used to perform the (in)validation is stored in SlotConfig.ReadKey.SlotConfig .KeyType determines the curve to be used. r_comp ( bytes ) \u2013 32 bytes, the R component of the ECDSA signature to be verified. s_comp ( bytes ) \u2013 32 bytes, the S component of the ECDSA signature to be verified. other_data ( bytes ) \u2013 19 bytes, the bytes used to generate the message for the validation. invalidate ( bool ) \u2013 If True set the mode to Invalidate instead of Validate. (Default value = False) Returns: 0 if the signature match. 1 if the signature doesn\u2019t match. An error status code if something went wrong. Return type: bytes verify_invalidate_cmd \u00b6 verify_invalidate_cmd ( key_id : bytes , r_comp : bytes , s_comp : bytes , other_data : bytes ) Shortcut for verify_validate_cmd() using invalidate mode. verify_validate_external_cmd(key_id: bytes, r_comp: bytes, s_comp: bytes)` The ValidateExternal mode is used to validate the public key stored in the EEPROM at key_id when X.509 format certificates are to be used. The digest of the message must be TempKey. TempKey must have been generated using the sha_public_cmd(), and the key for that computation must be the same as key_id. Arguments: key_id ( bytes ) \u2013 The slot containing the public key to be validated which must have been specified by a previous sha_public_cmd(). r_comp ( bytes ) \u2013 32 bytes, the R component of the ECDSA signature to be verified. s_comp ( bytes ) \u2013 32 bytes, the S component of the ECDSA signature to be verified. Returns: 0 if the signature match. 1 if the signature doesn\u2019t match. An error status code if something went wrong. Return type: bytes write_cmd \u00b6 write_cmd ( zone : str , address : bytes , value : bytes , is_input_encrypted : bool , mac : bytes = bytes ()) Writes either one four byte word or an 8-word block of 32 bytes to one of the EEPROM zones on the device. Depending upon the value of the WriteConfig byte for this slot, the data may be required to be encrypted by the system prior to being sent to the device. Arguments: zone ( str ) \u2013 Select the source zone. Must be one of Config, OTP or Data. address ( bytes ) \u2013 2 bytes address of the first word to be written. See datasheet page 58 for correct formats. value ( bytes ) \u2013 4 or 32 bytes to be written in the specified address. May be encrypted (set is_input_encrypted to True). is_input_encrypted ( bool ) \u2013 Must be set to True if the input is encrypted. See datasheet page 91 for details. mac ( bytes ) \u2013 Message authentication code to validate address and data. (Default value = bytes()) is_locked \u00b6 is_locked ( zone : str ) Check if selected zone has been locked. Arguments: zone ( str ) \u2013 Select the zone to check. Must be one of Config or Data. Returns: True if selected zone is locked. Return type: bool serial_number \u00b6 serial_number () Retrieve secure element\u2019s 72-bit serial number. Returns: Serial number. Return type: bytes class ATECC608A \u00b6 class ATECC608A ( i2c . I2C ) Class for controlling the ATECC608A chip. This class inherits all ATECC508A methods. Zerynth HWCrypto Interface \u00b6 ATECC608A.hwcrypto_init \u00b6 hwcrypto_init ( i2c_drv , key_slot , i2c_addr = 0x60 , dev_type = DEV_ATECC508A ) Note this function is available only when ZERYNTH_HWCRYPTO_ATECCx08A is set in project.yml file Arguments: i2c_drv \u2013 Interface for I2C communication. (e.g. I2C0 ) key_slot \u2013 Chosen private key slot number (can be used to sign, compute public, \u2026) i2c_addr \u2013 Address of the I2C chip. (Default value = 0x60 ) dev_type \u2013 Crypto chip type (Default = DEV_ATECC508A , can also be DEV_ATECC108A or DEV_ATECC608A ) Init and enable the use of the crypto chip from other Zerynth libraries through Zerynth HWCrypto C interface. C interface based on Microchip Cryptoauth Lib .","title":"ATECCx08A library"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#ateccx08a-library","text":"This module exports classes for Microchip ATECCx08A chip family and some utilities functions. Furthermore an interface to allow the use of chip-related functionalities from other Zerynth hybrid C/Python libraries is made available.","title":"ATECCx08A library"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#auxiliary-methods","text":"","title":"Auxiliary methods"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#crc16","text":"crc16 ( data : bytes ) Compute the CRC16 checksum for some bytes. The CRC is calculated using 0x8005 as polynomial and starting with the registry set as 0x00. Arguments: data (bytes) \u2013 bytes to be checksummed. ** Returns:** 2 bytes, representing the computed checksum. Return type: bytes","title":"crc16"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#atecc508a-class","text":"","title":"ATECC508A class"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#class-atecc508a","text":"class ATECC508A ( i2c . I2C ) Class for controlling the ATECC508A chip. Members: device_awake : Boolean. If True the device is running a multiple commands sequence.","title":"class ATECC508A"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#atecc508ainit","text":"__init__ ( drvname , addr = DEFAULT_ADDR , clk = 100000 ) Connect to a device and start I2C protocol. Arguments: drvname \u2013 Interface for I2C communication (e.g. I2C0) addr ( int [0-255] ) \u2013 Address of the I2C chip. (Default value = 0x60 for ATECC508A) clk ( int ) \u2013 Clock rate of the I2C communication in kHz. (Default value = 100000).","title":"ATECC508A.init"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#internal-methods","text":"","title":"Internal methods"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#_send_cmd","text":"_send_cmd ( self , opcode , param1 , param2 : bytes , data = bytes ()) Send a command packet to the device. Output packet structure: [ 0x03 ][ length ][ opcode ][ p1 ][ p2 ][ \u2026data\u2026 ][ crc ] * 0x03 is a constant defined in WORD_ADDRS at the beginning of this module. * length includes every bytes except the first 0x03 byte. * p1 is byte of length 1. (mandatory) * p2 is bytes of length 2. (mandatory) * data is optional and can have arbitraty length. * crc is a 2 byte checksum (calculated using `ecc508a.crc16()`). Arguments: opcode ( int ) \u2013 The code representing the selected command. Check OPCODES at the beginning of this module. param1 ( int ) \u2013 The first mandatory parameter. 1 byte long. param2 ( bytes ) \u2013 The second mandatory parameter. 2 bytes long. data ( bytes ) \u2013 Other optional data. (Default value = bytes())","title":"_send_cmd"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#_read_result","text":"_read_result () Read, verify checksum, and extract data of a packet from the device. Input packet structure: [ length ][ \u2026data\u2026 ][ crc ] Returns: the extracted data bytes. Return type: bytes Note: Length includes itself (1 byte), data (n bytes), and crc16 (2 bytes).","title":"_read_result"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#public-methods","text":"","title":"Public methods"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#start_cmd_sequence","text":"start_cmd_sequence () Call this function before a command sequence to wake up device from idle mode. This is done by keeping SDA low for more than 60 microseconds. Note At this moment a 0x00 byte is written as a normal I2C transaction, ignoring the exception raised. This workaround won\u2019t work at higher clock rates (more than ~100 kHz)!","title":"start_cmd_sequence"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#end_cmd_sequence","text":"end_cmd_sequence () Call this function at the end of a command sequence to put the device in idle mode. This must be done in order to avoid hitting the watchdog timeout (~1 second) which will put the device in idle mode no matter what.","title":"end_cmd_sequence"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#send_and_read","text":"send_and_read ( * args ) Send a command and return the result data. Note If start_cmd_sequence() was not invoked before this method, the device is automatically woke up and put again in idle mode after the command execution. (Default value = 50) Arguments: ** args* \u2013 All arguments are passed to _send_cmd() method.","title":"send_and_read"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#commands","text":"The functions names are the lowercase command name followed by _cmd. Parameters are command specific. A command usually return some bytes as the result of the command execution, or a status code.","title":"Commands"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#checkmac_cmd","text":"checkmac_cmd ( tempkey_as_message_source : bool , tempkey_as_first_block : bool , source_flag : int , key_id : bytes , challenge : bytes , response : bytes , other_data : bytes ) Verify a MAC calculated on another CryptoAuthentication device. Arguments: tempkey_as_message_source ( bool ) \u2013 If False the second 32 bytes of the SHA message are taken from challenge parameter, otherwise they are taken from TempKey. tempkey_as_first_block ( bool ) \u2013 If False Slot in first SHA block is used, otherwise TempKey is. source_flag ( int ) \u2013 Single bit. If tempkey_as_message_source or tempkey_as_first_block are set to True, then the value of this bit must match the value in TempKey.SourceFlag or the command will return an error. The fag is the fourth bit returned by info_cmd(\u2018State\u2019). key_id ( bytes ) \u2013 Internal key used to generate the response. All except last four bits are ignored. challenge ( bytes ) \u2013 32 bytes, challenge sent to client. If tempkey_as_message_source is True, this parameter will be ignored. response ( bytes ) \u2013 32 bytes, response generated by the client. other_data ( bytes ) \u2013 13 bytes, remaining constant data needed for response calculation. Returns: True if response matches the computed digest, False otherwise. Return type: bool","title":"checkmac_cmd"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#read_counter_cmd","text":"read_counter_cmd ( key_id ) Read one of the two monotonic counters. Arguments: key_id ( int ) \u2013 The specified counter. Can be 0 or 1. Returns: 4 bytes representing the current value of the counter, or 1 byte representing a status code. Return type: bytes","title":"read_counter_cmd"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#inc_counter_cmd","text":"inc_counter_cmd ( key_id ) Increment one of the two monotonic counters. The maximum value that the counter may have is 2,097,151. Any attempt to count beyond this value will result in an error code. Arguments: key_id ( int ) \u2013 The specified counter. Can be 0 or 1. Returns: 4 bytes representing the current value of the counter, or 1 byte representing a status code. Return type: bytes","title":"inc_counter_cmd"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#derivekey_cmd","text":"derivekey_cmd ( source_flag : int , target_key : bytes , mac = bytes ()) The device combines the current value of a key with the nonce stored in TempKey using SHA-256 and places the result into the target key slot. Prior to execution of this command, nonce_cmd() must have been run to create a valid nonce in TempKey. For full documentation check datasheet at pages 63-64. Arguments: source_flag ( int ) \u2013 Single bit (1 or 0). The value of this bit must match the value in TempKey.SourceFlag or the command will return an error. The flag is the fourth bit returned by info_cmd() . target_key ( bytes ) \u2013 2 bytes. Key slot to be written. mac (**bytes*) \u2013 MAC used to validate the operation. (Default value = bytes()) Returns: True if the operation completed successfully. Return type: bool","title":"derivekey_cmd"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#ecdh_cmd","text":"ecdh_cmd ( key_id : bytes , x_comp : bytes , y_comp : bytes ) Generate an ECDH master secret using stored private key and input public key. Arguments: key_id ( bytes ) \u2013 The private key to be used in the ECDH calculation. x_comp ( bytes ) \u2013 The X component of the public key to be used for ECDH calculation. y_comp ( bytes ) \u2013 The Y component of the public key to be used for ECDH calculation. Returns: If any error occured, the error code. If specified by SlotConfig.ReadKey<3>, the shared secret. Otherwise the success code 0x00. Return type: bytes","title":"ecdh_cmd"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#gendig_cmd","text":"gendig_cmd ( self , zone : int , key_id : bytes , other_data = bytes ()) Generate a data digest from a random or input seed and a key. See datasheet page 66-69 for full usage details. Arguments: zone ( int ) \u2013 Possible values are numbers between 0 and 5 (included). If 0x00 (Config), then use key_id to specify any of the four 256-bit blocks of the Configuration zone. If key_id has a value greater than three, the command will return an error. If 0x01 (OTP), use key_id to specify either the first or second 256-bit block of the OTP zone. If 0x02 (Data), then key_id specifies a slot in the Data zone or a transport key in the hardware array. If 0x03 (Shared Nonce), then key_id specifies the location of the input value in the message generation. If 0x04 (Counter), then key_id specifies the monotonic counter ID to be included in the message generation. If 0x05 (Key Config), then key_id specifies the slot for which the configuration information is to be included in the message generation. key_id ( bytes ) \u2013 Identification number of the key to be used, selection of which OTP block or message order for Shared Nonce mode. other_data ( bytes ) \u2013 4 bytes of data for SHA calculation when using a NoMac key, 32 bytes for \u201cShared Nonce\u201d mode, otherwise ignored. (Default value = bytes()) Returns: True if the operation completed successfully. Return type: bool","title":"gendig_cmd"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#gen_private_key","text":"gen_private_key ( self , key_slot : int , create_digest = False , other_data = bytes ( 3 ) Generate an ECC private key. Arguments: key_slot ( bytes ) \u2013 Specifies the slot where the private ECC key is generated. create_digest ( bool ) \u2013 If True the device creates a PubKey digest based on the private key in KeyID and places it in TempKey (ignored if create_digest is False). other_data ( bytes ) \u2013 3 bytes, used in the creation of the message used as input for the digest algorithm. Returns: 64 bytes representing public key X and Y coordinates or 1 byte representing a status code if an error occured. Return type: bytes","title":"gen_private_key"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#gen_public_key","text":"gen_public_key ( self , key_slot : int , create_digest = False , other_data = bytes ( 3 )) Generate the ECC public key starting from a private key. Arguments: key_slot ( int ) \u2013 Specifies the slot where the private ECC key is. create_digest ( bool ) \u2013 If True the device creates a PubKey digest based on the private key in KeyID and places it in TempKey (ignored if create_digest is False). other_data ( bytes ) \u2013 3 bytes, used in the creation of the message used as input for the digest algorithm. Returns: 64 bytes representing public key X and Y coordinates or 1 byte representing a status code if an error occured. Return type: bytes","title":"gen_public_key"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#gen_digest_cmd","text":"gen_digest_cmd ( self , key_id : bytes , other_data : bytes ) Generate a digest and store it in TempKey, using key_id as public key. Arguments: key_id ( bytes ) \u2013 Specifies the slot where the public ECC key is. other_data ( bytes ) \u2013 3 bytes, used in the creation of the message used as input for the digest algorithm. Returns: 64 bytes representing public key X and Y coordinates or 1 byte representing a status code if an error occured. Return type: bytes","title":"gen_digest_cmd"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#hmac_cmd","text":"hmac_cmd ( self , source_flag : int , key_id : bytes , include_sn : bool ) Calculate response from key and other internal data using HMAC/SHA-256. Arguments: source_flag ( int ) \u2013 Single bit. The value of this bit must match the value in TempKey.SourceFlag (1 = True, 0 = False) or the command will return an error. The flag is the fourth bit returned by info_cmd(\u2018State\u2019). key_id ( bytes ) \u2013 Specifies the slot where the key is. Note that while only last four bits are used to select a slot, all the two bytes will be included in the digest message. include_sn ( bool ) \u2013 If True, 48 bits from Configuration Zone are included in the digest message. Returns: 32 bytes, the computed HMAC digest. Return type: bytes","title":"hmac_cmd"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#info_cmd","text":"info_cmd ( self , mode : str , param = bytes ( 2 )) Return device state information. The information read can be static or dynamic. Arguments: zone ( str ) \u2013 Zone to read byte from. The value is case insensitive and can be one of Revision, KeyValid, State, GPIO. param (**bytes*) \u2013 Second parameter (Default value = bytes(2)) Returns: 4 bytes read from the device or 1 byte status code Return type: bytes lock_config_zone_cmd(self, checksum: bytes=None) ** Prevent further modifications to the Config zone of the device. Arguments: checksum ( bytes ) \u2013 2 bytes representing a CRC summary of the zone. If set the checksum is verified from the device prior locking. (Default value = None) Returns: Single byte 0 if the operation completed successfully. Return type: bytes","title":"info_cmd"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#lock_data_zone_cmd","text":"lock_data_zone_cmd ( checksum : bytes = None ) Prevent further modifications to the Data and OTP zones of the device. Arguments: checksum ( bytes ) \u2013 2 bytes representing a CRC summary of the zone. If set the checksum is verified from the device prior locking. (Default value = None) Returns: Single byte 0 if the operation completed successfully. Return type: bytes","title":"lock_data_zone_cmd"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#lock_single_slot_cmd","text":"lock_single_slot_cmd ( self , slot_number : int ) Prevent further modifications to a single slot of the device. Arguments: slot_number ( int ) \u2013 Slot ID to be locked, valid values are the numbers in range 0-15 (included). Returns: Single byte 0 if the operation completed successfully. Return type: bytes","title":"lock_single_slot_cmd"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#mac_cmd","text":"mac_cmd ( self , key_id : bytes , use_tempkey : bool , include_sn : bool , source_flag : int = 0 , challenge : bytes = bytes ()) Compute a SHA-256 digest from key and other internal data using SHA-256. The normal command flow to use this command is as follows: Run Nonce command to load input challenge and optionally combine it with a generated random number. The result of this operation is a nonce stored internally on the device. Optionally, run GenDig command to combine one or more stored EEPROM locations in the device with the nonce. The result is stored internally in the device. This capability permits two or more keys to be used as part of the response generation. Run this MAC command to combine the output of step one (and step two if desired) with an EEPROM key to generate an output response (i.e. digest). Note source_flag MUST be specified if use_tempkey is True or a challenge is used. Arguments: key_id ( bytes ) \u2013 2 bytes. Specifies the slot where the key is. Note that while only last four bits are used to select a slot, all the two bytes will be included in the digest message. use_tempkey ( bool ) \u2013 If False the first 32 bytes of the SHA message are loaded from one of the data slots. Otherwise the first 32 bytes are filled with TempKey (and source_flag must be used). include_sn ( bool ) \u2013 If True, 48 bits from Configuration Zone are included in the digest message. source_flag ( int ) \u2013 Single bit. The value of this bit must match the value in TempKey.SourceFlag (1 = True, 0 = False) or the command will return an error. The flag is the fourth bit returned by info_cmd(\u2018State\u2019). (Default value = 0) challenge ( bytes ) \u2013 32 bytes. If specified, it will be used in the input of the algorithm. (Default value = bytes()) Returns: 32 bytes, the computed SHA-256 digest. Return type: bytes","title":"mac_cmd"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#nonce_cmd","text":"nonce_cmd ( self , use_tempkey : bool , num_in : bytes , force_no_eeprom_update : bool = False ) Generate a 32-byte random number and an internally stored Nonce. The body used to create the nonce is stored internally in TempKey. Arguments: use_tempkey ( bool ) \u2013 TempKey is used instead of the RNG in the hash calculation input (message). TempKey is also returned by this command. TempKey must be valid prior to execution of this command and the values of the remaining TempKey flags remain unchanged. num_in ( bytes ) \u2013 20 bytes, the input parameter. force_no_eeprom_update ( bool ) \u2013 If True, the EEPROM is not updated before the RNG generation (the existing EEPROM is used, not recommended) (Default value = False) Returns: TempKey (32 bytes) if use_tempkey is True. Otherwise the RNG output. Return type: bytes","title":"nonce_cmd"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#nonce_passthrough_cmd","text":"nonce_passthrough_cmd ( self , num_in : bytes ) Pass-through mode of the Nonce command. TempKey is loaded with NumIn. No SHA-256 calculation is performed, and TempKey.SourceFlag is set to Input. (No data is returned to the system in this mode). Arguments: num_in ( bytes ) \u2013 32 bytes, input parameter. Returns: Single byte 0 if the operation completed successfully. Return type: bytes","title":"nonce_passthrough_cmd"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#privwrite_cmd","text":"privwrite_cmd ( self , encrypt_input : bool , key_id : bytes , value : bytes , mac : bytes ) Write an ECC private key into a slot in the Data zone. For best security, PrivWrite should not be used, and private keys should be internally generated from the RNG using gen_private_key command. The slot indicated by this command must be configured via KeyConfig.Private to contain an ECC private key, and SlotConfig.IsSecret must be set to one. See datasheet page 80 for full details. Arguments: encrypt_input ( bool ) \u2013 If True, the input data is encrypt using TempKey. Otherwise, the input data is not encrypted - this is valid only when Data zone is unlocked. key_id ( bytes ) \u2013 2 bytes, slot id to be written. value ( bytes ) \u2013 36 bytes integer. Information to be written to the slot, first 4 bytes should be zero. mac ( bytes ) \u2013 32 bytes. Message Authentication Code to validate EEPROM Write operation. Returns: Single byte 0 if the operation completed successfully. Return type: bytes","title":"privwrite_cmd"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#random_cmd","text":"random_cmd ( self , force_no_eeprom_update = False ) Generate a random number. The number is generated using a seed stored in the EEPROM and a hardware RNG. Arguments: force_no_eeprom_update ( bool ) \u2013 If True, the EEPROM is not updated before the RNG generation (the existing EEPROM is used, not recommended). (Default value = False) Returns: 32 bytes, output of RNG. Prior to the configuration zone being locked, the RNG produces a value of 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00 to facilitate testing. Return type: bytes","title":"random_cmd"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#read_cmd","text":"read_cmd ( self , zone : str , address : bytes , read_32_bytes : bool ) Read bytes from the device. This command can read bytes from an address of one of the memory zones See datasheet page 10 for zones details. Arguments: zone ( str ) \u2013 Select the source zone. Must be one of Config, OTP or Data. address ( bytes ) \u2013 2 bytes address of the first word to be read. See datasheet page 58 for correct formats. read_32_bytes ( bool ) \u2013 If True, 32 bytes are read and returned. Otherwise 4 bytes are read and returned. Returns: A single word (4 bytes) or a 8-words block (32 bytes), depending on the read_32_bytes parameter. The bytes can be encrypted depending on the zone and the device status. See datasheet page 81 for usage details. Return type: bytes","title":"read_cmd"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#sha_start_cmd","text":"sha_start_cmd ( self ) Start a SHA-256 digest computation. This command must be run before sha_end_cmd(). Returns: Single byte 0 if the operation completed correctly. Return type: bytes","title":"sha_start_cmd"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#sha_hmacstart_cmd","text":"sha_hmacstart_cmd ( self , key_id : bytes ) Start a HMAC digest computation. This command must be run before sha_hmacend_cmd() . Arguments: key_id ( bytes ) \u2013 Id of the HMAC key. Returns: Single byte 0 if the operation completed correctly. Return type: bytes","title":"sha_hmacstart_cmd"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#sha_update_cmd","text":"sha_update_cmd ( self , message : bytes ) Add 64 bytes in the message parameter to the SHA context. This command must be run after sha_start_cmd() or sha_hmacstart_cmd() . Arguments: message ( bytes ) \u2013 64 bytes, to be added in the SHA context. Returns: Single byte 0 if the operation completed correctly. Return type: bytes","title":"sha_update_cmd"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#sha_public_cmd","text":"sha_public_cmd ( self , key_id : bytes ) Add 64 bytes of a public key stored in one of the Data zone slots to the SHA context. Arguments: key_id ( bytes ) \u2013 The slot id of the public key. Returns: Single byte 0 if the operation completed successfully, or an error if the slot contains anything other than a public key. Return type: bytes","title":"sha_public_cmd"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#sha_end_cmd","text":"sha_end_cmd ( message : bytes ) Complete the SHA-256 computation and load the digest into TempKey and the output buffer. Up to 63 message bytes are accepted (Length must be 0 through 63 inclusive.) This command must be run after sha_start_cmd() and eventually after some sha_update_cmd(). Arguments: message ( bytes ) \u2013 0-63 bytes to be added in the SHA context before the final computation. Returns: 32 bytes representing the SHA256 digest. Return type: bytes","title":"sha_end_cmd"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#sha_hmacend_cmd","text":"sha_hmacend_cmd ( message : bytes ) Complete the HMAC computation and load the digest into TempKey and the output buffer. Up to 63 message bytes are accepted (length must be 0 through 63 inclusive). This command must be run after sha_hmacstart_cmd() and eventually after some sha_update_cmd(). Arguments: message ( bytes ) \u2013 0-63 bytes to be added in the SHA context before the final computation. Returns: 32 bytes representing the SHA256 digest. Return type: bytes sign_cmd(key_id: bytes, include_sn: bool, use_tempkey: bool, is_verify_invalidate: bool = False)` ECDSA signature calculation from an internal private key. Arguments: key_id ( bytes ) \u2013 Internal private key used to generate the signature. include_sn ( bool ) \u2013 If True, 48 bits from Configuration Zone are included in the digest message. use_tempkey ( bool ) \u2013 If True, the message to be signed is in TempKey.Otherwise the message is internally generated (see datasheet page 86). is_verify_invalidate ( bool ) \u2013 This flag must be set to True if the command is being used by verify(invalidate) (Default value = False). Returns: 64 bytes representing the signature composed of R and S, or an error code. Return type: bytes","title":"sha_hmacend_cmd"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#updateextra_cmd","text":"updateextra_cmd ( update_byte : int , new_value : int ) Update bytes 84 or 85 within the Configuration zone after the Configuration zone has been locked. Arguments: update_byte ( int ) \u2013 Select the byte to be updated, can be one of 84 or 85. new_value ( int ) \u2013 New value to be written in the selected byte. update_byte \u2013 int: new_value \u2013 int: Returns: 0 if the operation succeded, or an error status code. Return type: bytes","title":"updateextra_cmd"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#updateextra_decr_cmd","text":"updateextra_decr_cmd ( key_id ) Decrement the limited use counter associated with the key in slot after the Configuration zone has been locked. If the slot indicated by the \u201cNewValue\u201d param does not contain a key for which limited use is implemented or enabled, then the command returns without taking any action. If the indicated slot contains a limited use key, which does not have any uses remaining, then the command returns an error. Arguments: key_id ( bytes ) \u2013 2 bytes, the slot id of the key to be decremented. Returns: 0 if the operation succeded, or an error status code. Return type: bytes","title":"updateextra_decr_cmd"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#verify_external_cmd","text":"verify_external_cmd ( curve_type : int , r_comp : bytes , s_comp : bytes , x_comp : bytes , y_comp : bytes ) Takes an ECDSA signature and verifies that it is correctly generated from a given message and public key. In this mode the public key is an external input. Prior to this command being run, the message should be written to TempKey using the Nonce command. Arguments: curve_type ( int ) \u2013 Curve type to be used to verify the signature: 0b100 = P256 NIST ECC key 0b111 = Not an ECC key The value in this field is encoded identically to the KeyType field in the KeyConfig words within the Configuration zone. r_comp ( bytes ) \u2013 32 bytes, the R component of the ECDSA signature to be verified. s_comp ( bytes ) \u2013 32 bytes, the S component of the ECDSA signature to be verified. x_comp ( bytes ) \u2013 32 bytes, the X component of the public key to be used. y_comp ( bytes ) \u2013 32 bytes, the X component of the public key to be used. Returns: 0 if the signature match. 1 if the signature doesn\u2019t match. An error status code if an error occured. Return type: bytes verify_stored_cmd(key_id: bytes, r_comp: bytes, s_comp: bytes)` Takes an ECDSA signature and verifies that it is correctly generated from a given message and public key. In this mode the public key to be used is found in the KeyID EEPROM slot. The contents of TempKey should contain the SHA-256 digest of the message. Arguments: key_id ( bytes ) \u2013 2 bytes, the slot id containing the public key to be used. The key type is determined by KeyConfig.KeyType. r_comp ( bytes ) \u2013 32 bytes, the R component of the ECDSA signature to be verified. s_comp ( bytes ) \u2013 32 bytes, the S component of the ECDSA signature to be verified. Returns: 0 if the signature match. 1 if the signature doesn\u2019t match. An error status code if something went wrong. Return type: bytes","title":"verify_external_cmd"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#verify_validate_cmd","text":"verify_validate_cmd ( key_id : bytes , r_comp : bytes , s_comp : bytes , other_data : bytes , invalidate : bool = False ) The Validate and Invalidate modes are used to validate or invalidate the public key stored in the EEPROM. The contents of TempKey should contain a digest of the PublicKey at key_id. It must have been generated using genkey_cmd over the key_id slot. Arguments: key_id ( bytes ) \u2013 Slot id of the key to be (in)validated. The parent key to be used to perform the (in)validation is stored in SlotConfig.ReadKey.SlotConfig .KeyType determines the curve to be used. r_comp ( bytes ) \u2013 32 bytes, the R component of the ECDSA signature to be verified. s_comp ( bytes ) \u2013 32 bytes, the S component of the ECDSA signature to be verified. other_data ( bytes ) \u2013 19 bytes, the bytes used to generate the message for the validation. invalidate ( bool ) \u2013 If True set the mode to Invalidate instead of Validate. (Default value = False) Returns: 0 if the signature match. 1 if the signature doesn\u2019t match. An error status code if something went wrong. Return type: bytes","title":"verify_validate_cmd"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#verify_invalidate_cmd","text":"verify_invalidate_cmd ( key_id : bytes , r_comp : bytes , s_comp : bytes , other_data : bytes ) Shortcut for verify_validate_cmd() using invalidate mode. verify_validate_external_cmd(key_id: bytes, r_comp: bytes, s_comp: bytes)` The ValidateExternal mode is used to validate the public key stored in the EEPROM at key_id when X.509 format certificates are to be used. The digest of the message must be TempKey. TempKey must have been generated using the sha_public_cmd(), and the key for that computation must be the same as key_id. Arguments: key_id ( bytes ) \u2013 The slot containing the public key to be validated which must have been specified by a previous sha_public_cmd(). r_comp ( bytes ) \u2013 32 bytes, the R component of the ECDSA signature to be verified. s_comp ( bytes ) \u2013 32 bytes, the S component of the ECDSA signature to be verified. Returns: 0 if the signature match. 1 if the signature doesn\u2019t match. An error status code if something went wrong. Return type: bytes","title":"verify_invalidate_cmd"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#write_cmd","text":"write_cmd ( zone : str , address : bytes , value : bytes , is_input_encrypted : bool , mac : bytes = bytes ()) Writes either one four byte word or an 8-word block of 32 bytes to one of the EEPROM zones on the device. Depending upon the value of the WriteConfig byte for this slot, the data may be required to be encrypted by the system prior to being sent to the device. Arguments: zone ( str ) \u2013 Select the source zone. Must be one of Config, OTP or Data. address ( bytes ) \u2013 2 bytes address of the first word to be written. See datasheet page 58 for correct formats. value ( bytes ) \u2013 4 or 32 bytes to be written in the specified address. May be encrypted (set is_input_encrypted to True). is_input_encrypted ( bool ) \u2013 Must be set to True if the input is encrypted. See datasheet page 91 for details. mac ( bytes ) \u2013 Message authentication code to validate address and data. (Default value = bytes())","title":"write_cmd"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#is_locked","text":"is_locked ( zone : str ) Check if selected zone has been locked. Arguments: zone ( str ) \u2013 Select the zone to check. Must be one of Config or Data. Returns: True if selected zone is locked. Return type: bool","title":"is_locked"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#serial_number","text":"serial_number () Retrieve secure element\u2019s 72-bit serial number. Returns: Serial number. Return type: bytes","title":"serial_number"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#class-atecc608a","text":"class ATECC608A ( i2c . I2C ) Class for controlling the ATECC608A chip. This class inherits all ATECC508A methods.","title":"class ATECC608A"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#zerynth-hwcrypto-interface","text":"","title":"Zerynth HWCrypto Interface"},{"location":"reference/libs/xinabox/ah01/docs/ah01/#atecc608ahwcrypto_init","text":"hwcrypto_init ( i2c_drv , key_slot , i2c_addr = 0x60 , dev_type = DEV_ATECC508A ) Note this function is available only when ZERYNTH_HWCRYPTO_ATECCx08A is set in project.yml file Arguments: i2c_drv \u2013 Interface for I2C communication. (e.g. I2C0 ) key_slot \u2013 Chosen private key slot number (can be used to sign, compute public, \u2026) i2c_addr \u2013 Address of the I2C chip. (Default value = 0x60 ) dev_type \u2013 Crypto chip type (Default = DEV_ATECC508A , can also be DEV_ATECC108A or DEV_ATECC608A ) Init and enable the use of the crypto chip from other Zerynth libraries through Zerynth HWCrypto C interface. C interface based on Microchip Cryptoauth Lib .","title":"ATECC608A.hwcrypto_init"},{"location":"reference/libs/xinabox/ah01/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.xinabox.ah01. Ping example \u00b6 The simplest example to be tried for starting with the Zerynth ATECCx08A library and the ATECC508A crypto element. Simply read the Revision bytes of the chip, checking if they are the expected ones. main.py \"\"\" Simplest example of usage for the ATECCx08A library with ATECC508A crypto element. This module can be used an easy check device correct functioning. \"\"\" import streams from xinabox.ah01 import ah01 PORT = I2C0 CLOCK = 100000 streams . serial () crypto = ah01 . ATECC508A ( PORT , clk = CLOCK ) def bytes_hex ( data ): \"\"\" Return hex string representation of bytes/bytearray object. \"\"\" res = \"0x\" for byte in data : res += \" %02X \" % byte return res def info_cmd_test (): \"\"\" Send an info command and check the result, which is a chip constant. \"\"\" expected = bytes ([ 0x00 , 0x00 , 0x50 , 0x00 ]) response = crypto . info_cmd ( 'REVISION' ) if response == expected : print ( \"Success. Device replied correctly.\" ) else : print ( \"Response from device not matching:\" ) print ( bytes_hex ( response )) while True : try : info_cmd_test () except Exception as err : print ( err ) sleep ( 1000 )","title":"Examples"},{"location":"reference/libs/xinabox/ah01/docs/examples/#examples","text":"The following are a list of examples for lib.xinabox.ah01.","title":"Examples"},{"location":"reference/libs/xinabox/ah01/docs/examples/#ping-example","text":"The simplest example to be tried for starting with the Zerynth ATECCx08A library and the ATECC508A crypto element. Simply read the Revision bytes of the chip, checking if they are the expected ones. main.py \"\"\" Simplest example of usage for the ATECCx08A library with ATECC508A crypto element. This module can be used an easy check device correct functioning. \"\"\" import streams from xinabox.ah01 import ah01 PORT = I2C0 CLOCK = 100000 streams . serial () crypto = ah01 . ATECC508A ( PORT , clk = CLOCK ) def bytes_hex ( data ): \"\"\" Return hex string representation of bytes/bytearray object. \"\"\" res = \"0x\" for byte in data : res += \" %02X \" % byte return res def info_cmd_test (): \"\"\" Send an info command and check the result, which is a chip constant. \"\"\" expected = bytes ([ 0x00 , 0x00 , 0x50 , 0x00 ]) response = crypto . info_cmd ( 'REVISION' ) if response == expected : print ( \"Success. Device replied correctly.\" ) else : print ( \"Response from device not matching:\" ) print ( bytes_hex ( response )) while True : try : info_cmd_test () except Exception as err : print ( err ) sleep ( 1000 )","title":"Ping example"},{"location":"reference/libs/xinabox/cr02/docs/","text":"XinaBox CR02-LoRaWAN \u00b6 The CR02 xChip forms part of the core radio modules and features an ATmega328P CPU running at 16 MHz for handling system and radio operations. The on-board RFM95W LoRaTM module provides ultra-long range spread spectrum communication and high interference immunity whilst minimizing current consumption. CR02 is utilized as an I2C slave device using LoRaWAN to connect to The Things Network over the 868MHz range. Please note, CR02 and all other xChips is currently only supported in Zerynth Studio with XinaBox CW02 . Review the Quick Start guide for interfacing xChips. Contents: CR02_LoRaWAN Module Using CR02_LoRaWAN Module CR02_TTN class Examples ttn temperature","title":"XinaBox CR02-LoRaWAN"},{"location":"reference/libs/xinabox/cr02/docs/#xinabox-cr02-lorawan","text":"The CR02 xChip forms part of the core radio modules and features an ATmega328P CPU running at 16 MHz for handling system and radio operations. The on-board RFM95W LoRaTM module provides ultra-long range spread spectrum communication and high interference immunity whilst minimizing current consumption. CR02 is utilized as an I2C slave device using LoRaWAN to connect to The Things Network over the 868MHz range. Please note, CR02 and all other xChips is currently only supported in Zerynth Studio with XinaBox CW02 . Review the Quick Start guide for interfacing xChips. Contents: CR02_LoRaWAN Module Using CR02_LoRaWAN Module CR02_TTN class Examples ttn temperature","title":"XinaBox CR02-LoRaWAN"},{"location":"reference/libs/xinabox/cr02/docs/cr02_lorawan/","text":"CR02_LoRaWAN Module \u00b6 This is a module for the XinaBox LoRaWAN implementation using CR02 as an I2C slave device with CW02 as its master. CR02 operates in the 868MHz range. Using CR02_LoRaWAN Module \u00b6 CR02_LoRaWAN module is dependant on a .hex file which must be uploaded to CR02 via IP01 before the module can be utilized. The file can be found here accompanied with instructions on flashing it to CR02. Once flashed, CR02 can be used as a node to connect to The Things Network. CR02_TTN class \u00b6 class CR02_TTN \u00b6 class CR02_TTN ( drvname = I2C0 , addr = 8 , clk = 100000 ) Creates an intance of the CR02_TTN class. Arguments: drvname \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 8 clk \u2013 Clock speed, default 100kHz CR02_TTN.init \u00b6 init () Sends the keys generated by The Things Network (TTN) application to CR02. CR02 then establishes a connection with TTN. Raises an exeption if any error occurs during initialization. Arguments: appeui \u2013 The appeui generated by TTN application deveui \u2013 The deveui generated by TTN application appkey \u2013 The appkey generated by TTN application debug \u2013 Set True to view debugging information on CR02. Can only be used with MD03 whereby the serial communication between CW02 and CR02 is seperated. CR02_TTN.sendString \u00b6 sendString ( dataToSend = \"\" ) Sends a string of limit 30 bytes over the I2C bus to CR02. CR02 in turn sends the string to TTN. Exception raised if unsuccessful. Arguments: dataToSend \u2013 string to be sent to TTN. CR02_TTN.sendNumber \u00b6 sendNumber ( numberToSend = 0 ) Sends a number of limit 30 bytes over the I2C bus to CR02. CR02 in turn sends the number to TTN. Exception raised if unsuccessful. Arguments: sendNumber \u2013 number to be sent to TTN.","title":"CR02_LoRaWAN Module"},{"location":"reference/libs/xinabox/cr02/docs/cr02_lorawan/#cr02_lorawan-module","text":"This is a module for the XinaBox LoRaWAN implementation using CR02 as an I2C slave device with CW02 as its master. CR02 operates in the 868MHz range.","title":"CR02_LoRaWAN Module"},{"location":"reference/libs/xinabox/cr02/docs/cr02_lorawan/#using-cr02_lorawan-module","text":"CR02_LoRaWAN module is dependant on a .hex file which must be uploaded to CR02 via IP01 before the module can be utilized. The file can be found here accompanied with instructions on flashing it to CR02. Once flashed, CR02 can be used as a node to connect to The Things Network.","title":"Using CR02_LoRaWAN Module"},{"location":"reference/libs/xinabox/cr02/docs/cr02_lorawan/#cr02_ttn-class","text":"","title":"CR02_TTN class"},{"location":"reference/libs/xinabox/cr02/docs/cr02_lorawan/#class-cr02_ttn","text":"class CR02_TTN ( drvname = I2C0 , addr = 8 , clk = 100000 ) Creates an intance of the CR02_TTN class. Arguments: drvname \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 8 clk \u2013 Clock speed, default 100kHz","title":"class CR02_TTN"},{"location":"reference/libs/xinabox/cr02/docs/cr02_lorawan/#cr02_ttninit","text":"init () Sends the keys generated by The Things Network (TTN) application to CR02. CR02 then establishes a connection with TTN. Raises an exeption if any error occurs during initialization. Arguments: appeui \u2013 The appeui generated by TTN application deveui \u2013 The deveui generated by TTN application appkey \u2013 The appkey generated by TTN application debug \u2013 Set True to view debugging information on CR02. Can only be used with MD03 whereby the serial communication between CW02 and CR02 is seperated.","title":"CR02_TTN.init"},{"location":"reference/libs/xinabox/cr02/docs/cr02_lorawan/#cr02_ttnsendstring","text":"sendString ( dataToSend = \"\" ) Sends a string of limit 30 bytes over the I2C bus to CR02. CR02 in turn sends the string to TTN. Exception raised if unsuccessful. Arguments: dataToSend \u2013 string to be sent to TTN.","title":"CR02_TTN.sendString"},{"location":"reference/libs/xinabox/cr02/docs/cr02_lorawan/#cr02_ttnsendnumber","text":"sendNumber ( numberToSend = 0 ) Sends a number of limit 30 bytes over the I2C bus to CR02. CR02 in turn sends the number to TTN. Exception raised if unsuccessful. Arguments: sendNumber \u2013 number to be sent to TTN.","title":"CR02_TTN.sendNumber"},{"location":"reference/libs/xinabox/cr02/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.xinabox.cr02. Temperature to The Things Network \u00b6 This examples reads temperature data from SW01 (BME280) and sends it to The Things Network via LoRaWAN. main.py ''' LoraWan implementation using CR02, CW02 and SW01 This example sends temperature data to ttn dashboard. CR02 LED functionality _______________________ BLUE : blinks once when keys are received RED : flashes once every send cycle (60sec hardcoded in .bin file) GREEN : Will remain steady once connection to ttn is established **************************NOTE!!!!!!!!!!!*************************** A 10 second delay is utilized prior to any communication over the i2c bus or uart. Do not remove the delay or the CW02 will lock up when the console is opened. If the console is needed, open it up within the 10 second interval. Alternatively, use a terminal that can set DTR and RTS on. We recommend CoolTerm. Do not open up zerynth console during runtime. ******************************************************************** ''' import streams from xinabox.cr02_lorawan import cr02_lorawan from xinabox.sw01 import sw01 streams . serial () sleep ( 10000 ) # do not remove! # enter ttn keys generated by the ttn console. simply copy and paste. appeui = \"\" # < enter appeui between quotes deveui = \"\" # < eneter deveui between quotes appkey = \"\" # < enter appkey between quotes # SW01 instance SW01 = sw01 . SW01 ( I2C0 , 0x76 , 100000 ) # CR02 instance CR02 = cr02_lorawan . CR02_TTN ( I2C0 ) # send ttn keys to CR02 to establish a connection to ttn CR02 . init ( appeui , deveui , appkey ) while True : temp = SW01 . getTempC () # retrieve tempearture print ( temp ) CR02 . sendNumber ( temp ) # send tempearure to CR02. CR02 will then send the temperature to TTN every 60 seconds. sleep ( 1000 )","title":"Examples"},{"location":"reference/libs/xinabox/cr02/docs/examples/#examples","text":"The following are a list of examples for lib.xinabox.cr02.","title":"Examples"},{"location":"reference/libs/xinabox/cr02/docs/examples/#temperature-to-the-things-network","text":"This examples reads temperature data from SW01 (BME280) and sends it to The Things Network via LoRaWAN. main.py ''' LoraWan implementation using CR02, CW02 and SW01 This example sends temperature data to ttn dashboard. CR02 LED functionality _______________________ BLUE : blinks once when keys are received RED : flashes once every send cycle (60sec hardcoded in .bin file) GREEN : Will remain steady once connection to ttn is established **************************NOTE!!!!!!!!!!!*************************** A 10 second delay is utilized prior to any communication over the i2c bus or uart. Do not remove the delay or the CW02 will lock up when the console is opened. If the console is needed, open it up within the 10 second interval. Alternatively, use a terminal that can set DTR and RTS on. We recommend CoolTerm. Do not open up zerynth console during runtime. ******************************************************************** ''' import streams from xinabox.cr02_lorawan import cr02_lorawan from xinabox.sw01 import sw01 streams . serial () sleep ( 10000 ) # do not remove! # enter ttn keys generated by the ttn console. simply copy and paste. appeui = \"\" # < enter appeui between quotes deveui = \"\" # < eneter deveui between quotes appkey = \"\" # < enter appkey between quotes # SW01 instance SW01 = sw01 . SW01 ( I2C0 , 0x76 , 100000 ) # CR02 instance CR02 = cr02_lorawan . CR02_TTN ( I2C0 ) # send ttn keys to CR02 to establish a connection to ttn CR02 . init ( appeui , deveui , appkey ) while True : temp = SW01 . getTempC () # retrieve tempearture print ( temp ) CR02 . sendNumber ( temp ) # send tempearure to CR02. CR02 will then send the temperature to TTN every 60 seconds. sleep ( 1000 )","title":"Temperature to The Things Network"},{"location":"reference/libs/xinabox/oc03/docs/","text":"XinaBox OC03 \u00b6 The OC03 xChip is a low-voltage control relay module able to switch AC and DC loads. It is based on the PCA9554A and TLP241A . The optically isolated relay is controlled by a PCA9554A IO expander, which provides an control interface to the switch. The PCA9554A has several selectable I2C addresses accessible via solder pads. The TLP241A photorelay consist of a photo MOSFET optically coupled to an infrared light emitting diode which switches a AC or DC load. It provides an isolation voltage of 5000 Vrms, making it suitable for applications that require reinforced circuit insulation. Please note, OC03 and all other xChips is currently only supported in Zerynth Studio with XinaBox CW02 . Review the Quick Start guide for interfacing xChips. Technical Details \u00b6 PCA9554A \u00b6 400-kHz Fast I2C Bus Three Hardware Address Pins Allow up to Eight I2C Addresses Internal Power-On Reset No Glitch on Power Up Latched Outputs With High-Current Drive TLP241A \u00b6 Normally Open OFF-state output terminal voltage: 40 V (min) Trigger LED current: 3 mA (max) ON-state current: 2 A (max) ON-state resistance: 100 m\u03a9 (max, t < 1 s) 150 m\u03a9 (max, Continuous) Isolation voltage: 5000 Vrms (min) Contents: OC03 Module OC03 class Examples toggle output remote relay control weather monitor wolkabout","title":"XinaBox OC03"},{"location":"reference/libs/xinabox/oc03/docs/#xinabox-oc03","text":"The OC03 xChip is a low-voltage control relay module able to switch AC and DC loads. It is based on the PCA9554A and TLP241A . The optically isolated relay is controlled by a PCA9554A IO expander, which provides an control interface to the switch. The PCA9554A has several selectable I2C addresses accessible via solder pads. The TLP241A photorelay consist of a photo MOSFET optically coupled to an infrared light emitting diode which switches a AC or DC load. It provides an isolation voltage of 5000 Vrms, making it suitable for applications that require reinforced circuit insulation. Please note, OC03 and all other xChips is currently only supported in Zerynth Studio with XinaBox CW02 . Review the Quick Start guide for interfacing xChips.","title":"XinaBox OC03"},{"location":"reference/libs/xinabox/oc03/docs/#technical-details","text":"","title":"Technical Details"},{"location":"reference/libs/xinabox/oc03/docs/#pca9554a","text":"400-kHz Fast I2C Bus Three Hardware Address Pins Allow up to Eight I2C Addresses Internal Power-On Reset No Glitch on Power Up Latched Outputs With High-Current Drive","title":"PCA9554A"},{"location":"reference/libs/xinabox/oc03/docs/#tlp241a","text":"Normally Open OFF-state output terminal voltage: 40 V (min) Trigger LED current: 3 mA (max) ON-state current: 2 A (max) ON-state resistance: 100 m\u03a9 (max, t < 1 s) 150 m\u03a9 (max, Continuous) Isolation voltage: 5000 Vrms (min) Contents: OC03 Module OC03 class Examples toggle output remote relay control weather monitor wolkabout","title":"TLP241A"},{"location":"reference/libs/xinabox/oc03/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.xinabox.oc03. Toggle relay on OC03 \u00b6 This is a basic example to toggle the relay on OC03 and return the relay state. main.py ############################################## # This is an example for the OC03 module # # The relay is toggled at 500 ms and the # state printed to the console. ############################################## # imports import streams from xinabox.oc03 import oc03 streams . serial () # instantiate OC03 class OC03 = oc03 . OC03 ( I2C0 ) # start OC03 OC03 . init () # sleep time DELAY = 500 # infinite loop while True : # close relay OC03 . writePin ( True ) print ( OC03 . getStatus ()) # return state of relay to console sleep ( DELAY ) # open relay OC03 . writePin ( False ) print ( OC03 . getStatus ()) # return state of relay to console sleep ( DELAY ) Control OC03 xChip low voltage relay remotely \u00b6 This is an advanced example utilizing BME280, OC03 (PCA9554A) and the WolkAbout IoT Platform. BME280 data consisting of ambient temperature, humidity and pressure is sent to the WolkAbout Platform. OC03 relay output can be controlled from within the dashboad. Upload the CW02-SW01-OC01-deviceTemplate.json to WolkAbout IoT Platfrom. main.py ####################################################### # This example sends BME280 data to the WolkAbout cloud. # OC03 relay output can also be controlled from within the # WolkAbout dashboard. # # Upload the device template to the WolkAbout platform. ######################################################## # imports import i2c import streams from wolkabout.iot import iot from wireless import wifi from bosch.bme280 import bme280 from espressif.esp32net import esp32wifi as wifi_driver from xinabox.oc03 import oc03 # wifi details wifi_ssid = \"username\" wifi_pass = \"password\" wifi_secu = wifi . WIFI_WPA2 # rgb pins RED = D25 GREEN = D26 BLUE = D27 # enable console streams . serial () # wolkabout project details device_key = \"device_key\" device_password = \"device_password\" actuator_references = [ \"R\" ] # rgb pins set as output pinMode ( RED , OUTPUT ) pinMode ( GREEN , OUTPUT ) pinMode ( BLUE , OUTPUT ) # xChip instances SW01 = bme280 . BME280 ( I2C0 , 0x76 , 100000 ) OC03 = oc03 . OC03 ( I2C0 ) # configure OC03 OC03 . init () # init the wifi driver wifi_driver . auto_init () # method that establishes a wifi connection def wifi_connect (): for retry in range ( 10 ): try : print ( \"Establishing Link...\" ) wifi . link ( wifi_ssid , wifi_secu , wifi_pass ) print ( \"Link Established\" ) digitalWrite ( GREEN , HIGH ) break except Exception as e : print ( \"ooops, something wrong while linking :(\" , e ) digitalWrite ( GREEN , LOW ) digitalWrite ( RED , HIGH ) sleep ( 1000 ) digitalWrite ( RED , LOW ) sleep ( 1000 ) # connect to wifi wifi_connect () # establish a connection between device and wolkabout iot platform try : device = iot . Device ( device_key , device_password , actuator_references ) except Exception as e : print ( \"Something went wrong while creating the device: \" , e ) # PProvide implementation of a way to read and modify actuator state class ActuatorStatusProviderImpl ( iot . ActuatorStatusProvider ): def get_actuator_status ( reference ): if reference == actuator_references [ 0 ]: value = OC03 . getStatus () print ( value ) if value == 1 : return iot . ACTUATOR_STATE_READY , True else : return iot . ACTUATOR_STATE_READY , False class ActuationHandlerImpl ( iot . ActuationHandler ): def handle_actuation ( reference , value ): print ( \"Setting actuator \" + reference + \" to value: \" + str ( value )) if reference == actuator_references [ 0 ]: if value is False : OC03 . writePin ( False ) else : if value is True : OC03 . writePin ( True ) try : wolk = iot . Wolk ( device , actuation_handler = ActuationHandlerImpl , actuator_status_provider = ActuatorStatusProviderImpl , ) except Exception as e : print ( \"Something went wrong while creating the Wolk instance: \" , e ) # Establish a connection to the WolkAbout IoT Platform try : print ( \"Connecting to WolkAbout IoT Platform\" ) wolk . connect () print ( \"Done\" ) except Exception as e : print ( \"Something went wrong while connecting: \" , e ) publish_period = 5000 wolk . publish_actuator_status ( \"R\" ) try : while True : if not wifi . is_linked (): wifi_connect () sleep ( publish_period ) print ( \"Publishing sensor readings\" ) temperature = SW01 . get_temp () humidity = SW01 . get_hum () pressure = SW01 . get_press () print ( \"T\" , temperature , \"H\" , humidity , \"P\" , pressure ) wolk . add_sensor_reading ( \"T\" , temperature ) wolk . add_sensor_reading ( \"H\" , humidity ) wolk . add_sensor_reading ( \"P\" , pressure ) wolk . publish () except Exception as e : print ( \"Something went wrong: \" , e )","title":"Examples"},{"location":"reference/libs/xinabox/oc03/docs/examples/#examples","text":"The following are a list of examples for lib.xinabox.oc03.","title":"Examples"},{"location":"reference/libs/xinabox/oc03/docs/examples/#toggle-relay-on-oc03","text":"This is a basic example to toggle the relay on OC03 and return the relay state. main.py ############################################## # This is an example for the OC03 module # # The relay is toggled at 500 ms and the # state printed to the console. ############################################## # imports import streams from xinabox.oc03 import oc03 streams . serial () # instantiate OC03 class OC03 = oc03 . OC03 ( I2C0 ) # start OC03 OC03 . init () # sleep time DELAY = 500 # infinite loop while True : # close relay OC03 . writePin ( True ) print ( OC03 . getStatus ()) # return state of relay to console sleep ( DELAY ) # open relay OC03 . writePin ( False ) print ( OC03 . getStatus ()) # return state of relay to console sleep ( DELAY )","title":"Toggle relay on OC03"},{"location":"reference/libs/xinabox/oc03/docs/examples/#control-oc03-xchip-low-voltage-relay-remotely","text":"This is an advanced example utilizing BME280, OC03 (PCA9554A) and the WolkAbout IoT Platform. BME280 data consisting of ambient temperature, humidity and pressure is sent to the WolkAbout Platform. OC03 relay output can be controlled from within the dashboad. Upload the CW02-SW01-OC01-deviceTemplate.json to WolkAbout IoT Platfrom. main.py ####################################################### # This example sends BME280 data to the WolkAbout cloud. # OC03 relay output can also be controlled from within the # WolkAbout dashboard. # # Upload the device template to the WolkAbout platform. ######################################################## # imports import i2c import streams from wolkabout.iot import iot from wireless import wifi from bosch.bme280 import bme280 from espressif.esp32net import esp32wifi as wifi_driver from xinabox.oc03 import oc03 # wifi details wifi_ssid = \"username\" wifi_pass = \"password\" wifi_secu = wifi . WIFI_WPA2 # rgb pins RED = D25 GREEN = D26 BLUE = D27 # enable console streams . serial () # wolkabout project details device_key = \"device_key\" device_password = \"device_password\" actuator_references = [ \"R\" ] # rgb pins set as output pinMode ( RED , OUTPUT ) pinMode ( GREEN , OUTPUT ) pinMode ( BLUE , OUTPUT ) # xChip instances SW01 = bme280 . BME280 ( I2C0 , 0x76 , 100000 ) OC03 = oc03 . OC03 ( I2C0 ) # configure OC03 OC03 . init () # init the wifi driver wifi_driver . auto_init () # method that establishes a wifi connection def wifi_connect (): for retry in range ( 10 ): try : print ( \"Establishing Link...\" ) wifi . link ( wifi_ssid , wifi_secu , wifi_pass ) print ( \"Link Established\" ) digitalWrite ( GREEN , HIGH ) break except Exception as e : print ( \"ooops, something wrong while linking :(\" , e ) digitalWrite ( GREEN , LOW ) digitalWrite ( RED , HIGH ) sleep ( 1000 ) digitalWrite ( RED , LOW ) sleep ( 1000 ) # connect to wifi wifi_connect () # establish a connection between device and wolkabout iot platform try : device = iot . Device ( device_key , device_password , actuator_references ) except Exception as e : print ( \"Something went wrong while creating the device: \" , e ) # PProvide implementation of a way to read and modify actuator state class ActuatorStatusProviderImpl ( iot . ActuatorStatusProvider ): def get_actuator_status ( reference ): if reference == actuator_references [ 0 ]: value = OC03 . getStatus () print ( value ) if value == 1 : return iot . ACTUATOR_STATE_READY , True else : return iot . ACTUATOR_STATE_READY , False class ActuationHandlerImpl ( iot . ActuationHandler ): def handle_actuation ( reference , value ): print ( \"Setting actuator \" + reference + \" to value: \" + str ( value )) if reference == actuator_references [ 0 ]: if value is False : OC03 . writePin ( False ) else : if value is True : OC03 . writePin ( True ) try : wolk = iot . Wolk ( device , actuation_handler = ActuationHandlerImpl , actuator_status_provider = ActuatorStatusProviderImpl , ) except Exception as e : print ( \"Something went wrong while creating the Wolk instance: \" , e ) # Establish a connection to the WolkAbout IoT Platform try : print ( \"Connecting to WolkAbout IoT Platform\" ) wolk . connect () print ( \"Done\" ) except Exception as e : print ( \"Something went wrong while connecting: \" , e ) publish_period = 5000 wolk . publish_actuator_status ( \"R\" ) try : while True : if not wifi . is_linked (): wifi_connect () sleep ( publish_period ) print ( \"Publishing sensor readings\" ) temperature = SW01 . get_temp () humidity = SW01 . get_hum () pressure = SW01 . get_press () print ( \"T\" , temperature , \"H\" , humidity , \"P\" , pressure ) wolk . add_sensor_reading ( \"T\" , temperature ) wolk . add_sensor_reading ( \"H\" , humidity ) wolk . add_sensor_reading ( \"P\" , pressure ) wolk . publish () except Exception as e : print ( \"Something went wrong: \" , e )","title":"Control OC03 xChip low voltage relay remotely"},{"location":"reference/libs/xinabox/oc03/docs/oc03/","text":"OC03 Module \u00b6 This is a Module for the OC03 Relay Out Low Voltage. The board is based off the PCA9554A I/O expander manufactured by Texas Instruments. The Module implements the PCA9554A to drive a solid state relay utilizing the OC03 xChip . The board uses I2C for communication. Data Sheets: PCA9554A TLP241A OC03 class \u00b6 class OC03 \u00b6 class OC03 ( self , drvname , addr = PCA9554A_I2C_ADDRESS , clk = 100000 ) Create an instance of the OC03 class. Arguments: drvname \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x38 clk \u2013 Clock speed, default 100kHz OC03.init \u00b6 init ( self , pins = PCA9554A_ALL_OUTPUTS_OFF ) Configures PCA9554A and sets all outputs False by default. Arguments: pins \u2013 initializes the relay state. Accepts True (relay closed) and False (relay open). OC03.writePin \u00b6 writePin ( self , state ) Determines the status of the relay output Arguments: state \u2013 accepts True (relay closed) and False (relay open). OC03.getStatus \u00b6 getStatus ( self ) Reads the status of the relay. returns the status of the relay.","title":"OC03 Module"},{"location":"reference/libs/xinabox/oc03/docs/oc03/#oc03-module","text":"This is a Module for the OC03 Relay Out Low Voltage. The board is based off the PCA9554A I/O expander manufactured by Texas Instruments. The Module implements the PCA9554A to drive a solid state relay utilizing the OC03 xChip . The board uses I2C for communication. Data Sheets: PCA9554A TLP241A","title":"OC03 Module"},{"location":"reference/libs/xinabox/oc03/docs/oc03/#oc03-class","text":"","title":"OC03 class"},{"location":"reference/libs/xinabox/oc03/docs/oc03/#class-oc03","text":"class OC03 ( self , drvname , addr = PCA9554A_I2C_ADDRESS , clk = 100000 ) Create an instance of the OC03 class. Arguments: drvname \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x38 clk \u2013 Clock speed, default 100kHz","title":"class OC03"},{"location":"reference/libs/xinabox/oc03/docs/oc03/#oc03init","text":"init ( self , pins = PCA9554A_ALL_OUTPUTS_OFF ) Configures PCA9554A and sets all outputs False by default. Arguments: pins \u2013 initializes the relay state. Accepts True (relay closed) and False (relay open).","title":"OC03.init"},{"location":"reference/libs/xinabox/oc03/docs/oc03/#oc03writepin","text":"writePin ( self , state ) Determines the status of the relay output Arguments: state \u2013 accepts True (relay closed) and False (relay open).","title":"OC03.writePin"},{"location":"reference/libs/xinabox/oc03/docs/oc03/#oc03getstatus","text":"getStatus ( self ) Reads the status of the relay. returns the status of the relay.","title":"OC03.getStatus"},{"location":"reference/libs/xinabox/oc05/docs/","text":"XinaBox OC05 \u00b6 The OC05 xChip is an 8-channel servo motor driver. It is based on the popular PCA9685 manufactured by NXP Semiconductor. It is supported by a BU33SD5 regulator to drive and accurately control up to 8 servo motors on a single module and act as system power supply. The module has 8 standard 2.54 mm (0.1\u201d) servo headers, plus 1 standard 2.54 mm (0.1\u201d) battery/BEC input header. Please note, OC05 and all other xChips is currently only supported in Zerynth Studio with XinaBox CW02 . Review the Quick Start guide for interfacing xChips. Technical Details \u00b6 PCA9685 \u00b6 8 PWM Drivers 1 MHz Fast-mode Plus compatible I2C-bus interface 4096-step (12-bit) linear programmable PWM output varying from fully off (default) to maximum PWM Internal power-on reset No output glitches on power-up Low standby current Support for 8 different I2C Addresses (Possible to connect up to 64 Servos) BU33SD5 \u00b6 Input Power Supply Voltage Range: 3.5V to 6.0V Output Current Range: 0 to 500mA Operating Temperature Range: -40\u2103 to +105\u2103 Output Voltage Accuracy: \u00b12.0% Circuit Current: 33\u00b5A Standby Current: 0\u03bcA Contents: OC05 Module OC05 class Examples servo control","title":"XinaBox OC05"},{"location":"reference/libs/xinabox/oc05/docs/#xinabox-oc05","text":"The OC05 xChip is an 8-channel servo motor driver. It is based on the popular PCA9685 manufactured by NXP Semiconductor. It is supported by a BU33SD5 regulator to drive and accurately control up to 8 servo motors on a single module and act as system power supply. The module has 8 standard 2.54 mm (0.1\u201d) servo headers, plus 1 standard 2.54 mm (0.1\u201d) battery/BEC input header. Please note, OC05 and all other xChips is currently only supported in Zerynth Studio with XinaBox CW02 . Review the Quick Start guide for interfacing xChips.","title":"XinaBox OC05"},{"location":"reference/libs/xinabox/oc05/docs/#technical-details","text":"","title":"Technical Details"},{"location":"reference/libs/xinabox/oc05/docs/#pca9685","text":"8 PWM Drivers 1 MHz Fast-mode Plus compatible I2C-bus interface 4096-step (12-bit) linear programmable PWM output varying from fully off (default) to maximum PWM Internal power-on reset No output glitches on power-up Low standby current Support for 8 different I2C Addresses (Possible to connect up to 64 Servos)","title":"PCA9685"},{"location":"reference/libs/xinabox/oc05/docs/#bu33sd5","text":"Input Power Supply Voltage Range: 3.5V to 6.0V Output Current Range: 0 to 500mA Operating Temperature Range: -40\u2103 to +105\u2103 Output Voltage Accuracy: \u00b12.0% Circuit Current: 33\u00b5A Standby Current: 0\u03bcA Contents: OC05 Module OC05 class Examples servo control","title":"BU33SD5"},{"location":"reference/libs/xinabox/oc05/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.xinabox.oc05. Servo Position \u00b6 This example positions a servo motor on channel 1 90\u00b0 to the left and right from a centre reference point according to a user input. The serial console accepts 'l', 'r' and 'c' for left, right and centre respectively. main.py ############################################### # This is an example for the OC05 8-channel # servo driver. # # A servo on channel 1 is positioned according # to a desired degree of rotation. ############################################### import streams from xinabox.oc05 import oc05 # create a serial console s = streams . serial () # OC05 instance OC05 = oc05 . OC05 ( I2C0 ) # configure OC05 with frequency of 60Hz OC05 . init ( 60 ) while True : print ( 'SERVO CONTROL:' ) print ( 'Enter \\' l \\' for left and press enter' ) print ( 'Enter \\' r \\' for right and press enter' ) print ( 'Enter \\' c \\' for centre and press enter' ) print () dir = s . readline () print ( dir ) if dir == 'l \\n ' : OC05 . setServoPosition ( 1 , 0 ) # position servo to the left print ( 'LEFT' ) elif dir == 'r \\n ' : OC05 . setServoPosition ( 1 , 180 ) # position servo to the right print ( 'RIGHT' ) elif dir == 'c \\n ' : OC05 . setServoPosition ( 1 , 90 ) # position servo in the centre print ( 'CENTRE' ) else : print ( 'Please input a valid direction' )","title":"Examples"},{"location":"reference/libs/xinabox/oc05/docs/examples/#examples","text":"The following are a list of examples for lib.xinabox.oc05.","title":"Examples"},{"location":"reference/libs/xinabox/oc05/docs/examples/#servo-position","text":"This example positions a servo motor on channel 1 90\u00b0 to the left and right from a centre reference point according to a user input. The serial console accepts 'l', 'r' and 'c' for left, right and centre respectively. main.py ############################################### # This is an example for the OC05 8-channel # servo driver. # # A servo on channel 1 is positioned according # to a desired degree of rotation. ############################################### import streams from xinabox.oc05 import oc05 # create a serial console s = streams . serial () # OC05 instance OC05 = oc05 . OC05 ( I2C0 ) # configure OC05 with frequency of 60Hz OC05 . init ( 60 ) while True : print ( 'SERVO CONTROL:' ) print ( 'Enter \\' l \\' for left and press enter' ) print ( 'Enter \\' r \\' for right and press enter' ) print ( 'Enter \\' c \\' for centre and press enter' ) print () dir = s . readline () print ( dir ) if dir == 'l \\n ' : OC05 . setServoPosition ( 1 , 0 ) # position servo to the left print ( 'LEFT' ) elif dir == 'r \\n ' : OC05 . setServoPosition ( 1 , 180 ) # position servo to the right print ( 'RIGHT' ) elif dir == 'c \\n ' : OC05 . setServoPosition ( 1 , 90 ) # position servo in the centre print ( 'CENTRE' ) else : print ( 'Please input a valid direction' )","title":"Servo Position"},{"location":"reference/libs/xinabox/oc05/docs/oc05/","text":"OC05 Module \u00b6 This is a Module for the OC05 8-channel Servo Driver. The xChip is based off the PCA9685 LED controller manufactured by NXP Semiconductors. The board uses I2C for communication. Data Sheets: PCA9685 BU33SD5 OC05 class \u00b6 class OC05 \u00b6 class OC05 ( self , drvname , addr = 0x78 , clk = 100000 ) Arguments: drvname \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x78 clk \u2013 Clock speed, default 100kHz OC05.init \u00b6 init ( outFreq ) Configures the registers of PCA9685 and sets the frequency of modulation. Call before using OC05 Arguments: outFreq \u2013 Frequency of servo motor, default 60 for typical analogue servos. \u00b4\u00b4setServoPosition(channelNum, degrees)` Positions a servo on a selected channel by the desired degrees. Arguments: channelNum \u2013 Number of the channel. Corresponds to channel numbers on OC05 (1-8) degrees \u2013 Desired rotational distance in degrees OC05.setPinPulseRange \u00b6 setPinPulseRange ( pinNum , onStep , offStep ) Sets the PWM output on a selected pin. Arguments: pinNum \u2013 Number of the channel. Corresponds to channel numbers on OC05 (1-8) onStep \u2013 The point at which to turn the PWM output ON (0-4095) offStep \u2013 The point at which to turn the PWM output OFF (0-4095) OC05.setCRServoPosition \u00b6 setCRServoPosition ( channelNum , speed ) Used to set the rotation speed of a continous rotation servo from -100% to 100%. Arguments: channelNum \u2013 Number of the channel. Corresponds to channel numbers on OC05 (1-8) speed \u2013 speed [-100-100] The speed (-100-100) to turn the servo at","title":"OC05 Module"},{"location":"reference/libs/xinabox/oc05/docs/oc05/#oc05-module","text":"This is a Module for the OC05 8-channel Servo Driver. The xChip is based off the PCA9685 LED controller manufactured by NXP Semiconductors. The board uses I2C for communication. Data Sheets: PCA9685 BU33SD5","title":"OC05 Module"},{"location":"reference/libs/xinabox/oc05/docs/oc05/#oc05-class","text":"","title":"OC05 class"},{"location":"reference/libs/xinabox/oc05/docs/oc05/#class-oc05","text":"class OC05 ( self , drvname , addr = 0x78 , clk = 100000 ) Arguments: drvname \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x78 clk \u2013 Clock speed, default 100kHz","title":"class OC05"},{"location":"reference/libs/xinabox/oc05/docs/oc05/#oc05init","text":"init ( outFreq ) Configures the registers of PCA9685 and sets the frequency of modulation. Call before using OC05 Arguments: outFreq \u2013 Frequency of servo motor, default 60 for typical analogue servos. \u00b4\u00b4setServoPosition(channelNum, degrees)` Positions a servo on a selected channel by the desired degrees. Arguments: channelNum \u2013 Number of the channel. Corresponds to channel numbers on OC05 (1-8) degrees \u2013 Desired rotational distance in degrees","title":"OC05.init"},{"location":"reference/libs/xinabox/oc05/docs/oc05/#oc05setpinpulserange","text":"setPinPulseRange ( pinNum , onStep , offStep ) Sets the PWM output on a selected pin. Arguments: pinNum \u2013 Number of the channel. Corresponds to channel numbers on OC05 (1-8) onStep \u2013 The point at which to turn the PWM output ON (0-4095) offStep \u2013 The point at which to turn the PWM output OFF (0-4095)","title":"OC05.setPinPulseRange"},{"location":"reference/libs/xinabox/oc05/docs/oc05/#oc05setcrservoposition","text":"setCRServoPosition ( channelNum , speed ) Used to set the rotation speed of a continous rotation servo from -100% to 100%. Arguments: channelNum \u2013 Number of the channel. Corresponds to channel numbers on OC05 (1-8) speed \u2013 speed [-100-100] The speed (-100-100) to turn the servo at","title":"OC05.setCRServoPosition"},{"location":"reference/libs/xinabox/sh01/docs/","text":"XinaBox SH01 \u00b6 The SH01 xChip is a multiple channel capacitive touch sensor controller. It is based on the CAP1296 manufactured by Microchip. Each sensor input is calibrated to compensate for system parasitic capacitance and automatically recalibrated to compensate for gradual environmental changes. In addition, the CAP1296 can be configured to detect proximity on one or more channels with an optional signal guard to reduce noise sensitivity. The CAP1296 includes Multiple Pattern Touch recognition that allows the user to select a specific set of buttons to be touched simultaneously. If this pattern is detected, a status bit is set and an interrupt is generated. Please note, SH01 and all other xChips is currently only supported in Zerynth Studio with XinaBox CW02 . Review the Quick Start guide for interfacing xChips. Technical Details \u00b6 CAP1296 \u00b6 Based on CAP1296 From Microchip Technology Multiple Button Pattern Detection Power Button Support Press and Hold Feature for Volume-like Applications I2C Operating Ambient Temperature Range: -40 to 125 \u00b0C Storage Temperature Range: -55 to 150 \u00b0C Contents: SH01 Module SH01 class Examples touch button","title":"XinaBox SH01"},{"location":"reference/libs/xinabox/sh01/docs/#xinabox-sh01","text":"The SH01 xChip is a multiple channel capacitive touch sensor controller. It is based on the CAP1296 manufactured by Microchip. Each sensor input is calibrated to compensate for system parasitic capacitance and automatically recalibrated to compensate for gradual environmental changes. In addition, the CAP1296 can be configured to detect proximity on one or more channels with an optional signal guard to reduce noise sensitivity. The CAP1296 includes Multiple Pattern Touch recognition that allows the user to select a specific set of buttons to be touched simultaneously. If this pattern is detected, a status bit is set and an interrupt is generated. Please note, SH01 and all other xChips is currently only supported in Zerynth Studio with XinaBox CW02 . Review the Quick Start guide for interfacing xChips.","title":"XinaBox SH01"},{"location":"reference/libs/xinabox/sh01/docs/#technical-details","text":"","title":"Technical Details"},{"location":"reference/libs/xinabox/sh01/docs/#cap1296","text":"Based on CAP1296 From Microchip Technology Multiple Button Pattern Detection Power Button Support Press and Hold Feature for Volume-like Applications I2C Operating Ambient Temperature Range: -40 to 125 \u00b0C Storage Temperature Range: -55 to 150 \u00b0C Contents: SH01 Module SH01 class Examples touch button","title":"CAP1296"},{"location":"reference/libs/xinabox/sh01/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.xinabox.sh01. Capacitive Touch Detection \u00b6 This example detects a touch on each of the four touch inputs on SH01. The response is printed out on the serial console. main.py ############################################## # This is an example for SH01 capacitive # touch sensor. # # A touch input is detected on SH01 and # printed out on the console. ############################################## import streams from xinabox.sh01 import sh01 streams . serial () # SH01 instance SH01 = sh01 . SH01 ( I2C0 ) # configure SH01 SH01 . init () while True : button = SH01 . touched () # return which button is pressed if button == 'square' : # square touched print ( 'SQUARE TOUCHED' ) elif button == 'triangle' : # triangle touched print ( 'TRIANGLE TOUCHED' ) elif button == 'circle' : # circle touched print ( 'CIRCLE TOUCHED' ) elif button == 'cross' : # cross touched print ( 'CROSS TOUCHED' ) sleep ( 100 )","title":"Examples"},{"location":"reference/libs/xinabox/sh01/docs/examples/#examples","text":"The following are a list of examples for lib.xinabox.sh01.","title":"Examples"},{"location":"reference/libs/xinabox/sh01/docs/examples/#capacitive-touch-detection","text":"This example detects a touch on each of the four touch inputs on SH01. The response is printed out on the serial console. main.py ############################################## # This is an example for SH01 capacitive # touch sensor. # # A touch input is detected on SH01 and # printed out on the console. ############################################## import streams from xinabox.sh01 import sh01 streams . serial () # SH01 instance SH01 = sh01 . SH01 ( I2C0 ) # configure SH01 SH01 . init () while True : button = SH01 . touched () # return which button is pressed if button == 'square' : # square touched print ( 'SQUARE TOUCHED' ) elif button == 'triangle' : # triangle touched print ( 'TRIANGLE TOUCHED' ) elif button == 'circle' : # circle touched print ( 'CIRCLE TOUCHED' ) elif button == 'cross' : # cross touched print ( 'CROSS TOUCHED' ) sleep ( 100 )","title":"Capacitive Touch Detection"},{"location":"reference/libs/xinabox/sh01/docs/sh01/","text":"SH01 Module \u00b6 This is a Module for the SH01 capacitive touch sensor. The board is based off the CAP1296 capacitive touch sensor controller manufactured by Microchip Technology. The board uses I2C for communication. Data Sheets: CAP1296 SH01 class \u00b6 class SH01 \u00b6 class SH01 ( i2cdrv , addr = 0x28 , clk = 100000 ) Creates an intance of a new SH01. Arguments: i2cdrv \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x28 clk \u2013 Clock speed, default 100kHz SH01.init \u00b6 init ( self ) Configures the registers of CAP1296. Call before using SH01. SH01.touched \u00b6 touched ( self ) Detects a touch on all four buttons. Returns the button touched as a string data type.","title":"SH01 Module"},{"location":"reference/libs/xinabox/sh01/docs/sh01/#sh01-module","text":"This is a Module for the SH01 capacitive touch sensor. The board is based off the CAP1296 capacitive touch sensor controller manufactured by Microchip Technology. The board uses I2C for communication. Data Sheets: CAP1296","title":"SH01 Module"},{"location":"reference/libs/xinabox/sh01/docs/sh01/#sh01-class","text":"","title":"SH01 class"},{"location":"reference/libs/xinabox/sh01/docs/sh01/#class-sh01","text":"class SH01 ( i2cdrv , addr = 0x28 , clk = 100000 ) Creates an intance of a new SH01. Arguments: i2cdrv \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x28 clk \u2013 Clock speed, default 100kHz","title":"class SH01"},{"location":"reference/libs/xinabox/sh01/docs/sh01/#sh01init","text":"init ( self ) Configures the registers of CAP1296. Call before using SH01.","title":"SH01.init"},{"location":"reference/libs/xinabox/sh01/docs/sh01/#sh01touched","text":"touched ( self ) Detects a touch on all four buttons. Returns the button touched as a string data type.","title":"SH01.touched"},{"location":"reference/libs/xinabox/sl01/docs/","text":"XinaBox SL01 \u00b6 The SL01 xChip is a UV radiation and ambient light level sensor. It is based on the VEML6075 and TSL4531 . VEML6075 on the SL01 is capable of measuring UVA and UVB radiation, in turn, providing an acccurate UV Index. TSL4531 is a light sensor that is capable of measuring the luminosity (Wide Dynamic Range \u2014 3 lux to 220k lux) (visual brightness). Please note, SL01 and all other xChips is currently only supported in Zerynth Studio with XinaBox CW02 . Review the Quick Start guide for interfacing xChips. Technical Details \u00b6 VEML6075 \u00b6 Peak Sensitivity UVA, UVB(nm):365, 330 Temperature range: -40\u00b0C to 85\u00b0C Three User-Selectable Integration Times (400 ms, 200 ms, and 100 ms) TSL4331 \u00b6 Wide Dynamic Range \u2014 3 lux to 220k lux Simple Direct Lux Output Temperature range: -40\u00b0C to 85\u00b0C Three User-Selectable Integration Times (400 ms, 200 ms, and 100 ms) Contents: SL01 Module VEML6075 class TSL4531 class Examples lux measurements uv measurements","title":"XinaBox SL01"},{"location":"reference/libs/xinabox/sl01/docs/#xinabox-sl01","text":"The SL01 xChip is a UV radiation and ambient light level sensor. It is based on the VEML6075 and TSL4531 . VEML6075 on the SL01 is capable of measuring UVA and UVB radiation, in turn, providing an acccurate UV Index. TSL4531 is a light sensor that is capable of measuring the luminosity (Wide Dynamic Range \u2014 3 lux to 220k lux) (visual brightness). Please note, SL01 and all other xChips is currently only supported in Zerynth Studio with XinaBox CW02 . Review the Quick Start guide for interfacing xChips.","title":"XinaBox SL01"},{"location":"reference/libs/xinabox/sl01/docs/#technical-details","text":"","title":"Technical Details"},{"location":"reference/libs/xinabox/sl01/docs/#veml6075","text":"Peak Sensitivity UVA, UVB(nm):365, 330 Temperature range: -40\u00b0C to 85\u00b0C Three User-Selectable Integration Times (400 ms, 200 ms, and 100 ms)","title":"VEML6075"},{"location":"reference/libs/xinabox/sl01/docs/#tsl4331","text":"Wide Dynamic Range \u2014 3 lux to 220k lux Simple Direct Lux Output Temperature range: -40\u00b0C to 85\u00b0C Three User-Selectable Integration Times (400 ms, 200 ms, and 100 ms) Contents: SL01 Module VEML6075 class TSL4531 class Examples lux measurements uv measurements","title":"TSL4331"},{"location":"reference/libs/xinabox/sl01/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.xinabox.sl01. LUX Measurement \u00b6 This example reads the ambient light level from TSL4531 as LUX and prints it out on the serial console. main.py ############################################## # This is an example for SL01 UV and light # sensor. # # Ambient light level is measured and # printed out on the console. ############################################## import streams from xinabox.sl01 import sl01 streams . serial () # SL01 instance SL01_T = sl01 . TSL4531 ( I2C0 ) # configure and start TSL4531 SL01_T . init () while True : lux = SL01_T . getLUX () #return ambient light level as lux print ( 'Light level: ' , lux , ' LUX' ) sleep ( 2000 ) UV Measurements \u00b6 This example reads the UVA, UVB and UV Index from VEML6075 and prints it out on the serial console. main.py ############################################## # This is an example for SL01 UV and light # sensor. # # UV data is read and printed out on the # console. ############################################## import streams from xinabox.sl01 import sl01 streams . serial () # SL01 instance SL01_V = sl01 . VEML6075 ( I2C0 ) # configure and start SL01 SL01_V . init () while True : uva = SL01_V . getUVA () # return uva intensity uvb = SL01_V . getUVB () # return uvb intensity uvi = SL01_V . getUVIndex () # return uv index print ( 'UVA Intensity: ' , uva , ' uW/m^2 \\n\\n ' ) print ( 'UVB Intensity: ' , uvb , ' uW/m^2 \\n\\n ' ) print ( 'UV Index : ' , uvi , ' \\n\\n ' ) sleep ( 2000 )","title":"Examples"},{"location":"reference/libs/xinabox/sl01/docs/examples/#examples","text":"The following are a list of examples for lib.xinabox.sl01.","title":"Examples"},{"location":"reference/libs/xinabox/sl01/docs/examples/#lux-measurement","text":"This example reads the ambient light level from TSL4531 as LUX and prints it out on the serial console. main.py ############################################## # This is an example for SL01 UV and light # sensor. # # Ambient light level is measured and # printed out on the console. ############################################## import streams from xinabox.sl01 import sl01 streams . serial () # SL01 instance SL01_T = sl01 . TSL4531 ( I2C0 ) # configure and start TSL4531 SL01_T . init () while True : lux = SL01_T . getLUX () #return ambient light level as lux print ( 'Light level: ' , lux , ' LUX' ) sleep ( 2000 )","title":"LUX Measurement"},{"location":"reference/libs/xinabox/sl01/docs/examples/#uv-measurements","text":"This example reads the UVA, UVB and UV Index from VEML6075 and prints it out on the serial console. main.py ############################################## # This is an example for SL01 UV and light # sensor. # # UV data is read and printed out on the # console. ############################################## import streams from xinabox.sl01 import sl01 streams . serial () # SL01 instance SL01_V = sl01 . VEML6075 ( I2C0 ) # configure and start SL01 SL01_V . init () while True : uva = SL01_V . getUVA () # return uva intensity uvb = SL01_V . getUVB () # return uvb intensity uvi = SL01_V . getUVIndex () # return uv index print ( 'UVA Intensity: ' , uva , ' uW/m^2 \\n\\n ' ) print ( 'UVB Intensity: ' , uvb , ' uW/m^2 \\n\\n ' ) print ( 'UV Index : ' , uvi , ' \\n\\n ' ) sleep ( 2000 )","title":"UV Measurements"},{"location":"reference/libs/xinabox/sl01/docs/sl01/","text":"SL01 Module \u00b6 This is a Module for the SL01 UVA, UVB, UV Index and luminosity sensor. The xChip is based on the VEML6075 UVA and UVB Light Sensor and the TSL4531 digital ambient light sensor. The board uses I2C for communication. Data Sheets: VEML6075 TSL4531 VEML6075 class \u00b6 class VEML6075 \u00b6 class VEML6075 ( self , drvname , addr = 0x10 , clk = 100000 ) Create an instance of the VEML6075 class. Arguments: drvname \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x10 clk \u2013 Clock speed, default 100kHz VEML6075.init \u00b6 init () Configure registers of VEML6075 for UV measurements. Call after instantiating VEML6075 class. Exception raised if unsuccessful. VEML6075.getUVA \u00b6 getUVA () Reads the UVA value and returns it. Return the real UVA value as a float data type. VEML6075.getUVB \u00b6 getUVB () Reads the UVB value and returns it. Return the real UVB value as a float data type. VEML6075.getUVIndex \u00b6 getUVIndex () Reads the UV Index value and returns it. Return the real UV index as a float. TSL4531 class \u00b6 class TSL4531 \u00b6 class TSL4531 ( self , drvname , addr = 0x29 , clk = 100000 ) Create an instance of the TSL4531 class. Arguments: drvname \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x29 clk \u2013 Clock speed, default 100kHz TSL4531.init \u00b6 init () Configure registers of TSL4531 for light measurement. Call after instantiating TSL4531 class. Exception raised if unsuccessful. TSL4531.getLUX \u00b6 getLUX () Reads the luminosity value and returns it in LUX. Return the LUX value as a float.","title":"SL01 Module"},{"location":"reference/libs/xinabox/sl01/docs/sl01/#sl01-module","text":"This is a Module for the SL01 UVA, UVB, UV Index and luminosity sensor. The xChip is based on the VEML6075 UVA and UVB Light Sensor and the TSL4531 digital ambient light sensor. The board uses I2C for communication. Data Sheets: VEML6075 TSL4531","title":"SL01 Module"},{"location":"reference/libs/xinabox/sl01/docs/sl01/#veml6075-class","text":"","title":"VEML6075 class"},{"location":"reference/libs/xinabox/sl01/docs/sl01/#class-veml6075","text":"class VEML6075 ( self , drvname , addr = 0x10 , clk = 100000 ) Create an instance of the VEML6075 class. Arguments: drvname \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x10 clk \u2013 Clock speed, default 100kHz","title":"class VEML6075"},{"location":"reference/libs/xinabox/sl01/docs/sl01/#veml6075init","text":"init () Configure registers of VEML6075 for UV measurements. Call after instantiating VEML6075 class. Exception raised if unsuccessful.","title":"VEML6075.init"},{"location":"reference/libs/xinabox/sl01/docs/sl01/#veml6075getuva","text":"getUVA () Reads the UVA value and returns it. Return the real UVA value as a float data type.","title":"VEML6075.getUVA"},{"location":"reference/libs/xinabox/sl01/docs/sl01/#veml6075getuvb","text":"getUVB () Reads the UVB value and returns it. Return the real UVB value as a float data type.","title":"VEML6075.getUVB"},{"location":"reference/libs/xinabox/sl01/docs/sl01/#veml6075getuvindex","text":"getUVIndex () Reads the UV Index value and returns it. Return the real UV index as a float.","title":"VEML6075.getUVIndex"},{"location":"reference/libs/xinabox/sl01/docs/sl01/#tsl4531-class","text":"","title":"TSL4531 class"},{"location":"reference/libs/xinabox/sl01/docs/sl01/#class-tsl4531","text":"class TSL4531 ( self , drvname , addr = 0x29 , clk = 100000 ) Create an instance of the TSL4531 class. Arguments: drvname \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x29 clk \u2013 Clock speed, default 100kHz","title":"class TSL4531"},{"location":"reference/libs/xinabox/sl01/docs/sl01/#tsl4531init","text":"init () Configure registers of TSL4531 for light measurement. Call after instantiating TSL4531 class. Exception raised if unsuccessful.","title":"TSL4531.init"},{"location":"reference/libs/xinabox/sl01/docs/sl01/#tsl4531getlux","text":"getLUX () Reads the luminosity value and returns it in LUX. Return the LUX value as a float.","title":"TSL4531.getLUX"},{"location":"reference/libs/xinabox/sl06/docs/","text":"XinaBox SL06 \u00b6 The SL06 xChip features advanced Gesture detection, Proximity detection, Digital Ambient Light Sense (ALS) and Colour Sense (RGBC). It is based on the popular APDS9960 manufactured by Avago Technologies. Please note, SL06 and all other xChips is currently only supported in Zerynth Studio with XinaBox CW02 . Review the Quick Start guide for interfacing xChips. Technical Details \u00b6 APDS-9960 \u00b6 Ambient Light and RGB Color Sensing Ambient Light and RGB Color Sensing UV and IR blocking filters Programmable gain and integration time Very high sensitivity \u2013 Ideally suited for operation behind dark glass Proximity Sensing Trimmed to provide consistent reading Ambient light rejection Offset compensation Programmable driver for IR LED current Saturation indicator bit Complex Gesture Sensing Four separate diodes sensitive to different directions Ambient light rejection Offset compensation Programmable driver for IR LED current 32 dataset storage FIFO Interrupt driven I2C-bus communication I2C-bus Fast Mode Compatible Interface Data Rates up to 400 kHz Contents: SL06 Module SL06 class Examples ambient light colour gesture proximity","title":"XinaBox SL06"},{"location":"reference/libs/xinabox/sl06/docs/#xinabox-sl06","text":"The SL06 xChip features advanced Gesture detection, Proximity detection, Digital Ambient Light Sense (ALS) and Colour Sense (RGBC). It is based on the popular APDS9960 manufactured by Avago Technologies. Please note, SL06 and all other xChips is currently only supported in Zerynth Studio with XinaBox CW02 . Review the Quick Start guide for interfacing xChips.","title":"XinaBox SL06"},{"location":"reference/libs/xinabox/sl06/docs/#technical-details","text":"","title":"Technical Details"},{"location":"reference/libs/xinabox/sl06/docs/#apds-9960","text":"Ambient Light and RGB Color Sensing Ambient Light and RGB Color Sensing UV and IR blocking filters Programmable gain and integration time Very high sensitivity \u2013 Ideally suited for operation behind dark glass Proximity Sensing Trimmed to provide consistent reading Ambient light rejection Offset compensation Programmable driver for IR LED current Saturation indicator bit Complex Gesture Sensing Four separate diodes sensitive to different directions Ambient light rejection Offset compensation Programmable driver for IR LED current 32 dataset storage FIFO Interrupt driven I2C-bus communication I2C-bus Fast Mode Compatible Interface Data Rates up to 400 kHz Contents: SL06 Module SL06 class Examples ambient light colour gesture proximity","title":"APDS-9960"},{"location":"reference/libs/xinabox/sl06/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.xinabox.sl06. Ambient Light Detection \u00b6 This example enables SL06 as a light sensor. The ambient light level is measured and printed out on the serial console. main.py ############################################### # This is an example for the SL06 ambient # light, colour, gesture and proximity # sensor. # # SL06 is enabled as a light sensor. # # The ambient light level is measured and # displayed on the serial console. ############################################### import streams from xinabox.sl06 import sl06 streams . serial () # SL06 instance SL06 = sl06 . SL06 ( I2C0 ) # configure SL06 SL06 . init () # enable SL06 for light sensing SL06 . enableLightSensor () while True : light = SL06 . getAmbientLight () # read the the ambient light level print ( 'Ambient Light Level: ' , light ) sleep ( 2000 ) Colour Detection \u00b6 This example uses SL06 as a colour sensor. Red, green and blue light levels are detected and printed out on the console. main.py ############################################### # This is an example for the SL06 ambient # light, colour, gesture and proximity # sensor. # # SL06 is enabled as a light sensor. # # Place an object in front of the sensor # to determine how much red, green and blue # light it possesses. ############################################### import streams from xinabox.sl06 import sl06 streams . serial () # SL06 instance SL06 = sl06 . SL06 ( I2C0 ) # configure SL06 SL06 . init () # enable SL06 for light sensing SL06 . enableLightSensor () while True : red = SL06 . getRedLight () # read red light level green = SL06 . getGreenLight () # read green light level blue = SL06 . getBlueLight () # read blue light level print ( 'RED :' , red ) print ( 'GREEN :' , green ) print ( 'BLUE :' , blue ) sleep ( 2000 ) Gesture Detection \u00b6 This example enables SL06 as a gesture sensor. A swipe across the sensor will reveal the direction of your swipe on the serial console. main.py ############################################### # This is an example for the SL06 ambient # light, colour, gesture and proximity # sensor. # # SL06 is enabled as a gesture sensor. # # Swipe your hand across the sensor for a # reading to be printed on the console. ############################################### import streams from xinabox.sl06 import sl06 streams . serial () # SL06 instance SL06 = sl06 . SL06 ( I2C0 ) # configure SL06 SL06 . init () # enable SL06 for gesture sensing SL06 . enableGestureSensor () while True : if SL06 . isGestureAvailable (): # check for gesture dir = SL06 . getGesture () # read direction print ( dir ) # print direction on console sleep ( 100 ) Proximity Detection \u00b6 This example enables SL06 as a proximity sensor. A proximity level between between an object and the sensor is detected and printed out on the console. main.py ############################################### # This is an example for the SL06 ambient # light, colour, gesture and proximity # sensor. # # SL06 is enabled as a proximity sensor. # # Move and object to and away from the sensor # within a 10cm range. The proximity level # between the object and sensor is detected. ############################################### import streams from xinabox.sl06 import sl06 streams . serial () # SL06 instance SL06 = sl06 . SL06 ( I2C0 ) # configure SL06 SL06 . init () # enable SL06 for proximity sensing SL06 . enableProximitySensor () while True : prox = SL06 . getProximity () # read the proximity level print ( prox ) sleep ( 2000 )","title":"Examples"},{"location":"reference/libs/xinabox/sl06/docs/examples/#examples","text":"The following are a list of examples for lib.xinabox.sl06.","title":"Examples"},{"location":"reference/libs/xinabox/sl06/docs/examples/#ambient-light-detection","text":"This example enables SL06 as a light sensor. The ambient light level is measured and printed out on the serial console. main.py ############################################### # This is an example for the SL06 ambient # light, colour, gesture and proximity # sensor. # # SL06 is enabled as a light sensor. # # The ambient light level is measured and # displayed on the serial console. ############################################### import streams from xinabox.sl06 import sl06 streams . serial () # SL06 instance SL06 = sl06 . SL06 ( I2C0 ) # configure SL06 SL06 . init () # enable SL06 for light sensing SL06 . enableLightSensor () while True : light = SL06 . getAmbientLight () # read the the ambient light level print ( 'Ambient Light Level: ' , light ) sleep ( 2000 )","title":"Ambient Light Detection"},{"location":"reference/libs/xinabox/sl06/docs/examples/#colour-detection","text":"This example uses SL06 as a colour sensor. Red, green and blue light levels are detected and printed out on the console. main.py ############################################### # This is an example for the SL06 ambient # light, colour, gesture and proximity # sensor. # # SL06 is enabled as a light sensor. # # Place an object in front of the sensor # to determine how much red, green and blue # light it possesses. ############################################### import streams from xinabox.sl06 import sl06 streams . serial () # SL06 instance SL06 = sl06 . SL06 ( I2C0 ) # configure SL06 SL06 . init () # enable SL06 for light sensing SL06 . enableLightSensor () while True : red = SL06 . getRedLight () # read red light level green = SL06 . getGreenLight () # read green light level blue = SL06 . getBlueLight () # read blue light level print ( 'RED :' , red ) print ( 'GREEN :' , green ) print ( 'BLUE :' , blue ) sleep ( 2000 )","title":"Colour Detection"},{"location":"reference/libs/xinabox/sl06/docs/examples/#gesture-detection","text":"This example enables SL06 as a gesture sensor. A swipe across the sensor will reveal the direction of your swipe on the serial console. main.py ############################################### # This is an example for the SL06 ambient # light, colour, gesture and proximity # sensor. # # SL06 is enabled as a gesture sensor. # # Swipe your hand across the sensor for a # reading to be printed on the console. ############################################### import streams from xinabox.sl06 import sl06 streams . serial () # SL06 instance SL06 = sl06 . SL06 ( I2C0 ) # configure SL06 SL06 . init () # enable SL06 for gesture sensing SL06 . enableGestureSensor () while True : if SL06 . isGestureAvailable (): # check for gesture dir = SL06 . getGesture () # read direction print ( dir ) # print direction on console sleep ( 100 )","title":"Gesture Detection"},{"location":"reference/libs/xinabox/sl06/docs/examples/#proximity-detection","text":"This example enables SL06 as a proximity sensor. A proximity level between between an object and the sensor is detected and printed out on the console. main.py ############################################### # This is an example for the SL06 ambient # light, colour, gesture and proximity # sensor. # # SL06 is enabled as a proximity sensor. # # Move and object to and away from the sensor # within a 10cm range. The proximity level # between the object and sensor is detected. ############################################### import streams from xinabox.sl06 import sl06 streams . serial () # SL06 instance SL06 = sl06 . SL06 ( I2C0 ) # configure SL06 SL06 . init () # enable SL06 for proximity sensing SL06 . enableProximitySensor () while True : prox = SL06 . getProximity () # read the proximity level print ( prox ) sleep ( 2000 )","title":"Proximity Detection"},{"location":"reference/libs/xinabox/sl06/docs/sl06/","text":"SL06 Module \u00b6 This is a module for the SL06 Digital Proximity, Ambient Light, RGB and Gesture Sensor. The board is based off the APDS-9960 manufactured by Avago Technologies. The board uses I2C for communication. Data Sheets: APDS-9960 SL06 class \u00b6 class SL06(drvname, addr=0x39, clk=100000) Creates an intance of the SL06 class. Arguments: drvname \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x39 clk \u2013 Clock speed, default 100kHz init() Configures APDS-9960 by initializing registers to its default values. Call immediately after instantiating the SL06 class. Raises an exeption if any error occurs during initialization. Returns True if initialization is successful. getMode() Returns the mode of the sensor. setMode(mode, enable) Sets the desired mode on APDS9960. Exception raised if unsuccessful. Arguments: mode \u2013 desired mode. AMBIENT_LIGHT, PROXIMITY, GESTURE. enable \u2013 accepts 1 or 0 Returns True if successful. enableLightSensor(interrupts) Begins the light sensor. Exception raised if unsuccessful. Arguments: interrupts \u2013 Input True to enable hardware interrupt on light level. Defaults to False. disableLightSensor() Disables the light sensor. enableProximitySensor(interrupts) Begins the proximity sensor. Exception raised if unsuccessful. Arguments: interrupts \u2013 Input True to enable hardware interrupt on proximity detection. Defaults to False. disableProximitySensor() Disables the proximity sensor. enableGestureSensor(interrupts) Begins the gesture sensor. Exception raised if unsuccessful. Arguments: interrupts \u2013 Input True to enable hardware interrupt on gesture detection. Defaults to False. disableGestureSensor() Disables the gesture sensor. Exception raised if unsuccessful isGestureAvailable() Checks whether a gesture was detected. getGesture() Processes a gesture event and returns best guessed gesture. Returns the gesture direction as a string literal. enablePower() Turns APDS9960 on. disablePower() Turns APDS9960 off. getAmbientLight() Reads the ambient light measurement. Exception raised if unsuccessful. Returns the ambient light measurement. \u00b4\u00b4getRedLight()` Reads the red light level. Exception raised if unsuccessful. Returns the red light level. getBlueLight() Reads the blue light level. Exception raised if unsuccessful. Returns the blue light level. getGreenLight() Reads the green light level. Exception raised if unsuccessful. Returns the green light level. getProximity() Reads the proximity level. Exception raised if unsuccessful. Returns the proximity level.","title":"SL06 Module"},{"location":"reference/libs/xinabox/sl06/docs/sl06/#sl06-module","text":"This is a module for the SL06 Digital Proximity, Ambient Light, RGB and Gesture Sensor. The board is based off the APDS-9960 manufactured by Avago Technologies. The board uses I2C for communication. Data Sheets: APDS-9960","title":"SL06 Module"},{"location":"reference/libs/xinabox/sl06/docs/sl06/#sl06-class","text":"class SL06(drvname, addr=0x39, clk=100000) Creates an intance of the SL06 class. Arguments: drvname \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x39 clk \u2013 Clock speed, default 100kHz init() Configures APDS-9960 by initializing registers to its default values. Call immediately after instantiating the SL06 class. Raises an exeption if any error occurs during initialization. Returns True if initialization is successful. getMode() Returns the mode of the sensor. setMode(mode, enable) Sets the desired mode on APDS9960. Exception raised if unsuccessful. Arguments: mode \u2013 desired mode. AMBIENT_LIGHT, PROXIMITY, GESTURE. enable \u2013 accepts 1 or 0 Returns True if successful. enableLightSensor(interrupts) Begins the light sensor. Exception raised if unsuccessful. Arguments: interrupts \u2013 Input True to enable hardware interrupt on light level. Defaults to False. disableLightSensor() Disables the light sensor. enableProximitySensor(interrupts) Begins the proximity sensor. Exception raised if unsuccessful. Arguments: interrupts \u2013 Input True to enable hardware interrupt on proximity detection. Defaults to False. disableProximitySensor() Disables the proximity sensor. enableGestureSensor(interrupts) Begins the gesture sensor. Exception raised if unsuccessful. Arguments: interrupts \u2013 Input True to enable hardware interrupt on gesture detection. Defaults to False. disableGestureSensor() Disables the gesture sensor. Exception raised if unsuccessful isGestureAvailable() Checks whether a gesture was detected. getGesture() Processes a gesture event and returns best guessed gesture. Returns the gesture direction as a string literal. enablePower() Turns APDS9960 on. disablePower() Turns APDS9960 off. getAmbientLight() Reads the ambient light measurement. Exception raised if unsuccessful. Returns the ambient light measurement. \u00b4\u00b4getRedLight()` Reads the red light level. Exception raised if unsuccessful. Returns the red light level. getBlueLight() Reads the blue light level. Exception raised if unsuccessful. Returns the blue light level. getGreenLight() Reads the green light level. Exception raised if unsuccessful. Returns the green light level. getProximity() Reads the proximity level. Exception raised if unsuccessful. Returns the proximity level.","title":"SL06 class"},{"location":"reference/libs/xinabox/su02/docs/","text":"XinaBox SU02 \u00b6 The SU02 xChip is a digital input. It is based on the ADC081C021 manufactured by texas Instruments. Please note, SU02 and all other xChips is currently only supported in Zerynth Studio with XinaBox CW02 . Review the Quick Start guide for interfacing xChips. Technical Details \u00b6 ADC081C021 \u00b6 I2C-Compatible 2-Wire Interface Which Supports Standard (100 kHz), Fast (400 kHz), and High Speed (3.4 MHz) modes Out-of-Range Alert Function Automatic Power-Down Mode While Not Converting 4 hardware selectable I2C addresses Contents: SU02 Module SU02 class Examples read input","title":"XinaBox SU02"},{"location":"reference/libs/xinabox/su02/docs/#xinabox-su02","text":"The SU02 xChip is a digital input. It is based on the ADC081C021 manufactured by texas Instruments. Please note, SU02 and all other xChips is currently only supported in Zerynth Studio with XinaBox CW02 . Review the Quick Start guide for interfacing xChips.","title":"XinaBox SU02"},{"location":"reference/libs/xinabox/su02/docs/#technical-details","text":"","title":"Technical Details"},{"location":"reference/libs/xinabox/su02/docs/#adc081c021","text":"I2C-Compatible 2-Wire Interface Which Supports Standard (100 kHz), Fast (400 kHz), and High Speed (3.4 MHz) modes Out-of-Range Alert Function Automatic Power-Down Mode While Not Converting 4 hardware selectable I2C addresses Contents: SU02 Module SU02 class Examples read input","title":"ADC081C021"},{"location":"reference/libs/xinabox/su02/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.xinabox.su02.S Read Input State \u00b6 This example reads the input state of a switch connected to the terminals on SU02. Screw one end of the switch in a terminal and the other end in the remaining terminal. Flip the switch on and off to see the input change. No external power is required. main.py ############################################### # This is an example for the SU02 digital # input. # # The state is read and displayed over the # serial console. ############################################### import streams from xinabox.su02 import su02 streams . serial () # SU02 instance SU02 = su02 . SU02 ( I2C0 ) # configure SU02 SU02 . init () while True : state = SU02 . getState () # read the state at the input print ( state ) sleep ( 1000 )","title":"Examples"},{"location":"reference/libs/xinabox/su02/docs/examples/#examples","text":"The following are a list of examples for lib.xinabox.su02.S","title":"Examples"},{"location":"reference/libs/xinabox/su02/docs/examples/#read-input-state","text":"This example reads the input state of a switch connected to the terminals on SU02. Screw one end of the switch in a terminal and the other end in the remaining terminal. Flip the switch on and off to see the input change. No external power is required. main.py ############################################### # This is an example for the SU02 digital # input. # # The state is read and displayed over the # serial console. ############################################### import streams from xinabox.su02 import su02 streams . serial () # SU02 instance SU02 = su02 . SU02 ( I2C0 ) # configure SU02 SU02 . init () while True : state = SU02 . getState () # read the state at the input print ( state ) sleep ( 1000 )","title":"Read Input State"},{"location":"reference/libs/xinabox/su02/docs/su02/","text":"SU02 Module \u00b6 This is a Module for the SU02 digital input. The xChip is based on the ADC081C021 analogue to digital converter manufactured by Texas Instruments. The board uses I2C for communication. Data Sheets: ADC081C021 SU02 class \u00b6 class SU02 \u00b6 class SU02 ( self , drvname , addr = 0x55 , clk = 100000 ) Create an instance of the SU02 class. Arguments: drvname \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x55 clk \u2013 Clock speed, default 100kHz SU02.init \u00b6 init () Configures the registers of ADC081C021. Call after instantiation of the class. Exception raised if unsuccessful SU02.getState \u00b6 getState () Reads the state of the input. Returns False for Open and True for closed. SU02.getVolatge \u00b6 getVolatge () Reads the voltage on the input. Returns the voltage.","title":"SU02 Module"},{"location":"reference/libs/xinabox/su02/docs/su02/#su02-module","text":"This is a Module for the SU02 digital input. The xChip is based on the ADC081C021 analogue to digital converter manufactured by Texas Instruments. The board uses I2C for communication. Data Sheets: ADC081C021","title":"SU02 Module"},{"location":"reference/libs/xinabox/su02/docs/su02/#su02-class","text":"","title":"SU02 class"},{"location":"reference/libs/xinabox/su02/docs/su02/#class-su02","text":"class SU02 ( self , drvname , addr = 0x55 , clk = 100000 ) Create an instance of the SU02 class. Arguments: drvname \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x55 clk \u2013 Clock speed, default 100kHz","title":"class SU02"},{"location":"reference/libs/xinabox/su02/docs/su02/#su02init","text":"init () Configures the registers of ADC081C021. Call after instantiation of the class. Exception raised if unsuccessful","title":"SU02.init"},{"location":"reference/libs/xinabox/su02/docs/su02/#su02getstate","text":"getState () Reads the state of the input. Returns False for Open and True for closed.","title":"SU02.getState"},{"location":"reference/libs/xinabox/su02/docs/su02/#su02getvolatge","text":"getVolatge () Reads the voltage on the input. Returns the voltage.","title":"SU02.getVolatge"},{"location":"reference/libs/xinabox/sw01/docs/","text":"XinaBox SW01 \u00b6 The SW01 xChip is equipped with a weather sensor that is capable of measuring the temperature, humidity and atmospheric pressure. It is based on the BME280 manufactured by Bosch. The humidity sensor provides an extremely fast responce time for fast context awareness application and high overall accuracy over a wide temperature range. The pressure sensor is an absolute barometric pressure sensor with extremely high accuracy and resolution. The integrated temperature sensor has been optimized for lowest noise and highest resolution. Its output is used for temperature compensation of the pressure and humidity sensors and can also be used for estimation of the ambient temperature. Please note, SW01 and all other xChips is currently only supported in Zerynth Studio with XinaBox CW02 . Review the Quick Start guide for interfacing xChips. Technical Details \u00b6 BME280 \u00b6 Operating Range: Temperature: -40 to 85\u00b0C Relative Humidity: 0 to 100% Pressure: 300 to 1100 hPa Humidity Sensor and Pressure Sensor can be Independently Enabled/ Disabled. 3 Power Modes: Sleep Mode. Normal Mode. Forced Mode. Contents: SW01 Module SW01 class Examples environmental data","title":"XinaBox SW01"},{"location":"reference/libs/xinabox/sw01/docs/#xinabox-sw01","text":"The SW01 xChip is equipped with a weather sensor that is capable of measuring the temperature, humidity and atmospheric pressure. It is based on the BME280 manufactured by Bosch. The humidity sensor provides an extremely fast responce time for fast context awareness application and high overall accuracy over a wide temperature range. The pressure sensor is an absolute barometric pressure sensor with extremely high accuracy and resolution. The integrated temperature sensor has been optimized for lowest noise and highest resolution. Its output is used for temperature compensation of the pressure and humidity sensors and can also be used for estimation of the ambient temperature. Please note, SW01 and all other xChips is currently only supported in Zerynth Studio with XinaBox CW02 . Review the Quick Start guide for interfacing xChips.","title":"XinaBox SW01"},{"location":"reference/libs/xinabox/sw01/docs/#technical-details","text":"","title":"Technical Details"},{"location":"reference/libs/xinabox/sw01/docs/#bme280","text":"Operating Range: Temperature: -40 to 85\u00b0C Relative Humidity: 0 to 100% Pressure: 300 to 1100 hPa Humidity Sensor and Pressure Sensor can be Independently Enabled/ Disabled. 3 Power Modes: Sleep Mode. Normal Mode. Forced Mode. Contents: SW01 Module SW01 class Examples environmental data","title":"BME280"},{"location":"reference/libs/xinabox/sw01/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.xinabox.sw01. Environmental Data Measurement \u00b6 This example measures ambient temperature, humidity and atmoshperic pressure and prints it out on the serial console. main.py ############################################## # This is an example for the SW01 # weather sensor # # Ambient temperature, humidity and pressure # is measured and printed out on the console. ############################################## import streams from xinabox.sw01 import sw01 streams . serial () # SW01 instance SW01 = sw01 . SW01 ( I2C0 ) while True : tempC = SW01 . getTempC () # return temp in degree celcius tempF = SW01 . getTempF () # return temp in degree fahrenheit hum = SW01 . getHumidity () # return humidity in percentage pres = SW01 . getPressure () # return pressure in hectopascal print ( 'Temperature: ' , tempC , ' C' ) print ( 'Temperature: ' , tempF , ' F' ) print ( 'Humidity :' , hum , ' %' ) print ( 'Pressure :' , pres , ' hpa' ) sleep ( 1000 )","title":"Examples"},{"location":"reference/libs/xinabox/sw01/docs/examples/#examples","text":"The following are a list of examples for lib.xinabox.sw01.","title":"Examples"},{"location":"reference/libs/xinabox/sw01/docs/examples/#environmental-data-measurement","text":"This example measures ambient temperature, humidity and atmoshperic pressure and prints it out on the serial console. main.py ############################################## # This is an example for the SW01 # weather sensor # # Ambient temperature, humidity and pressure # is measured and printed out on the console. ############################################## import streams from xinabox.sw01 import sw01 streams . serial () # SW01 instance SW01 = sw01 . SW01 ( I2C0 ) while True : tempC = SW01 . getTempC () # return temp in degree celcius tempF = SW01 . getTempF () # return temp in degree fahrenheit hum = SW01 . getHumidity () # return humidity in percentage pres = SW01 . getPressure () # return pressure in hectopascal print ( 'Temperature: ' , tempC , ' C' ) print ( 'Temperature: ' , tempF , ' F' ) print ( 'Humidity :' , hum , ' %' ) print ( 'Pressure :' , pres , ' hpa' ) sleep ( 1000 )","title":"Environmental Data Measurement"},{"location":"reference/libs/xinabox/sw01/docs/sw01/","text":"SW01 Module \u00b6 This is a module for the SW01 ambient temperature, humidity and pressure sensor. The board is based off the BME280 manufactured by Bosch. The board uses I2C for communication. Data Sheets: BME280 SW01 class \u00b6 class SW01 \u00b6 class SW01 ( drvname , addr = 0x76 , clk = 100000 ) Creates an intance of the SW01 class. Arguments: drvname \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x76 clk \u2013 Clock speed, default 100kHz Sensor\u2019s calibration data are automatically read on object creation and setup method is called with default parameters. Temperature, humidity and pressure values can be easily obtained from the sensor: from xinabox.sw01 import sw01 ... SW01 = sw01 . SW01 ( I2C0 ) temp , hum , pres = bmp . get_values () SW01.setup \u00b6 setup ( mode = 3 , os_t = 1 , os_h = 1 , os_p = 1 , t_sb = 6 , filter = 1 ) This method sets the operating mode and the sampling parameters of the module. Parameters : mode : Control the operating mode. Sleep mode is entered by default after power on reset. In sleep mode, no measurement are performed and all registers are accessible. In normal mode the sensor cycles between an active measurement period and an inactive standby period. In forced mode a single measurement is perfomed in accordance to the selected measurement and filter options, after which the sensor enter in sleep mode. mode Operating mode 0 Sleep Mode 1 or 2 Forced Mode 3 Normal Mode Note See pages 12-13 of the datasheet_ for more details on operating mode and allowed sensor mode transitions. os_t : Oversampling setting for temperature sensor, see os_p for details on allowed values. os_h : Oversampling setting for humidity sensor, see os_p for details on allowed values. os_p : Oversampling setting for pressure sensor. os_p Oversampling setting 0 Skipped (output set to 0) 1 oversampling 1x 2 oversampling 2x 3 oversampling 4x 4 oversampling 8x 5 oversampling 16x t_sb : Control the inactive duration t_standby in normal mode. t_sb t_standby [ms] 0 0.5 1 62.5 2 125 3 250 4 500 5 1000 6 10 7 20 filter : Control the time constant of the internal IIR filter. It reduces the bandwidth of the temperature and pressure output signals and increases the resolution of the pressure and temperature output data to 20 bit. filter Filter coefficient 0 Filter off 1 2 2 4 3 8 4 16 SW01.getTempC \u00b6 getTempC () Return the current temperature value in Celsius degree. SW01.getTempF \u00b6 getTempF () Return the current temperature value in Celsius degree. SW01.getHumidity \u00b6 getHumidity () Return the current humidity value in %rH. SW01.getPressure \u00b6 getPressure () Return the current pressure value in Pascal. SW01.get_values \u00b6 get_values () Return a 3-element tuple containing current temperature, humidity and pressure values. SW01.soft_reset \u00b6 soft_reset () Reset the device using the complete power-on-reset procedure. SW01.get_status \u00b6 get_status () Return a two element long tuple representing the status of the sensor. The first element is equal to 1 whenever a conversion is running; it is equal to 0 when the results have been transferred to the data register. The second and last element of the returned tuple is euqal to 1 when the non-volatile memory data (calibration parameters) are being copied to image registers; it is equal to 0 when the copying is done. The data are copied at power-on-reset and before every conversion. SW01.get_chip_id \u00b6 get_chip_id () Return the device chip id as a single byte integer.","title":"SW01 Module"},{"location":"reference/libs/xinabox/sw01/docs/sw01/#sw01-module","text":"This is a module for the SW01 ambient temperature, humidity and pressure sensor. The board is based off the BME280 manufactured by Bosch. The board uses I2C for communication. Data Sheets: BME280","title":"SW01 Module"},{"location":"reference/libs/xinabox/sw01/docs/sw01/#sw01-class","text":"","title":"SW01 class"},{"location":"reference/libs/xinabox/sw01/docs/sw01/#class-sw01","text":"class SW01 ( drvname , addr = 0x76 , clk = 100000 ) Creates an intance of the SW01 class. Arguments: drvname \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x76 clk \u2013 Clock speed, default 100kHz Sensor\u2019s calibration data are automatically read on object creation and setup method is called with default parameters. Temperature, humidity and pressure values can be easily obtained from the sensor: from xinabox.sw01 import sw01 ... SW01 = sw01 . SW01 ( I2C0 ) temp , hum , pres = bmp . get_values ()","title":"class SW01"},{"location":"reference/libs/xinabox/sw01/docs/sw01/#sw01setup","text":"setup ( mode = 3 , os_t = 1 , os_h = 1 , os_p = 1 , t_sb = 6 , filter = 1 ) This method sets the operating mode and the sampling parameters of the module. Parameters : mode : Control the operating mode. Sleep mode is entered by default after power on reset. In sleep mode, no measurement are performed and all registers are accessible. In normal mode the sensor cycles between an active measurement period and an inactive standby period. In forced mode a single measurement is perfomed in accordance to the selected measurement and filter options, after which the sensor enter in sleep mode. mode Operating mode 0 Sleep Mode 1 or 2 Forced Mode 3 Normal Mode Note See pages 12-13 of the datasheet_ for more details on operating mode and allowed sensor mode transitions. os_t : Oversampling setting for temperature sensor, see os_p for details on allowed values. os_h : Oversampling setting for humidity sensor, see os_p for details on allowed values. os_p : Oversampling setting for pressure sensor. os_p Oversampling setting 0 Skipped (output set to 0) 1 oversampling 1x 2 oversampling 2x 3 oversampling 4x 4 oversampling 8x 5 oversampling 16x t_sb : Control the inactive duration t_standby in normal mode. t_sb t_standby [ms] 0 0.5 1 62.5 2 125 3 250 4 500 5 1000 6 10 7 20 filter : Control the time constant of the internal IIR filter. It reduces the bandwidth of the temperature and pressure output signals and increases the resolution of the pressure and temperature output data to 20 bit. filter Filter coefficient 0 Filter off 1 2 2 4 3 8 4 16","title":"SW01.setup"},{"location":"reference/libs/xinabox/sw01/docs/sw01/#sw01gettempc","text":"getTempC () Return the current temperature value in Celsius degree.","title":"SW01.getTempC"},{"location":"reference/libs/xinabox/sw01/docs/sw01/#sw01gettempf","text":"getTempF () Return the current temperature value in Celsius degree.","title":"SW01.getTempF"},{"location":"reference/libs/xinabox/sw01/docs/sw01/#sw01gethumidity","text":"getHumidity () Return the current humidity value in %rH.","title":"SW01.getHumidity"},{"location":"reference/libs/xinabox/sw01/docs/sw01/#sw01getpressure","text":"getPressure () Return the current pressure value in Pascal.","title":"SW01.getPressure"},{"location":"reference/libs/xinabox/sw01/docs/sw01/#sw01get_values","text":"get_values () Return a 3-element tuple containing current temperature, humidity and pressure values.","title":"SW01.get_values"},{"location":"reference/libs/xinabox/sw01/docs/sw01/#sw01soft_reset","text":"soft_reset () Reset the device using the complete power-on-reset procedure.","title":"SW01.soft_reset"},{"location":"reference/libs/xinabox/sw01/docs/sw01/#sw01get_status","text":"get_status () Return a two element long tuple representing the status of the sensor. The first element is equal to 1 whenever a conversion is running; it is equal to 0 when the results have been transferred to the data register. The second and last element of the returned tuple is euqal to 1 when the non-volatile memory data (calibration parameters) are being copied to image registers; it is equal to 0 when the copying is done. The data are copied at power-on-reset and before every conversion.","title":"SW01.get_status"},{"location":"reference/libs/xinabox/sw01/docs/sw01/#sw01get_chip_id","text":"get_chip_id () Return the device chip id as a single byte integer.","title":"SW01.get_chip_id"},{"location":"reference/libs/xinabox/sw03/docs/","text":"XinaBox SW03 \u00b6 The SW03 xChip is equipped with a weather sensor that is capable of measuring the temperature, atmospheric pressure and altitude. It is based on the MPL3115A2 manufactured by NXP Semiconductors. The MPL3115A2 is a compact, piezoresistive, absolute pressure sensor with an I2C digital interface. MPL3115A2 has a wide operating range of 20 kPa to 110 kPa, a range that covers all surface elevations on earth. The MEMS is temperature compensated utilizing an on-chip temperature sensor. The pressure and temperature data is fed into a high resolution ADC to provide fully compensated and digitized outputs for pressure in Pascals and temperature in \u00b0C. The compensated pressure output can then be converted to altitude. Please note, SW03 and all other xChips is currently only supported in Zerynth Studio with XinaBox CW02 . Review the Quick Start guide for interfacing xChips. Technical Details \u00b6 MPL3115A2 \u00b6 I2C interface Fully Compensated Internal Temperature Operating Range: -40\u00b0C to 85\u00b0C Absolute Pressure Operating Range: 20 kPa to 110 kPa Precision ADC resulting in 0.1 meter of effective resolution Direct reading Contents: SW03 Module SW03 class Examples environmental data","title":"XinaBox SW03"},{"location":"reference/libs/xinabox/sw03/docs/#xinabox-sw03","text":"The SW03 xChip is equipped with a weather sensor that is capable of measuring the temperature, atmospheric pressure and altitude. It is based on the MPL3115A2 manufactured by NXP Semiconductors. The MPL3115A2 is a compact, piezoresistive, absolute pressure sensor with an I2C digital interface. MPL3115A2 has a wide operating range of 20 kPa to 110 kPa, a range that covers all surface elevations on earth. The MEMS is temperature compensated utilizing an on-chip temperature sensor. The pressure and temperature data is fed into a high resolution ADC to provide fully compensated and digitized outputs for pressure in Pascals and temperature in \u00b0C. The compensated pressure output can then be converted to altitude. Please note, SW03 and all other xChips is currently only supported in Zerynth Studio with XinaBox CW02 . Review the Quick Start guide for interfacing xChips.","title":"XinaBox SW03"},{"location":"reference/libs/xinabox/sw03/docs/#technical-details","text":"","title":"Technical Details"},{"location":"reference/libs/xinabox/sw03/docs/#mpl3115a2","text":"I2C interface Fully Compensated Internal Temperature Operating Range: -40\u00b0C to 85\u00b0C Absolute Pressure Operating Range: 20 kPa to 110 kPa Precision ADC resulting in 0.1 meter of effective resolution Direct reading Contents: SW03 Module SW03 class Examples environmental data","title":"MPL3115A2"},{"location":"reference/libs/xinabox/sw03/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.xinabox.sw03. Environmental Data Measurement \u00b6 This example measures ambient temperature, altitude and atmospheric pressure and prints it out on the console. main.py ############################################## # This is an example for SW03 ambient # temperature, altitude and pressure # sensor. # # Ambient temperature, altitude and pressure # is measured and printed out on the console. ############################################## import streams from xinabox.sw03 import sw03 streams . serial () # SW03 instance SW03 = sw03 . SW03 ( I2C0 ) # configure SW03 SW03 . init () while True : temp = SW03 . getTempC () # return temp in degree celcius alt = SW03 . getAltitude () # return alitude in meters pres = SW03 . getPressure () # return pressure in pascals print ( 'Temperature: ' , temp , ' C' ) print ( 'Altitude : ' , alt , ' m' ) print ( 'Pressure : ' , pres , ' Pa' ) sleep ( 1000 )","title":"Examples"},{"location":"reference/libs/xinabox/sw03/docs/examples/#examples","text":"The following are a list of examples for lib.xinabox.sw03.","title":"Examples"},{"location":"reference/libs/xinabox/sw03/docs/examples/#environmental-data-measurement","text":"This example measures ambient temperature, altitude and atmospheric pressure and prints it out on the console. main.py ############################################## # This is an example for SW03 ambient # temperature, altitude and pressure # sensor. # # Ambient temperature, altitude and pressure # is measured and printed out on the console. ############################################## import streams from xinabox.sw03 import sw03 streams . serial () # SW03 instance SW03 = sw03 . SW03 ( I2C0 ) # configure SW03 SW03 . init () while True : temp = SW03 . getTempC () # return temp in degree celcius alt = SW03 . getAltitude () # return alitude in meters pres = SW03 . getPressure () # return pressure in pascals print ( 'Temperature: ' , temp , ' C' ) print ( 'Altitude : ' , alt , ' m' ) print ( 'Pressure : ' , pres , ' Pa' ) sleep ( 1000 )","title":"Environmental Data Measurement"},{"location":"reference/libs/xinabox/sw03/docs/sw03/","text":"SW03 Module \u00b6 This is a module for the SW03 ambient temperature, altitude and pressure sensor. The board is based off the MPL3115A2 manufactured by NXP Semiconductors. The board uses I2C for communication. Datasheets: MPL3115A2 SW03 class \u00b6 class SW03 \u00b6 class SW03 ( i2cdrv , addr = 0x60 , clk = 100000 ) Creates an intance of a new SW03. Arguments: i2cdrv \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x60 clk \u2013 Clock speed, default 100kHz Example: from xinabox.sw03 import sw03 ... SW03 = sw03 . SW03 ( I2C0 ) SW03 . init () alt = SW03 . getAltitude () pres = SW03 . getPressure () SW03.init \u00b6 init ( osr = 0 ) Initialize the MPL3115A2 setting the oversample rate value. Arguments: osr \u2013 set the oversample rate value (from 0 to 7), default 0. OSR Value Oversample Ratio Data Ready 0 1 6 ms 1 2 10 ms 2 4 18 ms 3 8 34 ms 4 16 66 ms 5 32 130 ms 6 64 258 ms 7 128 512 ms SW03.get_raw_alt \u00b6 get_raw_alt () Retrieves the current altitude data from the sensor as raw value. Returns raw_a. SW03.get_raw_pres \u00b6 get_raw_pres () Retrieves the current pressure data from the sensor as raw value. Returns raw_p. SW03.get_raw_temp \u00b6 get_raw_temp () Retrieves the current temperature data from the sensor as raw value. Returns raw_t. SW03.getAltitude \u00b6 getAltitude () Calculates, from measured pressure, the current altitude data as value in meters. Returns altitude. SW03.getPressure \u00b6 getPressure () Retrieves the current pressure data from the sensor as calibrate value in Pa. Returns pres. SW03.getTempC \u00b6 getTempC ( Retrieves the current temperature data from the sensor as calibrate value in \u00b0C. Returns temp.","title":"SW03 Module"},{"location":"reference/libs/xinabox/sw03/docs/sw03/#sw03-module","text":"This is a module for the SW03 ambient temperature, altitude and pressure sensor. The board is based off the MPL3115A2 manufactured by NXP Semiconductors. The board uses I2C for communication. Datasheets: MPL3115A2","title":"SW03 Module"},{"location":"reference/libs/xinabox/sw03/docs/sw03/#sw03-class","text":"","title":"SW03 class"},{"location":"reference/libs/xinabox/sw03/docs/sw03/#class-sw03","text":"class SW03 ( i2cdrv , addr = 0x60 , clk = 100000 ) Creates an intance of a new SW03. Arguments: i2cdrv \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x60 clk \u2013 Clock speed, default 100kHz Example: from xinabox.sw03 import sw03 ... SW03 = sw03 . SW03 ( I2C0 ) SW03 . init () alt = SW03 . getAltitude () pres = SW03 . getPressure ()","title":"class SW03"},{"location":"reference/libs/xinabox/sw03/docs/sw03/#sw03init","text":"init ( osr = 0 ) Initialize the MPL3115A2 setting the oversample rate value. Arguments: osr \u2013 set the oversample rate value (from 0 to 7), default 0. OSR Value Oversample Ratio Data Ready 0 1 6 ms 1 2 10 ms 2 4 18 ms 3 8 34 ms 4 16 66 ms 5 32 130 ms 6 64 258 ms 7 128 512 ms","title":"SW03.init"},{"location":"reference/libs/xinabox/sw03/docs/sw03/#sw03get_raw_alt","text":"get_raw_alt () Retrieves the current altitude data from the sensor as raw value. Returns raw_a.","title":"SW03.get_raw_alt"},{"location":"reference/libs/xinabox/sw03/docs/sw03/#sw03get_raw_pres","text":"get_raw_pres () Retrieves the current pressure data from the sensor as raw value. Returns raw_p.","title":"SW03.get_raw_pres"},{"location":"reference/libs/xinabox/sw03/docs/sw03/#sw03get_raw_temp","text":"get_raw_temp () Retrieves the current temperature data from the sensor as raw value. Returns raw_t.","title":"SW03.get_raw_temp"},{"location":"reference/libs/xinabox/sw03/docs/sw03/#sw03getaltitude","text":"getAltitude () Calculates, from measured pressure, the current altitude data as value in meters. Returns altitude.","title":"SW03.getAltitude"},{"location":"reference/libs/xinabox/sw03/docs/sw03/#sw03getpressure","text":"getPressure () Retrieves the current pressure data from the sensor as calibrate value in Pa. Returns pres.","title":"SW03.getPressure"},{"location":"reference/libs/xinabox/sw03/docs/sw03/#sw03gettempc","text":"getTempC ( Retrieves the current temperature data from the sensor as calibrate value in \u00b0C. Returns temp.","title":"SW03.getTempC"},{"location":"reference/libs/xinabox/sw10/docs/","text":"XinaBox SW10 \u00b6 This SW10 xChip is a temperature-to-digital converter using an on-chip band gap temperature sensor and Sigma-Delta A-to-D conversion technique with an over-temperature detection output. It is capable of measuring ambient temperature ranging from -55\u00b0C to +125\u00b0C. It is based on the LM75 manufactured by Texas Instruments. Please note, SW10 and all other xChips is currently only supported in Zerynth Studio with XinaBox CW02 . Review the Quick Start guide for interfacing xChips. Technical Details \u00b6 LM75 \u00b6 I2C-bus interface with up to 8 devices on the same bus Temperature range from -55\u00b0C to +125\u00b0C Frequency range 20 Hz to 400 kHz with bus fault time-out to prevent hanging up the bus Programmable temperature threshold and hysteresis set points Supply current of 1.0 \u00b5A in shutdown mode for power conservation Stand-alone operation as thermostat at power-up Contents: SW10 Module SW10 class Examples ambient temperature","title":"XinaBox SW10"},{"location":"reference/libs/xinabox/sw10/docs/#xinabox-sw10","text":"This SW10 xChip is a temperature-to-digital converter using an on-chip band gap temperature sensor and Sigma-Delta A-to-D conversion technique with an over-temperature detection output. It is capable of measuring ambient temperature ranging from -55\u00b0C to +125\u00b0C. It is based on the LM75 manufactured by Texas Instruments. Please note, SW10 and all other xChips is currently only supported in Zerynth Studio with XinaBox CW02 . Review the Quick Start guide for interfacing xChips.","title":"XinaBox SW10"},{"location":"reference/libs/xinabox/sw10/docs/#technical-details","text":"","title":"Technical Details"},{"location":"reference/libs/xinabox/sw10/docs/#lm75","text":"I2C-bus interface with up to 8 devices on the same bus Temperature range from -55\u00b0C to +125\u00b0C Frequency range 20 Hz to 400 kHz with bus fault time-out to prevent hanging up the bus Programmable temperature threshold and hysteresis set points Supply current of 1.0 \u00b5A in shutdown mode for power conservation Stand-alone operation as thermostat at power-up Contents: SW10 Module SW10 class Examples ambient temperature","title":"LM75"},{"location":"reference/libs/xinabox/sw10/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.xinabox.sw10. Ambient Temperature Measurement \u00b6 This example measures ambient temperature and prints it out on the serial console. main.py ############################################## # This is an example for SW10 temperature # sensor. # # Ambient temperature is measured and # printed out on the console. ############################################## import streams from xinabox.sw10 import sw10 streams . serial () # SW10 instance SW10 = sw10 . SW10 ( I2C0 ) # configure SW10 SW10 . init () while True : tempC = SW10 . getTempC () # return temp in celcius tempF = SW10 . getTempF () # return temp in fahrenheit # print to console print ( 'Temperature: ' , tempC , ' C' ) print ( 'Temperature: ' , tempF , ' F' ) sleep ( 2000 )","title":"Examples"},{"location":"reference/libs/xinabox/sw10/docs/examples/#examples","text":"The following are a list of examples for lib.xinabox.sw10.","title":"Examples"},{"location":"reference/libs/xinabox/sw10/docs/examples/#ambient-temperature-measurement","text":"This example measures ambient temperature and prints it out on the serial console. main.py ############################################## # This is an example for SW10 temperature # sensor. # # Ambient temperature is measured and # printed out on the console. ############################################## import streams from xinabox.sw10 import sw10 streams . serial () # SW10 instance SW10 = sw10 . SW10 ( I2C0 ) # configure SW10 SW10 . init () while True : tempC = SW10 . getTempC () # return temp in celcius tempF = SW10 . getTempF () # return temp in fahrenheit # print to console print ( 'Temperature: ' , tempC , ' C' ) print ( 'Temperature: ' , tempF , ' F' ) sleep ( 2000 )","title":"Ambient Temperature Measurement"},{"location":"reference/libs/xinabox/sw10/docs/sw10/","text":"SW10 Module \u00b6 This is a Module for the SW10 xChip ambient temperature sensor. The board is based off the LM75 temperature-to-digital converter manufactured by NXP Semiconductors. The board uses I2C for communication. Data Sheets: LM75 SW10 class \u00b6 class SW10 \u00b6 class SW10 ( self , drvname , addr = 0x48 , clk = 100000 ) Create an instance of the SW10 class. Arguments: drvname \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x48 clk \u2013 Clock speed, default 100kHz SW10.init \u00b6 init ( self ) Empty function. Only used to conform with other modules. No configuartion required for LM75. SW10.getTempC \u00b6 getTempC ( self ) Returns the ambient temerature in degree celcius. SW10.getTempF \u00b6 getTempF ( self ) Returns the ambient temerature in degree fahrenheit. SW10.readTemperature \u00b6 readTemperature ( self ) Reads the raw temperature from LM75. returns the raw temperature.","title":"SW10 Module"},{"location":"reference/libs/xinabox/sw10/docs/sw10/#sw10-module","text":"This is a Module for the SW10 xChip ambient temperature sensor. The board is based off the LM75 temperature-to-digital converter manufactured by NXP Semiconductors. The board uses I2C for communication. Data Sheets: LM75","title":"SW10 Module"},{"location":"reference/libs/xinabox/sw10/docs/sw10/#sw10-class","text":"","title":"SW10 class"},{"location":"reference/libs/xinabox/sw10/docs/sw10/#class-sw10","text":"class SW10 ( self , drvname , addr = 0x48 , clk = 100000 ) Create an instance of the SW10 class. Arguments: drvname \u2013 I2C Bus used \u2018( I2C0, \u2026 )\u2019 addr \u2013 Slave address, default 0x48 clk \u2013 Clock speed, default 100kHz","title":"class SW10"},{"location":"reference/libs/xinabox/sw10/docs/sw10/#sw10init","text":"init ( self ) Empty function. Only used to conform with other modules. No configuartion required for LM75.","title":"SW10.init"},{"location":"reference/libs/xinabox/sw10/docs/sw10/#sw10gettempc","text":"getTempC ( self ) Returns the ambient temerature in degree celcius.","title":"SW10.getTempC"},{"location":"reference/libs/xinabox/sw10/docs/sw10/#sw10gettempf","text":"getTempF ( self ) Returns the ambient temerature in degree fahrenheit.","title":"SW10.getTempF"},{"location":"reference/libs/xinabox/sw10/docs/sw10/#sw10readtemperature","text":"readTemperature ( self ) Reads the raw temperature from LM75. returns the raw temperature.","title":"SW10.readTemperature"},{"location":"reference/libs/zerynth/dcz/docs/","text":"Device Configuration Zone \u00b6 Device Configuration Zones are a mean of storing versioned and replicated firmware independent resources in an easy way. Here below, the Zerynth module to load and manage the zones. Contents: Device Configuration Zones DCZ class Examples DCZ Basic DCZ AWS","title":"Device Configuration Zone"},{"location":"reference/libs/zerynth/dcz/docs/#device-configuration-zone","text":"Device Configuration Zones are a mean of storing versioned and replicated firmware independent resources in an easy way. Here below, the Zerynth module to load and manage the zones. Contents: Device Configuration Zones DCZ class Examples DCZ Basic DCZ AWS","title":"Device Configuration Zone"},{"location":"reference/libs/zerynth/dcz/docs/dcz/","text":"Device Configuration Zones \u00b6 This module define the DCZ() class to simplify the management of provisioned device resources. In the lifecycle of an IoT device is of the utter importance to have a strategy for the management of firmware independent resources such as certificates, private keys, configuration files, etc\u2026 These resources must be written into the device memory when the device is mass programmed and they usually change when the devices is first provisioned (i.e. when the device needs to store WiFi credentials). The management of these resources must be as safe as possible both in terms of robustness to error (i.e. corruption of memory) and security (i.e. credentials must always be stored at least in some encrypted fashion). The Device Configuration Zones provided by Zerynth are regions of storage with the following properties: versioning: each resource can be replicated in up to 8 versioned slots in order to make the firmware always able to revert to the previous configuration, or recover from memory corruption encryption: an encryption mechanism is provided by the VM in order to store some sensitive data in an encryted way error checking: each DCZ and each DCZ resource is augmented with a checksum to immediately spot corruption or tampering of data serialization: resources included in a DCZ can be serialized and deserialized transparently with modules in the standard library (i.e. json and cbor) or by custom modules The DCZ module works best when used with the Zerynth toolchain related commands, but can also be used standalone. Device Confguration Zones are implemented as flash regions starting at specific addresses and containing: a checksum of the entire zone the size in bytes of the region the version number of the region the number of resources in the region the number of DCZ regions (replication number) a list of entries with the name, location, address and format of each provisioned resource Up to 8 DCZ can be handled by this module. DCZs are stored like these: | DCZ 0 @ 0x310000 | | DCZ 1 @ 0x311000 | ----------------------------- ----------------------------- | Checksum : 0xABCD1234 | | Checksum : 0xABCD1234 | | Size : 80 | | Size : 80 | | Version : 0 | | Version : 0 | | Resources : 1 | | Resources : 1 | | Replication : 2 | | Replication : 2 | | --------------------------| | --------------------------| | Entry : 0 | | Entry : 0 | | Name : cert | | Name : cert | | Address : 0x320000 | | Address : 0x330000 | | checksum : 0x2345BCDE | | checksum : 0x2345BCDE | | format : bin | | format : bin | | size : 1024 | | size : 1024 | | --------------------------| | --------------------------| The above configuration has a replication factor of 2 (all resources are replicated twice), both the DCZs have the same version and contain an entry to a resource named \u201ccert\u201d (most probably a certificate). The certificate managed by DCZ 0 can be found at address 0x320000 while the certificate copy managed by DCZ 1 can be found at 0x330000. If during the lifecyle of the device the certificate must be changed or renewed, the new version of the resource can be saved increasing its version number, reaching a state like this: | DCZ 0 @ 0x310000 | | DCZ 1 @ 0x311000 | ----------------------------- ----------------------------- | Checksum : 0xABCD1234 | | Checksum : 0xFFFF0000 | | Size : 80 | | Size : 80 | | Version : 0 | | Version : 1 | | Resources : 1 | | Resources : 1 | | Replication : 2 | | Replication : 2 | | --------------------------| =======> | --------------------------| | Entry : 0 | | Entry : 0 | | Name : cert | | Name : cert | | Address : 0x320000 | | Address : 0x330000 | | checksum : 0x2345BCDE | | checksum : 0xAAAABBBB | | format : bin | | format : bin | | size : 1024 | | size : 1120 | | --------------------------| | --------------------------| The DCZs now store two different resources named \u201ccert\u201d but with different version number, size and checksum. If something goes wrong during certificate renewal, the device can always go back to the previous version of the DCZ and try again. Increasing versions of resources are stored modulo the replication factor. In the case above, all odd numbered versions will be handled by DCZ 1 while even numbered versions will be handled by DCZ 0. At provisioning time, resources can be tagged as encrypted in the DCZ entries. Such resources are stored as a plaintext and are automatically encrypted by the VM the first time the DCZ module is initialized (usually at end of line testing). This is not the best possible security measure, but is a good alternative with respect to storing resources in the clear when a suitable secure storage hardware is not present. DCZ module makes no assumption on the flash layout of the device, therefore when deciding addresses for DCZs and resources the following criteria should be taken into consideration: choose addresses that are not in VM or bytecode areas choose addresses in such a way to accomodate the size of the resources in a non overlapping way (the size of a DCZ is 16 bytes plus 64 for each indexed resource) flash memories are often segmented in sectors that must be completely erased before writing to them. Organize resource and DCZs addresses in such a way that they do not share the same sector! Failing to do so will delete resources or DCZs when modifying the ones sharing the sector. The sector size may vary, consult the device flash layout map to choose correctly DCZ class \u00b6 class DCZ \u00b6 class DCZ ( mapping , serializers = {}) Create an instance of the DCZ class providing the following arguments: mapping , a list of addresses where the various DCZ versions start (in ascending order of version). A max of 8 addresses can be given. serializers , a dict mapping format names to serialization/deserialization modules. Format names are strings of at most 4 bytes, while serialization modules must provide a .loads(bytes) and .dumps(obj) to be used. To use json and cbor: import json import cbor from dcz import dcz dc = dcz . DCZ ([ 0x310000 , 0x311000 ],{ \"json\" : json , \"cbor\" : cbor }) After creation, the DCZ instance contain a latest_version field containing the highest available version of the stored DCZs. Note All methods expecting an optional version number will operate the latest_version if no version is given, otherwise they will operate on the DCZ slot correspondent to the given version modulo the replication number. DCZ.finalize \u00b6 finalize () This method scans all the DCZs and all the resources. For each DCZ it calculates the checksum and checks it against the one in the DCZ. If they do not match the DCZ is marked as invalid. For each resource of valid DCZs that is marked as requiring encryption, the resource is read (in binary format), encrypted, stored back to its address and marked as encrypted. This method is suggested to be run at end of line testing for each device that requires encrypted resources. DCZ.load_resource \u00b6 load_resource ( resource , version = None , check = False , deserialize = True , decrypt = True ) This is the method of choice to retrieve resources. It scans the DCZ identified by version and all its entries to find the one with the same name specified by the parameter resource . If the check parameter is True , the DCZChecksumError is raised if the entry checksum in the DCZ is not the same as the calculated checksum of the resource data. When deserialize is True an attempt to deserialize the resource data is made by passing it to the .loads method of the appropriate deserializer. The deserializer module is choosen by matching the resource format with the key of the dcz.serializers . If no deserializers can be found, DCZMissingSerializerError is raised. If deserialization is successful, the deserialized resource is returned. When deserialize is False , the binary representation of the resource is returned. If no resource with name resource can be found, DCZNoResourceError is raised. save_resource(resource, version=None, format=\"bin\", serialize=True) * This is method is used to update resources. It scans the DCZ identified by version and all its entries to find the one with the same name specified by the parameter resource . If version is not present, the DCZ matching the modulo operation with the replication number is selected and promoted to the new version. When serialize is True an attempt to serialize the resource data is made by passing it to the .dumps method of the appropriate serializer. The serializer module is choosen by matching the format with the key of the dcz.serializers . If no serializers can be found, DCZMissingSerializerError is raised. If serialization is successful, the serialized resource is saved and the DCZ updated accordingly. When a resource is marked for encryption, the resource is automatically encrypted and stored. If no resource with name resource can be found, DCZNoResourceError is raised. Return a tuple with the resource address and the DCZ address DCZ.get_header \u00b6 get_header ( version = None ) Return a list containing the DCZ header: size version number of indexed resources checksum replication number DCZ.get_entry \u00b6 get_entry ( i , version = None ) Return the ith entry in the DCZ indentified by version An entry is a list with: the name of the resource the list of all possible addresses of the resource the size of the resource the format of the resource the checksum of the resource a flag to 1 if encryption is required a flag to 1 if encryption has been performed the index of the entry in the DCZ the index of the DCZ DCZ.load_entry \u00b6 load_entry ( entry ) Return the raw binary data of the resource in entry as present on the flash (without decryption). An entry retrieved with :method: get_entry must be given in order to identify the resource. This method is exposed for custom usage of DCZ, but :method: load_resource is recommended. DCZ.save_entry \u00b6 save_entry ( entry , bin , new_version = None ) Save data in bin as is (no encryption step) to the resource pointed by entry and update the corresponding DCZ. If new_version is given the corresponding DCZ will be updated and its version number set to new_version . If not given, the corresponding DCZ will be the one identified by entry . Return the saved resource address and the address of the modified DCZ. DCZ.search_entry \u00b6 search_entry ( resource , version = None ) Search for a resource named resource in all DCZ and return a tuple with: resource address resource size resource format resource checksum encryption status If no resource exists, DCZNoResourceError is raised. DCZ.check_dcz \u00b6 check_dcz ( version = None ) Return True if the DCZ identified by version is valid. It reads the DCZ from memory, calculates the checksum and check it against the stored one. DCZ.is_valid_dcz \u00b6 is_valid_dcz ( version = None ) Return True if the DCZ identified by version is valid. It looks up validity from the checks done after init. DCZ.dump \u00b6 dump ( version = None , entries = False ) Print information about DCZs. If version is not given, all DCZs are printed, otherwise only the specific version . If entries is given, additional information about each entry is given. DCZ.versions \u00b6 versions () Return the list of DCZ versions. DCZ.resources \u00b6 resources () Return the list of resource names. DCZ.next_version \u00b6 next_version () Return the next version greater than all current versions.","title":"Device Configuration Zones"},{"location":"reference/libs/zerynth/dcz/docs/dcz/#device-configuration-zones","text":"This module define the DCZ() class to simplify the management of provisioned device resources. In the lifecycle of an IoT device is of the utter importance to have a strategy for the management of firmware independent resources such as certificates, private keys, configuration files, etc\u2026 These resources must be written into the device memory when the device is mass programmed and they usually change when the devices is first provisioned (i.e. when the device needs to store WiFi credentials). The management of these resources must be as safe as possible both in terms of robustness to error (i.e. corruption of memory) and security (i.e. credentials must always be stored at least in some encrypted fashion). The Device Configuration Zones provided by Zerynth are regions of storage with the following properties: versioning: each resource can be replicated in up to 8 versioned slots in order to make the firmware always able to revert to the previous configuration, or recover from memory corruption encryption: an encryption mechanism is provided by the VM in order to store some sensitive data in an encryted way error checking: each DCZ and each DCZ resource is augmented with a checksum to immediately spot corruption or tampering of data serialization: resources included in a DCZ can be serialized and deserialized transparently with modules in the standard library (i.e. json and cbor) or by custom modules The DCZ module works best when used with the Zerynth toolchain related commands, but can also be used standalone. Device Confguration Zones are implemented as flash regions starting at specific addresses and containing: a checksum of the entire zone the size in bytes of the region the version number of the region the number of resources in the region the number of DCZ regions (replication number) a list of entries with the name, location, address and format of each provisioned resource Up to 8 DCZ can be handled by this module. DCZs are stored like these: | DCZ 0 @ 0x310000 | | DCZ 1 @ 0x311000 | ----------------------------- ----------------------------- | Checksum : 0xABCD1234 | | Checksum : 0xABCD1234 | | Size : 80 | | Size : 80 | | Version : 0 | | Version : 0 | | Resources : 1 | | Resources : 1 | | Replication : 2 | | Replication : 2 | | --------------------------| | --------------------------| | Entry : 0 | | Entry : 0 | | Name : cert | | Name : cert | | Address : 0x320000 | | Address : 0x330000 | | checksum : 0x2345BCDE | | checksum : 0x2345BCDE | | format : bin | | format : bin | | size : 1024 | | size : 1024 | | --------------------------| | --------------------------| The above configuration has a replication factor of 2 (all resources are replicated twice), both the DCZs have the same version and contain an entry to a resource named \u201ccert\u201d (most probably a certificate). The certificate managed by DCZ 0 can be found at address 0x320000 while the certificate copy managed by DCZ 1 can be found at 0x330000. If during the lifecyle of the device the certificate must be changed or renewed, the new version of the resource can be saved increasing its version number, reaching a state like this: | DCZ 0 @ 0x310000 | | DCZ 1 @ 0x311000 | ----------------------------- ----------------------------- | Checksum : 0xABCD1234 | | Checksum : 0xFFFF0000 | | Size : 80 | | Size : 80 | | Version : 0 | | Version : 1 | | Resources : 1 | | Resources : 1 | | Replication : 2 | | Replication : 2 | | --------------------------| =======> | --------------------------| | Entry : 0 | | Entry : 0 | | Name : cert | | Name : cert | | Address : 0x320000 | | Address : 0x330000 | | checksum : 0x2345BCDE | | checksum : 0xAAAABBBB | | format : bin | | format : bin | | size : 1024 | | size : 1120 | | --------------------------| | --------------------------| The DCZs now store two different resources named \u201ccert\u201d but with different version number, size and checksum. If something goes wrong during certificate renewal, the device can always go back to the previous version of the DCZ and try again. Increasing versions of resources are stored modulo the replication factor. In the case above, all odd numbered versions will be handled by DCZ 1 while even numbered versions will be handled by DCZ 0. At provisioning time, resources can be tagged as encrypted in the DCZ entries. Such resources are stored as a plaintext and are automatically encrypted by the VM the first time the DCZ module is initialized (usually at end of line testing). This is not the best possible security measure, but is a good alternative with respect to storing resources in the clear when a suitable secure storage hardware is not present. DCZ module makes no assumption on the flash layout of the device, therefore when deciding addresses for DCZs and resources the following criteria should be taken into consideration: choose addresses that are not in VM or bytecode areas choose addresses in such a way to accomodate the size of the resources in a non overlapping way (the size of a DCZ is 16 bytes plus 64 for each indexed resource) flash memories are often segmented in sectors that must be completely erased before writing to them. Organize resource and DCZs addresses in such a way that they do not share the same sector! Failing to do so will delete resources or DCZs when modifying the ones sharing the sector. The sector size may vary, consult the device flash layout map to choose correctly","title":"Device Configuration Zones"},{"location":"reference/libs/zerynth/dcz/docs/dcz/#dcz-class","text":"","title":"DCZ class"},{"location":"reference/libs/zerynth/dcz/docs/dcz/#class-dcz","text":"class DCZ ( mapping , serializers = {}) Create an instance of the DCZ class providing the following arguments: mapping , a list of addresses where the various DCZ versions start (in ascending order of version). A max of 8 addresses can be given. serializers , a dict mapping format names to serialization/deserialization modules. Format names are strings of at most 4 bytes, while serialization modules must provide a .loads(bytes) and .dumps(obj) to be used. To use json and cbor: import json import cbor from dcz import dcz dc = dcz . DCZ ([ 0x310000 , 0x311000 ],{ \"json\" : json , \"cbor\" : cbor }) After creation, the DCZ instance contain a latest_version field containing the highest available version of the stored DCZs. Note All methods expecting an optional version number will operate the latest_version if no version is given, otherwise they will operate on the DCZ slot correspondent to the given version modulo the replication number.","title":"class DCZ"},{"location":"reference/libs/zerynth/dcz/docs/dcz/#dczfinalize","text":"finalize () This method scans all the DCZs and all the resources. For each DCZ it calculates the checksum and checks it against the one in the DCZ. If they do not match the DCZ is marked as invalid. For each resource of valid DCZs that is marked as requiring encryption, the resource is read (in binary format), encrypted, stored back to its address and marked as encrypted. This method is suggested to be run at end of line testing for each device that requires encrypted resources.","title":"DCZ.finalize"},{"location":"reference/libs/zerynth/dcz/docs/dcz/#dczload_resource","text":"load_resource ( resource , version = None , check = False , deserialize = True , decrypt = True ) This is the method of choice to retrieve resources. It scans the DCZ identified by version and all its entries to find the one with the same name specified by the parameter resource . If the check parameter is True , the DCZChecksumError is raised if the entry checksum in the DCZ is not the same as the calculated checksum of the resource data. When deserialize is True an attempt to deserialize the resource data is made by passing it to the .loads method of the appropriate deserializer. The deserializer module is choosen by matching the resource format with the key of the dcz.serializers . If no deserializers can be found, DCZMissingSerializerError is raised. If deserialization is successful, the deserialized resource is returned. When deserialize is False , the binary representation of the resource is returned. If no resource with name resource can be found, DCZNoResourceError is raised. save_resource(resource, version=None, format=\"bin\", serialize=True) * This is method is used to update resources. It scans the DCZ identified by version and all its entries to find the one with the same name specified by the parameter resource . If version is not present, the DCZ matching the modulo operation with the replication number is selected and promoted to the new version. When serialize is True an attempt to serialize the resource data is made by passing it to the .dumps method of the appropriate serializer. The serializer module is choosen by matching the format with the key of the dcz.serializers . If no serializers can be found, DCZMissingSerializerError is raised. If serialization is successful, the serialized resource is saved and the DCZ updated accordingly. When a resource is marked for encryption, the resource is automatically encrypted and stored. If no resource with name resource can be found, DCZNoResourceError is raised. Return a tuple with the resource address and the DCZ address","title":"DCZ.load_resource"},{"location":"reference/libs/zerynth/dcz/docs/dcz/#dczget_header","text":"get_header ( version = None ) Return a list containing the DCZ header: size version number of indexed resources checksum replication number","title":"DCZ.get_header"},{"location":"reference/libs/zerynth/dcz/docs/dcz/#dczget_entry","text":"get_entry ( i , version = None ) Return the ith entry in the DCZ indentified by version An entry is a list with: the name of the resource the list of all possible addresses of the resource the size of the resource the format of the resource the checksum of the resource a flag to 1 if encryption is required a flag to 1 if encryption has been performed the index of the entry in the DCZ the index of the DCZ","title":"DCZ.get_entry"},{"location":"reference/libs/zerynth/dcz/docs/dcz/#dczload_entry","text":"load_entry ( entry ) Return the raw binary data of the resource in entry as present on the flash (without decryption). An entry retrieved with :method: get_entry must be given in order to identify the resource. This method is exposed for custom usage of DCZ, but :method: load_resource is recommended.","title":"DCZ.load_entry"},{"location":"reference/libs/zerynth/dcz/docs/dcz/#dczsave_entry","text":"save_entry ( entry , bin , new_version = None ) Save data in bin as is (no encryption step) to the resource pointed by entry and update the corresponding DCZ. If new_version is given the corresponding DCZ will be updated and its version number set to new_version . If not given, the corresponding DCZ will be the one identified by entry . Return the saved resource address and the address of the modified DCZ.","title":"DCZ.save_entry"},{"location":"reference/libs/zerynth/dcz/docs/dcz/#dczsearch_entry","text":"search_entry ( resource , version = None ) Search for a resource named resource in all DCZ and return a tuple with: resource address resource size resource format resource checksum encryption status If no resource exists, DCZNoResourceError is raised.","title":"DCZ.search_entry"},{"location":"reference/libs/zerynth/dcz/docs/dcz/#dczcheck_dcz","text":"check_dcz ( version = None ) Return True if the DCZ identified by version is valid. It reads the DCZ from memory, calculates the checksum and check it against the stored one.","title":"DCZ.check_dcz"},{"location":"reference/libs/zerynth/dcz/docs/dcz/#dczis_valid_dcz","text":"is_valid_dcz ( version = None ) Return True if the DCZ identified by version is valid. It looks up validity from the checks done after init.","title":"DCZ.is_valid_dcz"},{"location":"reference/libs/zerynth/dcz/docs/dcz/#dczdump","text":"dump ( version = None , entries = False ) Print information about DCZs. If version is not given, all DCZs are printed, otherwise only the specific version . If entries is given, additional information about each entry is given.","title":"DCZ.dump"},{"location":"reference/libs/zerynth/dcz/docs/dcz/#dczversions","text":"versions () Return the list of DCZ versions.","title":"DCZ.versions"},{"location":"reference/libs/zerynth/dcz/docs/dcz/#dczresources","text":"resources () Return the list of resource names.","title":"DCZ.resources"},{"location":"reference/libs/zerynth/dcz/docs/dcz/#dcznext_version","text":"next_version () Return the next version greater than all current versions.","title":"DCZ.next_version"},{"location":"reference/libs/zerynth/dcz/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.zerynth.dcz. DCZ \u00b6 An example illustrating the usage of device configuration zones. main.py ################################################################################ # Device Configuration Zones # # Created by Zerynth Team 2015 CC # Authors: D. Mazzei, G. Baldi, ############################################################################### import streams import json # import the DCZ module from dcz import dcz streams . serial () try : # this example can run on an ESP32 device without modification # otherwise change the addresses both in mapping and in dcz.yml # there will be 2 DCZs at the following addresses mapping = [ 0x310000 , 0x311000 ] # let's create a DCZ instance that knows how to serialize and deserialize json dc = dcz . DCZ ( mapping , serializers = { \"json\" : json }) # before using it, DCZ instance must be init'ed dc . init () # if it is the first time the device runs, let's call finalize to encrypt resources if needed dc . finalize () # ok, print out the status dc . dump ( entries = True ) # get the list of resource names resources = dc . resources () # load them all and print their values for name in resources : print ( \"Resource\" , name ) resource = dc . load_resource ( name , check = True ) # the result is a Python object! binary_resource = dc . load_resource ( name , check = True , deserialize = False ) binary_resource_encrypted = dc . load_resource ( name , check = True , deserialize = False , decrypt = False ) print ( \"Deserialized:\" , resource ) print ( \"Binary: \" , \"\" . join ([ hex ( x , \"\" ) for x in binary_resource ])) print ( \"Encrypted: \" , \"\" . join ([ hex ( x , \"\" ) for x in binary_resource_encrypted ])) # get the next version next_version = dc . next_version () # now update a resource print ( \"=======================\" ) print ( \"Updating DCZ to version\" , next_version ) print ( \"=======================\" ) if \"test\" not in resource : resource [ \"test\" ] = 0 resource [ \"test\" ] = resource [ \"test\" ] + 1 print ( \"Saving \" , name ) dc . save_resource ( name , resource , format = \"json\" , version = next_version ) print ( \"Yes! Reset the device and see the DCZ get updated again and again...\" ) while ( True ): sleep ( 1000 ) except Exception as e : print ( e ) DCZ for AWS \u00b6 Simple automatic provisioning of AWS things managed with a DCZ. For the esample to work, a properly configured AWS Account must be present: IAM credentials of a user with access to IoT Core an IoT Policy to enable device connection and publishing # example device policy { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Effect\" : \"Allow\" , \"Action\" : \"iot:Connect\" , \"Resource\" : \"*\" }, { \"Effect\" : \"Allow\" , \"Action\" : \"iot:Publish\" , \"Resource\" : \"arn:aws:iot:<your-aws-region>:<your-aws-account-number>:topic/dev/sample\" } ] } main.py ################################################################################ # Device Configuration Zones # # Created by Zerynth Team 2019 CC # Authors: D. Mazzei, G. Baldi, ############################################################################### import streams import json # import the DCZ module from dcz import dcz # import aws iot module from aws.iot import iot # wifi driver from wireless import wifi from espressif.esp32net import esp32wifi as wifi_driver streams . serial () try : # this example can run on an ESP32 device without modification # otherwise change the addresses both in mapping and in dcz.yml # !!AWS Credentials must also be specified in the dcz.yml for the example to work!! # there will be 2 DCZs at the following addresses mapping = [ 0x310000 , 0x311000 ] # let's create a DCZ instance that knows how to serialize and deserialize json dc = dcz . DCZ ( mapping , serializers = { \"json\" : json }) # before using it, DCZ instance must be init'ed dc . init () # if it is the first time the device runs, let's call finalize to encrypt resources if needed dc . finalize () # ok, print out the status dc . dump ( entries = True ) # define a callback for shadow updates def shadow_callback ( requested ): global publish_period print ( 'requested publish period:' , requested [ 'publish_period' ]) publish_period = requested [ 'publish_period' ] return { 'publish_period' : publish_period } wifi_driver . auto_init () # let's retrieve credentials as an encrypted resource # this file should be updated when the device user input the wifi credentials # by using dc.save_resource() # For the sake of this example, just edit the files/wificred.json with your credentials wificred = dc . load_resource ( \"wificred\" ) print ( 'connecting to wifi...' , wificred [ \"ssid\" ]) wifi . link ( wificred [ \"ssid\" ], wifi . WIFI_WPA2 , wificred [ \"password\" ]) # load resourcef from the DCZ pkey = dc . load_resource ( \"prvkey\" ) clicert = dc . load_resource ( \"clicert\" ) cacert = dc . load_resource ( \"cacert\" ) thing_conf = dc . load_resource ( \"devinfo\" ) endpoint = dc . load_resource ( \"endpoint\" ) publish_period = 1000 # create aws iot thing instance, connect to mqtt broker, set shadow update callback and start mqtt reception loop thing = iot . Thing ( endpoint [ 'endpoint' ], thing_conf [ 'thing_name' ], clicert , pkey , thingname = thing_conf [ 'thing_name' ], cacert = cacert ) # free some memory by setting resources to None pkey = None clicert = None cacert = None print ( 'connecting to mqtt broker' ) print ( \"endpoint:\" , endpoint [ \"endpoint\" ]) print ( \"thing:\" , thing_conf [ \"thing_name\" ]) thing . mqtt . connect () thing . on_shadow_request ( shadow_callback ) thing . mqtt . loop () thing . update_shadow ({ 'publish_period' : publish_period }) while True : print ( 'publish random sample...' ) thing . mqtt . publish ( \"dev/sample\" , json . dumps ({ 'asample' : random ( 0 , 10 ) })) sleep ( publish_period ) except Exception as e : print ( e )","title":"Examples"},{"location":"reference/libs/zerynth/dcz/docs/examples/#examples","text":"The following are a list of examples for lib.zerynth.dcz.","title":"Examples"},{"location":"reference/libs/zerynth/dcz/docs/examples/#dcz","text":"An example illustrating the usage of device configuration zones. main.py ################################################################################ # Device Configuration Zones # # Created by Zerynth Team 2015 CC # Authors: D. Mazzei, G. Baldi, ############################################################################### import streams import json # import the DCZ module from dcz import dcz streams . serial () try : # this example can run on an ESP32 device without modification # otherwise change the addresses both in mapping and in dcz.yml # there will be 2 DCZs at the following addresses mapping = [ 0x310000 , 0x311000 ] # let's create a DCZ instance that knows how to serialize and deserialize json dc = dcz . DCZ ( mapping , serializers = { \"json\" : json }) # before using it, DCZ instance must be init'ed dc . init () # if it is the first time the device runs, let's call finalize to encrypt resources if needed dc . finalize () # ok, print out the status dc . dump ( entries = True ) # get the list of resource names resources = dc . resources () # load them all and print their values for name in resources : print ( \"Resource\" , name ) resource = dc . load_resource ( name , check = True ) # the result is a Python object! binary_resource = dc . load_resource ( name , check = True , deserialize = False ) binary_resource_encrypted = dc . load_resource ( name , check = True , deserialize = False , decrypt = False ) print ( \"Deserialized:\" , resource ) print ( \"Binary: \" , \"\" . join ([ hex ( x , \"\" ) for x in binary_resource ])) print ( \"Encrypted: \" , \"\" . join ([ hex ( x , \"\" ) for x in binary_resource_encrypted ])) # get the next version next_version = dc . next_version () # now update a resource print ( \"=======================\" ) print ( \"Updating DCZ to version\" , next_version ) print ( \"=======================\" ) if \"test\" not in resource : resource [ \"test\" ] = 0 resource [ \"test\" ] = resource [ \"test\" ] + 1 print ( \"Saving \" , name ) dc . save_resource ( name , resource , format = \"json\" , version = next_version ) print ( \"Yes! Reset the device and see the DCZ get updated again and again...\" ) while ( True ): sleep ( 1000 ) except Exception as e : print ( e )","title":"DCZ"},{"location":"reference/libs/zerynth/dcz/docs/examples/#dcz-for-aws","text":"Simple automatic provisioning of AWS things managed with a DCZ. For the esample to work, a properly configured AWS Account must be present: IAM credentials of a user with access to IoT Core an IoT Policy to enable device connection and publishing # example device policy { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Effect\" : \"Allow\" , \"Action\" : \"iot:Connect\" , \"Resource\" : \"*\" }, { \"Effect\" : \"Allow\" , \"Action\" : \"iot:Publish\" , \"Resource\" : \"arn:aws:iot:<your-aws-region>:<your-aws-account-number>:topic/dev/sample\" } ] } main.py ################################################################################ # Device Configuration Zones # # Created by Zerynth Team 2019 CC # Authors: D. Mazzei, G. Baldi, ############################################################################### import streams import json # import the DCZ module from dcz import dcz # import aws iot module from aws.iot import iot # wifi driver from wireless import wifi from espressif.esp32net import esp32wifi as wifi_driver streams . serial () try : # this example can run on an ESP32 device without modification # otherwise change the addresses both in mapping and in dcz.yml # !!AWS Credentials must also be specified in the dcz.yml for the example to work!! # there will be 2 DCZs at the following addresses mapping = [ 0x310000 , 0x311000 ] # let's create a DCZ instance that knows how to serialize and deserialize json dc = dcz . DCZ ( mapping , serializers = { \"json\" : json }) # before using it, DCZ instance must be init'ed dc . init () # if it is the first time the device runs, let's call finalize to encrypt resources if needed dc . finalize () # ok, print out the status dc . dump ( entries = True ) # define a callback for shadow updates def shadow_callback ( requested ): global publish_period print ( 'requested publish period:' , requested [ 'publish_period' ]) publish_period = requested [ 'publish_period' ] return { 'publish_period' : publish_period } wifi_driver . auto_init () # let's retrieve credentials as an encrypted resource # this file should be updated when the device user input the wifi credentials # by using dc.save_resource() # For the sake of this example, just edit the files/wificred.json with your credentials wificred = dc . load_resource ( \"wificred\" ) print ( 'connecting to wifi...' , wificred [ \"ssid\" ]) wifi . link ( wificred [ \"ssid\" ], wifi . WIFI_WPA2 , wificred [ \"password\" ]) # load resourcef from the DCZ pkey = dc . load_resource ( \"prvkey\" ) clicert = dc . load_resource ( \"clicert\" ) cacert = dc . load_resource ( \"cacert\" ) thing_conf = dc . load_resource ( \"devinfo\" ) endpoint = dc . load_resource ( \"endpoint\" ) publish_period = 1000 # create aws iot thing instance, connect to mqtt broker, set shadow update callback and start mqtt reception loop thing = iot . Thing ( endpoint [ 'endpoint' ], thing_conf [ 'thing_name' ], clicert , pkey , thingname = thing_conf [ 'thing_name' ], cacert = cacert ) # free some memory by setting resources to None pkey = None clicert = None cacert = None print ( 'connecting to mqtt broker' ) print ( \"endpoint:\" , endpoint [ \"endpoint\" ]) print ( \"thing:\" , thing_conf [ \"thing_name\" ]) thing . mqtt . connect () thing . on_shadow_request ( shadow_callback ) thing . mqtt . loop () thing . update_shadow ({ 'publish_period' : publish_period }) while True : print ( 'publish random sample...' ) thing . mqtt . publish ( \"dev/sample\" , json . dumps ({ 'asample' : random ( 0 , 10 ) })) sleep ( publish_period ) except Exception as e : print ( e )","title":"DCZ for AWS"},{"location":"reference/libs/zerynth/genann/docs/","text":"Zerynth Genann \u00b6 Below, Zerynth port of the powerful and simple Genann Artificial Neural Networks C library. Contents: Genann ANN Class Examples Hello XOR","title":"Index"},{"location":"reference/libs/zerynth/genann/docs/#zerynth-genann","text":"Below, Zerynth port of the powerful and simple Genann Artificial Neural Networks C library. Contents: Genann ANN Class Examples Hello XOR","title":"Zerynth Genann"},{"location":"reference/libs/zerynth/genann/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.zerynth.genann. Hello XOR \u00b6 Solve the XOR problem with a pre-trained ANN. main.py # Hello XOR with GENANN # Created at 2018-10-07 15:04:55.068270 import streams from genann import genann streams . serial () try : # create an ANN object ann = genann . ANN () # set the layers: 2 inputs, 1 output, 1 hidden layer of 2 neurons ann . create ( 2 , 1 , 1 , 2 ) # set the weights of a pretrained XOR model (https://github.com/codeplea/genann/blob/master/example/xor.ann) ann . set_weights ([ - 1.777 , - 5.734 , - 6.029 , - 4.460 , - 3.261 , - 3.172 , 2.444 , - 6.581 , 5.826 ]) # define the inputs input_set = [ [ 0.0 , 0.0 ], # 0 xor 0 = 1 [ 0.0 , 1.0 ], # 0 xor 1 = 0 [ 1.0 , 0.0 ], # 1 xor 0 = 0 [ 1.0 , 1.0 ] # 1 xor 1 = 1 ] # run the network for each input set for i in input_set : print ( \"Running XOR on\" , i ) out = ann . run ( i ) print ( \"Result\" , out ) # Enjoy AI on a microcontroller! :) except Exception as e : print ( e )","title":"Examples"},{"location":"reference/libs/zerynth/genann/docs/examples/#examples","text":"The following are a list of examples for lib.zerynth.genann.","title":"Examples"},{"location":"reference/libs/zerynth/genann/docs/examples/#hello-xor","text":"Solve the XOR problem with a pre-trained ANN. main.py # Hello XOR with GENANN # Created at 2018-10-07 15:04:55.068270 import streams from genann import genann streams . serial () try : # create an ANN object ann = genann . ANN () # set the layers: 2 inputs, 1 output, 1 hidden layer of 2 neurons ann . create ( 2 , 1 , 1 , 2 ) # set the weights of a pretrained XOR model (https://github.com/codeplea/genann/blob/master/example/xor.ann) ann . set_weights ([ - 1.777 , - 5.734 , - 6.029 , - 4.460 , - 3.261 , - 3.172 , 2.444 , - 6.581 , 5.826 ]) # define the inputs input_set = [ [ 0.0 , 0.0 ], # 0 xor 0 = 1 [ 0.0 , 1.0 ], # 0 xor 1 = 0 [ 1.0 , 0.0 ], # 1 xor 0 = 0 [ 1.0 , 1.0 ] # 1 xor 1 = 1 ] # run the network for each input set for i in input_set : print ( \"Running XOR on\" , i ) out = ann . run ( i ) print ( \"Result\" , out ) # Enjoy AI on a microcontroller! :) except Exception as e : print ( e )","title":"Hello XOR"},{"location":"reference/libs/zerynth/genann/docs/genann/","text":"Genann \u00b6 Genann is a minimal, well-tested library for training and using feedforward artificial neural networks (ANN) in C. Its primary focus is on being simple, fast, reliable, and hackable. It achieves this by providing only the necessary functions and little extra. This module is a Python wrapper around the genann library hosted here . It allows the execution of feedforward neural networks directly on the microcontroller. The training functions are not yet available. ANN Class \u00b6 class ANN \u00b6 class ANN () This class is an implementations of the interface with the gennann C library. Each istance of this class implements a separate neural network. The class is not thread safe, multiple network must be protected by locks when executed. ANN.create \u00b6 create ( inputs , outputs , nlayers , nhidden ) This method initializes a neural network with inputs inputs, outputs outputs and a number of hidden layers set by nlayers (that can be also 0). Each hidden layer, if present, contains exactly nhidden neurons. ANN.run \u00b6 run ( inputs ) This method executes the neural network using as input the array of float inputs . It returns an array of float representing the output layer. ANN.set_weights \u00b6 set_weights ( weights ) This method initializes the weights of the ANN. It can be used to load a pre-trained set of weights or to initializes the weights before training. Weights are represented by an array of floats weights .","title":"Genann"},{"location":"reference/libs/zerynth/genann/docs/genann/#genann","text":"Genann is a minimal, well-tested library for training and using feedforward artificial neural networks (ANN) in C. Its primary focus is on being simple, fast, reliable, and hackable. It achieves this by providing only the necessary functions and little extra. This module is a Python wrapper around the genann library hosted here . It allows the execution of feedforward neural networks directly on the microcontroller. The training functions are not yet available.","title":"Genann"},{"location":"reference/libs/zerynth/genann/docs/genann/#ann-class","text":"","title":"ANN Class"},{"location":"reference/libs/zerynth/genann/docs/genann/#class-ann","text":"class ANN () This class is an implementations of the interface with the gennann C library. Each istance of this class implements a separate neural network. The class is not thread safe, multiple network must be protected by locks when executed.","title":"class ANN"},{"location":"reference/libs/zerynth/genann/docs/genann/#anncreate","text":"create ( inputs , outputs , nlayers , nhidden ) This method initializes a neural network with inputs inputs, outputs outputs and a number of hidden layers set by nlayers (that can be also 0). Each hidden layer, if present, contains exactly nhidden neurons.","title":"ANN.create"},{"location":"reference/libs/zerynth/genann/docs/genann/#annrun","text":"run ( inputs ) This method executes the neural network using as input the array of float inputs . It returns an array of float representing the output layer.","title":"ANN.run"},{"location":"reference/libs/zerynth/genann/docs/genann/#annset_weights","text":"set_weights ( weights ) This method initializes the weights of the ANN. It can be used to load a pre-trained set of weights or to initializes the weights before training. Weights are represented by an array of floats weights .","title":"ANN.set_weights"},{"location":"reference/libs/zerynth/infrared/docs/","text":"Zerynth Infra Red \u00b6 Infra Red Technology is used for short and medium range communications and controls. Some systems operate in line-of-sight mode (there must be a visually unobstructed straight line through space between transmitter and receiver), and other systems operate in diffuse mode, also called scatter mode (the source and destination are not directly visible to each other but they can exchange data thanks to the signal rebounds). Note IR wireless signals cannot passthrough walls. IR wireless technology is used in intrusion detectors, home-entertainment control units, robot control systems, line-of-sight laser communications, cordless microphones, headsets, modems, printers and other peripherals. Here below, the Zerynth Library for Infra Red functionalities and some examples to better understand how to use it. Contents: Infra Red Library IRPacket class IRReceiver class IRSender class Examples IR Send Raw Data IR Capture Decode and Send","title":"Zerynth Infra Red"},{"location":"reference/libs/zerynth/infrared/docs/#zerynth-infra-red","text":"Infra Red Technology is used for short and medium range communications and controls. Some systems operate in line-of-sight mode (there must be a visually unobstructed straight line through space between transmitter and receiver), and other systems operate in diffuse mode, also called scatter mode (the source and destination are not directly visible to each other but they can exchange data thanks to the signal rebounds). Note IR wireless signals cannot passthrough walls. IR wireless technology is used in intrusion detectors, home-entertainment control units, robot control systems, line-of-sight laser communications, cordless microphones, headsets, modems, printers and other peripherals. Here below, the Zerynth Library for Infra Red functionalities and some examples to better understand how to use it. Contents: Infra Red Library IRPacket class IRReceiver class IRSender class Examples IR Send Raw Data IR Capture Decode and Send","title":"Zerynth Infra Red"},{"location":"reference/libs/zerynth/infrared/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.zerynth.infrared. IR send Raw \u00b6 Simple example showing how to send IR Raw packets stored as sequances of pulses (State 1, State 0) expressed in microseconds. main.py ################################################################################ # IR send Raw Data # # Created by Zerynth Team 2015 CC # Authors: D. Mazzei, G. Baldi, ############################################################################### import streams from infrared import infrared s = streams . serial () #Ir Remotes Raw data can be found on various websites like https://www.remotecentral.com/index.html #The IRSender.sendRaw method takes as input a list of times in microseconds where the first time is for the state 1 phase (IR LED firing) the second time is for state 0 (IR LED OFF) and so on. SamsungON = [ 4500 , 4500 , 590 , 1690 , 590 , 1690 , 590 , 1690 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 1690 , 590 , 1690 , 590 , 1690 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 1690 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 1690 , 590 , 590 , 590 , 1690 , 590 , 1690 , 590 , 1690 , 590 , 1690 , 590 , 1690 , 590 , 1690 , 590 , 4500 , 4500 , 590 , 1690 , 590 , 1690 , 590 , 1690 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 1690 , 590 , 1690 , 590 , 1690 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 ] #Create a IR packet sender passing it the pin where the IR LED is connected to specifying the PWM feature sender = infrared . IRSender ( D6 . PWM ) i = 0 while True : print ( \"Sending Samsung TV ON/OFF\" , i ) sender . sendRaw ( SamsungON ) sleep ( 2000 ) i += 1 IR Capture, Decode and Send \u00b6 Basics example showing how to capture IR packet and decode them. The IR capture is performed through an IR demodulator connected to a pin empowered with ICU feature. Once decoded, captured packet can be printed on the console or sent through an IR LED connected to a pin empowered with PWM feature. At the current stage the Zerynth Infrared library decode only Samsung and NEC protocols. Other protocols will be added soon. However, any captured packet can be stored and sent as raw packet without requiring a specific protocol decoder. main.py ################################################################################ # IR Capture, Decode and Send # # Created by Zerynth Team 2015 CC # Authors: D. Mazzei, G. Baldi, ############################################################################### import streams from infrared import infrared s = streams . serial () #create an instance of the IR receiver class passing it the pin where the IR demodulator is connected specifiying the ICU feature receiver = infrared . IRReceiver ( D2 . ICU ) #Create a IR packet sender specifying the pin where the IR LED is connected specifying the PWM feature sender = infrared . IRSender ( D6 . PWM ) while True : print ( \"Capturing...\" ) packet = receiver . captureAndDecode () packet . printPacket ( s ) print ( \"Wait 3 secs before sending the captured packet\" ) sleep ( 3000 ) for i in range ( 3 ): print ( \"Sending...\" , i ) sender . send ( packet ) sleep ( 1500 )","title":"Examples"},{"location":"reference/libs/zerynth/infrared/docs/examples/#examples","text":"The following are a list of examples for lib.zerynth.infrared.","title":"Examples"},{"location":"reference/libs/zerynth/infrared/docs/examples/#ir-send-raw","text":"Simple example showing how to send IR Raw packets stored as sequances of pulses (State 1, State 0) expressed in microseconds. main.py ################################################################################ # IR send Raw Data # # Created by Zerynth Team 2015 CC # Authors: D. Mazzei, G. Baldi, ############################################################################### import streams from infrared import infrared s = streams . serial () #Ir Remotes Raw data can be found on various websites like https://www.remotecentral.com/index.html #The IRSender.sendRaw method takes as input a list of times in microseconds where the first time is for the state 1 phase (IR LED firing) the second time is for state 0 (IR LED OFF) and so on. SamsungON = [ 4500 , 4500 , 590 , 1690 , 590 , 1690 , 590 , 1690 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 1690 , 590 , 1690 , 590 , 1690 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 1690 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 1690 , 590 , 590 , 590 , 1690 , 590 , 1690 , 590 , 1690 , 590 , 1690 , 590 , 1690 , 590 , 1690 , 590 , 4500 , 4500 , 590 , 1690 , 590 , 1690 , 590 , 1690 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 1690 , 590 , 1690 , 590 , 1690 , 590 , 590 , 590 , 590 , 590 , 590 , 590 , 590 ] #Create a IR packet sender passing it the pin where the IR LED is connected to specifying the PWM feature sender = infrared . IRSender ( D6 . PWM ) i = 0 while True : print ( \"Sending Samsung TV ON/OFF\" , i ) sender . sendRaw ( SamsungON ) sleep ( 2000 ) i += 1","title":"IR send Raw"},{"location":"reference/libs/zerynth/infrared/docs/examples/#ir-capture-decode-and-send","text":"Basics example showing how to capture IR packet and decode them. The IR capture is performed through an IR demodulator connected to a pin empowered with ICU feature. Once decoded, captured packet can be printed on the console or sent through an IR LED connected to a pin empowered with PWM feature. At the current stage the Zerynth Infrared library decode only Samsung and NEC protocols. Other protocols will be added soon. However, any captured packet can be stored and sent as raw packet without requiring a specific protocol decoder. main.py ################################################################################ # IR Capture, Decode and Send # # Created by Zerynth Team 2015 CC # Authors: D. Mazzei, G. Baldi, ############################################################################### import streams from infrared import infrared s = streams . serial () #create an instance of the IR receiver class passing it the pin where the IR demodulator is connected specifiying the ICU feature receiver = infrared . IRReceiver ( D2 . ICU ) #Create a IR packet sender specifying the pin where the IR LED is connected specifying the PWM feature sender = infrared . IRSender ( D6 . PWM ) while True : print ( \"Capturing...\" ) packet = receiver . captureAndDecode () packet . printPacket ( s ) print ( \"Wait 3 secs before sending the captured packet\" ) sleep ( 3000 ) for i in range ( 3 ): print ( \"Sending...\" , i ) sender . send ( packet ) sleep ( 1500 )","title":"IR Capture, Decode and Send"},{"location":"reference/libs/zerynth/infrared/docs/infrared/","text":"Infra Red Library \u00b6 Infra Red Capture, Send and Decode module. This module contains class definitions and methods to capture, decode and send IR packets. The IRPacket class allows the definition of IRPacket objects. The IRReceiver class allows the definition of an IR capture unit based on an IR receiver and demodulator connected to a pin empowered with ICU feature. The IRSender class allows the definition of an IR sender based on an IR LED connected to a pin endowed with PWM feature. IRPacket class \u00b6 class IRPacket \u00b6 class IRPacket ( packet_type , addr1 , addr2 , d1 , d2 , hexd , rawdata , databits ) This is the class that allows the definition of IR messages/packets. Attributes: packet_type: it is a string identifying the packet IR protocol of the message. Currently the following packets are supported: SAMSUNG, NEC and UNKNOWN. addr1: it is the first address data packet (to be set to 0 if not supported by the selected protocol) addr2: it is the second address data packet (to be set to 0 if not supported by the selected protocol) d1: it is the first message data packet d2: it is the second message data packet (to be set as 0 if not supported by the selected protocol) hexd: it is the Hexadecimal string representing the data contained in d1 and d2 rawdata: it is a list of int containing the raw data acquired by the transducer during the acquisition of the packet. Data are listed as int representing the duration in microseconds of a \u201cpulse state\u201d the first reported time is an HIGH pulse duration, the second is the duration of the following LOW pulse and so on. databits: is a list of strings \u201c0\u201d or \u201c1\u201d representing the boolean decode of rawdata obtained through the decoder selected according to the packet_type IrPacket instances are generated by the infrared.decode() and are taken as input by the IRSender.send() methods. IRPacket.printPacket \u00b6 printPacket ( stream ) Generates a Print-friendly and readable output containing the packet data and print it on the selected stream. IRReceiver class \u00b6 class IRReceiver \u00b6 class IRReceiver ( IrRecvPin ) This is the class that allows definition of an IR receivers made by using an IR demodulator. IrRecvPin : The pin connected with the IR demodulator. The pin have to be endowed with ICU functionality and passed using the Dx.ICU signature. IRReceiver.decode \u00b6 decode ( data ) Analyzes the raw captured data identifying the protocol. If the protocol is recognized data are decoded and an IRPacket returned. Otherwise an IRPacket with packet_type \u201cUNKNOWN\u201d is returned. IRReceiver.capture \u00b6 capture ( max_samples = 100 , time_window = 200 , wait = 0 ) Starts the IR capture activating the ICU on the receiver pin. max_samples: it sets the number of samples to be collected before terminate the capture. Default is set to 100 that works for most of the used IR protocols. time_window: it sets the max amount in milliseconds of the capture window. Default is set to 200 milliseconds that works for most of the used IR protocols. wait: it allows the definition of a sleeping time in millisecond to be waited after a capture in order to avoid capturing repeated packets as partial raw data. Consider that air conditioning remote controller IR packets are very long therefore these values have to be tuned according to the desired application. The method returns raw captured data packet that can be used as input for IRSender.sendRaw() or decoded using IRReceiver.decode(). IRReceiver.captureAndDecode \u00b6 captureAndDecode ( max_samples = 100 , time_window = 200 , wait = 0 ) Starts the IR capture activating the ICU on the receiver pin and pass the captured raw signal to the decode method returning an IRPacket. max_samples: it sets the number of samples to be collected before terminate the capture. Default is set to 100 that works for most of the used IR protocols. time_window: it sets the max amount in milliseconds of the capture window. Default is set to 200 milliseconds that works for most of the used IR protocols. wait: it allows the definition of a sleeping time in millisecond to be waited after a capture in order to avoid capturing repeated packet as partial raw data. Consider that air conditioning remote controller IR packets are very long therefore these values have to be tuned according tot the desired application. The method returns an IRPacket. IRSender class \u00b6 class IRSender \u00b6 class IRSender ( IRSenderPin , Frequency = 38000 , Duty = 30 ) This is the class that allows the definition of an IR sender made by connecting and IR LED to a pin endowed with PWM. IRSenderPin: it is the pin where the LED is connected. Have to be passed specifying the PWM feature i.e, D3.PWM Frequency: it is the IR pulse modulation frequency. default is set to 38000 Hz that is the most used standard. Duty: It is the duration in percentage 0-100 of the IR pulse. The duty definition allows reducing power consumption avoiding long pulses. Default is set to 30 while values in the range 20-50 can be used. The class has two methods for sending respectively raw data and IRPacket. IRSender.sendRaw \u00b6 sendRaw ( data ) Sends raw data by taking as input a list of pulses duration in microseconds. The first represents the duration of IR firing phase (state 1) while the the second is the IR LED OFF phase (state 0) and so on. IRSender.send \u00b6 send ( IRPacket ) Sends the IR message contained in the passed IRPacket. If IRPacket packet_type is UNKNOWN data are sent as raw data.","title":"Infra Red Library"},{"location":"reference/libs/zerynth/infrared/docs/infrared/#infra-red-library","text":"Infra Red Capture, Send and Decode module. This module contains class definitions and methods to capture, decode and send IR packets. The IRPacket class allows the definition of IRPacket objects. The IRReceiver class allows the definition of an IR capture unit based on an IR receiver and demodulator connected to a pin empowered with ICU feature. The IRSender class allows the definition of an IR sender based on an IR LED connected to a pin endowed with PWM feature.","title":"Infra Red Library"},{"location":"reference/libs/zerynth/infrared/docs/infrared/#irpacket-class","text":"","title":"IRPacket class"},{"location":"reference/libs/zerynth/infrared/docs/infrared/#class-irpacket","text":"class IRPacket ( packet_type , addr1 , addr2 , d1 , d2 , hexd , rawdata , databits ) This is the class that allows the definition of IR messages/packets. Attributes: packet_type: it is a string identifying the packet IR protocol of the message. Currently the following packets are supported: SAMSUNG, NEC and UNKNOWN. addr1: it is the first address data packet (to be set to 0 if not supported by the selected protocol) addr2: it is the second address data packet (to be set to 0 if not supported by the selected protocol) d1: it is the first message data packet d2: it is the second message data packet (to be set as 0 if not supported by the selected protocol) hexd: it is the Hexadecimal string representing the data contained in d1 and d2 rawdata: it is a list of int containing the raw data acquired by the transducer during the acquisition of the packet. Data are listed as int representing the duration in microseconds of a \u201cpulse state\u201d the first reported time is an HIGH pulse duration, the second is the duration of the following LOW pulse and so on. databits: is a list of strings \u201c0\u201d or \u201c1\u201d representing the boolean decode of rawdata obtained through the decoder selected according to the packet_type IrPacket instances are generated by the infrared.decode() and are taken as input by the IRSender.send() methods.","title":"class IRPacket"},{"location":"reference/libs/zerynth/infrared/docs/infrared/#irpacketprintpacket","text":"printPacket ( stream ) Generates a Print-friendly and readable output containing the packet data and print it on the selected stream.","title":"IRPacket.printPacket"},{"location":"reference/libs/zerynth/infrared/docs/infrared/#irreceiver-class","text":"","title":"IRReceiver class"},{"location":"reference/libs/zerynth/infrared/docs/infrared/#class-irreceiver","text":"class IRReceiver ( IrRecvPin ) This is the class that allows definition of an IR receivers made by using an IR demodulator. IrRecvPin : The pin connected with the IR demodulator. The pin have to be endowed with ICU functionality and passed using the Dx.ICU signature.","title":"class IRReceiver"},{"location":"reference/libs/zerynth/infrared/docs/infrared/#irreceiverdecode","text":"decode ( data ) Analyzes the raw captured data identifying the protocol. If the protocol is recognized data are decoded and an IRPacket returned. Otherwise an IRPacket with packet_type \u201cUNKNOWN\u201d is returned.","title":"IRReceiver.decode"},{"location":"reference/libs/zerynth/infrared/docs/infrared/#irreceivercapture","text":"capture ( max_samples = 100 , time_window = 200 , wait = 0 ) Starts the IR capture activating the ICU on the receiver pin. max_samples: it sets the number of samples to be collected before terminate the capture. Default is set to 100 that works for most of the used IR protocols. time_window: it sets the max amount in milliseconds of the capture window. Default is set to 200 milliseconds that works for most of the used IR protocols. wait: it allows the definition of a sleeping time in millisecond to be waited after a capture in order to avoid capturing repeated packets as partial raw data. Consider that air conditioning remote controller IR packets are very long therefore these values have to be tuned according to the desired application. The method returns raw captured data packet that can be used as input for IRSender.sendRaw() or decoded using IRReceiver.decode().","title":"IRReceiver.capture"},{"location":"reference/libs/zerynth/infrared/docs/infrared/#irreceivercaptureanddecode","text":"captureAndDecode ( max_samples = 100 , time_window = 200 , wait = 0 ) Starts the IR capture activating the ICU on the receiver pin and pass the captured raw signal to the decode method returning an IRPacket. max_samples: it sets the number of samples to be collected before terminate the capture. Default is set to 100 that works for most of the used IR protocols. time_window: it sets the max amount in milliseconds of the capture window. Default is set to 200 milliseconds that works for most of the used IR protocols. wait: it allows the definition of a sleeping time in millisecond to be waited after a capture in order to avoid capturing repeated packet as partial raw data. Consider that air conditioning remote controller IR packets are very long therefore these values have to be tuned according tot the desired application. The method returns an IRPacket.","title":"IRReceiver.captureAndDecode"},{"location":"reference/libs/zerynth/infrared/docs/infrared/#irsender-class","text":"","title":"IRSender class"},{"location":"reference/libs/zerynth/infrared/docs/infrared/#class-irsender","text":"class IRSender ( IRSenderPin , Frequency = 38000 , Duty = 30 ) This is the class that allows the definition of an IR sender made by connecting and IR LED to a pin endowed with PWM. IRSenderPin: it is the pin where the LED is connected. Have to be passed specifying the PWM feature i.e, D3.PWM Frequency: it is the IR pulse modulation frequency. default is set to 38000 Hz that is the most used standard. Duty: It is the duration in percentage 0-100 of the IR pulse. The duty definition allows reducing power consumption avoiding long pulses. Default is set to 30 while values in the range 20-50 can be used. The class has two methods for sending respectively raw data and IRPacket.","title":"class IRSender"},{"location":"reference/libs/zerynth/infrared/docs/infrared/#irsendersendraw","text":"sendRaw ( data ) Sends raw data by taking as input a list of pulses duration in microseconds. The first represents the duration of IR firing phase (state 1) while the the second is the IR LED OFF phase (state 0) and so on.","title":"IRSender.sendRaw"},{"location":"reference/libs/zerynth/infrared/docs/infrared/#irsendersend","text":"send ( IRPacket ) Sends the IR message contained in the passed IRPacket. If IRPacket packet_type is UNKNOWN data are sent as raw data.","title":"IRSender.send"},{"location":"reference/libs/zerynth/lwmqtt/docs/","text":"Zerynth Lightweight MQTT \u00b6 MQTT is a machine-to-machine (M2M) connectivity protocol usable for \u201cInternet of Things\u201d solutions. It is designed as an extremely lightweight publish/subscribe messaging transport and is useful for connections with remote locations where a small code footprint is required and/or network bandwidth is at a premium. It is ideal for mobile applications because of its small size, low power usage, minimised data packets, and efficient distribution of information to one or many receivers; more information at MQTT dedicated page . This publish/subscribe messaging pattern requires a message broker. The broker is responsible for distributing messages to interested clients based on the topic of a message. So a client must connect to a broker in order to: publish messages specifying a topic so that other clients that have subscribed to that topic will be able to receive those messages; receive messages subscribing to a specific topic. To clarify this behaviour imagine a home network of temperature sensors and controllers where each temperature sensor publishes sampled data on \u2018home/nameOfRoom\u2019 channel and the home temperature controller subscribes to all channels to achieve a smart heating. Here below, the Zerynth Lightweight Library for MQTT connectivity protocol and some examples to better understand how to use it. Contents: Lightweight MQTT Library Client class Examples LWMQTT at mosquitto org","title":"Zerynth Lightweight MQTT"},{"location":"reference/libs/zerynth/lwmqtt/docs/#zerynth-lightweight-mqtt","text":"MQTT is a machine-to-machine (M2M) connectivity protocol usable for \u201cInternet of Things\u201d solutions. It is designed as an extremely lightweight publish/subscribe messaging transport and is useful for connections with remote locations where a small code footprint is required and/or network bandwidth is at a premium. It is ideal for mobile applications because of its small size, low power usage, minimised data packets, and efficient distribution of information to one or many receivers; more information at MQTT dedicated page . This publish/subscribe messaging pattern requires a message broker. The broker is responsible for distributing messages to interested clients based on the topic of a message. So a client must connect to a broker in order to: publish messages specifying a topic so that other clients that have subscribed to that topic will be able to receive those messages; receive messages subscribing to a specific topic. To clarify this behaviour imagine a home network of temperature sensors and controllers where each temperature sensor publishes sampled data on \u2018home/nameOfRoom\u2019 channel and the home temperature controller subscribes to all channels to achieve a smart heating. Here below, the Zerynth Lightweight Library for MQTT connectivity protocol and some examples to better understand how to use it. Contents: Lightweight MQTT Library Client class Examples LWMQTT at mosquitto org","title":"Zerynth Lightweight MQTT"},{"location":"reference/libs/zerynth/lwmqtt/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.zerynth.lwmqtt. LWMQTT at mosquitto.org \u00b6 This simple example shows how to connect to an mqtt broker using Zerynth lwmqtt module and start publishing and receiving messages. main.py import streams import json from microchip.winc1500 import winc1500 as wifi_driver # from espressif.esp32net import esp32wifi as wifi_driver from wireless import wifi from lwmqtt import mqtt def hello_samples ( client , payload ): print ( '> received: ' , payload ) def connection_subscribe ( client ): # subscribe after connection to that even after re-connection subscription are renewed client . subscribe ( \"zerynth/samples\" , hello_samples ) def loop_failure ( client ): # called when packet handle loop fails # the user can implement reconnection logic (e.g. exponential backoff) here while True : try : print ( \"> reconnecting...\" ) client . reconnect () break except Exception as e : print ( e ) sleep ( 1000 ) return mqtt . RECOVERED streams . serial () wifi_driver . auto_init ( ext = 1 ) print ( '> wifi link' ) wifi . link ( \"SSID\" , wifi . WIFI_WPA2 , \"PSW\" ) print ( '> linked' ) client = mqtt . Client ( \"zerynth-mqtt\" ) # connect to \"test.mosquitto.org\" for retry in range ( 10 ): try : print ( \"connect\" ) client . connect ( \"test.mosquitto.org\" , 60 , aconnect_cb = connection_subscribe , loop_failure = loop_failure ) break except Exception as e : print ( \"connecting...\" ) else : print ( \"> connection failed!\" ) raise IOError print ( \"> connected.\" ) # subscribe to channels client . subscribe ( \"zerynth/samples\" , hello_samples ) while True : if client . connected (): print ( \"> publish.\" ) client . publish ( \"zerynth/samples\" , json . dumps ({ 'rand' : random ( 0 , 10 )})) sleep ( 1000 )","title":"Examples"},{"location":"reference/libs/zerynth/lwmqtt/docs/examples/#examples","text":"The following are a list of examples for lib.zerynth.lwmqtt.","title":"Examples"},{"location":"reference/libs/zerynth/lwmqtt/docs/examples/#lwmqtt-at-mosquittoorg","text":"This simple example shows how to connect to an mqtt broker using Zerynth lwmqtt module and start publishing and receiving messages. main.py import streams import json from microchip.winc1500 import winc1500 as wifi_driver # from espressif.esp32net import esp32wifi as wifi_driver from wireless import wifi from lwmqtt import mqtt def hello_samples ( client , payload ): print ( '> received: ' , payload ) def connection_subscribe ( client ): # subscribe after connection to that even after re-connection subscription are renewed client . subscribe ( \"zerynth/samples\" , hello_samples ) def loop_failure ( client ): # called when packet handle loop fails # the user can implement reconnection logic (e.g. exponential backoff) here while True : try : print ( \"> reconnecting...\" ) client . reconnect () break except Exception as e : print ( e ) sleep ( 1000 ) return mqtt . RECOVERED streams . serial () wifi_driver . auto_init ( ext = 1 ) print ( '> wifi link' ) wifi . link ( \"SSID\" , wifi . WIFI_WPA2 , \"PSW\" ) print ( '> linked' ) client = mqtt . Client ( \"zerynth-mqtt\" ) # connect to \"test.mosquitto.org\" for retry in range ( 10 ): try : print ( \"connect\" ) client . connect ( \"test.mosquitto.org\" , 60 , aconnect_cb = connection_subscribe , loop_failure = loop_failure ) break except Exception as e : print ( \"connecting...\" ) else : print ( \"> connection failed!\" ) raise IOError print ( \"> connected.\" ) # subscribe to channels client . subscribe ( \"zerynth/samples\" , hello_samples ) while True : if client . connected (): print ( \"> publish.\" ) client . publish ( \"zerynth/samples\" , json . dumps ({ 'rand' : random ( 0 , 10 )})) sleep ( 1000 )","title":"LWMQTT at mosquitto.org"},{"location":"reference/libs/zerynth/lwmqtt/docs/mqtt/","text":"Lightweight MQTT Library \u00b6 This module contains an implementation of an MQTT client based on the paho-project embedded c client . It aims to be less memory consuming than the pure Python one. The Client allows to connect to a broker (both via insecure and TLS channels) and start publishing messages/subscribing to topics with a simple interface. Python callbacks can be easily set to handle incoming messages. Reconnection can be manually handled by the user by means of several callbacks and methods ( reconnect() , connected() , loop_failure ) Client class \u00b6 class Client \u00b6 class Client ( client_id , clean_session = True , cycle_timeout = 500 , command_timeout = 60000 ) Arguments: client_id \u2013 unique ID of the MQTT Client (multiple clients connecting to the same broken with the same ID are not allowed), can be an empty string with clean_session set to true. clean_session \u2013 when True requests the broker to assign a clean state to connecting client without remembering previous subscriptions or other configurations. cycle_timeout \u2013 maximum time to wait for received messages on every loop cycle (in milliseconds) command_timeout \u2013 maximum time to wait for protocol commands to be acknowledged (in milliseconds) Instantiates the MQTT Client. Client.connect \u00b6 connect ( host , keepalive , port = 1883 , ssl_ctx = None , breconnect_cb = None , aconnect_cb = None , loop_failure = None , start_loop = True ) Arguments: host \u2013 hostname or IP address of the remote broker. port \u2013 network port of the server host to connect to, defaults to 1883. keepalive \u2013 maximum period in seconds between communications with the broker. If no other messages are being exchanged, this controls the rate at which the client will send ping messages to the broker. ssl_ctx \u2013 optional ssl context (Zerynth SSL module) for secure mqtt channels. breconnect_cb \u2013 optional callback with actions to be performed when reconnect() is called. The callback function will be called passing mqtt client instance. aconnect_cb \u2013 optional callback with actions to be performed after the client successfully connects. The callback function will be called passing mqtt client instance. loop_failure \u2013 optional callback with actions to be performed on failures happening during the MQTT read cycle. The user should try to implement client reconnection logic here. By default, or if loop_failure callback returns mqtt.BREAK_LOOP , the read loop is terminated on failures. loop_failure callback must return mqtt.RECOVERED to keep the MQTT read cycle alive. start_loop \u2013 if True starts the MQTT read cycle after connection. Connects to a remote broker and start the MQTT reception thread. Client.get_return_code \u00b6 get_return_code () Get the return code of the last connection attempt. Client.reconnect \u00b6 reconnect () Tries to connect again with previously set connection parameters. If breconnect_cb was passed to connect() , breconnect_cb is executed first. Return the return code of the connection. Client.connected \u00b6 connected () Returns True if client is connected, False otherwise. Client.loop \u00b6 loop () Starts MQTT background loop to handle incoming packets. Already called by connect() if start_loop is True . Client.set_username_pw \u00b6 set_username_pw ( username , password = '' ) Arguments: username \u2013 connection username. password \u2013 connection password. Sets connection username and password. Client.publish \u00b6 publish ( topic , payload = '' , qos = 0 , retain = False ) Arguments: topic \u2013 topic the message should be published on. payload \u2013 actual message to send. If not given a zero length message will be used. qos \u2013 is the quality of service level to use. retain \u2013 if set to true, the message will be set as the \u201clast known good\u201d/retained message for the topic. Publishes a message on a topic. This causes a message to be sent to the broker and subsequently from the broker to any clients subscribing to matching topics. Client.subscribe \u00b6 subscribe ( topic , function , qos = 0 ) ` * Arguments: topic \u2013 topic to subscribe to. function \u2013 callback to be executed when a message published on chosen topic is received. qos \u2013 quality of service for the subscription. Subscribes to a topic and set a callback for processing messages published on it. The callback function is called passing three parameters: the MQTT client object, the payload of received message and the actual topic: def my_callback ( mqtt_client , payload , topic ): # do something with client, payload and topic ... Client.unsubscribe \u00b6 unsubscribe ( topic ) Unsubscribes the client from one topic. Arguments: topic \u2013 is the string representing the subscribed topic to unsubscribe from. Client.disconnect \u00b6 disconnect ( timeout = None ) Sends a disconnect message, optionally waiting for the loop to exit. Arguments: timeout \u2013 is the maximum time to wait (in milliseconds).","title":"Lightweight MQTT Library"},{"location":"reference/libs/zerynth/lwmqtt/docs/mqtt/#lightweight-mqtt-library","text":"This module contains an implementation of an MQTT client based on the paho-project embedded c client . It aims to be less memory consuming than the pure Python one. The Client allows to connect to a broker (both via insecure and TLS channels) and start publishing messages/subscribing to topics with a simple interface. Python callbacks can be easily set to handle incoming messages. Reconnection can be manually handled by the user by means of several callbacks and methods ( reconnect() , connected() , loop_failure )","title":"Lightweight MQTT Library"},{"location":"reference/libs/zerynth/lwmqtt/docs/mqtt/#client-class","text":"","title":"Client class"},{"location":"reference/libs/zerynth/lwmqtt/docs/mqtt/#class-client","text":"class Client ( client_id , clean_session = True , cycle_timeout = 500 , command_timeout = 60000 ) Arguments: client_id \u2013 unique ID of the MQTT Client (multiple clients connecting to the same broken with the same ID are not allowed), can be an empty string with clean_session set to true. clean_session \u2013 when True requests the broker to assign a clean state to connecting client without remembering previous subscriptions or other configurations. cycle_timeout \u2013 maximum time to wait for received messages on every loop cycle (in milliseconds) command_timeout \u2013 maximum time to wait for protocol commands to be acknowledged (in milliseconds) Instantiates the MQTT Client.","title":"class Client"},{"location":"reference/libs/zerynth/lwmqtt/docs/mqtt/#clientconnect","text":"connect ( host , keepalive , port = 1883 , ssl_ctx = None , breconnect_cb = None , aconnect_cb = None , loop_failure = None , start_loop = True ) Arguments: host \u2013 hostname or IP address of the remote broker. port \u2013 network port of the server host to connect to, defaults to 1883. keepalive \u2013 maximum period in seconds between communications with the broker. If no other messages are being exchanged, this controls the rate at which the client will send ping messages to the broker. ssl_ctx \u2013 optional ssl context (Zerynth SSL module) for secure mqtt channels. breconnect_cb \u2013 optional callback with actions to be performed when reconnect() is called. The callback function will be called passing mqtt client instance. aconnect_cb \u2013 optional callback with actions to be performed after the client successfully connects. The callback function will be called passing mqtt client instance. loop_failure \u2013 optional callback with actions to be performed on failures happening during the MQTT read cycle. The user should try to implement client reconnection logic here. By default, or if loop_failure callback returns mqtt.BREAK_LOOP , the read loop is terminated on failures. loop_failure callback must return mqtt.RECOVERED to keep the MQTT read cycle alive. start_loop \u2013 if True starts the MQTT read cycle after connection. Connects to a remote broker and start the MQTT reception thread.","title":"Client.connect"},{"location":"reference/libs/zerynth/lwmqtt/docs/mqtt/#clientget_return_code","text":"get_return_code () Get the return code of the last connection attempt.","title":"Client.get_return_code"},{"location":"reference/libs/zerynth/lwmqtt/docs/mqtt/#clientreconnect","text":"reconnect () Tries to connect again with previously set connection parameters. If breconnect_cb was passed to connect() , breconnect_cb is executed first. Return the return code of the connection.","title":"Client.reconnect"},{"location":"reference/libs/zerynth/lwmqtt/docs/mqtt/#clientconnected","text":"connected () Returns True if client is connected, False otherwise.","title":"Client.connected"},{"location":"reference/libs/zerynth/lwmqtt/docs/mqtt/#clientloop","text":"loop () Starts MQTT background loop to handle incoming packets. Already called by connect() if start_loop is True .","title":"Client.loop"},{"location":"reference/libs/zerynth/lwmqtt/docs/mqtt/#clientset_username_pw","text":"set_username_pw ( username , password = '' ) Arguments: username \u2013 connection username. password \u2013 connection password. Sets connection username and password.","title":"Client.set_username_pw"},{"location":"reference/libs/zerynth/lwmqtt/docs/mqtt/#clientpublish","text":"publish ( topic , payload = '' , qos = 0 , retain = False ) Arguments: topic \u2013 topic the message should be published on. payload \u2013 actual message to send. If not given a zero length message will be used. qos \u2013 is the quality of service level to use. retain \u2013 if set to true, the message will be set as the \u201clast known good\u201d/retained message for the topic. Publishes a message on a topic. This causes a message to be sent to the broker and subsequently from the broker to any clients subscribing to matching topics.","title":"Client.publish"},{"location":"reference/libs/zerynth/lwmqtt/docs/mqtt/#clientsubscribe","text":"subscribe ( topic , function , qos = 0 ) ` * Arguments: topic \u2013 topic to subscribe to. function \u2013 callback to be executed when a message published on chosen topic is received. qos \u2013 quality of service for the subscription. Subscribes to a topic and set a callback for processing messages published on it. The callback function is called passing three parameters: the MQTT client object, the payload of received message and the actual topic: def my_callback ( mqtt_client , payload , topic ): # do something with client, payload and topic ...","title":"Client.subscribe"},{"location":"reference/libs/zerynth/lwmqtt/docs/mqtt/#clientunsubscribe","text":"unsubscribe ( topic ) Unsubscribes the client from one topic. Arguments: topic \u2013 is the string representing the subscribed topic to unsubscribe from.","title":"Client.unsubscribe"},{"location":"reference/libs/zerynth/lwmqtt/docs/mqtt/#clientdisconnect","text":"disconnect ( timeout = None ) Sends a disconnect message, optionally waiting for the loop to exit. Arguments: timeout \u2013 is the maximum time to wait (in milliseconds).","title":"Client.disconnect"},{"location":"reference/libs/zerynth/modbus/docs/","text":"Zerynth Modbus \u00b6 Modbus is a serial communication protocol published by Modicon in 1979 for use with its PLCs. There are two different devices involved: Master : the device requesting the informations; Slave : the device supplying the informations. In a standard network there is one Master and up to 247 slaves, each with a unique Slave Address (identifier) from 1 to 247. The protocol has become a standard in industry and today it\u2019s the most commonly available means of connecting industrial electronic devices. This library allows to communicate with slave modbus devices both via TCP and via serial line. The modbus specification can be (freely) found at http://modbus.org/ . To work via RTU, a device class that implements read, write and close methods is needed. Both examples of RTU and TCP communication are provided, as well as an implementation of a device class for the rs485. Contents: MODBUS Library ModbusTCP class ModbusSerial class Examples ModbusTcp ModbusSerial","title":"Zerynth Modbus"},{"location":"reference/libs/zerynth/modbus/docs/#zerynth-modbus","text":"Modbus is a serial communication protocol published by Modicon in 1979 for use with its PLCs. There are two different devices involved: Master : the device requesting the informations; Slave : the device supplying the informations. In a standard network there is one Master and up to 247 slaves, each with a unique Slave Address (identifier) from 1 to 247. The protocol has become a standard in industry and today it\u2019s the most commonly available means of connecting industrial electronic devices. This library allows to communicate with slave modbus devices both via TCP and via serial line. The modbus specification can be (freely) found at http://modbus.org/ . To work via RTU, a device class that implements read, write and close methods is needed. Both examples of RTU and TCP communication are provided, as well as an implementation of a device class for the rs485. Contents: MODBUS Library ModbusTCP class ModbusSerial class Examples ModbusTcp ModbusSerial","title":"Zerynth Modbus"},{"location":"reference/libs/zerynth/modbus/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.zerynth.modbus. main.py ################################################################################ # Modbus communications via tcp. # # Created: 2019-03-21 # Author: L. Marsicano ################################################################################ import streams # Needed for internet connectivity. # This is dependent on your device. from wireless import wifi from espressif.esp32net import esp32wifi as wifi_driver from modbus import modbus wifi_driver . auto_init () streams . serial () try : try : wifi . link ( \"SSID\" , 3 , \"password\" ) except Exception as e : print ( \"Exception while trying to connect to the network \" , e ) master = modbus . ModbusTCP ( 1 ) try : master . connect ( \"ip-address\" ) print ( \"Connected.\" ) except Exception as e : print ( \"Couldn't connect to the slave device \" , e ) result = master . write_coil ( 2 , 0xff00 ) print ( \"Written coil 2: \" , result ) result = master . write_register ( 55 , 745 ) print ( \"Written discrete register: \" , result ) result = master . write_multiple_coils ( 10 , 10 , [ 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 ]) print ( \"Written \" , result , \" coils\" ) result = master . write_multiple_registers ( 20 , 10 , [ 55 , 555 , 123 , 42 , 352 , 546 , 754 , 34 , 643 , 23 ]) print ( \"Written \" , result , \" registers\" ) coils = master . read_coils ( 20 , 19 ) print ( \"Coils 20-38 status: \" , coils ) discrete = master . read_discrete ( 20 , 15 ) print ( \"Discrete inputs 20-34 values: \" , discrete ) holding = master . read_holding ( 20 , 10 ) print ( \"Holding registers 20-29 values: \" , holding ) inputs = master . read_input ( 20 , 10 ) print ( \"Input registers 20-29 values: \" , inputs ) master . close () print ( \"Closed.\" ) except Exception as e : print ( \"Error \" , e ) main.py ################################################################################ # Modbus communications via serial line. # # Created: 2019-03-21 # Author: L. Marsicano ################################################################################ import rs485 from modbus import modbus import streams try : device = rs485 . RS485 ( 100000 ) # Wait for the serial port to open. This may not be necessary sleep ( 10000 ) master = modbus . ModbusSerial ( 1 , serial_device = device ) result = master . write_register ( 5 , 745 ) print ( \"Written discrete register: \" , result ) result = master . write_multiple_registers ( 2 , 4 , [ 55 , 555 , 123 , 42 ]) print ( \"Written \" , result , \" registers\" ) discrete = master . read_discrete ( 2 , 4 ) print ( \"Discrete inputs values: \" , discrete ) holding = master . read_holding ( 3 , 2 ) print ( \"Holding registers values: \" , holding ) master . close () print ( \"Closed.\" ) except Exception as e : print ( \"Exception \" , e )","title":"Examples"},{"location":"reference/libs/zerynth/modbus/docs/examples/#examples","text":"The following are a list of examples for lib.zerynth.modbus. main.py ################################################################################ # Modbus communications via tcp. # # Created: 2019-03-21 # Author: L. Marsicano ################################################################################ import streams # Needed for internet connectivity. # This is dependent on your device. from wireless import wifi from espressif.esp32net import esp32wifi as wifi_driver from modbus import modbus wifi_driver . auto_init () streams . serial () try : try : wifi . link ( \"SSID\" , 3 , \"password\" ) except Exception as e : print ( \"Exception while trying to connect to the network \" , e ) master = modbus . ModbusTCP ( 1 ) try : master . connect ( \"ip-address\" ) print ( \"Connected.\" ) except Exception as e : print ( \"Couldn't connect to the slave device \" , e ) result = master . write_coil ( 2 , 0xff00 ) print ( \"Written coil 2: \" , result ) result = master . write_register ( 55 , 745 ) print ( \"Written discrete register: \" , result ) result = master . write_multiple_coils ( 10 , 10 , [ 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 ]) print ( \"Written \" , result , \" coils\" ) result = master . write_multiple_registers ( 20 , 10 , [ 55 , 555 , 123 , 42 , 352 , 546 , 754 , 34 , 643 , 23 ]) print ( \"Written \" , result , \" registers\" ) coils = master . read_coils ( 20 , 19 ) print ( \"Coils 20-38 status: \" , coils ) discrete = master . read_discrete ( 20 , 15 ) print ( \"Discrete inputs 20-34 values: \" , discrete ) holding = master . read_holding ( 20 , 10 ) print ( \"Holding registers 20-29 values: \" , holding ) inputs = master . read_input ( 20 , 10 ) print ( \"Input registers 20-29 values: \" , inputs ) master . close () print ( \"Closed.\" ) except Exception as e : print ( \"Error \" , e ) main.py ################################################################################ # Modbus communications via serial line. # # Created: 2019-03-21 # Author: L. Marsicano ################################################################################ import rs485 from modbus import modbus import streams try : device = rs485 . RS485 ( 100000 ) # Wait for the serial port to open. This may not be necessary sleep ( 10000 ) master = modbus . ModbusSerial ( 1 , serial_device = device ) result = master . write_register ( 5 , 745 ) print ( \"Written discrete register: \" , result ) result = master . write_multiple_registers ( 2 , 4 , [ 55 , 555 , 123 , 42 ]) print ( \"Written \" , result , \" registers\" ) discrete = master . read_discrete ( 2 , 4 ) print ( \"Discrete inputs values: \" , discrete ) holding = master . read_holding ( 3 , 2 ) print ( \"Holding registers values: \" , holding ) master . close () print ( \"Closed.\" ) except Exception as e : print ( \"Exception \" , e )","title":"Examples"},{"location":"reference/libs/zerynth/modbus/docs/modbus/","text":"MODBUS Library \u00b6 To talk with a slave device an object of type ModbusTCP or ModbusSerial must be initialized, depending on what kind of communication is needed. If serial communication is used, a device object that implements write, read and close methods is needed: Example: import gpio import streams import mcu import sfw from semtech.sx1503 import sx1503 RS485EN = D40 LED_R = D47 LED_G = D54 LED_B = D55 pinmap = { # now add pins definition for the expander LED_R : 7 , # LED R mapped to pin 7 on sx1503 LED_G : 14 , # LED G mapped to pin 14 on sx1503 LED_B : 15 , # LED B mapped to pin 15 on sx1503 RS485EN : 0 , # RS485 pin trasmit/recieve } class RS485 (): def __init__ ( self , watchdog_time ): sfw . watchdog ( 0 , watchdog_time ) port_expander = sx1503 . SX1503 ( I2C0 , 400000 ) gpio . add_expander ( 1 , port_expander , pinmap ) gpio . mode ( LED_R , OUTPUT ) gpio . mode ( LED_G , OUTPUT ) gpio . mode ( LED_B , OUTPUT ) gpio . mode ( RS485EN , OUTPUT ) gpio . low ( LED_G ) gpio . low ( LED_R ) gpio . high ( LED_B ) gpio . low ( RS485EN ) self . port = streams . serial ( drvname = SERIAL1 , baud = 9600 , set_default = False ) def read ( self ): gpio . low ( RS485EN ) bc = self . port . available () sfw . kick () return self . port . read ( bc ) def write ( self , packet ): gpio . high ( RS485EN ) self . port . write ( packet ) gpio . low ( RS485EN ) sfw . kick () def close ( self ): self . port . close () When a connection with a slave device has been established, coils and registers can be accessed with the methods in each class. ModbusTCP class \u00b6 class ModbusTCP \u00b6 class ModbusTCP ( identifier ) Create an instance of the ModbusTCP class which allow modbus communication with slave device using TCP. Arguments: identifier \u2013 The slave device identifier, used in the header of every packet. ModbusTCP.read_coils \u00b6 read_coils ( address , n ) Arguments: address \u2013 The starting address n \u2013 the number of coils to read from address Read the status of n coils, starting from address . Returns: a python list containing the values of the coils. ModbusTCP.read_input \u00b6 read_input ( address , n ) Arguments address \u2013 The starting address n \u2013 the number of input register to read, starting from address Returns: a python list containing the values of the input registers. ModbusTCP.read_holding \u00b6 read_holding ( address , n ) Arguments: address \u2013 The starting address n \u2013 the number of holding register to read, starting from address Returns: a python list containing the values of the holding registers. ModbusTCP.read_discrete \u00b6 read_discrete ( address , n ) Arguments: address \u2013 The starting address n \u2013 the number of discrete register to read, starting from address Returns: a python list containing the values of the discrete registers. ModbusTCP.write_coil \u00b6 write_coil ( address , n ) Arguments: address \u2013 the address of the coil value \u2013 the new value Returns: 1 if the write has been successfull. Otherwhise an exception will be thrown. ModbusTCP.write_register \u00b6 write_register ( address , n ) Arguments: address \u2013 the address of the register value \u2013 the new value Returns: 1 if the write has been successfull. Otherwhise an exception will be thrown. ModbusTCP.write_multiple_coils \u00b6 write_multiple_coils ( address , n , value Arguments: address \u2013 the address of the first coil n \u2013 the number of coils value \u2013 a python list containing the new values Returns: the number of coils written. ModbusTCP.write_multiple_registers \u00b6 write_multiple_registers ( address , n , values ) Arguments: address \u2013 the address of the first holding register n \u2013 the number of registers value \u2013 a python list containing the new values Returns: the number of holding registers written ModbusTCP.connect \u00b6 connect ( address , ) Arguments: address \u2013 the ip address of the slave device port \u2013 port on which the slave device is listening to ModbusTCP.close \u00b6 close () Close the connection with the slave device. ModbusSerial class \u00b6 class ModbusSerial \u00b6 class ModbusSerial ( identifier , serial_device ) Create an instance of the ModbusSerial class which allow modbus communication with slave device using RTU. Arguments: identifier \u2013 The slave device identifier serial_device \u2013 an object representing the device. It must implement read, write and close methods to communicate with the serial port. See rs485 in the example folder. receive_sleep \u2013 timeout on the receiving function; ModbusSerial.read_coils \u00b6 read_coils ( address , n ) Arguments: address \u2013 The starting address n \u2013 the number of coils to read from address Read the status of n coils, starting from address . Returns: a python list containing the values of the coils. ModbusSerial.read_input \u00b6 read_input ( address , n ) Arguments: address \u2013 The starting address n \u2013 the number of input register to read, starting from address Returns: a python list containing the values of the input registers. ModbusSerial.read_holding \u00b6 read_holding ( address , n ) Arguments: address \u2013 The starting address n \u2013 the number of holding register to read, starting from address Returns: a python list containing the values of the holding registers. ModbusSerial.read_discrete \u00b6 read_discrete ( address , n ) Arguments: address \u2013 The starting address n \u2013 the number of discrete register to read, starting from address Returns: a python list containing the values of the discrete registers. ModbusSerial.write_coil \u00b6 write_coil ( address , n ) Arguments: address \u2013 the address of the coil value \u2013 the new value Returns: 1 if the write has been successfull. Otherwhise an exception will be thrown. ModbusSerial.write_register \u00b6 write_register ( address , n ) Arguments: address \u2013 the address of the register value \u2013 the new value Returns: 1 if the write has been successfull. Otherwhise an exception will be thrown. ModbusSerial.write_multiple_coils \u00b6 write_multiple_coils ( address , n , values ) Arguments: address \u2013 the address of the first coil n \u2013 the number of coils value \u2013 a python list containing the new values Returns: the number of coils written. ModbusSerial.write_multiple_registers \u00b6 write_multiple_registers ( address , n , values ) Arguments: address \u2013 the address of the first holding register n \u2013 the number of registers value \u2013 a python list containing the new values Returns: the number of holding registers written. ModbusSerial.close \u00b6 close () Close the serial port by calling the close function implemented by the device class.","title":"MODBUS Library"},{"location":"reference/libs/zerynth/modbus/docs/modbus/#modbus-library","text":"To talk with a slave device an object of type ModbusTCP or ModbusSerial must be initialized, depending on what kind of communication is needed. If serial communication is used, a device object that implements write, read and close methods is needed: Example: import gpio import streams import mcu import sfw from semtech.sx1503 import sx1503 RS485EN = D40 LED_R = D47 LED_G = D54 LED_B = D55 pinmap = { # now add pins definition for the expander LED_R : 7 , # LED R mapped to pin 7 on sx1503 LED_G : 14 , # LED G mapped to pin 14 on sx1503 LED_B : 15 , # LED B mapped to pin 15 on sx1503 RS485EN : 0 , # RS485 pin trasmit/recieve } class RS485 (): def __init__ ( self , watchdog_time ): sfw . watchdog ( 0 , watchdog_time ) port_expander = sx1503 . SX1503 ( I2C0 , 400000 ) gpio . add_expander ( 1 , port_expander , pinmap ) gpio . mode ( LED_R , OUTPUT ) gpio . mode ( LED_G , OUTPUT ) gpio . mode ( LED_B , OUTPUT ) gpio . mode ( RS485EN , OUTPUT ) gpio . low ( LED_G ) gpio . low ( LED_R ) gpio . high ( LED_B ) gpio . low ( RS485EN ) self . port = streams . serial ( drvname = SERIAL1 , baud = 9600 , set_default = False ) def read ( self ): gpio . low ( RS485EN ) bc = self . port . available () sfw . kick () return self . port . read ( bc ) def write ( self , packet ): gpio . high ( RS485EN ) self . port . write ( packet ) gpio . low ( RS485EN ) sfw . kick () def close ( self ): self . port . close () When a connection with a slave device has been established, coils and registers can be accessed with the methods in each class.","title":"MODBUS Library"},{"location":"reference/libs/zerynth/modbus/docs/modbus/#modbustcp-class","text":"","title":"ModbusTCP class"},{"location":"reference/libs/zerynth/modbus/docs/modbus/#class-modbustcp","text":"class ModbusTCP ( identifier ) Create an instance of the ModbusTCP class which allow modbus communication with slave device using TCP. Arguments: identifier \u2013 The slave device identifier, used in the header of every packet.","title":"class ModbusTCP"},{"location":"reference/libs/zerynth/modbus/docs/modbus/#modbustcpread_coils","text":"read_coils ( address , n ) Arguments: address \u2013 The starting address n \u2013 the number of coils to read from address Read the status of n coils, starting from address . Returns: a python list containing the values of the coils.","title":"ModbusTCP.read_coils"},{"location":"reference/libs/zerynth/modbus/docs/modbus/#modbustcpread_input","text":"read_input ( address , n ) Arguments address \u2013 The starting address n \u2013 the number of input register to read, starting from address Returns: a python list containing the values of the input registers.","title":"ModbusTCP.read_input"},{"location":"reference/libs/zerynth/modbus/docs/modbus/#modbustcpread_holding","text":"read_holding ( address , n ) Arguments: address \u2013 The starting address n \u2013 the number of holding register to read, starting from address Returns: a python list containing the values of the holding registers.","title":"ModbusTCP.read_holding"},{"location":"reference/libs/zerynth/modbus/docs/modbus/#modbustcpread_discrete","text":"read_discrete ( address , n ) Arguments: address \u2013 The starting address n \u2013 the number of discrete register to read, starting from address Returns: a python list containing the values of the discrete registers.","title":"ModbusTCP.read_discrete"},{"location":"reference/libs/zerynth/modbus/docs/modbus/#modbustcpwrite_coil","text":"write_coil ( address , n ) Arguments: address \u2013 the address of the coil value \u2013 the new value Returns: 1 if the write has been successfull. Otherwhise an exception will be thrown.","title":"ModbusTCP.write_coil"},{"location":"reference/libs/zerynth/modbus/docs/modbus/#modbustcpwrite_register","text":"write_register ( address , n ) Arguments: address \u2013 the address of the register value \u2013 the new value Returns: 1 if the write has been successfull. Otherwhise an exception will be thrown.","title":"ModbusTCP.write_register"},{"location":"reference/libs/zerynth/modbus/docs/modbus/#modbustcpwrite_multiple_coils","text":"write_multiple_coils ( address , n , value Arguments: address \u2013 the address of the first coil n \u2013 the number of coils value \u2013 a python list containing the new values Returns: the number of coils written.","title":"ModbusTCP.write_multiple_coils"},{"location":"reference/libs/zerynth/modbus/docs/modbus/#modbustcpwrite_multiple_registers","text":"write_multiple_registers ( address , n , values ) Arguments: address \u2013 the address of the first holding register n \u2013 the number of registers value \u2013 a python list containing the new values Returns: the number of holding registers written","title":"ModbusTCP.write_multiple_registers"},{"location":"reference/libs/zerynth/modbus/docs/modbus/#modbustcpconnect","text":"connect ( address , ) Arguments: address \u2013 the ip address of the slave device port \u2013 port on which the slave device is listening to","title":"ModbusTCP.connect"},{"location":"reference/libs/zerynth/modbus/docs/modbus/#modbustcpclose","text":"close () Close the connection with the slave device.","title":"ModbusTCP.close"},{"location":"reference/libs/zerynth/modbus/docs/modbus/#modbusserial-class","text":"","title":"ModbusSerial class"},{"location":"reference/libs/zerynth/modbus/docs/modbus/#class-modbusserial","text":"class ModbusSerial ( identifier , serial_device ) Create an instance of the ModbusSerial class which allow modbus communication with slave device using RTU. Arguments: identifier \u2013 The slave device identifier serial_device \u2013 an object representing the device. It must implement read, write and close methods to communicate with the serial port. See rs485 in the example folder. receive_sleep \u2013 timeout on the receiving function;","title":"class ModbusSerial"},{"location":"reference/libs/zerynth/modbus/docs/modbus/#modbusserialread_coils","text":"read_coils ( address , n ) Arguments: address \u2013 The starting address n \u2013 the number of coils to read from address Read the status of n coils, starting from address . Returns: a python list containing the values of the coils.","title":"ModbusSerial.read_coils"},{"location":"reference/libs/zerynth/modbus/docs/modbus/#modbusserialread_input","text":"read_input ( address , n ) Arguments: address \u2013 The starting address n \u2013 the number of input register to read, starting from address Returns: a python list containing the values of the input registers.","title":"ModbusSerial.read_input"},{"location":"reference/libs/zerynth/modbus/docs/modbus/#modbusserialread_holding","text":"read_holding ( address , n ) Arguments: address \u2013 The starting address n \u2013 the number of holding register to read, starting from address Returns: a python list containing the values of the holding registers.","title":"ModbusSerial.read_holding"},{"location":"reference/libs/zerynth/modbus/docs/modbus/#modbusserialread_discrete","text":"read_discrete ( address , n ) Arguments: address \u2013 The starting address n \u2013 the number of discrete register to read, starting from address Returns: a python list containing the values of the discrete registers.","title":"ModbusSerial.read_discrete"},{"location":"reference/libs/zerynth/modbus/docs/modbus/#modbusserialwrite_coil","text":"write_coil ( address , n ) Arguments: address \u2013 the address of the coil value \u2013 the new value Returns: 1 if the write has been successfull. Otherwhise an exception will be thrown.","title":"ModbusSerial.write_coil"},{"location":"reference/libs/zerynth/modbus/docs/modbus/#modbusserialwrite_register","text":"write_register ( address , n ) Arguments: address \u2013 the address of the register value \u2013 the new value Returns: 1 if the write has been successfull. Otherwhise an exception will be thrown.","title":"ModbusSerial.write_register"},{"location":"reference/libs/zerynth/modbus/docs/modbus/#modbusserialwrite_multiple_coils","text":"write_multiple_coils ( address , n , values ) Arguments: address \u2013 the address of the first coil n \u2013 the number of coils value \u2013 a python list containing the new values Returns: the number of coils written.","title":"ModbusSerial.write_multiple_coils"},{"location":"reference/libs/zerynth/modbus/docs/modbus/#modbusserialwrite_multiple_registers","text":"write_multiple_registers ( address , n , values ) Arguments: address \u2013 the address of the first holding register n \u2013 the number of registers value \u2013 a python list containing the new values Returns: the number of holding registers written.","title":"ModbusSerial.write_multiple_registers"},{"location":"reference/libs/zerynth/modbus/docs/modbus/#modbusserialclose","text":"close () Close the serial port by calling the close function implemented by the device class.","title":"ModbusSerial.close"},{"location":"reference/libs/zerynth/mqtt/docs/","text":"Zerynth MQTT \u00b6 MQTT is a machine-to-machine (M2M) connectivity protocol usable for \u201cInternet of Things\u201d solutions. It is designed as an extremely lightweight publish/subscribe messaging transport and is useful for connections with remote locations where a small code footprint is required and/or network bandwidth is at a premium. It is ideal for mobile applications because of its small size, low power usage, minimised data packets, and efficient distribution of information to one or many receivers; more information at MQTT dedicated page This publish/subscribe messaging pattern requires a message broker. The broker is responsible for distributing messages to interested clients based on the topic of a message. So a client must connect to a broker in order to: publish messages specifying a topic so that other clients that have subscribed to that topic will be able to receive those messages; receive messages subscribing to a specific topic. To clarify this behaviour imagine a home network of temperature sensors and controllers where each temperature sensor publishes sampled data on \u2018home/nameOfRoom\u2019 channel and the home temperature controller subscribes to all channels to achieve a smart heating. Here below, the Zerynth Library for MQTT connectivity protocol and some examples to better understand how to use it. Contents: MQTT Library MQTTMessage class Client class Examples MQTT at mosquitto org","title":"Zerynth MQTT"},{"location":"reference/libs/zerynth/mqtt/docs/#zerynth-mqtt","text":"MQTT is a machine-to-machine (M2M) connectivity protocol usable for \u201cInternet of Things\u201d solutions. It is designed as an extremely lightweight publish/subscribe messaging transport and is useful for connections with remote locations where a small code footprint is required and/or network bandwidth is at a premium. It is ideal for mobile applications because of its small size, low power usage, minimised data packets, and efficient distribution of information to one or many receivers; more information at MQTT dedicated page This publish/subscribe messaging pattern requires a message broker. The broker is responsible for distributing messages to interested clients based on the topic of a message. So a client must connect to a broker in order to: publish messages specifying a topic so that other clients that have subscribed to that topic will be able to receive those messages; receive messages subscribing to a specific topic. To clarify this behaviour imagine a home network of temperature sensors and controllers where each temperature sensor publishes sampled data on \u2018home/nameOfRoom\u2019 channel and the home temperature controller subscribes to all channels to achieve a smart heating. Here below, the Zerynth Library for MQTT connectivity protocol and some examples to better understand how to use it. Contents: MQTT Library MQTTMessage class Client class Examples MQTT at mosquitto org","title":"Zerynth MQTT"},{"location":"reference/libs/zerynth/mqtt/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.zerynth.mqtt. MQTT at mosquitto.org \u00b6 This simple example shows how to connect to an mqtt broker using Zerynth mqtt module and how to start publishing data on a channel and receiving data from other sources publishing on different ones. main.py ################################################################################ # MQTT at mosquitto.org # # Created: 2015-10-15 21:37:25.886276 # ################################################################################ import streams from mqtt import mqtt from wireless import wifi # the wifi module needs a networking driver to be loaded # in order to control the device hardware. # FOR THIS EXAMPLE TO WORK, A NETWORK DRIVER MUST BE SELECTED BELOW # uncomment one of the following lines depending on used board # (e.g. Particle Photon, esp8266 based board, esp32 based board) # from broadcom.bcm43362 import bcm43362 as wifi_driver # from espressif.esp32net import esp32wifi as wifi_driver # from espressif.esp8266wifi import esp8266wifi as wifi_driver # init the wifi driver! # The driver automatically registers itself to the wifi interface # with the correct configuration for the selected device wifi_driver . auto_init () streams . serial () # use the wifi interface to link to the Access Point # change network name, security and password as needed print ( \"Establishing Link...\" ) try : # FOR THIS EXAMPLE TO WORK, \"Network-Name\" AND \"Wifi-Password\" MUST BE SET # TO MATCH YOUR ACTUAL NETWORK CONFIGURATION wifi . link ( \"Network-Name\" , wifi . WIFI_WPA2 , \"Wifi-Password\" ) except Exception as e : print ( \"ooops, something wrong while linking :(\" , e ) while True : sleep ( 1000 ) # define MQTT callbacks def is_sample ( data ): if ( 'message' in data ): return ( data [ 'message' ] . qos == 1 and data [ 'message' ] . topic == \"desktop/samples\" ) return False def print_sample ( client , data ): message = data [ 'message' ] print ( \"sample received: \" , message . payload ) def print_other ( client , data ): message = data [ 'message' ] print ( \"topic: \" , message . topic ) print ( \"payload received: \" , message . payload ) def send_sample ( obj ): print ( \"publishing: \" , obj ) client . publish ( \"temp/random\" , str ( obj )) def publish_to_self (): client . publish ( \"desktop/samples\" , \"hello! \" + str ( random ( 0 , 10 ))) try : # set the mqtt id to \"zerynth-mqtt\" client = mqtt . Client ( \"zerynth-mqtt\" , True ) # and try to connect to \"test.mosquitto.org\" for retry in range ( 10 ): try : client . connect ( \"test.mosquitto.org\" , 60 ) break except Exception as e : print ( \"connecting...\" ) print ( \"connected.\" ) # subscribe to channels client . subscribe ([[ \"desktop/samples\" , 1 ]]) client . subscribe ([[ \"desktop/others\" , 2 ]]) # configure callbacks for \"PUBLISH\" message client . on ( mqtt . PUBLISH , print_sample , is_sample ) # start the mqtt loop client . loop ( print_other ) # Every 3 seconds, send a random number to \"temp/random\" # you can check temp/random changing here: http://test.mosquitto.org/gauge/ while True : sleep ( 3000 ) x = random ( 0 , 50 ) send_sample ( x ) # when x ends with 0, publish a message to desktop/samples # it is echoed back if x % 10 == 0 : publish_to_self () except Exception as e : print ( e )","title":"Examples"},{"location":"reference/libs/zerynth/mqtt/docs/examples/#examples","text":"The following are a list of examples for lib.zerynth.mqtt.","title":"Examples"},{"location":"reference/libs/zerynth/mqtt/docs/examples/#mqtt-at-mosquittoorg","text":"This simple example shows how to connect to an mqtt broker using Zerynth mqtt module and how to start publishing data on a channel and receiving data from other sources publishing on different ones. main.py ################################################################################ # MQTT at mosquitto.org # # Created: 2015-10-15 21:37:25.886276 # ################################################################################ import streams from mqtt import mqtt from wireless import wifi # the wifi module needs a networking driver to be loaded # in order to control the device hardware. # FOR THIS EXAMPLE TO WORK, A NETWORK DRIVER MUST BE SELECTED BELOW # uncomment one of the following lines depending on used board # (e.g. Particle Photon, esp8266 based board, esp32 based board) # from broadcom.bcm43362 import bcm43362 as wifi_driver # from espressif.esp32net import esp32wifi as wifi_driver # from espressif.esp8266wifi import esp8266wifi as wifi_driver # init the wifi driver! # The driver automatically registers itself to the wifi interface # with the correct configuration for the selected device wifi_driver . auto_init () streams . serial () # use the wifi interface to link to the Access Point # change network name, security and password as needed print ( \"Establishing Link...\" ) try : # FOR THIS EXAMPLE TO WORK, \"Network-Name\" AND \"Wifi-Password\" MUST BE SET # TO MATCH YOUR ACTUAL NETWORK CONFIGURATION wifi . link ( \"Network-Name\" , wifi . WIFI_WPA2 , \"Wifi-Password\" ) except Exception as e : print ( \"ooops, something wrong while linking :(\" , e ) while True : sleep ( 1000 ) # define MQTT callbacks def is_sample ( data ): if ( 'message' in data ): return ( data [ 'message' ] . qos == 1 and data [ 'message' ] . topic == \"desktop/samples\" ) return False def print_sample ( client , data ): message = data [ 'message' ] print ( \"sample received: \" , message . payload ) def print_other ( client , data ): message = data [ 'message' ] print ( \"topic: \" , message . topic ) print ( \"payload received: \" , message . payload ) def send_sample ( obj ): print ( \"publishing: \" , obj ) client . publish ( \"temp/random\" , str ( obj )) def publish_to_self (): client . publish ( \"desktop/samples\" , \"hello! \" + str ( random ( 0 , 10 ))) try : # set the mqtt id to \"zerynth-mqtt\" client = mqtt . Client ( \"zerynth-mqtt\" , True ) # and try to connect to \"test.mosquitto.org\" for retry in range ( 10 ): try : client . connect ( \"test.mosquitto.org\" , 60 ) break except Exception as e : print ( \"connecting...\" ) print ( \"connected.\" ) # subscribe to channels client . subscribe ([[ \"desktop/samples\" , 1 ]]) client . subscribe ([[ \"desktop/others\" , 2 ]]) # configure callbacks for \"PUBLISH\" message client . on ( mqtt . PUBLISH , print_sample , is_sample ) # start the mqtt loop client . loop ( print_other ) # Every 3 seconds, send a random number to \"temp/random\" # you can check temp/random changing here: http://test.mosquitto.org/gauge/ while True : sleep ( 3000 ) x = random ( 0 , 50 ) send_sample ( x ) # when x ends with 0, publish a message to desktop/samples # it is echoed back if x % 10 == 0 : publish_to_self () except Exception as e : print ( e )","title":"MQTT at mosquitto.org"},{"location":"reference/libs/zerynth/mqtt/docs/mqtt/","text":"MQTT Library \u00b6 This module contains an implementation of the MQTT protocol (client-side) based on the work of Roger Light < roger@atchoo.org > from the paho-project . When publishing and subscribing, a client is able to specify a quality of service (QoS) level for messages which activates procedures to assure a message to be actually delivered or received, available levels are: 0 - at most once 1 - at least once 2 - exactly once Note Resource clearly explaining the QoS feature: mqtt-quality-of-service-levels . Back to the implementation Zerynth mqtt.Client class provides methods to: connect to a broker publish subscribe unsubscribe disconnect from the broker and a system of callbacks to handle incoming packets. MQTTMessage class \u00b6 class MQTTMessage \u00b6 class MQTTMessage () This is a class that describes an incoming message. It is passed to callbacks as message field in the data dictionary. Members: topic : String. topic that the message was published on. payload : String. the message payload. qos : Integer. The message Quality of Service 0, 1 or 2. retain : Boolean. If true, the message is a retained message and not fresh. mid : Integer. The message id. Client class \u00b6 class Client \u00b6 class Client () This is the main module class. After connecting to a broker it is suggested to subscribe to some channels and configure callbacks. Then, a non-blocking loop function, starts a separate thread to handle incoming packets. Example: my_client = mqtt . Client ( \"myId\" , True ) for retry in range ( 10 ): try : my_client . connect ( \"test.mosquitto.org\" , 60 ) break except Exception as e : print ( \"connecting...\" ) my_client . subscribe ([[ \"cool/channel\" , 1 ]]) my_client . on ( mqtt . PUBLISH , print_cool_stuff , is_cool ) my_client . loop () # do something else... Details about the callback system under on() method. Client. init \u00b6 __init__ ( client_id , clean_session = True ) client_id is the unique client id string used when connecting to the broker. clean_session is a boolean that determines the client type. If True, the broker will remove all information about this client when it disconnects. If False, the client is a persistent client and subscription information and queued messages will be retained when the client disconnects. Note that a client will never discard its own outgoing messages if accidentally disconnected: calling reconnect() will cause the messages to be resent. Client.on \u00b6 on ( command , function , condition = None , priority = 0 ) Set a callback in response to an MQTT received command. command is a constant referring to which MQTT command call the callback on, can be one of: mqtt . PUBLISH mqtt . PUBACK mqtt . PUBREC mqtt . PUBREL mqtt . PUBCOMP mqtt . SUBACK mqtt . UNSUBACK mqtt . PINGREQ mqtt . PINGRESP function is the function to execute if condition is respected. It takes both the client itself and a data dictionary as parameters. The data dictionary may contain the following fields: message : MQTTMessage present only on PUBLISH packets for messages with qos equal to 0 or 1, or on PUBREL packets for messages with qos equal to 2 condition is a function taking the same data dictionary as parameter and returning True or False if the packet respects a certain condition. condition parameter is optional because a generic callback can be set without specifying a condition, only in response to a command. A callback of this type is called a \u2018low priority\u2019 callback meaning that it is called only if all the more specific callbacks (the ones with condition) get a False condition response. Example: def is_cool ( data ): if ( 'message' in data ): return ( data [ 'message' ] . topic == \"cool\" ) # N.B. not checking if 'message' is in data could lead to Exception # on PUBLISH packets for messages with qos equal to 2 return False def print_cool_stuff ( client , data ): print ( \"cool: \" , data [ 'message' ] . payload ) def print_generic_stuff ( client , data ): if ( 'message' in data ): print ( \"not cool: \" , data [ 'message' ] . payload ) my_client . on ( mqtt . PUBLISH , print_cool_stuff , is_cool ) my_client . on ( mqtt . PUBLISH , print_generic_stuff ) In the above example for every PUBLISH packet it is checked if the topic is cool , only if this condition fails, print_generic_stuff gets executed. Client.set_will \u00b6 set_will ( topic , payload , qos , retain ) Set client will. Client.set_username_pw \u00b6 set_username_pw ( username , password = None ) Set connection username and password. Client.connect \u00b6 connect ( host , keepalive , port = 1883 , ssl_ctx = None , breconnect_cb = None , aconnect_cb = None , sock_keepalive = None ) Connects to a remote broker. host is the hostname or IP address of the remote broker. port is the network port of the server host to connect to. Defaults to 1883. keepalive is the maximum period in seconds between communications with the broker. If no other messages are being exchanged, this controls the rate at which the client will send ping messages to the broker. ssl_ctx is an optional ssl context (Zerynth SSL module) for secure mqtt channels. breconnect_cb is an optional callback with actions to be performed before the client tries to reconnect when connection is lost. The callback function will be called passing mqtt client instance. aconnect_cb is an optional callback with actions to be performed after the client successfully connects. The callback function will be called passing mqtt client instance. sock_keepalive is a list of int values (3 elements) representing in order count (pure number), idle (in seconds) and interval (in seconds) of the keepalive socket option (default None - disabled). Client.reconnect \u00b6 reconnect () Reconnects the client if accidentally disconnected. Client.subscribe \u00b6 subscribe ( topics Subscribes to one or more topics. topis a list structured this way: [[ topic1 , qos1 ],[ topic2 , qos2 ], ... ] where topic1,topic2,\u2026 are strings and qos1,qos2,\u2026 are integers for the maximum quality of service for each topic Client.unsubscribe \u00b6 unsubscribe ( topics ) Unsubscribes the client from one or more topics. topics is list of strings that are subscribed topics to unsubscribe from. Client.publish \u00b6 publish ( topic , payload = None , qos = 0 , retain = False ) Publishes a message on a topic. This causes a message to be sent to the broker and subsequently from the broker to any clients subscribing to matching topics. topic is the topic that the message should be published on. payload is the actual message to send. If not given, or set to None a zero length message will be used. qos is the quality of service level to use. retain : if set to true, the message will be set as the \u201clast known good\u201d/retained message for the topic. It returns the mid generated for the message to give the possibility to set a callback precisely for that message. Client.reconnect \u00b6 reconnect () Sends a disconnect message. Client.loop \u00b6 loop ( on_message = None ) Non blocking loop method that starts a thread to handle incoming packets. on_message is an optional argument to set a generic callback on messages with qos equal to 0, 1 or 2","title":"MQTT Library"},{"location":"reference/libs/zerynth/mqtt/docs/mqtt/#mqtt-library","text":"This module contains an implementation of the MQTT protocol (client-side) based on the work of Roger Light < roger@atchoo.org > from the paho-project . When publishing and subscribing, a client is able to specify a quality of service (QoS) level for messages which activates procedures to assure a message to be actually delivered or received, available levels are: 0 - at most once 1 - at least once 2 - exactly once Note Resource clearly explaining the QoS feature: mqtt-quality-of-service-levels . Back to the implementation Zerynth mqtt.Client class provides methods to: connect to a broker publish subscribe unsubscribe disconnect from the broker and a system of callbacks to handle incoming packets.","title":"MQTT Library"},{"location":"reference/libs/zerynth/mqtt/docs/mqtt/#mqttmessage-class","text":"","title":"MQTTMessage class"},{"location":"reference/libs/zerynth/mqtt/docs/mqtt/#class-mqttmessage","text":"class MQTTMessage () This is a class that describes an incoming message. It is passed to callbacks as message field in the data dictionary. Members: topic : String. topic that the message was published on. payload : String. the message payload. qos : Integer. The message Quality of Service 0, 1 or 2. retain : Boolean. If true, the message is a retained message and not fresh. mid : Integer. The message id.","title":"class MQTTMessage"},{"location":"reference/libs/zerynth/mqtt/docs/mqtt/#client-class","text":"","title":"Client class"},{"location":"reference/libs/zerynth/mqtt/docs/mqtt/#class-client","text":"class Client () This is the main module class. After connecting to a broker it is suggested to subscribe to some channels and configure callbacks. Then, a non-blocking loop function, starts a separate thread to handle incoming packets. Example: my_client = mqtt . Client ( \"myId\" , True ) for retry in range ( 10 ): try : my_client . connect ( \"test.mosquitto.org\" , 60 ) break except Exception as e : print ( \"connecting...\" ) my_client . subscribe ([[ \"cool/channel\" , 1 ]]) my_client . on ( mqtt . PUBLISH , print_cool_stuff , is_cool ) my_client . loop () # do something else... Details about the callback system under on() method.","title":"class Client"},{"location":"reference/libs/zerynth/mqtt/docs/mqtt/#clientinit","text":"__init__ ( client_id , clean_session = True ) client_id is the unique client id string used when connecting to the broker. clean_session is a boolean that determines the client type. If True, the broker will remove all information about this client when it disconnects. If False, the client is a persistent client and subscription information and queued messages will be retained when the client disconnects. Note that a client will never discard its own outgoing messages if accidentally disconnected: calling reconnect() will cause the messages to be resent.","title":"Client.init"},{"location":"reference/libs/zerynth/mqtt/docs/mqtt/#clienton","text":"on ( command , function , condition = None , priority = 0 ) Set a callback in response to an MQTT received command. command is a constant referring to which MQTT command call the callback on, can be one of: mqtt . PUBLISH mqtt . PUBACK mqtt . PUBREC mqtt . PUBREL mqtt . PUBCOMP mqtt . SUBACK mqtt . UNSUBACK mqtt . PINGREQ mqtt . PINGRESP function is the function to execute if condition is respected. It takes both the client itself and a data dictionary as parameters. The data dictionary may contain the following fields: message : MQTTMessage present only on PUBLISH packets for messages with qos equal to 0 or 1, or on PUBREL packets for messages with qos equal to 2 condition is a function taking the same data dictionary as parameter and returning True or False if the packet respects a certain condition. condition parameter is optional because a generic callback can be set without specifying a condition, only in response to a command. A callback of this type is called a \u2018low priority\u2019 callback meaning that it is called only if all the more specific callbacks (the ones with condition) get a False condition response. Example: def is_cool ( data ): if ( 'message' in data ): return ( data [ 'message' ] . topic == \"cool\" ) # N.B. not checking if 'message' is in data could lead to Exception # on PUBLISH packets for messages with qos equal to 2 return False def print_cool_stuff ( client , data ): print ( \"cool: \" , data [ 'message' ] . payload ) def print_generic_stuff ( client , data ): if ( 'message' in data ): print ( \"not cool: \" , data [ 'message' ] . payload ) my_client . on ( mqtt . PUBLISH , print_cool_stuff , is_cool ) my_client . on ( mqtt . PUBLISH , print_generic_stuff ) In the above example for every PUBLISH packet it is checked if the topic is cool , only if this condition fails, print_generic_stuff gets executed.","title":"Client.on"},{"location":"reference/libs/zerynth/mqtt/docs/mqtt/#clientset_will","text":"set_will ( topic , payload , qos , retain ) Set client will.","title":"Client.set_will"},{"location":"reference/libs/zerynth/mqtt/docs/mqtt/#clientset_username_pw","text":"set_username_pw ( username , password = None ) Set connection username and password.","title":"Client.set_username_pw"},{"location":"reference/libs/zerynth/mqtt/docs/mqtt/#clientconnect","text":"connect ( host , keepalive , port = 1883 , ssl_ctx = None , breconnect_cb = None , aconnect_cb = None , sock_keepalive = None ) Connects to a remote broker. host is the hostname or IP address of the remote broker. port is the network port of the server host to connect to. Defaults to 1883. keepalive is the maximum period in seconds between communications with the broker. If no other messages are being exchanged, this controls the rate at which the client will send ping messages to the broker. ssl_ctx is an optional ssl context (Zerynth SSL module) for secure mqtt channels. breconnect_cb is an optional callback with actions to be performed before the client tries to reconnect when connection is lost. The callback function will be called passing mqtt client instance. aconnect_cb is an optional callback with actions to be performed after the client successfully connects. The callback function will be called passing mqtt client instance. sock_keepalive is a list of int values (3 elements) representing in order count (pure number), idle (in seconds) and interval (in seconds) of the keepalive socket option (default None - disabled).","title":"Client.connect"},{"location":"reference/libs/zerynth/mqtt/docs/mqtt/#clientreconnect","text":"reconnect () Reconnects the client if accidentally disconnected.","title":"Client.reconnect"},{"location":"reference/libs/zerynth/mqtt/docs/mqtt/#clientsubscribe","text":"subscribe ( topics Subscribes to one or more topics. topis a list structured this way: [[ topic1 , qos1 ],[ topic2 , qos2 ], ... ] where topic1,topic2,\u2026 are strings and qos1,qos2,\u2026 are integers for the maximum quality of service for each topic","title":"Client.subscribe"},{"location":"reference/libs/zerynth/mqtt/docs/mqtt/#clientunsubscribe","text":"unsubscribe ( topics ) Unsubscribes the client from one or more topics. topics is list of strings that are subscribed topics to unsubscribe from.","title":"Client.unsubscribe"},{"location":"reference/libs/zerynth/mqtt/docs/mqtt/#clientpublish","text":"publish ( topic , payload = None , qos = 0 , retain = False ) Publishes a message on a topic. This causes a message to be sent to the broker and subsequently from the broker to any clients subscribing to matching topics. topic is the topic that the message should be published on. payload is the actual message to send. If not given, or set to None a zero length message will be used. qos is the quality of service level to use. retain : if set to true, the message will be set as the \u201clast known good\u201d/retained message for the topic. It returns the mid generated for the message to give the possibility to set a callback precisely for that message.","title":"Client.publish"},{"location":"reference/libs/zerynth/mqtt/docs/mqtt/#clientreconnect_1","text":"reconnect () Sends a disconnect message.","title":"Client.reconnect"},{"location":"reference/libs/zerynth/mqtt/docs/mqtt/#clientloop","text":"loop ( on_message = None ) Non blocking loop method that starts a thread to handle incoming packets. on_message is an optional argument to set a generic callback on messages with qos equal to 0, 1 or 2","title":"Client.loop"},{"location":"reference/libs/zerynth/rtttl/docs/","text":"Zerynth RTTTL \u00b6 Ring Tone Text Transfer Language (RTTTL) was developed by Nokia to be used to transfer ringtones of mobile phones. The RTTTL format is a string divided into three sections: name, default value, and data. The name section consists of a string describing the name of the ringtone. It can be no longer than 10 characters, and cannot contain a colon \u201d:\u201d character (however, since the Smart Messaging specification allows names up to 15 characters in length, some applications processing RTTTL also do so). The default value section is a set of values separated by commas, where each value contains a key and a value separated by an \u201d=\u201d character, which describes certain defaults which should be adhered to during the execution of the ringtone. Possible names are: d - duration o - octave b - beat, tempo The data section consists of a set of character strings separated by commas, where each string contains a duration, pitch, octave and optional dotting (which increases the duration of the note by one half). Here below, the Zerynth Library for RTTTL melody player and some examples to better understand how to use it. Contents: RTTTL Library Examples RTTTL Basics","title":"Index"},{"location":"reference/libs/zerynth/rtttl/docs/#zerynth-rtttl","text":"Ring Tone Text Transfer Language (RTTTL) was developed by Nokia to be used to transfer ringtones of mobile phones. The RTTTL format is a string divided into three sections: name, default value, and data. The name section consists of a string describing the name of the ringtone. It can be no longer than 10 characters, and cannot contain a colon \u201d:\u201d character (however, since the Smart Messaging specification allows names up to 15 characters in length, some applications processing RTTTL also do so). The default value section is a set of values separated by commas, where each value contains a key and a value separated by an \u201d=\u201d character, which describes certain defaults which should be adhered to during the execution of the ringtone. Possible names are: d - duration o - octave b - beat, tempo The data section consists of a set of character strings separated by commas, where each string contains a duration, pitch, octave and optional dotting (which increases the duration of the note by one half). Here below, the Zerynth Library for RTTTL melody player and some examples to better understand how to use it. Contents: RTTTL Library Examples RTTTL Basics","title":"Zerynth RTTTL"},{"location":"reference/libs/zerynth/rtttl/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.zerynth.rtttl. RTTTL Library Basics \u00b6 Basic example of use of the RTTTL melody player library. main.py ################################################################################ # RTTTL Library Basics # # Created by Zerynth Team 2015 CC # Authors: D. Mazzei, G. Baldi, ############################################################################### from rtttl import rtttl import streams s = streams . serial () # define a RTTTL melody to be played by passing it the RTTTL string. # find more songs at http://ez4mobile.com/nokiatone/rtttf.htm and many other websites song = rtttl . tune ( \"StWars:d=4,o=5,b=160:8f,8f,8f,2a#.,2f.6,8d#6,8d6,8c6,2a#.6,f.6,8d#6,8d6,8c6,2a#.6,f.6,8d#6,8d6,8d#6,2c6,p,8f,8f,8f,2a#.,2f.6,8d#6,8d6,8c6,2a#.6,f.6,8d#6,8d6,8c6,2a#.6,f.6,8d#6,8d6,8d#6,2c6\" ) while True : print ( \"Waiting for input\" ) print ( \"Use p for PLAY\" ) # Read the serial port waiting for the Play start command line = str ( s . readline ()) if line [ 0 ] == \"p\" : print ( \"Start Melody\" ) print ( \"-\" * 30 ) print ( \"MAY THE FORCE BE WITH YOU!\" ) print ( \"-\" * 30 ) # play the melody actuating the PWM of pin D8 (Try it with the Zerynth Shield) song . play ( D8 . PWM )","title":"Examples"},{"location":"reference/libs/zerynth/rtttl/docs/examples/#examples","text":"The following are a list of examples for lib.zerynth.rtttl.","title":"Examples"},{"location":"reference/libs/zerynth/rtttl/docs/examples/#rtttl-library-basics","text":"Basic example of use of the RTTTL melody player library. main.py ################################################################################ # RTTTL Library Basics # # Created by Zerynth Team 2015 CC # Authors: D. Mazzei, G. Baldi, ############################################################################### from rtttl import rtttl import streams s = streams . serial () # define a RTTTL melody to be played by passing it the RTTTL string. # find more songs at http://ez4mobile.com/nokiatone/rtttf.htm and many other websites song = rtttl . tune ( \"StWars:d=4,o=5,b=160:8f,8f,8f,2a#.,2f.6,8d#6,8d6,8c6,2a#.6,f.6,8d#6,8d6,8c6,2a#.6,f.6,8d#6,8d6,8d#6,2c6,p,8f,8f,8f,2a#.,2f.6,8d#6,8d6,8c6,2a#.6,f.6,8d#6,8d6,8c6,2a#.6,f.6,8d#6,8d6,8d#6,2c6\" ) while True : print ( \"Waiting for input\" ) print ( \"Use p for PLAY\" ) # Read the serial port waiting for the Play start command line = str ( s . readline ()) if line [ 0 ] == \"p\" : print ( \"Start Melody\" ) print ( \"-\" * 30 ) print ( \"MAY THE FORCE BE WITH YOU!\" ) print ( \"-\" * 30 ) # play the melody actuating the PWM of pin D8 (Try it with the Zerynth Shield) song . play ( D8 . PWM )","title":"RTTTL Library Basics"},{"location":"reference/libs/zerynth/rtttl/docs/rtttl/","text":"RTTTL Library \u00b6 This module contains class definitions for the \u201cRTTTL\u201d melody player to be used for driving buzzers or speakers connected to PWM pins. The format of RTTTL notation is similar to the Music Macro Language found in BASIC implementations present on many early microcomputers. Various RTTTL melodies can be founded and downloaded here and many other websites. class tune \u00b6 class tune ( txt ) This is the class for creating the melody to be played by the RTTTL player. The melody is passed as string tune.play \u00b6 play ( pin , callback = None , restart = False ) Starts playing the melody actuating the PWM on the selected pin. It is also possible to pass a function as callback that will be called every time a note is played. The callback passes the played note to the called function. Moreover, loop play is also possible by setting the restart parameter to True. pin: Dx.PWM, it is the pin where the buzzer is connected. callback: the function to be called every time a note is played. Played note will be passed to the called function. restart: it activates the playloop. tune.setbpm \u00b6 setbpm ( bpm ) Changes the melody speed. bpm: RTTTL melodies include tempo definition in BPM, however through this function it is possible to manually change the melody speed.","title":"RTTTL Library"},{"location":"reference/libs/zerynth/rtttl/docs/rtttl/#rtttl-library","text":"This module contains class definitions for the \u201cRTTTL\u201d melody player to be used for driving buzzers or speakers connected to PWM pins. The format of RTTTL notation is similar to the Music Macro Language found in BASIC implementations present on many early microcomputers. Various RTTTL melodies can be founded and downloaded here and many other websites.","title":"RTTTL Library"},{"location":"reference/libs/zerynth/rtttl/docs/rtttl/#class-tune","text":"class tune ( txt ) This is the class for creating the melody to be played by the RTTTL player. The melody is passed as string","title":"class tune"},{"location":"reference/libs/zerynth/rtttl/docs/rtttl/#tuneplay","text":"play ( pin , callback = None , restart = False ) Starts playing the melody actuating the PWM on the selected pin. It is also possible to pass a function as callback that will be called every time a note is played. The callback passes the played note to the called function. Moreover, loop play is also possible by setting the restart parameter to True. pin: Dx.PWM, it is the pin where the buzzer is connected. callback: the function to be called every time a note is played. Played note will be passed to the called function. restart: it activates the playloop.","title":"tune.play"},{"location":"reference/libs/zerynth/rtttl/docs/rtttl/#tunesetbpm","text":"setbpm ( bpm ) Changes the melody speed. bpm: RTTTL melodies include tempo definition in BPM, however through this function it is possible to manually change the melody speed.","title":"tune.setbpm"},{"location":"reference/libs/zerynth/servo/docs/","text":"Zerynth Servo \u00b6 Servo Motors are rotary or linear actuators that allow for precise control of angular or linear position, velocity and acceleration. Each Servo Motor consists of a suitable motor coupled to a sensor for position feedback. It also requires a relatively sophisticated controller, often a dedicated module designed specifically for use with Servo Motors. This kind of motor is a closed-loop servomechanism that uses position feedback to control its motion and final position. The input to its control is a signal, either analogue or digital, representing the position commanded for the output shaft. The motor is paired with some type of encoder to provide position and speed feedback. The measured position of the output is compared to the command position, the external input to the controller. If the output position differs from that required, an error signal is generated which then causes the motor to rotate in either direction, as needed to bring the output shaft to the appropriate position. As the positions approach, the error signal reduces to zero and the motor stops. Servo Motors are used in applications such as robotics, CNC machinery or automated manufacturing. Here below, the Zerynth Library for Servo Motors and some examples to better understand how to use it. Contents: Servo Library Servo class Examples Servo Motor Basics Servo Motor Animation","title":"Index"},{"location":"reference/libs/zerynth/servo/docs/#zerynth-servo","text":"Servo Motors are rotary or linear actuators that allow for precise control of angular or linear position, velocity and acceleration. Each Servo Motor consists of a suitable motor coupled to a sensor for position feedback. It also requires a relatively sophisticated controller, often a dedicated module designed specifically for use with Servo Motors. This kind of motor is a closed-loop servomechanism that uses position feedback to control its motion and final position. The input to its control is a signal, either analogue or digital, representing the position commanded for the output shaft. The motor is paired with some type of encoder to provide position and speed feedback. The measured position of the output is compared to the command position, the external input to the controller. If the output position differs from that required, an error signal is generated which then causes the motor to rotate in either direction, as needed to bring the output shaft to the appropriate position. As the positions approach, the error signal reduces to zero and the motor stops. Servo Motors are used in applications such as robotics, CNC machinery or automated manufacturing. Here below, the Zerynth Library for Servo Motors and some examples to better understand how to use it. Contents: Servo Library Servo class Examples Servo Motor Basics Servo Motor Animation","title":"Zerynth Servo"},{"location":"reference/libs/zerynth/servo/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.zerynth.servo. Servo basics \u00b6 Basic example of use of the servo library. It is possible to control a servo motor by setting the position as pulse width (microseconds) or in degrees. main.py ################################################################################ # Servo Motor Basics # # Created by Zerynth Team 2015 CC # Authors: D. Mazzei, G. Baldi, ############################################################################### from servo import servo import streams s = streams . serial () # create a servo motor attaching it to the pin D11. D11.PWM notation must be used. # min max are left to defaults 500-2500. they need to be properly set to the servo specifications # control signal period is left to default 20ms MyServo = servo . Servo ( D11 . PWM ) while True : print ( \"Servo ON\" ) MyServo . attach () sleep ( 3000 ) print ( \"Servo controlled in pulse width\" ) for i in range ( 500 , 2500 , 10 ): MyServo . moveToPulseWidth ( i ) print ( MyServo . getCurrentPulseWidth ()) # Very important: servo default control signal period is 20ms, don't update the controlling PWM faster than that! sleep ( 100 ) print ( \"Servo controlled in degrees\" ) for i in range ( 0 , 180 , 1 ): # Very important: degree accuracy depends by the min max pulse width setup. Refer to the servo specifications for proper configuration MyServo . moveToDegree ( i ) print ( MyServo . getCurrentDegree ()) sleep ( 100 ) print ( \"servo OFF\" ) MyServo . detach () sleep ( 3000 ) Servo Motor Animation \u00b6 Example of use of the Animator library for controlling a servo motor. The libreary allows definign an animation composed of points to be reached at certain times. The animator calls the servo moveToDegree fucntion in parallel to the program workflow execution withouth requiring any time monitoring routine main.py ################################################################################ # Servo Motor Animation # # Created by Zerynth Team 2015 CC # Authors: D. Mazzei, G. Baldi, ############################################################################### from servo import servo # WARNING! for this example to work the community floyd.animator must be installed! from community.floyd.animator import animator import streams s = streams . serial () # creates a list of points to be reached by the servo motor using tuples (position, millisecond) # The first tuple has to be set with time=0: (desired_pos,0). This is the value from which the animation will start # In this case servo motor positions in degrees are scheduled pointList = [( 0 , 0 ),( 180 , 10000 ),( 90 , 3000 ),( 0 , 5000 ),( 180 , 5000 )] print ( \"scheduled positions at times (ms):\" , pointList ) # create a servo motor attaching it to the pin D11. Specification of the PWM feature using the Zerynth pin mapping signature is required. # min max defaults in this case are selected for working with Hitech servomotors MyServo = servo . Servo ( D11 . PWM , 500 , 2500 ) # create an animator that runs at 10Hz passing data to MyServo.moveToDegree # don't set too high frequency, 10-30 Hz are fine. The Servo is controlled with a period of 20ms, frequancy higher than 45Hz will block the motor! anim = animator . Animator ( 25 , MyServo . moveToDegree ) # start the animations using the defined point list anim . animate ( pointList ) while True : #just print the animator position and interpolated value print ( anim . currentPosition ()) sleep ( 500 )","title":"Examples"},{"location":"reference/libs/zerynth/servo/docs/examples/#examples","text":"The following are a list of examples for lib.zerynth.servo.","title":"Examples"},{"location":"reference/libs/zerynth/servo/docs/examples/#servo-basics","text":"Basic example of use of the servo library. It is possible to control a servo motor by setting the position as pulse width (microseconds) or in degrees. main.py ################################################################################ # Servo Motor Basics # # Created by Zerynth Team 2015 CC # Authors: D. Mazzei, G. Baldi, ############################################################################### from servo import servo import streams s = streams . serial () # create a servo motor attaching it to the pin D11. D11.PWM notation must be used. # min max are left to defaults 500-2500. they need to be properly set to the servo specifications # control signal period is left to default 20ms MyServo = servo . Servo ( D11 . PWM ) while True : print ( \"Servo ON\" ) MyServo . attach () sleep ( 3000 ) print ( \"Servo controlled in pulse width\" ) for i in range ( 500 , 2500 , 10 ): MyServo . moveToPulseWidth ( i ) print ( MyServo . getCurrentPulseWidth ()) # Very important: servo default control signal period is 20ms, don't update the controlling PWM faster than that! sleep ( 100 ) print ( \"Servo controlled in degrees\" ) for i in range ( 0 , 180 , 1 ): # Very important: degree accuracy depends by the min max pulse width setup. Refer to the servo specifications for proper configuration MyServo . moveToDegree ( i ) print ( MyServo . getCurrentDegree ()) sleep ( 100 ) print ( \"servo OFF\" ) MyServo . detach () sleep ( 3000 )","title":"Servo basics"},{"location":"reference/libs/zerynth/servo/docs/examples/#servo-motor-animation","text":"Example of use of the Animator library for controlling a servo motor. The libreary allows definign an animation composed of points to be reached at certain times. The animator calls the servo moveToDegree fucntion in parallel to the program workflow execution withouth requiring any time monitoring routine main.py ################################################################################ # Servo Motor Animation # # Created by Zerynth Team 2015 CC # Authors: D. Mazzei, G. Baldi, ############################################################################### from servo import servo # WARNING! for this example to work the community floyd.animator must be installed! from community.floyd.animator import animator import streams s = streams . serial () # creates a list of points to be reached by the servo motor using tuples (position, millisecond) # The first tuple has to be set with time=0: (desired_pos,0). This is the value from which the animation will start # In this case servo motor positions in degrees are scheduled pointList = [( 0 , 0 ),( 180 , 10000 ),( 90 , 3000 ),( 0 , 5000 ),( 180 , 5000 )] print ( \"scheduled positions at times (ms):\" , pointList ) # create a servo motor attaching it to the pin D11. Specification of the PWM feature using the Zerynth pin mapping signature is required. # min max defaults in this case are selected for working with Hitech servomotors MyServo = servo . Servo ( D11 . PWM , 500 , 2500 ) # create an animator that runs at 10Hz passing data to MyServo.moveToDegree # don't set too high frequency, 10-30 Hz are fine. The Servo is controlled with a period of 20ms, frequancy higher than 45Hz will block the motor! anim = animator . Animator ( 25 , MyServo . moveToDegree ) # start the animations using the defined point list anim . animate ( pointList ) while True : #just print the animator position and interpolated value print ( anim . currentPosition ()) sleep ( 500 )","title":"Servo Motor Animation"},{"location":"reference/libs/zerynth/servo/docs/servo/","text":"Servo Library \u00b6 This module contains class definitions for servo motors. The Servo class provides methods for handling generic servo motors connected to PWM enabled pins. It also provides easily accessible attributes for the control of motor positions with pulse width or angle inputs. Every Servo instance implements the following methods: attach: connects the servo motor and sets the default position detach: sets the PWM pulse width of the instanced servo to 0 thus disconnecting the motor moveToDegree: sets the servo position to the desired angle passed as float moveToPulseWidth: sets the servo position to the desired raw value expressed as pulse width (int) microseconds getCurrentPulseWidth: returns the current servo position in pulse width (int) microseconds getCurrentDegree: returns the current position in degrees Servo class \u00b6 class Servo \u00b6 class Servo ( pin , min_width = 500 , max_width = 2500 , default_width = 1500 , period = 20000 ) Creates a Servo instance: pin : it is the pin where the servo motor signal wire is connected. The pin requires PWM functionality and its name has to be passed using the DX.PWM notation min_width : it is the min value of the control PWM pulse width (microseconds). It has to be tuned according to servo capabilities. Defaults is set to 500. max_width : it is the max value of the control PWM pulse width (microseconds). It has to be tuned according to servo capabilities. Defaults is set to 2500. default_width : it is the position where the servo motor is moved when attached. It is expressed in microseconds and the default is set to 1500 corresponding to 90 degrees if the min-max range is set as default. period : it is the period of the PWM used for controlling the servo expressed in microseconds. Default is 20000 microseconds that is the most used standard. After initialization the servo motor object is created and the controlling PWM set to 0 leaving the servo digitally disconnected Servo.attach \u00b6 attach () Writes default_width to the servo associated PWM, enabling the motor and moving it to the default position. Servo.detach \u00b6 detach () Writes 0 to the servo associated PWM disabling the motor. Servo.moveToDegree \u00b6 moveToDegree ( degree ) Moves the servo motor to the desired position expressed in degrees (float). Servo.moveToPulseWidth \u00b6 moveToPulseWidth ( width ) Moves the servo motor to the desired position expressed as pulse width (int) microseconds. The input has to be in min_width:max_width range. Servo.getCurrentPulseWidth \u00b6 getCurrentPulseWidth () Returns the servo motor position as pulse width (microseconds). Servo.getCurrentDegree \u00b6 getCurrentDegree () Returns the servo motor position as degrees.","title":"Servo Library"},{"location":"reference/libs/zerynth/servo/docs/servo/#servo-library","text":"This module contains class definitions for servo motors. The Servo class provides methods for handling generic servo motors connected to PWM enabled pins. It also provides easily accessible attributes for the control of motor positions with pulse width or angle inputs. Every Servo instance implements the following methods: attach: connects the servo motor and sets the default position detach: sets the PWM pulse width of the instanced servo to 0 thus disconnecting the motor moveToDegree: sets the servo position to the desired angle passed as float moveToPulseWidth: sets the servo position to the desired raw value expressed as pulse width (int) microseconds getCurrentPulseWidth: returns the current servo position in pulse width (int) microseconds getCurrentDegree: returns the current position in degrees","title":"Servo Library"},{"location":"reference/libs/zerynth/servo/docs/servo/#servo-class","text":"","title":"Servo class"},{"location":"reference/libs/zerynth/servo/docs/servo/#class-servo","text":"class Servo ( pin , min_width = 500 , max_width = 2500 , default_width = 1500 , period = 20000 ) Creates a Servo instance: pin : it is the pin where the servo motor signal wire is connected. The pin requires PWM functionality and its name has to be passed using the DX.PWM notation min_width : it is the min value of the control PWM pulse width (microseconds). It has to be tuned according to servo capabilities. Defaults is set to 500. max_width : it is the max value of the control PWM pulse width (microseconds). It has to be tuned according to servo capabilities. Defaults is set to 2500. default_width : it is the position where the servo motor is moved when attached. It is expressed in microseconds and the default is set to 1500 corresponding to 90 degrees if the min-max range is set as default. period : it is the period of the PWM used for controlling the servo expressed in microseconds. Default is 20000 microseconds that is the most used standard. After initialization the servo motor object is created and the controlling PWM set to 0 leaving the servo digitally disconnected","title":"class Servo"},{"location":"reference/libs/zerynth/servo/docs/servo/#servoattach","text":"attach () Writes default_width to the servo associated PWM, enabling the motor and moving it to the default position.","title":"Servo.attach"},{"location":"reference/libs/zerynth/servo/docs/servo/#servodetach","text":"detach () Writes 0 to the servo associated PWM disabling the motor.","title":"Servo.detach"},{"location":"reference/libs/zerynth/servo/docs/servo/#servomovetodegree","text":"moveToDegree ( degree ) Moves the servo motor to the desired position expressed in degrees (float).","title":"Servo.moveToDegree"},{"location":"reference/libs/zerynth/servo/docs/servo/#servomovetopulsewidth","text":"moveToPulseWidth ( width ) Moves the servo motor to the desired position expressed as pulse width (int) microseconds. The input has to be in min_width:max_width range.","title":"Servo.moveToPulseWidth"},{"location":"reference/libs/zerynth/servo/docs/servo/#servogetcurrentpulsewidth","text":"getCurrentPulseWidth () Returns the servo motor position as pulse width (microseconds).","title":"Servo.getCurrentPulseWidth"},{"location":"reference/libs/zerynth/servo/docs/servo/#servogetcurrentdegree","text":"getCurrentDegree () Returns the servo motor position as degrees.","title":"Servo.getCurrentDegree"},{"location":"reference/libs/zerynth/smartsensors/docs/","text":"Zerynth Smart Sensors \u00b6 A Smart Sensor, at a minimum, is made of a sensor that takes input from the physical environment and uses built-in compute resources to perform predefined functions upon detection of specific input and then process data before passing it on. Smart sensors enable more accurate and automated collection of environmental data with less erroneous noise amongst the accurately recorded information. These sensors are used for monitoring and control mechanisms in a wide variety of environments including smart grids, battlefield reconnaissance, exploration and they have become a crucial and integral element in the Internet of Things (IoT) applications. A smart sensor may also include a number of other components besides the primary sensor. These components can include transducers, amplifiers, excitation control, analog filters and compensation. A smart sensor also incorporates software-defined elements that provide functions such as data conversion, digital processing and communication to external devices. Zerynth Smart Sensor set of libraries and built-in functions helps to handle and manage all sensors connected to specific pins of a device. Here below, the Zerynth Libraries for Generic Sensors class with Analog/Digital subclasses and Sensor Pool; there are also some examples to better understand how to use these libraries. Contents: Generic Sensor Library The Sensor class Analog Sensor Library AnalogSensor class Digital Sensor Library DigitalSensor class Pool Sensor Library [SensorPool class]( https://docs.zerynth.com/latest/official/lib.zerynth.smartsensors/docs/official_lib.zerynth.smartsensors_sensorPool.html#sensorpool-class Examples Analog Sensor Basics Analog Sensor Advanced Analog Sensor Data Smoothing Digital Sensor Debounce Smart Sensor Pool","title":"Zerynth Smart Sensors"},{"location":"reference/libs/zerynth/smartsensors/docs/#zerynth-smart-sensors","text":"A Smart Sensor, at a minimum, is made of a sensor that takes input from the physical environment and uses built-in compute resources to perform predefined functions upon detection of specific input and then process data before passing it on. Smart sensors enable more accurate and automated collection of environmental data with less erroneous noise amongst the accurately recorded information. These sensors are used for monitoring and control mechanisms in a wide variety of environments including smart grids, battlefield reconnaissance, exploration and they have become a crucial and integral element in the Internet of Things (IoT) applications. A smart sensor may also include a number of other components besides the primary sensor. These components can include transducers, amplifiers, excitation control, analog filters and compensation. A smart sensor also incorporates software-defined elements that provide functions such as data conversion, digital processing and communication to external devices. Zerynth Smart Sensor set of libraries and built-in functions helps to handle and manage all sensors connected to specific pins of a device. Here below, the Zerynth Libraries for Generic Sensors class with Analog/Digital subclasses and Sensor Pool; there are also some examples to better understand how to use these libraries. Contents: Generic Sensor Library The Sensor class Analog Sensor Library AnalogSensor class Digital Sensor Library DigitalSensor class Pool Sensor Library [SensorPool class]( https://docs.zerynth.com/latest/official/lib.zerynth.smartsensors/docs/official_lib.zerynth.smartsensors_sensorPool.html#sensorpool-class Examples Analog Sensor Basics Analog Sensor Advanced Analog Sensor Data Smoothing Digital Sensor Debounce Smart Sensor Pool","title":"Zerynth Smart Sensors"},{"location":"reference/libs/zerynth/smartsensors/docs/analogSensors/","text":"Analog Sensor Library \u00b6 This module contains class definitions for analog sensors. AnalogSensor class is a subclass of the generic Sensor class and provides a simple way to handle sensors sensing quantities that can assume more than two different values. Every AnalogSensor instance inherits the whole set of methods from generic Sensor class. AnalogSensor class \u00b6 class AnalogSensor \u00b6 class AnalogSensor ( pin ) This is the class for sensing analog quantities. Pin can be both a real device pin and a tuple containing an analog sensor object and a string for a window parameter to read. Example: lightSensor = AnalogSensor ( A4 ) sensorOnAverage = AnalogSensor (( lightSensor , 'currentAverage' )) The code above, instantiates a light sensor on a device pin and another sensor that takes as input the lightSensor average.","title":"analogSensors"},{"location":"reference/libs/zerynth/smartsensors/docs/analogSensors/#analog-sensor-library","text":"This module contains class definitions for analog sensors. AnalogSensor class is a subclass of the generic Sensor class and provides a simple way to handle sensors sensing quantities that can assume more than two different values. Every AnalogSensor instance inherits the whole set of methods from generic Sensor class.","title":"Analog Sensor Library"},{"location":"reference/libs/zerynth/smartsensors/docs/analogSensors/#analogsensor-class","text":"","title":"AnalogSensor class"},{"location":"reference/libs/zerynth/smartsensors/docs/analogSensors/#class-analogsensor","text":"class AnalogSensor ( pin ) This is the class for sensing analog quantities. Pin can be both a real device pin and a tuple containing an analog sensor object and a string for a window parameter to read. Example: lightSensor = AnalogSensor ( A4 ) sensorOnAverage = AnalogSensor (( lightSensor , 'currentAverage' )) The code above, instantiates a light sensor on a device pin and another sensor that takes as input the lightSensor average.","title":"class AnalogSensor"},{"location":"reference/libs/zerynth/smartsensors/docs/digitalSensors/","text":"Digital Sensor Library \u00b6 This module contains class definitions for digital sensors. DigitalSensor class is a subclass of the generic Sensor class and provides a simple way to handle sensors sensing quantities that can assume only two different values. Every DigitalSensor instance inherits the whole set of methods from generic Sensor class and it also implements the following methods: onSequence: see method onSequence onRiseAndFall: see method onRiseAndFall onFallAndRise: see method onFallAndRise onRise: alias for onPinRise on the instance pin onFall: alias for onPinFall on the instance pin An instance of a digitalSensor can be used both in interrupt mode and sampling mode. DigitalSensor class \u00b6 class DigitalSensor \u00b6 class DigitalSensor ( pin ) This is the class for handling digital sensors and any other boolean input connected to digital pins. DigitalSensor.onSequence \u00b6 onSequence ( first , times , to_dos , long_fn ) Sets functions to be executed in a sequence of pin values changes respecting precise time constraints. first: is the value of the pin from which the method waits for the first change times: is a list of min and max times of persistence in a precise state before changing it to opposite one to_dos: is a list of functions to be executed at every step of the sequence long_fn: is a function to be executed if the first max time constraint is exceeded Example: def hello (): print ( \"hello\" ) def world (): print ( \"world\" ) def longworld (): print ( \"longworld\" ) mySensor . onSequence ( 0 ,[[ 15 , 30 ],[ 15 , 30 ]],[ hello , world ], longworld ) Assuming to start from a 0 value on the pin, when the value changes to 1, a timer starts to check the persistance in this state. When the value returns to 0, if the time passed in a HIGH state is: less than 15 milliseconds the sequence restarts more than 30 milliseconds longworld function is called and then the sequence restarts between 15 and 30 milliseconds the function hello is executed and the sequence goes on. For the second step the same assumptions are valid: if the time constraints are respected world function is called, otherwise the sequence restarts ( long_fn is called only if the first max bound is not respected ). To be noticed that the second step analyze the persistance at LOW level in this case. DigitalSensor.onRiseAndFall \u00b6 onRiseAndFall ( min_time , max_time , to_do , long_fn = None ) Sets to_do as the function to be executed when the value of the pin changes from 0 to 1 ( onRise ) and again from 1 to 0 ( andFall ). The value must stay HIGH at least min_time (make sure the transition is voluntary, not due to noise) and less than max_time . There is the possibility to also set a long_fn which is executed is the max_time bound is overcome. min_time: the minimum duration of the signal to be considered as a real event max_time: the maximum duration of the signal that if passed will trigger a \u201clong\u201d event to_do: the function called if the signal state change is between min and max time long_fn: the function called if the signal state change is longer than max time DigitalSensor.onFallAndRise \u00b6 onFallAndRise ( min_time , max_time , to_do , long_fn = None ) Sets to_do as the function to be executed when the value of the pin changes from 1 to 0 ( onFall ) and again from 0 to 1 ( andRise ). The value must stay LOW at least min_time (make sure the transition is voluntary, not due to noise) and less than max_time . There is the possibility to also set a long_fn which is executed if the max_time bound is overcome. min_time: the minimum duration of the signal to be considered as a real event max_time: the maximum duration of the signal that if passed will trigger a \u201clong\u201d event to_do: the function called if the signal state change is between min and max time long_fn: the function called if the signal state change is longer than max time","title":"digitalSensors"},{"location":"reference/libs/zerynth/smartsensors/docs/digitalSensors/#digital-sensor-library","text":"This module contains class definitions for digital sensors. DigitalSensor class is a subclass of the generic Sensor class and provides a simple way to handle sensors sensing quantities that can assume only two different values. Every DigitalSensor instance inherits the whole set of methods from generic Sensor class and it also implements the following methods: onSequence: see method onSequence onRiseAndFall: see method onRiseAndFall onFallAndRise: see method onFallAndRise onRise: alias for onPinRise on the instance pin onFall: alias for onPinFall on the instance pin An instance of a digitalSensor can be used both in interrupt mode and sampling mode.","title":"Digital Sensor Library"},{"location":"reference/libs/zerynth/smartsensors/docs/digitalSensors/#digitalsensor-class","text":"","title":"DigitalSensor class"},{"location":"reference/libs/zerynth/smartsensors/docs/digitalSensors/#class-digitalsensor","text":"class DigitalSensor ( pin ) This is the class for handling digital sensors and any other boolean input connected to digital pins.","title":"class DigitalSensor"},{"location":"reference/libs/zerynth/smartsensors/docs/digitalSensors/#digitalsensoronsequence","text":"onSequence ( first , times , to_dos , long_fn ) Sets functions to be executed in a sequence of pin values changes respecting precise time constraints. first: is the value of the pin from which the method waits for the first change times: is a list of min and max times of persistence in a precise state before changing it to opposite one to_dos: is a list of functions to be executed at every step of the sequence long_fn: is a function to be executed if the first max time constraint is exceeded Example: def hello (): print ( \"hello\" ) def world (): print ( \"world\" ) def longworld (): print ( \"longworld\" ) mySensor . onSequence ( 0 ,[[ 15 , 30 ],[ 15 , 30 ]],[ hello , world ], longworld ) Assuming to start from a 0 value on the pin, when the value changes to 1, a timer starts to check the persistance in this state. When the value returns to 0, if the time passed in a HIGH state is: less than 15 milliseconds the sequence restarts more than 30 milliseconds longworld function is called and then the sequence restarts between 15 and 30 milliseconds the function hello is executed and the sequence goes on. For the second step the same assumptions are valid: if the time constraints are respected world function is called, otherwise the sequence restarts ( long_fn is called only if the first max bound is not respected ). To be noticed that the second step analyze the persistance at LOW level in this case.","title":"DigitalSensor.onSequence"},{"location":"reference/libs/zerynth/smartsensors/docs/digitalSensors/#digitalsensoronriseandfall","text":"onRiseAndFall ( min_time , max_time , to_do , long_fn = None ) Sets to_do as the function to be executed when the value of the pin changes from 0 to 1 ( onRise ) and again from 1 to 0 ( andFall ). The value must stay HIGH at least min_time (make sure the transition is voluntary, not due to noise) and less than max_time . There is the possibility to also set a long_fn which is executed is the max_time bound is overcome. min_time: the minimum duration of the signal to be considered as a real event max_time: the maximum duration of the signal that if passed will trigger a \u201clong\u201d event to_do: the function called if the signal state change is between min and max time long_fn: the function called if the signal state change is longer than max time","title":"DigitalSensor.onRiseAndFall"},{"location":"reference/libs/zerynth/smartsensors/docs/digitalSensors/#digitalsensoronfallandrise","text":"onFallAndRise ( min_time , max_time , to_do , long_fn = None ) Sets to_do as the function to be executed when the value of the pin changes from 1 to 0 ( onFall ) and again from 0 to 1 ( andRise ). The value must stay LOW at least min_time (make sure the transition is voluntary, not due to noise) and less than max_time . There is the possibility to also set a long_fn which is executed if the max_time bound is overcome. min_time: the minimum duration of the signal to be considered as a real event max_time: the maximum duration of the signal that if passed will trigger a \u201clong\u201d event to_do: the function called if the signal state change is between min and max time long_fn: the function called if the signal state change is longer than max time","title":"DigitalSensor.onFallAndRise"},{"location":"reference/libs/zerynth/smartsensors/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.zerynth.smartsensors. Basic Analog Sensor \u00b6 The smartSensors library is a ready to use set of functions that are very useful for managing analog and digital sensors. Common operations like calculating min, max, average and trends are completely automated by the smartSensors library. Moreover the smartSensors lib allows user to define calibration functions for analog sensors and to use callback to schedule sampling and acquisition operations. This examples shows the basic use of the analogSensor module of the smartSensors library. In the example ADC4 is used for instancing an analogSensors running the automatic calculation of min, Max, average, trend and derivative. Calculated data are printed on the console through a function that is called by the library every-time a new sample is acquired. The sampling rate and the parameter calculation window size (expressed in samples) are set through the startSampling function integrated n the library that automates the entire acquisition and calculation process. tags: [Smart Sensors Lib, analogSensors] groups:[Smart Sensors Library] main.py ################################################################################ # Basic Analog Sensor for SmartSensor Lib # # Created by Zerynth Team 2015 CC # Authors: L. Rizzello, G. Baldi, D. Mazzei ############################################################################### import streams # import analogSensors module from smartsensors import analogSensors # define a function that takes a sensor object as parameter and prints # the last read sample and all the window parameters def out ( obj ): print ( \"read sample: \" , obj . currentSample ()) print ( \"average: \" , obj . currentAverage ) print ( \"min: \" , obj . minSample ) print ( \"max: \" , obj . maxSample ) print ( \"trend: \" , obj . currentTrend ) print ( \"derivative: \" , obj . currentDerivative ) # define a 'condition' function that takes a sensor object as parameter # and returns True if its current moving average is not None and # greater than a fixed threshold def averageGreaterThanTh ( obj ): if not obj . currentAverage : return False return ( obj . currentAverage > 2000 ) # define a function that simply prints a message def gOut ( obj ): print ( \"average over threshold\" ) streams . serial () # initialize an AnalogSensor object on pin A4 a = analogSensors . AnalogSensor ( A4 ) # set out function as a function to be executed every time a new sample # is acquired by the sensor # set averageGreaterThanTh function as a condition to be checked and to # be verified to execute gOut function every time a new sample is # acquired by the sensor a . doEverySample ( out ) . addCheck ( averageGreaterThanTh , gOut ) # start sampling at 1000 millis with a window of 4 samples to evaluate # window parameters a . startSampling ( 1000 , 4 ) Advanced Analog Sensor \u00b6 The smartSensors library is a ready to use set of functions that are very useful for managing analog and digital sensors. Common operations like calculating min, max, average and trends are completely automated by the smartSensors library. Moreover the smartSensors lib allows user to define calibration functions for analog sensors and to use callback to schedule sampling and acquisition operations. This examples shows an advanced use of the analogSensor module where a sensor is created attaching it to and ADC and another virtual sensor is created attaching in to the \"average\" output of the first analog sensor. In the example ADC4 is used for instancing an analogSensors running the automatic calculation of min, Max, average, trend and derivative. Calculated data are printed on the console through a function. Moreover another sensor is created taking as input the \"average\" calculated by the first \"real\" sensor. This trick is used to calculate the Derivative of the average monitoring it through another function in order to notify the user is the derivative of the average is passing a threshold. In the example the sensorPool module is also used. please refer to the sensorPoll example and documentation for more details. This example can be used as starting point for very complex analogical data analysis routine where the monitoring of multiple variables is required at different sample rates and with different configurations tags: [Smart Sensors Lib, analogSensors] groups:[Smart Sensors Library] main.py ################################################################################ # Advanced Analog Sensor for SmartSensor Lib # # Created by Zerynth Team 2015 CC # Authors: L. Rizzello, G. Baldi, D. Mazzei ############################################################################### import streams # import analogSensors and sensorPool from smartsensors import analogSensors from smartsensors import sensorPool # define a function that takes a sensor object as parameter and prints its last # read sample and the current moving average def out ( obj ): print ( \"current sample: \" , obj . currentSample ()) print ( \"average: \" , obj . currentAverage ) # define a 'condition' function that takes a sensor object as parameter # and returns True if its current derivative is not None and # greater than a fixed threshold def derivativeOfAverageGreaterThanTh ( obj ): if type ( obj . currentDerivative ) == PNONE : return False return ( obj . currentDerivative > 10 ) # define a function that simply prints a message def gOut ( obj ): print ( \"derivative of average over threshold!\" ) streams . serial () # initialize an AnalogSensor object on pin A4 and set 'out' as the function to be # applied to every acquired sample a = analogSensors . AnalogSensor ( A4 ) a . highPrecision = True a . doEverySample ( out ) # initialize an AnalogSensor object on currentAverage of 'a' sensor # a_avg sensor allows to easily monitor 'a' currentAverage but also to handle new # parameters like its min a max value and derivative for example. # set detrivativeOfAverageGreaterThanTh function as a condition to be checked and to # be verified to execute gOut function every time a new sample is acquired by the 'sensor # of the sensor' a_avg = analogSensors . AnalogSensor (( a , \"currentAverage\" )) #this is a new sensor that takes as input the average of the a sensor a_avg . addCheck ( derivativeOfAverageGreaterThanTh , gOut ) # to start sampling both sensors are put in a pool, see Pool Example for details pool = sensorPool . SensorPool ([ a , a_avg ]) pool . startSampling ([ 1000 , 1000 ],[ 5 , 5 ],[ \"raw\" , \"raw\" ]) Smoothing Analog Data with Moving Average \u00b6 The smartSensors library is a ready to use set of functions that are very useful for managing analog and digital sensors. Common operations like calculating min, max, average and trends are completely automated by the smartSensors library. Moreover the smartSensors lib allows user to define calibration functions for analog sensors and to use callback to schedule sampling and acquisition operations. In this example the average method is used for smoothing analogical data acquired through the ADC running a moving average filter. Note that at program starts the average results \"None\" because the filter window is not yet completely filled and the library verify it avoiding to results wrong data calculation. This feature is very useful in programs where the sampling and analysis routine is stopped and restarted periodically avoiding wrong calculation due to inconsistent incoming data. tags: [Smart Sensors Lib, analogSensors, Zerynth Shield, sensorPool] groups:[Smart Sensors Library, Zerynth Shield Driver] main.py ############################################################################### # Smoothing # # Created by Zerynth Team 2015 CC # Authors: L. Rizzello, G. Baldi, D. Mazzei ############################################################################### import streams # import analogSensors module from smartsensors import analogSensors # define a function that takes a sensor object as parameter and prints # its moving average automatically evaluated def out ( obj ): print ( obj . currentAverage ) streams . serial () # initialize an analogSensor object on pin A4 s = analogSensors . AnalogSensor ( A4 ) # set highPrecision to True to evaluate the moving average more precisely s . highPrecision = True # set out function as a function to be executed every time a new sample # is acquired by the sensor s . doEverySample ( out ) # start sampling at 1000 millis with a window of 10 samples to evaluate # window parameters s . startSampling ( 1000 , 10 ) Debounce Digital Sensor Input \u00b6 The smartSensors library is a ready to use set of functions that are very useful for managing analog and digital sensors. Common operations like calculating min, max, average and trends are completely automated by the smartSensors library. Moreover the smartSensors lib allows user to define calibration functions for analog sensors and to use callback to schedule sampling and acquisition operations. In this example the digitalSensors module is used to monitor a DIO and trigger a function only when a state change longer than 500 millisec is detected. This example is very useful for the design of user interfaces where button are included. In this case it is very common to have false detections due to noise or movements and also to have undesired double detection due to a longer press of the button that could be detected by the software as double click. This example is very useful for improving the usability of the Zerynth Shield Touch sensor. tags: [digitalSensors, Zerynth Shield, Touch, Button ] groups:[Smart Sensors Library, Zerynth Shield Driver] main.py ################################################################################ # Debounce Digital Sensor Input # # Created by Zerynth Team 2015 CC # Authors: L. Rizzello, G. Baldi, D. Mazzei ############################################################################### import streams # import digitalSensors module from smartsensors import digitalSensors # set a state variable to 0 state = 0 # define a function that changes the value of state global variable from 0 to 1 # or from 1 to 0 and prints the new state value def changeState (): global state state = state ^ 1 print ( \"new state: \" , state ) streams . serial () # initialize a digitalSensor object on pin D7 d = digitalSensors . DigitalSensor ( D7 ) # set changeState as the function to be executed when the value of the pin changes # from 0 to 1 ( onRise ) and again from 1 to 0 ( andFall ) respecting the time # constraint: the value must stay HIGH at least 500 milliseconds (make sure the # transition is voluntary) and less than 2000 milliseconds d . onRiseAndFall ( 500 , 2000 , changeState ) Smart Sensor Pool \u00b6 The smartSensors library is a ready to use set of functions that are very useful for managing analog and digital sensors. Common operations like calculating min, max, average and trends are completely automated by the smartSensors library. Moreover the smartSensors lib allows user to define calibration functions for analog sensors and to use callback to schedule sampling and acquisition operations. This examples shows the basic use of the sensorPool, a module of the library used to create set of heterogeneous sensors to be managed in parallel simplifying the acquisition and calculation routines. tags: [Smart Sensors Lib, analogSensors, digitalSensors, sensorPool] groups:[Smart Sensors Library] main.py ################################################################################ # Smart Sensor Pool # # Created by Zerynth Team 2015 CC # Authors: L. Rizzello, G. Baldi, D. Mazzei ############################################################################### import streams # import analogSensors, digitalSensors and sensorPool modules from smartsensors import analogSensors from smartsensors import digitalSensors from smartsensors import sensorPool # define two functions that take a sensor object as parameter and print its # last read value def outA ( obj ): print ( \"a: \" , obj . currentSample ()) def outD ( obj ): print ( \"d: \" , obj . currentSample ()) # define a function that takes a value and a sensor object as parameters and # returns a 'normalized' version of the value def normA ( val , obj ): return val // 100 streams . serial () # initialize an analog and a digital sensor on pins A4 and D7 a = analogSensors . AnalogSensor ( A4 ) d = digitalSensors . DigitalSensor ( D7 ) # set a normalization function 'normA' to sensor 'a' to normalize every acquired # sample and 'outA' as the function to be executed every time a new sample is read a . setNormFunc ( normA ) . doEverySample ( outA ) # set 'outD' as the function to be executed every time a new sample is read by # sensor 'd' d . doEverySample ( outD ) # initialize a sensorPool object that contains 'a' and 'd' sensors pool = sensorPool . SensorPool ([ a , d ]) # start sampling process for the objects in the pool specifying different # sampling parameters: # # sampling time | window size | type of acquisition # object a 1000 | None | normalized # object b 2000 | None | raw # # window size is set to None because window parameters (moving average,trend...) # are not needed in this example pool . startSampling ([ 1000 , 2000 ],[ None , None ],[ \"norm\" , \"raw\" ])","title":"Examples"},{"location":"reference/libs/zerynth/smartsensors/docs/examples/#examples","text":"The following are a list of examples for lib.zerynth.smartsensors.","title":"Examples"},{"location":"reference/libs/zerynth/smartsensors/docs/examples/#basic-analog-sensor","text":"The smartSensors library is a ready to use set of functions that are very useful for managing analog and digital sensors. Common operations like calculating min, max, average and trends are completely automated by the smartSensors library. Moreover the smartSensors lib allows user to define calibration functions for analog sensors and to use callback to schedule sampling and acquisition operations. This examples shows the basic use of the analogSensor module of the smartSensors library. In the example ADC4 is used for instancing an analogSensors running the automatic calculation of min, Max, average, trend and derivative. Calculated data are printed on the console through a function that is called by the library every-time a new sample is acquired. The sampling rate and the parameter calculation window size (expressed in samples) are set through the startSampling function integrated n the library that automates the entire acquisition and calculation process. tags: [Smart Sensors Lib, analogSensors] groups:[Smart Sensors Library] main.py ################################################################################ # Basic Analog Sensor for SmartSensor Lib # # Created by Zerynth Team 2015 CC # Authors: L. Rizzello, G. Baldi, D. Mazzei ############################################################################### import streams # import analogSensors module from smartsensors import analogSensors # define a function that takes a sensor object as parameter and prints # the last read sample and all the window parameters def out ( obj ): print ( \"read sample: \" , obj . currentSample ()) print ( \"average: \" , obj . currentAverage ) print ( \"min: \" , obj . minSample ) print ( \"max: \" , obj . maxSample ) print ( \"trend: \" , obj . currentTrend ) print ( \"derivative: \" , obj . currentDerivative ) # define a 'condition' function that takes a sensor object as parameter # and returns True if its current moving average is not None and # greater than a fixed threshold def averageGreaterThanTh ( obj ): if not obj . currentAverage : return False return ( obj . currentAverage > 2000 ) # define a function that simply prints a message def gOut ( obj ): print ( \"average over threshold\" ) streams . serial () # initialize an AnalogSensor object on pin A4 a = analogSensors . AnalogSensor ( A4 ) # set out function as a function to be executed every time a new sample # is acquired by the sensor # set averageGreaterThanTh function as a condition to be checked and to # be verified to execute gOut function every time a new sample is # acquired by the sensor a . doEverySample ( out ) . addCheck ( averageGreaterThanTh , gOut ) # start sampling at 1000 millis with a window of 4 samples to evaluate # window parameters a . startSampling ( 1000 , 4 )","title":"Basic Analog Sensor"},{"location":"reference/libs/zerynth/smartsensors/docs/examples/#advanced-analog-sensor","text":"The smartSensors library is a ready to use set of functions that are very useful for managing analog and digital sensors. Common operations like calculating min, max, average and trends are completely automated by the smartSensors library. Moreover the smartSensors lib allows user to define calibration functions for analog sensors and to use callback to schedule sampling and acquisition operations. This examples shows an advanced use of the analogSensor module where a sensor is created attaching it to and ADC and another virtual sensor is created attaching in to the \"average\" output of the first analog sensor. In the example ADC4 is used for instancing an analogSensors running the automatic calculation of min, Max, average, trend and derivative. Calculated data are printed on the console through a function. Moreover another sensor is created taking as input the \"average\" calculated by the first \"real\" sensor. This trick is used to calculate the Derivative of the average monitoring it through another function in order to notify the user is the derivative of the average is passing a threshold. In the example the sensorPool module is also used. please refer to the sensorPoll example and documentation for more details. This example can be used as starting point for very complex analogical data analysis routine where the monitoring of multiple variables is required at different sample rates and with different configurations tags: [Smart Sensors Lib, analogSensors] groups:[Smart Sensors Library] main.py ################################################################################ # Advanced Analog Sensor for SmartSensor Lib # # Created by Zerynth Team 2015 CC # Authors: L. Rizzello, G. Baldi, D. Mazzei ############################################################################### import streams # import analogSensors and sensorPool from smartsensors import analogSensors from smartsensors import sensorPool # define a function that takes a sensor object as parameter and prints its last # read sample and the current moving average def out ( obj ): print ( \"current sample: \" , obj . currentSample ()) print ( \"average: \" , obj . currentAverage ) # define a 'condition' function that takes a sensor object as parameter # and returns True if its current derivative is not None and # greater than a fixed threshold def derivativeOfAverageGreaterThanTh ( obj ): if type ( obj . currentDerivative ) == PNONE : return False return ( obj . currentDerivative > 10 ) # define a function that simply prints a message def gOut ( obj ): print ( \"derivative of average over threshold!\" ) streams . serial () # initialize an AnalogSensor object on pin A4 and set 'out' as the function to be # applied to every acquired sample a = analogSensors . AnalogSensor ( A4 ) a . highPrecision = True a . doEverySample ( out ) # initialize an AnalogSensor object on currentAverage of 'a' sensor # a_avg sensor allows to easily monitor 'a' currentAverage but also to handle new # parameters like its min a max value and derivative for example. # set detrivativeOfAverageGreaterThanTh function as a condition to be checked and to # be verified to execute gOut function every time a new sample is acquired by the 'sensor # of the sensor' a_avg = analogSensors . AnalogSensor (( a , \"currentAverage\" )) #this is a new sensor that takes as input the average of the a sensor a_avg . addCheck ( derivativeOfAverageGreaterThanTh , gOut ) # to start sampling both sensors are put in a pool, see Pool Example for details pool = sensorPool . SensorPool ([ a , a_avg ]) pool . startSampling ([ 1000 , 1000 ],[ 5 , 5 ],[ \"raw\" , \"raw\" ])","title":"Advanced Analog Sensor"},{"location":"reference/libs/zerynth/smartsensors/docs/examples/#smoothing-analog-data-with-moving-average","text":"The smartSensors library is a ready to use set of functions that are very useful for managing analog and digital sensors. Common operations like calculating min, max, average and trends are completely automated by the smartSensors library. Moreover the smartSensors lib allows user to define calibration functions for analog sensors and to use callback to schedule sampling and acquisition operations. In this example the average method is used for smoothing analogical data acquired through the ADC running a moving average filter. Note that at program starts the average results \"None\" because the filter window is not yet completely filled and the library verify it avoiding to results wrong data calculation. This feature is very useful in programs where the sampling and analysis routine is stopped and restarted periodically avoiding wrong calculation due to inconsistent incoming data. tags: [Smart Sensors Lib, analogSensors, Zerynth Shield, sensorPool] groups:[Smart Sensors Library, Zerynth Shield Driver] main.py ############################################################################### # Smoothing # # Created by Zerynth Team 2015 CC # Authors: L. Rizzello, G. Baldi, D. Mazzei ############################################################################### import streams # import analogSensors module from smartsensors import analogSensors # define a function that takes a sensor object as parameter and prints # its moving average automatically evaluated def out ( obj ): print ( obj . currentAverage ) streams . serial () # initialize an analogSensor object on pin A4 s = analogSensors . AnalogSensor ( A4 ) # set highPrecision to True to evaluate the moving average more precisely s . highPrecision = True # set out function as a function to be executed every time a new sample # is acquired by the sensor s . doEverySample ( out ) # start sampling at 1000 millis with a window of 10 samples to evaluate # window parameters s . startSampling ( 1000 , 10 )","title":"Smoothing Analog Data with Moving Average"},{"location":"reference/libs/zerynth/smartsensors/docs/examples/#debounce-digital-sensor-input","text":"The smartSensors library is a ready to use set of functions that are very useful for managing analog and digital sensors. Common operations like calculating min, max, average and trends are completely automated by the smartSensors library. Moreover the smartSensors lib allows user to define calibration functions for analog sensors and to use callback to schedule sampling and acquisition operations. In this example the digitalSensors module is used to monitor a DIO and trigger a function only when a state change longer than 500 millisec is detected. This example is very useful for the design of user interfaces where button are included. In this case it is very common to have false detections due to noise or movements and also to have undesired double detection due to a longer press of the button that could be detected by the software as double click. This example is very useful for improving the usability of the Zerynth Shield Touch sensor. tags: [digitalSensors, Zerynth Shield, Touch, Button ] groups:[Smart Sensors Library, Zerynth Shield Driver] main.py ################################################################################ # Debounce Digital Sensor Input # # Created by Zerynth Team 2015 CC # Authors: L. Rizzello, G. Baldi, D. Mazzei ############################################################################### import streams # import digitalSensors module from smartsensors import digitalSensors # set a state variable to 0 state = 0 # define a function that changes the value of state global variable from 0 to 1 # or from 1 to 0 and prints the new state value def changeState (): global state state = state ^ 1 print ( \"new state: \" , state ) streams . serial () # initialize a digitalSensor object on pin D7 d = digitalSensors . DigitalSensor ( D7 ) # set changeState as the function to be executed when the value of the pin changes # from 0 to 1 ( onRise ) and again from 1 to 0 ( andFall ) respecting the time # constraint: the value must stay HIGH at least 500 milliseconds (make sure the # transition is voluntary) and less than 2000 milliseconds d . onRiseAndFall ( 500 , 2000 , changeState )","title":"Debounce Digital Sensor Input"},{"location":"reference/libs/zerynth/smartsensors/docs/examples/#smart-sensor-pool","text":"The smartSensors library is a ready to use set of functions that are very useful for managing analog and digital sensors. Common operations like calculating min, max, average and trends are completely automated by the smartSensors library. Moreover the smartSensors lib allows user to define calibration functions for analog sensors and to use callback to schedule sampling and acquisition operations. This examples shows the basic use of the sensorPool, a module of the library used to create set of heterogeneous sensors to be managed in parallel simplifying the acquisition and calculation routines. tags: [Smart Sensors Lib, analogSensors, digitalSensors, sensorPool] groups:[Smart Sensors Library] main.py ################################################################################ # Smart Sensor Pool # # Created by Zerynth Team 2015 CC # Authors: L. Rizzello, G. Baldi, D. Mazzei ############################################################################### import streams # import analogSensors, digitalSensors and sensorPool modules from smartsensors import analogSensors from smartsensors import digitalSensors from smartsensors import sensorPool # define two functions that take a sensor object as parameter and print its # last read value def outA ( obj ): print ( \"a: \" , obj . currentSample ()) def outD ( obj ): print ( \"d: \" , obj . currentSample ()) # define a function that takes a value and a sensor object as parameters and # returns a 'normalized' version of the value def normA ( val , obj ): return val // 100 streams . serial () # initialize an analog and a digital sensor on pins A4 and D7 a = analogSensors . AnalogSensor ( A4 ) d = digitalSensors . DigitalSensor ( D7 ) # set a normalization function 'normA' to sensor 'a' to normalize every acquired # sample and 'outA' as the function to be executed every time a new sample is read a . setNormFunc ( normA ) . doEverySample ( outA ) # set 'outD' as the function to be executed every time a new sample is read by # sensor 'd' d . doEverySample ( outD ) # initialize a sensorPool object that contains 'a' and 'd' sensors pool = sensorPool . SensorPool ([ a , d ]) # start sampling process for the objects in the pool specifying different # sampling parameters: # # sampling time | window size | type of acquisition # object a 1000 | None | normalized # object b 2000 | None | raw # # window size is set to None because window parameters (moving average,trend...) # are not needed in this example pool . startSampling ([ 1000 , 2000 ],[ None , None ],[ \"norm\" , \"raw\" ])","title":"Smart Sensor Pool"},{"location":"reference/libs/zerynth/smartsensors/docs/sensorPool/","text":"Pool Sensor Library \u00b6 This module contains class definitions for pool of sensors. SensorPool class takes for its initialization the list of sensors (from Generic Sensor class or Analog/Digital subclasses) Every SensorPool instance redefines the startSampling() and stopSampling() functions seen in Generic Sensor class for list of sensors instead of single sensor. SensorPool class \u00b6 class SensorPool \u00b6 class SensorPool ( sensors ) This is the class for handling pool of sensors passed as a list.","title":"sensorPool"},{"location":"reference/libs/zerynth/smartsensors/docs/sensorPool/#pool-sensor-library","text":"This module contains class definitions for pool of sensors. SensorPool class takes for its initialization the list of sensors (from Generic Sensor class or Analog/Digital subclasses) Every SensorPool instance redefines the startSampling() and stopSampling() functions seen in Generic Sensor class for list of sensors instead of single sensor.","title":"Pool Sensor Library"},{"location":"reference/libs/zerynth/smartsensors/docs/sensorPool/#sensorpool-class","text":"","title":"SensorPool class"},{"location":"reference/libs/zerynth/smartsensors/docs/sensorPool/#class-sensorpool","text":"class SensorPool ( sensors ) This is the class for handling pool of sensors passed as a list.","title":"class SensorPool"},{"location":"reference/libs/zerynth/smartsensors/docs/sensors/","text":"Generic Sensor Library \u00b6 This module contains class definitions for sensors. The Sensor class provides methods for handling generic sensors connected to specific pins of a device. It also provides easily accessible attributes for useful parameters automatically evaluated during the acquisition. Every Sensor instance implements the following methods: getRaw: reads a raw value from the sensor and returns it setNormFunc: sets a normalization function getNormalized: reads a raw value from the sensor and returns a normalized one currentSample: returns last read sample previousSample: returns the last but one read sample doEverySample: appends to a list a function to be executed every time a get function is called resetSampleActions: resets Actions list addCheck: appends to a list a couple of a condition to be checked every time a get function is called the action to be executed if the condition is verified resetChek: resets Checks list startSampling: sets a sampling interval stopSampling: clears the sampling interval wait: sleeps setObservationWindow: sets the length of the window used to evaluate a set of useful parameters setSamplingTime: sets the private attribute _samplingTime (use carefully) Every Sensor instance provides the following parameters evaluated in a window of n acquisitions (both in sampling mode and simple get calls): currentAverage: moving average for last n samples currentDerivative: last sample minus penultimate sample, all divided by sampling time in seconds (only sampling mode) currentTrend: last sample minus first sample of the window, all divided by sampling time in seconds (only sampling mode) minSample: smallest sample of the window maxSample: greatest sample of the window And the following attributes to control the process of evaluation of the parameters: skipEval: if True skips the whole process of evaluation storeAverage: if False skips average evaluation storeTrend: if False skips trend evaluation storeMinMax: if False skips min and max evaluation The Sensor class \u00b6 class Sensor \u00b6 class Sensor () This is the base class for generic sensors connected to pins. Sensor._resetSamplingParams \u00b6 _resetSamplingParams () Resets sampling parameters. Sensor.setObservationWindow \u00b6 setObservationWindow ( n ) Sets the length of the window (n) used to evaluate a set of useful parameters. Needed to evaluate those parameters during manual acquisition (calling getRaw/getNormalized functions), in sampling mode (entered by startSampling call) the length is given as a parameter of startSampling method. Note self._samplingTime can be found set in: sampling mode: setObservationWindow should not have been called get mode: self._samplingTime has been manually set because samplingTime dependent parameters (like trend and derivatived) are necessary in a non-sampling mode (should be very rare) Sensor.setSamplingTime \u00b6 setSamplingTime ( time ) Manually sets _samplingTime private attribute. Warning Use carefully setObservationWindow method. This attribute is automatically set when startSampling method is called. Sensor.currentSample \u00b6 currentSample () Returns last read sample: stored as the last element of the buffer list. The buffer is a list of _observationWindowN elements if the window evaluation process is not skipped, as a private attribute otherwise. Sensor.previousSample \u00b6 previousSample () Returns last but one read sample: stored in the buffer list (see currentSample). Note Not available if evaluation process is skipped. Sensor.getRaw \u00b6 getRaw () Main acquisition method for raw data. Sensor.getNormalized \u00b6 getNormalized () Main acquisition method for normalized data. Sensor.doEverySample \u00b6 doEverySample ( to_do ) Appends a function to the list of those to be executed when _getValue is called. Note _getValue is called both in sampling and manual acquisition mode. Example: def out ( obj ): print ( obj . currentSample ()) mySensor . doEverySample ( out ) ### 'out' is executed in both cases: mySensor . startSampling ( ... ) mySensor . getRaw () Returns self to allow a compact code: mySensor . doEverySample ( out ) . addCheck ( ... ) . startSampling ( ... ) Sensor.resetSampleActions \u00b6 resetSampleActions () Resets _everySampleActions list. Sensor.addCheck \u00b6 addCheck ( condition , to_do ) Appends a condition to those to be checked every time _getValue is called and a function to the list of those to be executed when their conditions are verified. \u2018condition\u2019 must be a function that takes the current sensor object as a parameter and returns a boolean value: def averageGreaterThanThreshold ( obj ): if type ( obj . currentAverage ) != PNONE : if obj . currentAverage > 50 : return True else : return False else : return False \u2018to_do\u2019 must be a function that takes the current sensor object as a parameter and performs some actions: def succeed ( obj ): print ( \"Average is greater than threshold!\" ) print ( obj . currentAverage ) Returns self to allow a compact code (see doEverySample). Sensor.resetCheck \u00b6 resetCheck () Resets _checkFunctions and _checkConditions lists. Sensor.setNormFunc \u00b6 setNormFunc ( fn ) Sets a normalization function. A normalization function takes the last raw acquired value and the current sensor object as parameters. Example: def normalizeData ( val , obj ): return obj . scale * ( val / 100 ) It is recommended to use only static parameters stored in current object like scale factors... note:: In the object passed, obj.currentSample() returns the last but one read value because the buffer list is updated only after the normalization. Returns self to allow a compact code (see doEverySample). Sensor.startSampling \u00b6 startSampling ( time , observation_window , get_type , time_unit ) Starts reading samples every _samplingTime. Length of _observationWindowN to evaluate window parameters, type of acquisition and time_unit characterize the acquisition itself. If no observation_window is passed the evaluation of window parameters is skipped. Returns self to allow a compact code (see doEverySample). Sensor.stopSampling \u00b6 stopSampling () Depending on mode: sampling mode: clears timer interval and stops sampling non sampling mode: resets sampling parameters Returns self to allow a compact code (see doEverySample). Sensor.wait \u00b6 wait ( time ) Sleeps for time milliseconds and returns self to allow a compact code: mySensor . doEverySample ( out ) . startSampling ( \u2026 ) . wait ( 5000 ) . stopSampling ()","title":"Generic Sensor Library"},{"location":"reference/libs/zerynth/smartsensors/docs/sensors/#generic-sensor-library","text":"This module contains class definitions for sensors. The Sensor class provides methods for handling generic sensors connected to specific pins of a device. It also provides easily accessible attributes for useful parameters automatically evaluated during the acquisition. Every Sensor instance implements the following methods: getRaw: reads a raw value from the sensor and returns it setNormFunc: sets a normalization function getNormalized: reads a raw value from the sensor and returns a normalized one currentSample: returns last read sample previousSample: returns the last but one read sample doEverySample: appends to a list a function to be executed every time a get function is called resetSampleActions: resets Actions list addCheck: appends to a list a couple of a condition to be checked every time a get function is called the action to be executed if the condition is verified resetChek: resets Checks list startSampling: sets a sampling interval stopSampling: clears the sampling interval wait: sleeps setObservationWindow: sets the length of the window used to evaluate a set of useful parameters setSamplingTime: sets the private attribute _samplingTime (use carefully) Every Sensor instance provides the following parameters evaluated in a window of n acquisitions (both in sampling mode and simple get calls): currentAverage: moving average for last n samples currentDerivative: last sample minus penultimate sample, all divided by sampling time in seconds (only sampling mode) currentTrend: last sample minus first sample of the window, all divided by sampling time in seconds (only sampling mode) minSample: smallest sample of the window maxSample: greatest sample of the window And the following attributes to control the process of evaluation of the parameters: skipEval: if True skips the whole process of evaluation storeAverage: if False skips average evaluation storeTrend: if False skips trend evaluation storeMinMax: if False skips min and max evaluation","title":"Generic Sensor Library"},{"location":"reference/libs/zerynth/smartsensors/docs/sensors/#the-sensor-class","text":"","title":"The Sensor class"},{"location":"reference/libs/zerynth/smartsensors/docs/sensors/#class-sensor","text":"class Sensor () This is the base class for generic sensors connected to pins.","title":"class Sensor"},{"location":"reference/libs/zerynth/smartsensors/docs/sensors/#sensor_resetsamplingparams","text":"_resetSamplingParams () Resets sampling parameters.","title":"Sensor._resetSamplingParams"},{"location":"reference/libs/zerynth/smartsensors/docs/sensors/#sensorsetobservationwindow","text":"setObservationWindow ( n ) Sets the length of the window (n) used to evaluate a set of useful parameters. Needed to evaluate those parameters during manual acquisition (calling getRaw/getNormalized functions), in sampling mode (entered by startSampling call) the length is given as a parameter of startSampling method. Note self._samplingTime can be found set in: sampling mode: setObservationWindow should not have been called get mode: self._samplingTime has been manually set because samplingTime dependent parameters (like trend and derivatived) are necessary in a non-sampling mode (should be very rare)","title":"Sensor.setObservationWindow"},{"location":"reference/libs/zerynth/smartsensors/docs/sensors/#sensorsetsamplingtime","text":"setSamplingTime ( time ) Manually sets _samplingTime private attribute. Warning Use carefully setObservationWindow method. This attribute is automatically set when startSampling method is called.","title":"Sensor.setSamplingTime"},{"location":"reference/libs/zerynth/smartsensors/docs/sensors/#sensorcurrentsample","text":"currentSample () Returns last read sample: stored as the last element of the buffer list. The buffer is a list of _observationWindowN elements if the window evaluation process is not skipped, as a private attribute otherwise.","title":"Sensor.currentSample"},{"location":"reference/libs/zerynth/smartsensors/docs/sensors/#sensorprevioussample","text":"previousSample () Returns last but one read sample: stored in the buffer list (see currentSample). Note Not available if evaluation process is skipped.","title":"Sensor.previousSample"},{"location":"reference/libs/zerynth/smartsensors/docs/sensors/#sensorgetraw","text":"getRaw () Main acquisition method for raw data.","title":"Sensor.getRaw"},{"location":"reference/libs/zerynth/smartsensors/docs/sensors/#sensorgetnormalized","text":"getNormalized () Main acquisition method for normalized data.","title":"Sensor.getNormalized"},{"location":"reference/libs/zerynth/smartsensors/docs/sensors/#sensordoeverysample","text":"doEverySample ( to_do ) Appends a function to the list of those to be executed when _getValue is called. Note _getValue is called both in sampling and manual acquisition mode. Example: def out ( obj ): print ( obj . currentSample ()) mySensor . doEverySample ( out ) ### 'out' is executed in both cases: mySensor . startSampling ( ... ) mySensor . getRaw () Returns self to allow a compact code: mySensor . doEverySample ( out ) . addCheck ( ... ) . startSampling ( ... )","title":"Sensor.doEverySample"},{"location":"reference/libs/zerynth/smartsensors/docs/sensors/#sensorresetsampleactions","text":"resetSampleActions () Resets _everySampleActions list.","title":"Sensor.resetSampleActions"},{"location":"reference/libs/zerynth/smartsensors/docs/sensors/#sensoraddcheck","text":"addCheck ( condition , to_do ) Appends a condition to those to be checked every time _getValue is called and a function to the list of those to be executed when their conditions are verified. \u2018condition\u2019 must be a function that takes the current sensor object as a parameter and returns a boolean value: def averageGreaterThanThreshold ( obj ): if type ( obj . currentAverage ) != PNONE : if obj . currentAverage > 50 : return True else : return False else : return False \u2018to_do\u2019 must be a function that takes the current sensor object as a parameter and performs some actions: def succeed ( obj ): print ( \"Average is greater than threshold!\" ) print ( obj . currentAverage ) Returns self to allow a compact code (see doEverySample).","title":"Sensor.addCheck"},{"location":"reference/libs/zerynth/smartsensors/docs/sensors/#sensorresetcheck","text":"resetCheck () Resets _checkFunctions and _checkConditions lists.","title":"Sensor.resetCheck"},{"location":"reference/libs/zerynth/smartsensors/docs/sensors/#sensorsetnormfunc","text":"setNormFunc ( fn ) Sets a normalization function. A normalization function takes the last raw acquired value and the current sensor object as parameters. Example: def normalizeData ( val , obj ): return obj . scale * ( val / 100 ) It is recommended to use only static parameters stored in current object like scale factors... note:: In the object passed, obj.currentSample() returns the last but one read value because the buffer list is updated only after the normalization. Returns self to allow a compact code (see doEverySample).","title":"Sensor.setNormFunc"},{"location":"reference/libs/zerynth/smartsensors/docs/sensors/#sensorstartsampling","text":"startSampling ( time , observation_window , get_type , time_unit ) Starts reading samples every _samplingTime. Length of _observationWindowN to evaluate window parameters, type of acquisition and time_unit characterize the acquisition itself. If no observation_window is passed the evaluation of window parameters is skipped. Returns self to allow a compact code (see doEverySample).","title":"Sensor.startSampling"},{"location":"reference/libs/zerynth/smartsensors/docs/sensors/#sensorstopsampling","text":"stopSampling () Depending on mode: sampling mode: clears timer interval and stops sampling non sampling mode: resets sampling parameters Returns self to allow a compact code (see doEverySample).","title":"Sensor.stopSampling"},{"location":"reference/libs/zerynth/smartsensors/docs/sensors/#sensorwait","text":"wait ( time ) Sleeps for time milliseconds and returns self to allow a compact code: mySensor . doEverySample ( out ) . startSampling ( \u2026 ) . wait ( 5000 ) . stopSampling ()","title":"Sensor.wait"},{"location":"reference/libs/zerynth/zadm/docs/","text":"Zerynth ADM Library \u00b6 Contents: Zerynth ADM Library Zerynth ADM Step by Step The Device class Examples Simple ADM FOTA updates","title":"Zerynth ADM Library"},{"location":"reference/libs/zerynth/zadm/docs/#zerynth-adm-library","text":"Contents: Zerynth ADM Library Zerynth ADM Step by Step The Device class Examples Simple ADM FOTA updates","title":"Zerynth ADM Library"},{"location":"reference/libs/zerynth/zadm/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.zerynth.zadm. Simple ADM \u00b6 A basic example showing RPC calls, events and mobile notifications using th Zerynth ADM. main.py from wireless import wifi # this example is based on Particle Photon # change the following line to use a different wifi driver from broadcom.bcm43362 import bcm43362 as wifi_driver import streams # Import the Zerynth ADM library from zadm import zadm streams . serial () sleep ( 1000 ) print ( \"STARTING...\" ) # define a RPC function: generate a random number def do_random ( a , b ): return random ( a , b ) methods = { \"random\" : do_random } # send events on button pressed def on_btn (): z . send_event ({ \"my_button\" : \"pressed\" }) z . send_notification ( \"BUTTON!\" , \"PRESSED!\" ) onPinFall ( BTN0 , on_btn , debounce = 1000 ) # Create a device instance by passing the device UID and TOKEN (copy and paste from the ADM panel) # enable logging to debug and pass in the dictionary of remotely callable functions z = zadm . Device ( \"DEVICE UID HERE\" , \"DEVICE TOKEN HERE\" , log = True , rpc = methods ) try : # connect to the wifi network (Set your SSID and password below) wifi_driver . auto_init () for i in range ( 0 , 5 ): try : wifi . link ( \"NETWORK SSID\" , wifi . WIFI_WPA2 , \"NETWORK PASSWORD\" ) break except Exception as e : print ( \"Can't link\" , e ) else : print ( \"Impossible to link!\" ) while True : sleep ( 1000 ) # Start the device instance! # It immediately returns while a background thread keeps trying to connect and receive messages. # As soon as a RPC call is received, do_random is automatically called and the result send back to the ADM. # If the device button is pressed long enough, a notification and an event are sent to the ADM that dispatches them to all connected templates and apps z . start () # Do whatever you need here while True : print ( \".\" ) sleep ( 5000 ) except Exception as e : print ( e ) FOTA updates \u00b6 A basic example showing how to perform FOTA updates via the Zerynth ADM. main.py ################################################################################ # FOTA Updates # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ############################################################################### ## ## This example only works on a FOTA enabled Virtual Machine! ## from wireless import wifi # this example is based on a ESP8266 device # change the following line to use a different wifi driver from espressif.esp8266wifi import esp8266wifi as wifi_driver import streams # Import the Zerynth ADM library from zadm import zadm # Import the fota library import fota streams . serial () sleep ( 1000 ) print ( \"STARTING...\" ) def fota_callback ( event ): if event == 0 : print ( \"FOTA Started\" ) elif event == 1 : print ( \"FOTA record is changing\" ) elif event == 2 : print ( \"device is going to RESET!\" ) sleep ( 2000 ) return True # Create a device instance by passing the device UID and TOKEN (copy and paste from the ADM panel) # enable logging to debug z = zadm . Device ( \"DEVICE-UID-HERE\" , \"DEVICE-TOKEN-HERE\" , log = False , fota_callback = fota_callback ) try : # Get information about the currently running configuration # Check documentation here: https://docs.zerynth.com/latest/official/core.zerynth.stdlib/docs/official_core.zerynth.stdlib_fota.html rec = fota . get_record () bcslot = rec [ 4 ] valid_runtime = rec [ 0 ] # connect to the wifi network (Set your SSID and password below) wifi_driver . auto_init () for i in range ( 0 , 5 ): try : wifi . link ( \"SSID\" , wifi . WIFI_WPA2 , \"password\" ) break except Exception as e : print ( \"Can't link!\" , e ) else : print ( \"Impossible to link!\" ) while True : sleep ( 1000 ) # Start the device instance! # It immediately returns while a background thread keeps trying to connect and receive messages z . start () # Do whatever you need here if valid_runtime : msg = \"Hello, this is Bytecode running on slot \" + str ( bcslot ) else : msg = \"Hello, this is Bytecode runnung on slot ??\" pinMode ( LED0 , OUTPUT ) # blink a led and print some message while True : print ( msg ) sleep ( 5000 ) pinToggle ( LED0 ) except Exception as e : print ( e )","title":"Examples"},{"location":"reference/libs/zerynth/zadm/docs/examples/#examples","text":"The following are a list of examples for lib.zerynth.zadm.","title":"Examples"},{"location":"reference/libs/zerynth/zadm/docs/examples/#simple-adm","text":"A basic example showing RPC calls, events and mobile notifications using th Zerynth ADM. main.py from wireless import wifi # this example is based on Particle Photon # change the following line to use a different wifi driver from broadcom.bcm43362 import bcm43362 as wifi_driver import streams # Import the Zerynth ADM library from zadm import zadm streams . serial () sleep ( 1000 ) print ( \"STARTING...\" ) # define a RPC function: generate a random number def do_random ( a , b ): return random ( a , b ) methods = { \"random\" : do_random } # send events on button pressed def on_btn (): z . send_event ({ \"my_button\" : \"pressed\" }) z . send_notification ( \"BUTTON!\" , \"PRESSED!\" ) onPinFall ( BTN0 , on_btn , debounce = 1000 ) # Create a device instance by passing the device UID and TOKEN (copy and paste from the ADM panel) # enable logging to debug and pass in the dictionary of remotely callable functions z = zadm . Device ( \"DEVICE UID HERE\" , \"DEVICE TOKEN HERE\" , log = True , rpc = methods ) try : # connect to the wifi network (Set your SSID and password below) wifi_driver . auto_init () for i in range ( 0 , 5 ): try : wifi . link ( \"NETWORK SSID\" , wifi . WIFI_WPA2 , \"NETWORK PASSWORD\" ) break except Exception as e : print ( \"Can't link\" , e ) else : print ( \"Impossible to link!\" ) while True : sleep ( 1000 ) # Start the device instance! # It immediately returns while a background thread keeps trying to connect and receive messages. # As soon as a RPC call is received, do_random is automatically called and the result send back to the ADM. # If the device button is pressed long enough, a notification and an event are sent to the ADM that dispatches them to all connected templates and apps z . start () # Do whatever you need here while True : print ( \".\" ) sleep ( 5000 ) except Exception as e : print ( e )","title":"Simple ADM"},{"location":"reference/libs/zerynth/zadm/docs/examples/#fota-updates","text":"A basic example showing how to perform FOTA updates via the Zerynth ADM. main.py ################################################################################ # FOTA Updates # # Created by Zerynth Team 2015 CC # Authors: G. Baldi, D. Mazzei ############################################################################### ## ## This example only works on a FOTA enabled Virtual Machine! ## from wireless import wifi # this example is based on a ESP8266 device # change the following line to use a different wifi driver from espressif.esp8266wifi import esp8266wifi as wifi_driver import streams # Import the Zerynth ADM library from zadm import zadm # Import the fota library import fota streams . serial () sleep ( 1000 ) print ( \"STARTING...\" ) def fota_callback ( event ): if event == 0 : print ( \"FOTA Started\" ) elif event == 1 : print ( \"FOTA record is changing\" ) elif event == 2 : print ( \"device is going to RESET!\" ) sleep ( 2000 ) return True # Create a device instance by passing the device UID and TOKEN (copy and paste from the ADM panel) # enable logging to debug z = zadm . Device ( \"DEVICE-UID-HERE\" , \"DEVICE-TOKEN-HERE\" , log = False , fota_callback = fota_callback ) try : # Get information about the currently running configuration # Check documentation here: https://docs.zerynth.com/latest/official/core.zerynth.stdlib/docs/official_core.zerynth.stdlib_fota.html rec = fota . get_record () bcslot = rec [ 4 ] valid_runtime = rec [ 0 ] # connect to the wifi network (Set your SSID and password below) wifi_driver . auto_init () for i in range ( 0 , 5 ): try : wifi . link ( \"SSID\" , wifi . WIFI_WPA2 , \"password\" ) break except Exception as e : print ( \"Can't link!\" , e ) else : print ( \"Impossible to link!\" ) while True : sleep ( 1000 ) # Start the device instance! # It immediately returns while a background thread keeps trying to connect and receive messages z . start () # Do whatever you need here if valid_runtime : msg = \"Hello, this is Bytecode running on slot \" + str ( bcslot ) else : msg = \"Hello, this is Bytecode runnung on slot ??\" pinMode ( LED0 , OUTPUT ) # blink a led and print some message while True : print ( msg ) sleep ( 5000 ) pinToggle ( LED0 ) except Exception as e : print ( e )","title":"FOTA updates"},{"location":"reference/libs/zerynth/zadm/docs/zadm/","text":"Zerynth ADM Library \u00b6 The Zerynth ADM library can be used yo ease the connection to the Zerynth ADM sandbox . It takes care of connecting to the ADM and listening for incoming messages. Moreover it seamlessly enables RPC calls and mobile integration. For Virtual Machines supporting FOTA updates, the Zerynth ADM also performs the FOTA process automatically when requested. Zerynth ADM Step by Step \u00b6 Using the ADM library is very simple: obtain device credentials (UID and TOKEN): can be copied and pasted directly from Zerynth Studio (ADM panel) or the Zerynth Toolchain optionally define a dictionary of remotely callable functions create an instance of the Device class with the desired configuration start the device instance send and receive messages from connected templates and apps Check the provided examples for more details. The Device class \u00b6 class Device \u00b6 class Device ( uid , token , ip = None , address = \"things.zerynth.com\" , heartbeat = 60 , rpc = None , log = False , fota_callback = None , low_res = False ) Creates a Device instance with uid uid and token token . All other parameters are optional and have default values. ip is the ip address of the ADM. This argument is used when the network driver does not support hostname resolution address is the hostname of the ADM instance. It is used by default and resolved to an ip address when the network driver supports the functionality heartbeat is the number of seconds between heartbeat messages. If the ADM detects that a connected device is not sending heartbeat messages two times in a row, it automatically terminates the connection. Heartbeat messages are automatically sent by the Device class. The ADM may not accept the specified heartbeat time and force the device to use another, based on network traffic and other parameters. rpc is a dictionary with keys representing function names and values representing actual Python functions. When a RPC call is made to the ADM, the message is relayed to the connected device. The Device class, scans the rpc dictionary and if a key matching the requested call is found, the corresponding function is executed (in the Device class thread). The result (or the exception message) is then sent back to the ADM that relays it to the caller. log , if true prints logging messages to the device serial console fota_callback , is a function accepting one ore more arguments that will be called at different steps of the FOTA process. The argument will be set to: 0 , when the FOTA process is started 1 , when the FOTA process needs to update the FOTA record 2 , when the FOTA process needs to reseet the device at the end of the FOTA process the fota_callback can return a boolean value. If the return value is True, the FOTA process continues, otherwise it is stopped. * low_res , if true makes the FOTA process a bit less performant but more lightweight (needed for low-resource devices) Device.start \u00b6 start () Starts the connection process and creates background threads to handle incoming and outgoing messages. It returns immediately. Device.send \u00b6 send ( msg ) Send a raw message to the ADM. msg is a dictionary that will be serialized to JSON and sent. Device.send_event \u00b6 send_event ( payload ) Send an event message containing the payload payload to the ADM. Payload is given as a dictionary and then serialized to JSON. Device.send_notification \u00b6 send_notification ( title , text ) Send a push notification to connected apps and templates. The notification must have a title and a text .","title":"Zerynth ADM Library"},{"location":"reference/libs/zerynth/zadm/docs/zadm/#zerynth-adm-library","text":"The Zerynth ADM library can be used yo ease the connection to the Zerynth ADM sandbox . It takes care of connecting to the ADM and listening for incoming messages. Moreover it seamlessly enables RPC calls and mobile integration. For Virtual Machines supporting FOTA updates, the Zerynth ADM also performs the FOTA process automatically when requested.","title":"Zerynth ADM Library"},{"location":"reference/libs/zerynth/zadm/docs/zadm/#zerynth-adm-step-by-step","text":"Using the ADM library is very simple: obtain device credentials (UID and TOKEN): can be copied and pasted directly from Zerynth Studio (ADM panel) or the Zerynth Toolchain optionally define a dictionary of remotely callable functions create an instance of the Device class with the desired configuration start the device instance send and receive messages from connected templates and apps Check the provided examples for more details.","title":"Zerynth ADM Step by Step"},{"location":"reference/libs/zerynth/zadm/docs/zadm/#the-device-class","text":"","title":"The Device class"},{"location":"reference/libs/zerynth/zadm/docs/zadm/#class-device","text":"class Device ( uid , token , ip = None , address = \"things.zerynth.com\" , heartbeat = 60 , rpc = None , log = False , fota_callback = None , low_res = False ) Creates a Device instance with uid uid and token token . All other parameters are optional and have default values. ip is the ip address of the ADM. This argument is used when the network driver does not support hostname resolution address is the hostname of the ADM instance. It is used by default and resolved to an ip address when the network driver supports the functionality heartbeat is the number of seconds between heartbeat messages. If the ADM detects that a connected device is not sending heartbeat messages two times in a row, it automatically terminates the connection. Heartbeat messages are automatically sent by the Device class. The ADM may not accept the specified heartbeat time and force the device to use another, based on network traffic and other parameters. rpc is a dictionary with keys representing function names and values representing actual Python functions. When a RPC call is made to the ADM, the message is relayed to the connected device. The Device class, scans the rpc dictionary and if a key matching the requested call is found, the corresponding function is executed (in the Device class thread). The result (or the exception message) is then sent back to the ADM that relays it to the caller. log , if true prints logging messages to the device serial console fota_callback , is a function accepting one ore more arguments that will be called at different steps of the FOTA process. The argument will be set to: 0 , when the FOTA process is started 1 , when the FOTA process needs to update the FOTA record 2 , when the FOTA process needs to reseet the device at the end of the FOTA process the fota_callback can return a boolean value. If the return value is True, the FOTA process continues, otherwise it is stopped. * low_res , if true makes the FOTA process a bit less performant but more lightweight (needed for low-resource devices)","title":"class Device"},{"location":"reference/libs/zerynth/zadm/docs/zadm/#devicestart","text":"start () Starts the connection process and creates background threads to handle incoming and outgoing messages. It returns immediately.","title":"Device.start"},{"location":"reference/libs/zerynth/zadm/docs/zadm/#devicesend","text":"send ( msg ) Send a raw message to the ADM. msg is a dictionary that will be serialized to JSON and sent.","title":"Device.send"},{"location":"reference/libs/zerynth/zadm/docs/zadm/#devicesend_event","text":"send_event ( payload ) Send an event message containing the payload payload to the ADM. Payload is given as a dictionary and then serialized to JSON.","title":"Device.send_event"},{"location":"reference/libs/zerynth/zadm/docs/zadm/#devicesend_notification","text":"send_notification ( title , text ) Send a push notification to connected apps and templates. The notification must have a title and a text .","title":"Device.send_notification"},{"location":"reference/libs/zerynth/zdm/docs/","text":"Zerynth ZDM Library \u00b6 The Zerynth ZDM library can be used to connect and manage your devices with the Zerynth Device Manager. It takes care of connecting to the ZDM and listening for incoming messages. It enables you to call jobs on devices remotely, to do FOTA (firmware over the air) for Virtual Machines supporting FOTA updates. Contents: Getting started The Device class Examples Simple ZDM ZDM Jobs Advanced FOTA update ZDM events ZDM Advanced","title":"Zerynth ZDM Library"},{"location":"reference/libs/zerynth/zdm/docs/#zerynth-zdm-library","text":"The Zerynth ZDM library can be used to connect and manage your devices with the Zerynth Device Manager. It takes care of connecting to the ZDM and listening for incoming messages. It enables you to call jobs on devices remotely, to do FOTA (firmware over the air) for Virtual Machines supporting FOTA updates. Contents: Getting started The Device class Examples Simple ZDM ZDM Jobs Advanced FOTA update ZDM events ZDM Advanced","title":"Zerynth ZDM Library"},{"location":"reference/libs/zerynth/zdm/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.zerynth.zdm. Simple ZDM \u00b6 In this example you can see how to create a ZDM device and connect it to the Zerynth Device Manager and send periodically data. It simulates a weather sensor that sends temperature and pressure values to the ZDM periodically. You can use this example to test ZDM Webhooks and Ubidots integration. To check if the ZDM is correctly receiving data sent by your device, use the data ZDM command. main.py ################################################################################ # Zerynth Device Manager # # Created by Zerynth Team 2020 CC # Authors: E.Neri, D.Neri ############################################################################### from zdm import zdm from wireless import wifi # Please uncomment the line related to the wi-fi chip architecture you are using # from microchip.winc1500 import winc1500 as wifi_driver # from espressif.esp32net import esp32wifi as wifi_driver import streams import json # paste here your device id and password generated by the ZDM # the password is a jwt generated from a device's key device_id = 'your device id' password = 'your device password' def pub_random (): # this function is called periodically to publish to ZDM random int value labeled with tags values print ( '------ publish random ------' ) tags = [ 'tag1' , 'tag2' , 'tag3' ] payload = { 'value' : 0 } for t in tags : payload [ 'value' ] = random ( 0 , 100 ) # publish payload to ZDM device . publish ( json . dumps ( payload ), t ) print ( 'published on tag:' , t , ':' , payload ) print ( 'pub_random done' ) def pub_temp_pressure (): # this function publish another payload with two random int values print ( '---- publish temp_pressure ----' ) tag = 'tag4' temp = random ( 19 , 23 ) pressure = random ( 50 , 60 ) payload = { 'temp' : temp , 'pressure' : pressure } device . publish ( json . dumps ( payload ), tag ) print ( 'published on tag: ' , tag , ':' , payload ) streams . serial () try : wifi_driver . auto_init () for _ in range ( 5 ): try : print ( \"connect wifi\" ) # Write here your wifi SSID and password wifi . link ( \"***Wifi-name***\" , wifi . WIFI_WPA2 , \"***Wifi-password***\" ) print ( \"connect wifi done\" ) break except Exception as e : print ( \"wifi connect err\" , e ) # create a ZDM Device instance with your device id device = zdm . Device ( device_id ) # set the device's password (jwt) device . set_password ( password ) # connect your device to ZDM enabling the device to receive incoming messages device . connect () while True : sleep ( 5000 ) pub_random () pub_temp_pressure () except Exception as e : print ( \"main\" , e ) ZDM Jobs \u00b6 A basic example showing ZDM Jobs and how to handle them. Write your own jobs, then add them in the jobs dictionary with a custom key. Once your device is connected to the ZDM, you can send it job commands using the key you defined and your device will execute functions remotely. main.py ################################################################################ # Zerynth Device Manager # # Created by Zerynth Team 2020 CC # Authors: E.Neri, D.Neri ############################################################################### from zdm import zdm from wireless import wifi # Please uncomment the line related to the wi-fi chip architecture you are using # from microchip.winc1500 import winc1500 as wifi_driver # from espressif.esp32net import esp32wifi as wifi_driver import streams import json # paste here your device id and password generated by the ZDM # the password is a jwt generated from a device's key device_id = 'your device id' password = 'your device password' def custom_job_1 ( obj , arg ): print ( \"custom_job_1\" ) return { 'value 1' : random ( 0 , 100 ), 'value 2' : random ( 100 , 200 ) } def custom_job_2 ( obj , arg ): print ( \"custom_job_2\" ) return 'this is an example result' # you can call job1 and job2 method using rpc my_jobs = { 'job1' : custom_job_1 , 'job2' : custom_job_2 , } streams . serial () try : wifi_driver . auto_init () for _ in range ( 5 ): try : print ( \"connect wifi\" ) # Write here your wifi SSID and password wifi . link ( \"***Wifi-name***\" , wifi . WIFI_WPA2 , \"***Wifi-password***\" ) print ( \"connect wifi done\" ) break except Exception as e : print ( \"wifi connect err\" , e ) # create a ZDM Device instance with your id and the jobs dictionary device = zdm . Device ( device_id , jobs_dict = my_jobs ) # set the device's password (jwt) device . set_password ( password ) # connect your device to ZDM enabling the device to receive incoming messages device . connect () while True : sleep ( 1000 ) except Exception as e : print ( \"main\" , e ) FOTA Updates \u00b6 Connect your device to ZDM and start updating the firmware seamlessly. In this example you can see how to create a ZDM device and connect it to the Zerynth Device Manager. In this example, a FOTA callback function is defined, which is called during the FOTA update steps. The FOTA callback allows you to accept or refuse a FOTA from your devices using the return value. If the callback returns True the device will accept the FOTA update requests, if the callback return False the device will refuse it. Try to edit the function e do your tests using ZDM FOTA commands. main.py ################################################################################ # Zerynth Device Manager # # Created by Zerynth Team 2020 CC # Authors: E.Neri, D.Neri ############################################################################### from zdm import zdm from wireless import wifi # choose a wifi chip supporting secure sockets and client certificates # from microchip.winc1500 import winc1500 as wifi_driver # from espressif.esp32net import esp32wifi as wifi_driver import streams # paste here your device id and password generated by the ZDM # the password is a jwt generated from a device's key device_id = 'your device id' password = 'your device password' def fota_callback (): # This function is called many times during a FOTA update. If it returns True the FOTA update will # be accepted by the device, refused if it returns False print ( \"Fota callback called\" ) return True streams . serial () try : wifi_driver . auto_init () for _ in range ( 5 ): try : print ( \"connect wifi\" ) # Write here your wifi SSID and password wifi . link ( \"***Wifi-name***\" , wifi . WIFI_WPA2 , \"***Wifi-password***\" ) print ( \"connect wifi done\" ) break except Exception as e : print ( \"wifi connect err\" , e ) # create a ZDM Device instance with your id and the fota callback device = zdm . Device ( device_id , fota_callback = fota_callback ) # set the device's password (jwt) device . set_password ( password ) # connect your device to ZDM enabling the device to receive incoming messages device . connect () while True : sleep ( 1000 ) except Exception as e : print ( \"main\" , e ) ZDM_events \u00b6 ZDM_events example show you how to send events from your device. You could use events to let the device notify a specific status or condition with a message, for example when a variable reach a threshold value. This example creates a ZDM Device instance that starts a loop and sends an example event every 10 seconds. main.py ################################################################################ # Zerynth Device Manager # # Created by Zerynth Team 2020 CC # Authors: E.Neri ############################################################################### from zdm import zdm from wireless import wifi import streams # Please uncomment the line related to the wi-fi chip architecture you are using # from microchip.winc1500 import winc1500 as wifi_driver # from espressif.esp32net import esp32wifi as wifi_driver # paste here your device id and password generated by the ZDM # the password is a jwt generated from a device's key device_id = 'your device id' password = 'your device password' streams . serial () try : wifi_driver . auto_init () for _ in range ( 5 ): try : print ( \"connect wifi\" ) # Write here your wifi SSID and password wifi . link ( \"***Wifi-name***\" , wifi . WIFI_WPA2 , \"***Wifi-password***\" ) print ( \"connect wifi done\" ) break except Exception as e : print ( \"wifi connect err\" , e ) # create a ZDM Device instance with your device id device = zdm . Device ( device_id ) # set the device's password (jwt) device . set_password ( password ) # connect your device to ZDM enabling the device to receive incoming messages device . connect () while True : sleep ( 10000 ) value = { 'name' : 'optional event name' , 'message' : 'this is an event' } device . send_event ( value ) except Exception as e : print ( \"main\" , e ) ZDM_Advanced \u00b6 This is an advanced example aimed at showing all the ZDM functionalities integrated in an embedded firmware. The example simulates the use of the ZDM in an industrial IOT scenario where industrial machines are monitored via sensors interfaced with zerynth powered boards In this example we simulate the acquisition of 3 variables from 2 industrial machines (a CNC and an industrial pump). The setup also includes two relays used to control a Red and a Green light indicators placed near the machine. The lights are used to notify the operator on remote alarms sent directly by the ZDM as jobs. main.py ################################################################################ # Zerynth Device Manager # # Created by Zerynth Team 2020 CC # Author: E.Neri, D.Mazzei ############################################################################### from zdm import zdm from wireless import wifi import streams import json import monitor # *** Please uncomment the line related to the wi-fi chip architecture you are using *** # from microchip.winc1500 import winc1500 as wifi_driver # from espressif.esp32net import esp32wifi as wifi_driver # *** Paste here your device id and password generated by the ZDM *** device_id = 'device-id' password = 'device-password' # *** Write here your wifi ssid and password wifi_ssid = '' wifi_password = '' monitor = monitor . machinesMonitor () # cnc and pump period indicates the interval in seconds between two data publish for each machine cncPeriod = 10 pumpPeriod = 10 # this bool variables [default=false] are set remotely using jobs below # when True, device sends also instantaneous values for the associated machine instantCnc = False instantPump = False # acceptFOTA [default True] indicates if the device Fota si enabled or not acceptFOTA = True # jobs def enable_instant_cnc (): global instantCnc instantCnc = True return \"instant cnc enabled\" def disable_instant_cnc (): global instantCnc instantCnc = False return \"instant cnc disabled\" def enable_instant_pump (): global instantPump instantPump = True return \"instant pump enabled\" def disable_instant_pump (): global instantPump instantPump = False return \"instant pump disabled\" # to set cnc period use the command set_cnc_period --arg period 12 device_id def set_cnc_period ( obj , args ): if not ( 'period' in args [ 'args' ]) or args [ 'args' ][ 'period' ] is None : return \"use zmd set_cnc_period --arg period [int] [device_id]\" global cncPeriod monitor . resetCncVariables () monitor . resetCncCounter () cncPeriod = args [ 'args' ][ 'period' ] print ( \"CNC period set remotely. New value:\" , cncPeriod ) return \"CNC period set\" # to set pump period use the command set_pump_period --arg period 12 device_id def set_pump_period ( obj , args ): if not ( 'period' in args [ 'args' ]) or args [ 'args' ][ 'period' ] is None : return \"use zmd set_pump_period --arg period [int] [device_id]\" global pumpPeriod monitor . resetPumpVariables () monitor . resetPumpCounter () pumpPeriod = args [ 'args' ][ 'period' ] print ( \"Pump period set remotely. New value:\" , pumpPeriod ) return \"Pump period set\" # turn on green lamp def green_lamp_on (): print ( \"###### GREEN LAMP IS ON ######\" ) return \"green lamp ON\" # turn off green lamp def green_lamp_off (): print ( \"###### GREEN LAMP IS OFF ######\" ) return \"green lamp OFF\" # turn on red lamp def red_lamp_on (): print ( \"###### RED LAMP IS ON ######\" ) return \"red lamp ON\" #turn off red lamp def red_lamp_off (): print ( \"###### RED LAMP IS OFF ######\" ) return \"red lamp OFF\" # to set cnc temp threshold use the command zdm cnc_temp_threshold --arg threshold [int] [device_id] def cnc_temp_threshold ( obj , args ): if not ( 'threshold' in args [ 'args' ]) or args [ 'args' ][ 'threshold' ] is None : return \"use zdm cnc_temp_threshold --arg threshold [int] [device_id]\" monitor . setCncTempThreshold ( args [ 'args' ][ 'threshold' ]) print ( \"CNC temp threshold set\" ) return \"CNC temp threshold set\" # to set cnc amp threshold use the command zdm cnc_amp_threshold --arg threshold [int] [device_id] def cnc_amp_threshold ( obj , args ): if not ( 'threshold' in args [ 'args' ]) or args [ 'args' ][ 'threshold' ] is None : return \"use zdm cnc_amp_threshold --arg threshold [int] [device_id]\" monitor . setCncAmpThreshold ( args [ 'args' ][ 'threshold' ]) print ( \"CNC amp threshold set\" ) return \"CNC amp threshold set\" # to set pump temp threshold use the command zdm pump_temp_threshold --arg threshold [int] [device_id] def pump_temp_threshold ( obj , args ): if not ( 'threshold' in args [ 'args' ]) or args [ 'args' ][ 'threshold' ] is None : return \"use zdm pump_temp_threshold --arg threshold [int] [device_id]\" monitor . setPumpTempThreshold ( args [ 'args' ][ 'threshold' ]) print ( \"Pump temp threshold set\" ) return \"Pump temp threshold set\" # to set cnc amp threshold use the command zdm cnc_amp_threshold --arg threshold [int] [device_id] def pump_amp_threshold ( obj , args ): if not ( 'threshold' in args [ 'args' ]) or args [ 'args' ][ 'threshold' ] is None : return \"use zdm pump_amp_threshold --arg threshold [int] [device_id]\" monitor . setPumpAmpThreshold ( args [ 'args' ][ 'threshold' ]) print ( \"Pump amp threshold set\" ) return \"Pump amp threshold set\" # toggleAcceptFota is a job used to change the acceptFOTA variable def toggleAcceptFota (): global acceptFOTA if acceptFOTA == True : acceptFOTA = False return \"acceptFOTA: false\" else : acceptFOTA = True return \"acceptFOTA: true\" # you can call your jobs using ZDM using names enable_instant_cnc, # disable_instant_cnc, enable_instant_pump, disable_instant_pump jobs = { 'enable_instant_cnc' : enable_instant_cnc , 'disable_instant_cnc' : disable_instant_cnc , 'enable_instant_pump' : enable_instant_pump , 'disable_instant_pump' : disable_instant_pump , 'set_cnc_period' : set_cnc_period , 'set_pump_period' : set_pump_period , 'green_lamp_on' : green_lamp_on , 'green_lamp_off' : green_lamp_off , 'red_lamp_on' : red_lamp_on , 'red_lamp_off' : red_lamp_off , 'cnc_temp_threshold' : cnc_temp_threshold , 'cnc_amp_threshold' : cnc_amp_threshold , 'pump_temp_threshold' : pump_temp_threshold , 'pump_amp_threshold' : pump_amp_threshold , 'toggle_accept_fota' : toggleAcceptFota } # collectCNCData - returns a dict with three random values [temp, vibration, ampere] def collectCNCData (): temp = random ( 10 , 100 ) vibration = random ( - 3 , 3 ) ampere = random ( 0 , 15 ) data = { 'temp' : temp , 'vibration' : vibration , 'ampere' : ampere } if temp >= monitor . cncTempThres : value = { \"name\" : \"CNC temp threshold\" , \"message\" : \"cnc temp treshold reached\" } device . send_event ( value ) print ( \"CNC Temp threshold reached! Event sent\" ) if ampere >= monitor . cncAmpThres : value = { \"name\" : \"CNC amp threshold\" , \"message\" : \"cnc amp treshold reached\" } device . send_event ( value ) print ( \"CNC Temp threshold reached! Event sent\" ) return data # collectPumpData - returns a dict with three random values [temp, press, ampere] def collectPumpData (): temp = random ( 10 , 100 ) press = random ( 0 , 20 ) ampere = random ( 0 , 15 ) data = { 'temp' : temp , 'press' : press , 'ampere' : ampere } if temp >= monitor . pumpTempThres : value = { \"name\" : \"Pump temp threshold\" , \"message\" : \"pump temp treshold reached\" } device . send_event ( value ) print ( \"Pump Temp threshold reached! Event sent\" ) if ampere >= monitor . pumpAmpThres : value = { \"name\" : \"Pump amp threshold\" , \"message\" : \"Pump amp treshold reached\" } device . send_event ( value ) print ( \"Pump Temp threshold reached! Event sent\" ) return data # publishCncData publishes to the ZDM cnc payload generated by the machines monitor def publishCncData (): cncPayload = monitor . getCncPayload () device . publish ( cncPayload , monitor . cncTag ) print ( \"CNC data published:\" ) print ( cncPayload ) def publishPumpData (): pumpPayload = monitor . getPumpPayload () device . publish ( pumpPayload , monitor . pumpTag ) print ( \"Pump data published:\" ) print ( pumpPayload ) # publishInstantCnc publishes to the ZDM instantenous CNC values def publishInstantCnc ( cnc ): cncPayload = { 'instCncTemp' : cnc [ 'temp' ], 'instCncVibration' : cnc [ 'vibration' ], 'instCncAmpere' : cnc [ 'ampere' ] } device . publish ( cncPayload , monitor . cncTag ) print ( \"Instant CNC values published:\" , cncPayload ) # publishInstantPump publishes to the ZDM instantenous pump values def publishInstantPump ( pump ): pumpPayload = { 'instPumpTemp' : pump [ 'temp' ], 'instPumpPress' : pump [ 'press' ], 'instPumpAmpere' : pump [ 'ampere' ] } device . publish ( pumpPayload , monitor . pumpTag ) print ( \"Instant pump values published:\" , pumpPayload ) def fotaCallback (): global acceptFOTA if acceptFOTA == True : return True else : return False streams . serial () try : wifi_driver . auto_init () for _ in range ( 5 ): try : print ( \"connect wifi\" ) wifi . link ( wifi_ssid , wifi . WIFI_WPA2 , wifi_password ) print ( \"connect wifi done\" ) break except Exception as e : print ( \"wifi connect err\" , e ) # create a ZDM Device instance with id and the custom jobs device = zdm . Device ( device_id , jobs_dict = jobs , fota_callback = fotaCallback ) # set the device's password (jwt) device . set_password ( password ) # connect your device to ZDM enabling the device to receive incoming messages device . connect () while True : sleep ( 1000 ) global cncPeriod global pumpPeriod # read cnc values cnc = collectCNCData () # read pump values pump = collectPumpData () # increment cnc counter monitor . incCncCounter () # increment pump counter monitor . incPumpCounter () # update min max and avg values monitor . updateStatisticalData ( cnc , pump ) # get cnc and pump counter values. if it's equal to the period, device will send data cncCnt = monitor . getCncCounter () pumpCnt = monitor . getPumpCounter () # after CncPeriod iterations, device will send to the ZDM two payloads with min, max and avg values # using the corresponding tag for each machine if cncCnt == cncPeriod : publishCncData () # call reset variables and counter after the data has been published to avoid zero divisions monitor . resetCncVariables () monitor . resetCncCounter () if pumpCnt == pumpPeriod : publishPumpData () # call reset variables and counter after the data has been published to avoid zero divisions monitor . resetPumpVariables () monitor . resetPumpCounter () # if instantCnc is True (set remotely with job), the device sends instantaneout CNC values if instantCnc == True : publishInstantCnc ( cnc ) # if instantPump is True (set remotely with job), the device sends instantaneout Pump values if instantPump == True : publishInstantPump ( pump ) except Exception as e : print ( \"main\" , e )","title":"Examples"},{"location":"reference/libs/zerynth/zdm/docs/examples/#examples","text":"The following are a list of examples for lib.zerynth.zdm.","title":"Examples"},{"location":"reference/libs/zerynth/zdm/docs/examples/#simple-zdm","text":"In this example you can see how to create a ZDM device and connect it to the Zerynth Device Manager and send periodically data. It simulates a weather sensor that sends temperature and pressure values to the ZDM periodically. You can use this example to test ZDM Webhooks and Ubidots integration. To check if the ZDM is correctly receiving data sent by your device, use the data ZDM command. main.py ################################################################################ # Zerynth Device Manager # # Created by Zerynth Team 2020 CC # Authors: E.Neri, D.Neri ############################################################################### from zdm import zdm from wireless import wifi # Please uncomment the line related to the wi-fi chip architecture you are using # from microchip.winc1500 import winc1500 as wifi_driver # from espressif.esp32net import esp32wifi as wifi_driver import streams import json # paste here your device id and password generated by the ZDM # the password is a jwt generated from a device's key device_id = 'your device id' password = 'your device password' def pub_random (): # this function is called periodically to publish to ZDM random int value labeled with tags values print ( '------ publish random ------' ) tags = [ 'tag1' , 'tag2' , 'tag3' ] payload = { 'value' : 0 } for t in tags : payload [ 'value' ] = random ( 0 , 100 ) # publish payload to ZDM device . publish ( json . dumps ( payload ), t ) print ( 'published on tag:' , t , ':' , payload ) print ( 'pub_random done' ) def pub_temp_pressure (): # this function publish another payload with two random int values print ( '---- publish temp_pressure ----' ) tag = 'tag4' temp = random ( 19 , 23 ) pressure = random ( 50 , 60 ) payload = { 'temp' : temp , 'pressure' : pressure } device . publish ( json . dumps ( payload ), tag ) print ( 'published on tag: ' , tag , ':' , payload ) streams . serial () try : wifi_driver . auto_init () for _ in range ( 5 ): try : print ( \"connect wifi\" ) # Write here your wifi SSID and password wifi . link ( \"***Wifi-name***\" , wifi . WIFI_WPA2 , \"***Wifi-password***\" ) print ( \"connect wifi done\" ) break except Exception as e : print ( \"wifi connect err\" , e ) # create a ZDM Device instance with your device id device = zdm . Device ( device_id ) # set the device's password (jwt) device . set_password ( password ) # connect your device to ZDM enabling the device to receive incoming messages device . connect () while True : sleep ( 5000 ) pub_random () pub_temp_pressure () except Exception as e : print ( \"main\" , e )","title":"Simple ZDM"},{"location":"reference/libs/zerynth/zdm/docs/examples/#zdm-jobs","text":"A basic example showing ZDM Jobs and how to handle them. Write your own jobs, then add them in the jobs dictionary with a custom key. Once your device is connected to the ZDM, you can send it job commands using the key you defined and your device will execute functions remotely. main.py ################################################################################ # Zerynth Device Manager # # Created by Zerynth Team 2020 CC # Authors: E.Neri, D.Neri ############################################################################### from zdm import zdm from wireless import wifi # Please uncomment the line related to the wi-fi chip architecture you are using # from microchip.winc1500 import winc1500 as wifi_driver # from espressif.esp32net import esp32wifi as wifi_driver import streams import json # paste here your device id and password generated by the ZDM # the password is a jwt generated from a device's key device_id = 'your device id' password = 'your device password' def custom_job_1 ( obj , arg ): print ( \"custom_job_1\" ) return { 'value 1' : random ( 0 , 100 ), 'value 2' : random ( 100 , 200 ) } def custom_job_2 ( obj , arg ): print ( \"custom_job_2\" ) return 'this is an example result' # you can call job1 and job2 method using rpc my_jobs = { 'job1' : custom_job_1 , 'job2' : custom_job_2 , } streams . serial () try : wifi_driver . auto_init () for _ in range ( 5 ): try : print ( \"connect wifi\" ) # Write here your wifi SSID and password wifi . link ( \"***Wifi-name***\" , wifi . WIFI_WPA2 , \"***Wifi-password***\" ) print ( \"connect wifi done\" ) break except Exception as e : print ( \"wifi connect err\" , e ) # create a ZDM Device instance with your id and the jobs dictionary device = zdm . Device ( device_id , jobs_dict = my_jobs ) # set the device's password (jwt) device . set_password ( password ) # connect your device to ZDM enabling the device to receive incoming messages device . connect () while True : sleep ( 1000 ) except Exception as e : print ( \"main\" , e )","title":"ZDM Jobs"},{"location":"reference/libs/zerynth/zdm/docs/examples/#fota-updates","text":"Connect your device to ZDM and start updating the firmware seamlessly. In this example you can see how to create a ZDM device and connect it to the Zerynth Device Manager. In this example, a FOTA callback function is defined, which is called during the FOTA update steps. The FOTA callback allows you to accept or refuse a FOTA from your devices using the return value. If the callback returns True the device will accept the FOTA update requests, if the callback return False the device will refuse it. Try to edit the function e do your tests using ZDM FOTA commands. main.py ################################################################################ # Zerynth Device Manager # # Created by Zerynth Team 2020 CC # Authors: E.Neri, D.Neri ############################################################################### from zdm import zdm from wireless import wifi # choose a wifi chip supporting secure sockets and client certificates # from microchip.winc1500 import winc1500 as wifi_driver # from espressif.esp32net import esp32wifi as wifi_driver import streams # paste here your device id and password generated by the ZDM # the password is a jwt generated from a device's key device_id = 'your device id' password = 'your device password' def fota_callback (): # This function is called many times during a FOTA update. If it returns True the FOTA update will # be accepted by the device, refused if it returns False print ( \"Fota callback called\" ) return True streams . serial () try : wifi_driver . auto_init () for _ in range ( 5 ): try : print ( \"connect wifi\" ) # Write here your wifi SSID and password wifi . link ( \"***Wifi-name***\" , wifi . WIFI_WPA2 , \"***Wifi-password***\" ) print ( \"connect wifi done\" ) break except Exception as e : print ( \"wifi connect err\" , e ) # create a ZDM Device instance with your id and the fota callback device = zdm . Device ( device_id , fota_callback = fota_callback ) # set the device's password (jwt) device . set_password ( password ) # connect your device to ZDM enabling the device to receive incoming messages device . connect () while True : sleep ( 1000 ) except Exception as e : print ( \"main\" , e )","title":"FOTA Updates"},{"location":"reference/libs/zerynth/zdm/docs/examples/#zdm_events","text":"ZDM_events example show you how to send events from your device. You could use events to let the device notify a specific status or condition with a message, for example when a variable reach a threshold value. This example creates a ZDM Device instance that starts a loop and sends an example event every 10 seconds. main.py ################################################################################ # Zerynth Device Manager # # Created by Zerynth Team 2020 CC # Authors: E.Neri ############################################################################### from zdm import zdm from wireless import wifi import streams # Please uncomment the line related to the wi-fi chip architecture you are using # from microchip.winc1500 import winc1500 as wifi_driver # from espressif.esp32net import esp32wifi as wifi_driver # paste here your device id and password generated by the ZDM # the password is a jwt generated from a device's key device_id = 'your device id' password = 'your device password' streams . serial () try : wifi_driver . auto_init () for _ in range ( 5 ): try : print ( \"connect wifi\" ) # Write here your wifi SSID and password wifi . link ( \"***Wifi-name***\" , wifi . WIFI_WPA2 , \"***Wifi-password***\" ) print ( \"connect wifi done\" ) break except Exception as e : print ( \"wifi connect err\" , e ) # create a ZDM Device instance with your device id device = zdm . Device ( device_id ) # set the device's password (jwt) device . set_password ( password ) # connect your device to ZDM enabling the device to receive incoming messages device . connect () while True : sleep ( 10000 ) value = { 'name' : 'optional event name' , 'message' : 'this is an event' } device . send_event ( value ) except Exception as e : print ( \"main\" , e )","title":"ZDM_events"},{"location":"reference/libs/zerynth/zdm/docs/examples/#zdm_advanced","text":"This is an advanced example aimed at showing all the ZDM functionalities integrated in an embedded firmware. The example simulates the use of the ZDM in an industrial IOT scenario where industrial machines are monitored via sensors interfaced with zerynth powered boards In this example we simulate the acquisition of 3 variables from 2 industrial machines (a CNC and an industrial pump). The setup also includes two relays used to control a Red and a Green light indicators placed near the machine. The lights are used to notify the operator on remote alarms sent directly by the ZDM as jobs. main.py ################################################################################ # Zerynth Device Manager # # Created by Zerynth Team 2020 CC # Author: E.Neri, D.Mazzei ############################################################################### from zdm import zdm from wireless import wifi import streams import json import monitor # *** Please uncomment the line related to the wi-fi chip architecture you are using *** # from microchip.winc1500 import winc1500 as wifi_driver # from espressif.esp32net import esp32wifi as wifi_driver # *** Paste here your device id and password generated by the ZDM *** device_id = 'device-id' password = 'device-password' # *** Write here your wifi ssid and password wifi_ssid = '' wifi_password = '' monitor = monitor . machinesMonitor () # cnc and pump period indicates the interval in seconds between two data publish for each machine cncPeriod = 10 pumpPeriod = 10 # this bool variables [default=false] are set remotely using jobs below # when True, device sends also instantaneous values for the associated machine instantCnc = False instantPump = False # acceptFOTA [default True] indicates if the device Fota si enabled or not acceptFOTA = True # jobs def enable_instant_cnc (): global instantCnc instantCnc = True return \"instant cnc enabled\" def disable_instant_cnc (): global instantCnc instantCnc = False return \"instant cnc disabled\" def enable_instant_pump (): global instantPump instantPump = True return \"instant pump enabled\" def disable_instant_pump (): global instantPump instantPump = False return \"instant pump disabled\" # to set cnc period use the command set_cnc_period --arg period 12 device_id def set_cnc_period ( obj , args ): if not ( 'period' in args [ 'args' ]) or args [ 'args' ][ 'period' ] is None : return \"use zmd set_cnc_period --arg period [int] [device_id]\" global cncPeriod monitor . resetCncVariables () monitor . resetCncCounter () cncPeriod = args [ 'args' ][ 'period' ] print ( \"CNC period set remotely. New value:\" , cncPeriod ) return \"CNC period set\" # to set pump period use the command set_pump_period --arg period 12 device_id def set_pump_period ( obj , args ): if not ( 'period' in args [ 'args' ]) or args [ 'args' ][ 'period' ] is None : return \"use zmd set_pump_period --arg period [int] [device_id]\" global pumpPeriod monitor . resetPumpVariables () monitor . resetPumpCounter () pumpPeriod = args [ 'args' ][ 'period' ] print ( \"Pump period set remotely. New value:\" , pumpPeriod ) return \"Pump period set\" # turn on green lamp def green_lamp_on (): print ( \"###### GREEN LAMP IS ON ######\" ) return \"green lamp ON\" # turn off green lamp def green_lamp_off (): print ( \"###### GREEN LAMP IS OFF ######\" ) return \"green lamp OFF\" # turn on red lamp def red_lamp_on (): print ( \"###### RED LAMP IS ON ######\" ) return \"red lamp ON\" #turn off red lamp def red_lamp_off (): print ( \"###### RED LAMP IS OFF ######\" ) return \"red lamp OFF\" # to set cnc temp threshold use the command zdm cnc_temp_threshold --arg threshold [int] [device_id] def cnc_temp_threshold ( obj , args ): if not ( 'threshold' in args [ 'args' ]) or args [ 'args' ][ 'threshold' ] is None : return \"use zdm cnc_temp_threshold --arg threshold [int] [device_id]\" monitor . setCncTempThreshold ( args [ 'args' ][ 'threshold' ]) print ( \"CNC temp threshold set\" ) return \"CNC temp threshold set\" # to set cnc amp threshold use the command zdm cnc_amp_threshold --arg threshold [int] [device_id] def cnc_amp_threshold ( obj , args ): if not ( 'threshold' in args [ 'args' ]) or args [ 'args' ][ 'threshold' ] is None : return \"use zdm cnc_amp_threshold --arg threshold [int] [device_id]\" monitor . setCncAmpThreshold ( args [ 'args' ][ 'threshold' ]) print ( \"CNC amp threshold set\" ) return \"CNC amp threshold set\" # to set pump temp threshold use the command zdm pump_temp_threshold --arg threshold [int] [device_id] def pump_temp_threshold ( obj , args ): if not ( 'threshold' in args [ 'args' ]) or args [ 'args' ][ 'threshold' ] is None : return \"use zdm pump_temp_threshold --arg threshold [int] [device_id]\" monitor . setPumpTempThreshold ( args [ 'args' ][ 'threshold' ]) print ( \"Pump temp threshold set\" ) return \"Pump temp threshold set\" # to set cnc amp threshold use the command zdm cnc_amp_threshold --arg threshold [int] [device_id] def pump_amp_threshold ( obj , args ): if not ( 'threshold' in args [ 'args' ]) or args [ 'args' ][ 'threshold' ] is None : return \"use zdm pump_amp_threshold --arg threshold [int] [device_id]\" monitor . setPumpAmpThreshold ( args [ 'args' ][ 'threshold' ]) print ( \"Pump amp threshold set\" ) return \"Pump amp threshold set\" # toggleAcceptFota is a job used to change the acceptFOTA variable def toggleAcceptFota (): global acceptFOTA if acceptFOTA == True : acceptFOTA = False return \"acceptFOTA: false\" else : acceptFOTA = True return \"acceptFOTA: true\" # you can call your jobs using ZDM using names enable_instant_cnc, # disable_instant_cnc, enable_instant_pump, disable_instant_pump jobs = { 'enable_instant_cnc' : enable_instant_cnc , 'disable_instant_cnc' : disable_instant_cnc , 'enable_instant_pump' : enable_instant_pump , 'disable_instant_pump' : disable_instant_pump , 'set_cnc_period' : set_cnc_period , 'set_pump_period' : set_pump_period , 'green_lamp_on' : green_lamp_on , 'green_lamp_off' : green_lamp_off , 'red_lamp_on' : red_lamp_on , 'red_lamp_off' : red_lamp_off , 'cnc_temp_threshold' : cnc_temp_threshold , 'cnc_amp_threshold' : cnc_amp_threshold , 'pump_temp_threshold' : pump_temp_threshold , 'pump_amp_threshold' : pump_amp_threshold , 'toggle_accept_fota' : toggleAcceptFota } # collectCNCData - returns a dict with three random values [temp, vibration, ampere] def collectCNCData (): temp = random ( 10 , 100 ) vibration = random ( - 3 , 3 ) ampere = random ( 0 , 15 ) data = { 'temp' : temp , 'vibration' : vibration , 'ampere' : ampere } if temp >= monitor . cncTempThres : value = { \"name\" : \"CNC temp threshold\" , \"message\" : \"cnc temp treshold reached\" } device . send_event ( value ) print ( \"CNC Temp threshold reached! Event sent\" ) if ampere >= monitor . cncAmpThres : value = { \"name\" : \"CNC amp threshold\" , \"message\" : \"cnc amp treshold reached\" } device . send_event ( value ) print ( \"CNC Temp threshold reached! Event sent\" ) return data # collectPumpData - returns a dict with three random values [temp, press, ampere] def collectPumpData (): temp = random ( 10 , 100 ) press = random ( 0 , 20 ) ampere = random ( 0 , 15 ) data = { 'temp' : temp , 'press' : press , 'ampere' : ampere } if temp >= monitor . pumpTempThres : value = { \"name\" : \"Pump temp threshold\" , \"message\" : \"pump temp treshold reached\" } device . send_event ( value ) print ( \"Pump Temp threshold reached! Event sent\" ) if ampere >= monitor . pumpAmpThres : value = { \"name\" : \"Pump amp threshold\" , \"message\" : \"Pump amp treshold reached\" } device . send_event ( value ) print ( \"Pump Temp threshold reached! Event sent\" ) return data # publishCncData publishes to the ZDM cnc payload generated by the machines monitor def publishCncData (): cncPayload = monitor . getCncPayload () device . publish ( cncPayload , monitor . cncTag ) print ( \"CNC data published:\" ) print ( cncPayload ) def publishPumpData (): pumpPayload = monitor . getPumpPayload () device . publish ( pumpPayload , monitor . pumpTag ) print ( \"Pump data published:\" ) print ( pumpPayload ) # publishInstantCnc publishes to the ZDM instantenous CNC values def publishInstantCnc ( cnc ): cncPayload = { 'instCncTemp' : cnc [ 'temp' ], 'instCncVibration' : cnc [ 'vibration' ], 'instCncAmpere' : cnc [ 'ampere' ] } device . publish ( cncPayload , monitor . cncTag ) print ( \"Instant CNC values published:\" , cncPayload ) # publishInstantPump publishes to the ZDM instantenous pump values def publishInstantPump ( pump ): pumpPayload = { 'instPumpTemp' : pump [ 'temp' ], 'instPumpPress' : pump [ 'press' ], 'instPumpAmpere' : pump [ 'ampere' ] } device . publish ( pumpPayload , monitor . pumpTag ) print ( \"Instant pump values published:\" , pumpPayload ) def fotaCallback (): global acceptFOTA if acceptFOTA == True : return True else : return False streams . serial () try : wifi_driver . auto_init () for _ in range ( 5 ): try : print ( \"connect wifi\" ) wifi . link ( wifi_ssid , wifi . WIFI_WPA2 , wifi_password ) print ( \"connect wifi done\" ) break except Exception as e : print ( \"wifi connect err\" , e ) # create a ZDM Device instance with id and the custom jobs device = zdm . Device ( device_id , jobs_dict = jobs , fota_callback = fotaCallback ) # set the device's password (jwt) device . set_password ( password ) # connect your device to ZDM enabling the device to receive incoming messages device . connect () while True : sleep ( 1000 ) global cncPeriod global pumpPeriod # read cnc values cnc = collectCNCData () # read pump values pump = collectPumpData () # increment cnc counter monitor . incCncCounter () # increment pump counter monitor . incPumpCounter () # update min max and avg values monitor . updateStatisticalData ( cnc , pump ) # get cnc and pump counter values. if it's equal to the period, device will send data cncCnt = monitor . getCncCounter () pumpCnt = monitor . getPumpCounter () # after CncPeriod iterations, device will send to the ZDM two payloads with min, max and avg values # using the corresponding tag for each machine if cncCnt == cncPeriod : publishCncData () # call reset variables and counter after the data has been published to avoid zero divisions monitor . resetCncVariables () monitor . resetCncCounter () if pumpCnt == pumpPeriod : publishPumpData () # call reset variables and counter after the data has been published to avoid zero divisions monitor . resetPumpVariables () monitor . resetPumpCounter () # if instantCnc is True (set remotely with job), the device sends instantaneout CNC values if instantCnc == True : publishInstantCnc ( cnc ) # if instantPump is True (set remotely with job), the device sends instantaneout Pump values if instantPump == True : publishInstantPump ( pump ) except Exception as e : print ( \"main\" , e )","title":"ZDM_Advanced"},{"location":"reference/libs/zerynth/zdm/docs/zdm/","text":"Getting started \u00b6 The Zerynth Device Manager (ZDM) Library contains many different commands that allows you to connect your devices to the ZDM. You can use ZDM lib to send data from your devices and to let them receive your remote commands (jobs). To learn how to be able to use it and call ZDM methods, see the ZDM getting started doc . The Device class \u00b6 class Device \u00b6 class Device ( device_id , jobs_dict = None , endpoint , port , fota_callback = None ) Creates a Device instance with uid device_id . All other parameters are optional and have default values. endpoint is the endpoint of the zdm. port is the port of the zdm. jobs_dict is the dictionary that defines the device\u2019s available jobs fota_callback , is a function accepting one ore more arguments that will be called at different steps of the FOTA process. the fota_callback can return a boolean value. If the return value is True, the FOTA process continues, otherwise it is stopped. Device.set_password \u00b6 set_password ( password ) Set the device password to password . You can generate a password using the ZDM, creating a key for your device. Device.connect \u00b6 connect () Connect your device to the ZDM. You must set device\u2019s password first. It also enable your device to receive incoming messages. Device.publish \u00b6 publish ( data , tag = None ) Publish a message to the ZDM. data is the message payload, represented by a dictionary tag , is a label for the device\u2019s data into your workspace. More than one device can publish message to the same tag Device.send_event \u00b6 send_event ( value ) Send an event from device to the ZDM. Events should be used to notify the occurrence of certain conditions, for example reaching a threshold. value is the message payload, represented by a dictionary value is a custom dictionary that can contains custom field but, if you want to give a name to your events (default name is \u2018event\u2019) you should add \u2018name\u2019 field. For example: value={\u2018name\u2019: \u2018my_event\u2019, \u2018message\u2019: \u2018custom event message\u2019}","title":"Getting started"},{"location":"reference/libs/zerynth/zdm/docs/zdm/#getting-started","text":"The Zerynth Device Manager (ZDM) Library contains many different commands that allows you to connect your devices to the ZDM. You can use ZDM lib to send data from your devices and to let them receive your remote commands (jobs). To learn how to be able to use it and call ZDM methods, see the ZDM getting started doc .","title":"Getting started"},{"location":"reference/libs/zerynth/zdm/docs/zdm/#the-device-class","text":"","title":"The Device class"},{"location":"reference/libs/zerynth/zdm/docs/zdm/#class-device","text":"class Device ( device_id , jobs_dict = None , endpoint , port , fota_callback = None ) Creates a Device instance with uid device_id . All other parameters are optional and have default values. endpoint is the endpoint of the zdm. port is the port of the zdm. jobs_dict is the dictionary that defines the device\u2019s available jobs fota_callback , is a function accepting one ore more arguments that will be called at different steps of the FOTA process. the fota_callback can return a boolean value. If the return value is True, the FOTA process continues, otherwise it is stopped.","title":"class Device"},{"location":"reference/libs/zerynth/zdm/docs/zdm/#deviceset_password","text":"set_password ( password ) Set the device password to password . You can generate a password using the ZDM, creating a key for your device.","title":"Device.set_password"},{"location":"reference/libs/zerynth/zdm/docs/zdm/#deviceconnect","text":"connect () Connect your device to the ZDM. You must set device\u2019s password first. It also enable your device to receive incoming messages.","title":"Device.connect"},{"location":"reference/libs/zerynth/zdm/docs/zdm/#devicepublish","text":"publish ( data , tag = None ) Publish a message to the ZDM. data is the message payload, represented by a dictionary tag , is a label for the device\u2019s data into your workspace. More than one device can publish message to the same tag","title":"Device.publish"},{"location":"reference/libs/zerynth/zdm/docs/zdm/#devicesend_event","text":"send_event ( value ) Send an event from device to the ZDM. Events should be used to notify the occurrence of certain conditions, for example reaching a threshold. value is the message payload, represented by a dictionary value is a custom dictionary that can contains custom field but, if you want to give a name to your events (default name is \u2018event\u2019) you should add \u2018name\u2019 field. For example: value={\u2018name\u2019: \u2018my_event\u2019, \u2018message\u2019: \u2018custom event message\u2019}","title":"Device.send_event"},{"location":"reference/libs/zerynth/zerynthapp/docs/","text":"Zerynth App \u00b6 The Zerynth App is a ready to use mobile app that acts as an interface for all the Zerynth powered objects and permits to turn any mobile into the controller and display for smart objects and IoT systems. Thanks to the Zerynth App, a bidirectional communication channel between the Zerynth script and the user mobile is enabled and with HTML 5 templates edited directly in Zerynth Studio and embedded in the bytecode, there is no need to develop the application in Android or iOS code. Here below, the Zerynth Library for handling the Zerynth App and some examples to better understand how to use it. Contents: ZerynthApp Library ZerynthApp Step by Step HTML templates Zerynth App Instances The ZerynthApp class Examples Zerynth App Basic Zerynth App Oscilloscope","title":"Zerynth App"},{"location":"reference/libs/zerynth/zerynthapp/docs/#zerynth-app","text":"The Zerynth App is a ready to use mobile app that acts as an interface for all the Zerynth powered objects and permits to turn any mobile into the controller and display for smart objects and IoT systems. Thanks to the Zerynth App, a bidirectional communication channel between the Zerynth script and the user mobile is enabled and with HTML 5 templates edited directly in Zerynth Studio and embedded in the bytecode, there is no need to develop the application in Android or iOS code. Here below, the Zerynth Library for handling the Zerynth App and some examples to better understand how to use it. Contents: ZerynthApp Library ZerynthApp Step by Step HTML templates Zerynth App Instances The ZerynthApp class Examples Zerynth App Basic Zerynth App Oscilloscope","title":"Zerynth App"},{"location":"reference/libs/zerynth/zerynthapp/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.zerynth.zerynthapp. ZerynthApp Basic \u00b6 This example is a very minimal ZerynthApp demo. Bidirectional communication between the script and the mobile app is demostrated: eveytime a button on the mobile app is pressed, a message is received on the board. Everytime the board button is pressed, a message is sent to the mobile app. main.py from wireless import wifi # this example is based on Particle Photon # change the following line to use a different wifi driver from broadcom.bcm43362 import bcm43362 as wifi_driver import streams # Import the Zerynth APP library from zerynthapp import zerynthapp streams . serial () sleep ( 1000 ) print ( \"STARTING...\" ) # define a RPC function: generate a random number def do_random ( a , b ): return random ( a , b ) # send events on button pressed def on_btn (): zapp . event ({ \"my_button\" : \"pressed\" }) onPinFall ( BTN0 , on_btn , debounce = 1000 ) # Device UID and TOKEN can be created in the ADM panel zapp = zerynthapp . ZerynthApp ( \"DEVICE UID HERE\" , \"DEVICE TOKEN HERE\" , log = True ) # link \"random\" to do_random zapp . on ( \"random\" , do_random ) try : # connect to the wifi network (Set your SSID and password below) wifi_driver . auto_init () for i in range ( 0 , 5 ): try : wifi . link ( \"NETWORK SSID\" , wifi . WIFI_WPA2 , \"NETWORK PASSWORD\" ) break except Exception as e : print ( \"Can't link\" , e ) else : print ( \"Impossible to link!\" ) while True : sleep ( 1000 ) # Start the Zerynth app instance! # Remember to create a template with the files under the \"template\" folder you just cloned # upload it to the ADM and associate it with the connected device zapp . run () # Do whatever you need here while True : print ( \".\" ) sleep ( 5000 ) except Exception as e : print ( e ) Zerynth App Oscilloscope \u00b6 This example demonstrates the advanced gui capabilities of the ZerynthApp. A graphical oscilloscope is visualized by the mobile app with data coming from the board. main.py ################################################################################ # Zerynth App Oscilloscope # # Created by ZERYNTH Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ # zapp # Created at 2017-03-06 11:40:48.064968 from wireless import wifi # this example is based on Particle Photon # change the following line to use a different wifi driver from broadcom.bcm43362 import bcm43362 as wifi_driver import streams import adc # Import the Zerynth APP library from zerynthapp import zerynthapp streams . serial () sleep ( 1000 ) print ( \"STARTING...\" ) try : # Device UID and TOKEN can be created in the ADM panel zapp = zerynthapp . ZerynthApp ( \"DEVICE UID\" , \"DEVICE TOKEN\" , log = True ) # connect to the wifi network (Set your SSID and password below) wifi_driver . auto_init () for i in range ( 0 , 5 ): try : wifi . link ( \"SSID\" , wifi . WIFI_WPA2 , \"PASSWORD\" ) break except Exception as e : print ( \"Can't link\" , e ) else : print ( \"Impossible to link!\" ) while True : sleep ( 1000 ) # Start the Zerynth app instance! # Remember to create a template with the files under the \"template\" folder you just cloned # upload it to the ADM and associate it with the connected device zapp . run () # Read ADC and send values to the ADM while True : sleep ( 1000 ) x = ( adc . read ( A4 ) * 100 ) // 4096 zapp . event ({ \"data\" : x }) if x > 95 : # send mobile notification # (there is a limit of one notification per minute per device on the ADM sandbox) zapp . notify ( \"ALARM!\" , \"The value is greater than 95!\" ) except Exception as e : print ( e )","title":"Examples"},{"location":"reference/libs/zerynth/zerynthapp/docs/examples/#examples","text":"The following are a list of examples for lib.zerynth.zerynthapp.","title":"Examples"},{"location":"reference/libs/zerynth/zerynthapp/docs/examples/#zerynthapp-basic","text":"This example is a very minimal ZerynthApp demo. Bidirectional communication between the script and the mobile app is demostrated: eveytime a button on the mobile app is pressed, a message is received on the board. Everytime the board button is pressed, a message is sent to the mobile app. main.py from wireless import wifi # this example is based on Particle Photon # change the following line to use a different wifi driver from broadcom.bcm43362 import bcm43362 as wifi_driver import streams # Import the Zerynth APP library from zerynthapp import zerynthapp streams . serial () sleep ( 1000 ) print ( \"STARTING...\" ) # define a RPC function: generate a random number def do_random ( a , b ): return random ( a , b ) # send events on button pressed def on_btn (): zapp . event ({ \"my_button\" : \"pressed\" }) onPinFall ( BTN0 , on_btn , debounce = 1000 ) # Device UID and TOKEN can be created in the ADM panel zapp = zerynthapp . ZerynthApp ( \"DEVICE UID HERE\" , \"DEVICE TOKEN HERE\" , log = True ) # link \"random\" to do_random zapp . on ( \"random\" , do_random ) try : # connect to the wifi network (Set your SSID and password below) wifi_driver . auto_init () for i in range ( 0 , 5 ): try : wifi . link ( \"NETWORK SSID\" , wifi . WIFI_WPA2 , \"NETWORK PASSWORD\" ) break except Exception as e : print ( \"Can't link\" , e ) else : print ( \"Impossible to link!\" ) while True : sleep ( 1000 ) # Start the Zerynth app instance! # Remember to create a template with the files under the \"template\" folder you just cloned # upload it to the ADM and associate it with the connected device zapp . run () # Do whatever you need here while True : print ( \".\" ) sleep ( 5000 ) except Exception as e : print ( e )","title":"ZerynthApp Basic"},{"location":"reference/libs/zerynth/zerynthapp/docs/examples/#zerynth-app-oscilloscope","text":"This example demonstrates the advanced gui capabilities of the ZerynthApp. A graphical oscilloscope is visualized by the mobile app with data coming from the board. main.py ################################################################################ # Zerynth App Oscilloscope # # Created by ZERYNTH Team 2015 CC # Authors: G. Baldi, D. Mazzei ################################################################################ # zapp # Created at 2017-03-06 11:40:48.064968 from wireless import wifi # this example is based on Particle Photon # change the following line to use a different wifi driver from broadcom.bcm43362 import bcm43362 as wifi_driver import streams import adc # Import the Zerynth APP library from zerynthapp import zerynthapp streams . serial () sleep ( 1000 ) print ( \"STARTING...\" ) try : # Device UID and TOKEN can be created in the ADM panel zapp = zerynthapp . ZerynthApp ( \"DEVICE UID\" , \"DEVICE TOKEN\" , log = True ) # connect to the wifi network (Set your SSID and password below) wifi_driver . auto_init () for i in range ( 0 , 5 ): try : wifi . link ( \"SSID\" , wifi . WIFI_WPA2 , \"PASSWORD\" ) break except Exception as e : print ( \"Can't link\" , e ) else : print ( \"Impossible to link!\" ) while True : sleep ( 1000 ) # Start the Zerynth app instance! # Remember to create a template with the files under the \"template\" folder you just cloned # upload it to the ADM and associate it with the connected device zapp . run () # Read ADC and send values to the ADM while True : sleep ( 1000 ) x = ( adc . read ( A4 ) * 100 ) // 4096 zapp . event ({ \"data\" : x }) if x > 95 : # send mobile notification # (there is a limit of one notification per minute per device on the ADM sandbox) zapp . notify ( \"ALARM!\" , \"The value is greater than 95!\" ) except Exception as e : print ( e )","title":"Zerynth App Oscilloscope"},{"location":"reference/libs/zerynth/zerynthapp/docs/zerynthapp/","text":"ZerynthApp Library \u00b6 This module provides access to the Zerynth App functionalities. The Zerynth App is an innovative mobile app designed to make interaction with Zerynth programs easy. A Zerynth App can be tought as a bidirectional communication channel between a Zerynth script running on a device and some HTML+Javascript template running on the mobile app. A program using the ZerynthApp module must provide some components: an UI template, responsible of the Javascript part a set of remotely callable functions representing the channel from Javascript to Python a set of events representing the channel from Python to Javascript When the ZerynthApp class, defined in this module, is instantiated and run, it waits for messages coming from the mobile app through the Zerynth Advanced Device Manager . ZerynthApp Step by Step \u00b6 Using the \u201czerynthapp\u201d module is easy. First, a device template must be defined by creating the needed HTL and javascript files. The template must be uploaded to the ADM directly from Zerynth Studio or through the Zerynth Toolchain. A \u201czerynthapp\u201d instance must be created The \u201czerynthapp\u201d instance must be configured with credentials The \u201czerynthapp\u201d callable functions must be defined The \u201czerynthapp\u201d instance must be run HTML templates \u00b6 HTML templates reside on the ADM servers and are transferred from it to the mobile app where they are rendered. Javascript is needed to add some logic to the template. The task is made easier by using the Zerynth ADM Javascript library . Templates are better explained with examples: < ! DOCTYPE html > < html lang = \"en\" > < head > < meta charset = \"utf-8\" > < meta http - equiv = \"X-UA-Compatible\" content = \"IE=edge\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1\" > < title > Zerynth </ title > < ! -- LOAD JQUERY AND BOOTSTRAP --> < script src = \"https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js\" ></ script > < link rel = \"stylesheet\" href = \"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" integrity = \"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" crossorigin = \"anonymous\" > < link rel = \"stylesheet\" href = \"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css\" integrity = \"sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp\" crossorigin = \"anonymous\" > < script src = \"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\" integrity = \"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa\" crossorigin = \"anonymous\" ></ script > < ! -- LOAD THE ZERYNTH ADM JS LIBRARY --> < script src = \"https://api.zerynth.com/zadm/latest/z.js\" ></ script > </ head > < body > < div style = \"text-align:center\" > < p id = \"status\" style = \"background:#ddd;font-weight:bold\" ></ p > < h1 > Hello , Zerynth ! </ h1 > < div style = \"margin-left: 20px;margin-right: 20px\" > < button class = \"btn btn-primary btn-xs\" onclick = \"Z.call('random',[0,20],random_callback)\" > Random ! </ button > </ div > < div id = \"number\" ></ div > </ div > < script > // callback for remote random method function random_callback ( msg ){ $ ( \"#number\" ) . html ( msg . res ) } $ ( document ) . ready ( function () { // initialize the Z object Z . init ({ on_connected : function (){ $ ( \"#status\" ) . html ( \"CONNECTED\" )}, on_error : function (){ $ ( \"#status\" ) . html ( \"ERROR\" )}, on_disconnected : function (){ $ ( \"#status\" ) . html ( \"DISCONNECTED\" ); return true }, on_online : function ( evt ){ $ ( \"#status\" ) . html ( \"ONLINE\" );}, on_offline : function ( evt ){ $ ( \"#status\" ) . html ( \"OFFLINE\" );}, on_event : function ( evt ){ // display received event $ ( \"#status\" ) . html ( \"EVENT!\" + JSON . stringify ( evt )); } }) }); </ script > </ body > </ html > In the body section, the html scaffolding is layed out and logic is inserted to link the template events with the functions running on the device. For example, in the onclick part of the button a RPC to the method \u201crandom\u201d is generated by using the construct Z.call(method,parameters,callback) . All the parameters are encoded, sent to the device, and used as arguments of the corresponding Python function. The Z.call function is the channel from Javascript to Python. Everytime the device will send an event, such event will be passed to the on_event callback of the Z object. Parameters can be passed to the event function and transmitted to the mobile app. The event method of the ZerynthApp instance is the channel from Python to Javascript. Zerynth App Instances \u00b6 A template must be coupled with a Zerynth script running on a device. Here it is an example: from wireless import wifi # this example is based on Particle Photon # change the following line to use a different wifi driver from broadcom.bcm43362 import bcm43362 as wifi_driver import streams # Import the Zerynth APP library from zerynthapp import zerynthapp streams . serial () sleep ( 1000 ) print ( \"STARTING...\" ) # define a RPC function: generate a random number def do_random ( a , b ): return random ( a , b ) # send events on button pressed def on_btn (): zapp . event ({ \"my_button\" : \"pressed\" }) onPinFall ( BTN0 , on_btn , debounce = 1000 ) zapp = zerynthapp . ZerynthApp ( \"DEVICE UID HERE\" , \"DEVICE TOKEN HERE\" , log = True ) # link \"random\" to do_random zapp . on ( \"random\" , do_random ) try : # connect to the wifi network (Set your SSID and password below) wifi_driver . auto_init () for i in range ( 0 , 5 ): try : wifi . link ( \"NETWORK SSID\" , wifi . WIFI_WPA2 , \"NETWORK PASSWORD\" ) break except Exception as e : print ( \"Can't link\" , e ) else : print ( \"Impossible to link!\" ) while True : sleep ( 1000 ) # Start the Zerynth app instance! zapp . run () # Do whatever you need here while True : print ( \".\" ) sleep ( 5000 ) except Exception as e : print ( e ) This simple script connects to the local Wifi network, configures and runs a ZerynthApp instance. The method on is called to configure the Javascript-to-Python channel: everytime a call to \u201crandom\u201d is remotely requested from Javascript, the function do_random is called in the Zerynth script. When the device button is pressed, the event method is called, and the event is transferred to the mobile app, where Javascript, configured in the template, updates a label. The ZerynthApp class \u00b6 class ZerynthApp \u00b6 class ZerynthApp ( uid , token , ip = None , address = \"things.zerynth.com\" , log = False ) Creates a ZerynthApp instance or the device with uid uid and token token . If log is True, some debug messages are printed. If ip is given, it tries to connect to the ADM instance hosted at ip (default ip is 178.22.65.123). If address is given, it tries to connect to the ADM instance hosted ad address url (default address is \u201cthings.zerynth.com\u201d). ZerynthApp.on \u00b6 on ( method , fn ) Associates the method name method to the callable fn . Everytime the ZerynthApp instance receives a request for method from the mobile app, the callable fn is executed (possibly with arguments). ZerynthApp.event \u00b6 event ( payload ) Sends an event with payload payload to the mobile app. ZerynthApp.notify \u00b6 notify ( title , text ) Sends a push notification to connected apps with title title and text text . ZerynthApp.run \u00b6 run () Starts the ZerynthApp instance on a separate thread and returns immediately.","title":"ZerynthApp Library"},{"location":"reference/libs/zerynth/zerynthapp/docs/zerynthapp/#zerynthapp-library","text":"This module provides access to the Zerynth App functionalities. The Zerynth App is an innovative mobile app designed to make interaction with Zerynth programs easy. A Zerynth App can be tought as a bidirectional communication channel between a Zerynth script running on a device and some HTML+Javascript template running on the mobile app. A program using the ZerynthApp module must provide some components: an UI template, responsible of the Javascript part a set of remotely callable functions representing the channel from Javascript to Python a set of events representing the channel from Python to Javascript When the ZerynthApp class, defined in this module, is instantiated and run, it waits for messages coming from the mobile app through the Zerynth Advanced Device Manager .","title":"ZerynthApp Library"},{"location":"reference/libs/zerynth/zerynthapp/docs/zerynthapp/#zerynthapp-step-by-step","text":"Using the \u201czerynthapp\u201d module is easy. First, a device template must be defined by creating the needed HTL and javascript files. The template must be uploaded to the ADM directly from Zerynth Studio or through the Zerynth Toolchain. A \u201czerynthapp\u201d instance must be created The \u201czerynthapp\u201d instance must be configured with credentials The \u201czerynthapp\u201d callable functions must be defined The \u201czerynthapp\u201d instance must be run","title":"ZerynthApp Step by Step"},{"location":"reference/libs/zerynth/zerynthapp/docs/zerynthapp/#html-templates","text":"HTML templates reside on the ADM servers and are transferred from it to the mobile app where they are rendered. Javascript is needed to add some logic to the template. The task is made easier by using the Zerynth ADM Javascript library . Templates are better explained with examples: < ! DOCTYPE html > < html lang = \"en\" > < head > < meta charset = \"utf-8\" > < meta http - equiv = \"X-UA-Compatible\" content = \"IE=edge\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1\" > < title > Zerynth </ title > < ! -- LOAD JQUERY AND BOOTSTRAP --> < script src = \"https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js\" ></ script > < link rel = \"stylesheet\" href = \"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" integrity = \"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" crossorigin = \"anonymous\" > < link rel = \"stylesheet\" href = \"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css\" integrity = \"sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp\" crossorigin = \"anonymous\" > < script src = \"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\" integrity = \"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa\" crossorigin = \"anonymous\" ></ script > < ! -- LOAD THE ZERYNTH ADM JS LIBRARY --> < script src = \"https://api.zerynth.com/zadm/latest/z.js\" ></ script > </ head > < body > < div style = \"text-align:center\" > < p id = \"status\" style = \"background:#ddd;font-weight:bold\" ></ p > < h1 > Hello , Zerynth ! </ h1 > < div style = \"margin-left: 20px;margin-right: 20px\" > < button class = \"btn btn-primary btn-xs\" onclick = \"Z.call('random',[0,20],random_callback)\" > Random ! </ button > </ div > < div id = \"number\" ></ div > </ div > < script > // callback for remote random method function random_callback ( msg ){ $ ( \"#number\" ) . html ( msg . res ) } $ ( document ) . ready ( function () { // initialize the Z object Z . init ({ on_connected : function (){ $ ( \"#status\" ) . html ( \"CONNECTED\" )}, on_error : function (){ $ ( \"#status\" ) . html ( \"ERROR\" )}, on_disconnected : function (){ $ ( \"#status\" ) . html ( \"DISCONNECTED\" ); return true }, on_online : function ( evt ){ $ ( \"#status\" ) . html ( \"ONLINE\" );}, on_offline : function ( evt ){ $ ( \"#status\" ) . html ( \"OFFLINE\" );}, on_event : function ( evt ){ // display received event $ ( \"#status\" ) . html ( \"EVENT!\" + JSON . stringify ( evt )); } }) }); </ script > </ body > </ html > In the body section, the html scaffolding is layed out and logic is inserted to link the template events with the functions running on the device. For example, in the onclick part of the button a RPC to the method \u201crandom\u201d is generated by using the construct Z.call(method,parameters,callback) . All the parameters are encoded, sent to the device, and used as arguments of the corresponding Python function. The Z.call function is the channel from Javascript to Python. Everytime the device will send an event, such event will be passed to the on_event callback of the Z object. Parameters can be passed to the event function and transmitted to the mobile app. The event method of the ZerynthApp instance is the channel from Python to Javascript.","title":"HTML templates"},{"location":"reference/libs/zerynth/zerynthapp/docs/zerynthapp/#zerynth-app-instances","text":"A template must be coupled with a Zerynth script running on a device. Here it is an example: from wireless import wifi # this example is based on Particle Photon # change the following line to use a different wifi driver from broadcom.bcm43362 import bcm43362 as wifi_driver import streams # Import the Zerynth APP library from zerynthapp import zerynthapp streams . serial () sleep ( 1000 ) print ( \"STARTING...\" ) # define a RPC function: generate a random number def do_random ( a , b ): return random ( a , b ) # send events on button pressed def on_btn (): zapp . event ({ \"my_button\" : \"pressed\" }) onPinFall ( BTN0 , on_btn , debounce = 1000 ) zapp = zerynthapp . ZerynthApp ( \"DEVICE UID HERE\" , \"DEVICE TOKEN HERE\" , log = True ) # link \"random\" to do_random zapp . on ( \"random\" , do_random ) try : # connect to the wifi network (Set your SSID and password below) wifi_driver . auto_init () for i in range ( 0 , 5 ): try : wifi . link ( \"NETWORK SSID\" , wifi . WIFI_WPA2 , \"NETWORK PASSWORD\" ) break except Exception as e : print ( \"Can't link\" , e ) else : print ( \"Impossible to link!\" ) while True : sleep ( 1000 ) # Start the Zerynth app instance! zapp . run () # Do whatever you need here while True : print ( \".\" ) sleep ( 5000 ) except Exception as e : print ( e ) This simple script connects to the local Wifi network, configures and runs a ZerynthApp instance. The method on is called to configure the Javascript-to-Python channel: everytime a call to \u201crandom\u201d is remotely requested from Javascript, the function do_random is called in the Zerynth script. When the device button is pressed, the event method is called, and the event is transferred to the mobile app, where Javascript, configured in the template, updates a label.","title":"Zerynth App Instances"},{"location":"reference/libs/zerynth/zerynthapp/docs/zerynthapp/#the-zerynthapp-class","text":"","title":"The ZerynthApp class"},{"location":"reference/libs/zerynth/zerynthapp/docs/zerynthapp/#class-zerynthapp","text":"class ZerynthApp ( uid , token , ip = None , address = \"things.zerynth.com\" , log = False ) Creates a ZerynthApp instance or the device with uid uid and token token . If log is True, some debug messages are printed. If ip is given, it tries to connect to the ADM instance hosted at ip (default ip is 178.22.65.123). If address is given, it tries to connect to the ADM instance hosted ad address url (default address is \u201cthings.zerynth.com\u201d).","title":"class ZerynthApp"},{"location":"reference/libs/zerynth/zerynthapp/docs/zerynthapp/#zerynthappon","text":"on ( method , fn ) Associates the method name method to the callable fn . Everytime the ZerynthApp instance receives a request for method from the mobile app, the callable fn is executed (possibly with arguments).","title":"ZerynthApp.on"},{"location":"reference/libs/zerynth/zerynthapp/docs/zerynthapp/#zerynthappevent","text":"event ( payload ) Sends an event with payload payload to the mobile app.","title":"ZerynthApp.event"},{"location":"reference/libs/zerynth/zerynthapp/docs/zerynthapp/#zerynthappnotify","text":"notify ( title , text ) Sends a push notification to connected apps with title title and text text .","title":"ZerynthApp.notify"},{"location":"reference/libs/zerynth/zerynthapp/docs/zerynthapp/#zerynthapprun","text":"run () Starts the ZerynthApp instance on a separate thread and returns immediately.","title":"ZerynthApp.run"},{"location":"reference/libs/zerynth/zerynthshield/docs/","text":"Zerynth Shield \u00b6 The Zerynth Shield is a ready to use multi-sensors device that adds smart functions to your everyday life objects. The first shield that can be plugged on both Arduino and Particle devices without any adapter. With a set of on-board sensors and all the most used communication ports ready to be plugged, the Zerynth Shield allows makers, designers and IoT professionals to easily develop their smart objects, without care about wiring and soldering becoming crazy with funky circuits. Here below, the Zerynth Library for handling the Zerynth Shield\u2019s sensors and some examples to better understand how to use it. Contents: Zerynth Shield Library TouchSensor class LightSensor class TemperatureSensor class MicrophoneSensor class Examples Zerynth Shield Basics Microphone Peak Detector Temperature Sampling Light Controlled PWM Zerynth Shield Sensor Pool Touch Smart Detector Zerynth Shield IR Capture","title":"Zerynth Shield"},{"location":"reference/libs/zerynth/zerynthshield/docs/#zerynth-shield","text":"The Zerynth Shield is a ready to use multi-sensors device that adds smart functions to your everyday life objects. The first shield that can be plugged on both Arduino and Particle devices without any adapter. With a set of on-board sensors and all the most used communication ports ready to be plugged, the Zerynth Shield allows makers, designers and IoT professionals to easily develop their smart objects, without care about wiring and soldering becoming crazy with funky circuits. Here below, the Zerynth Library for handling the Zerynth Shield\u2019s sensors and some examples to better understand how to use it. Contents: Zerynth Shield Library TouchSensor class LightSensor class TemperatureSensor class MicrophoneSensor class Examples Zerynth Shield Basics Microphone Peak Detector Temperature Sampling Light Controlled PWM Zerynth Shield Sensor Pool Touch Smart Detector Zerynth Shield IR Capture","title":"Zerynth Shield"},{"location":"reference/libs/zerynth/zerynthshield/docs/examples/","text":"Examples \u00b6 The following are a list of examples for lib.zerynth.zerynthshield. Zerynth Shield Basics \u00b6 Zerynth Shield defines pin names in a board indipendent manner. This way you can upload the same script on different boards without changing anything. In this example raw values from sensors are read and printed to console. main.py ################################################################################ # Zerynth Shield basic # # Created by Zerynth Team 2015 CC # Authors: L. Rizzello, G. Baldi, D. Mazzei ############################################################################### import streams import adc from zerynthshield import zerynthshield streams . serial () # zerynthshield defines pin names in a device indipendent manner # let's use them to read raw sensors values while True : print ( \" Microphone:\" , adc . read ( zerynthshield . microphone_pin )) print ( \" Light:\" , adc . read ( zerynthshield . light_pin )) print ( \"Temperature:\" , adc . read ( zerynthshield . temperature_pin )) print ( \" Touch:\" , digitalRead ( zerynthshield . touch_pin )) # aux pins are also accessible! print ( \" AUX1:\" , adc . read ( zerynthshield . aux1 . ADC )) print ( \"-\" * 40 ) sleep ( 500 ) # this scripts runs on every supported device, without a single change...cool isn't it? :) Electrect Microphone Peak Detector \u00b6 The smartSensors library is a ready to use set of functions that are very useful for managing analog and digital sensors. Common operations like calculating min, max, average and trends are completely automated by the smartSensors library. Moreover the smartSensors lib allows user to define calibration functions for analog sensors and to use callback to schedule sampling and acquisition operations. In this example the analogSensors module is used to acquire data from the Electrect Microphone embedded in the Zerynth Shield but an be also used with any other analog sensor connected to an analog pin. The analogSensors integrated routines are used to calculate the min-Max difference and then trigger a function if a threshold is passed. Use this sensor to start to develop your knock triggered smart device. tags: [Smart Sensors Lib, analogSensors, Zerynth Shield, Electrect Microphone, Sound] groups:[Smart Sensors Library, Zerynth Shield Driver] main.py ################################################################################ # Electrect Microphone Peak Detector # # Created by Zerynth Team 2015 CC # Authors: L. Rizzello, G. Baldi, D. Mazzei ############################################################################### import streams # import zerynthshield module from zerynthshield import zerynthshield # define a function that takes a sensor object as parameter and checks the # maximum peak to peak extension of the signal in a preset window # if the extension is over the threshold prints a message def detectSound ( obj ): if ( obj . resetMinMaxCounter == obj . _observationWindowN ): extension = obj . staticMax - obj . staticMin if ( extension > 1000 ): print ( \"!!!\" ) obj . staticMax , obj . staticMin = - 4096 , 4096 obj . resetMinMaxCounter = 0 else : c = obj . currentSample () if ( c > obj . staticMax ): obj . staticMax = c elif ( c < obj . staticMin ): obj . staticMin = c obj . resetMinMaxCounter += 1 streams . serial () # set three new attributes to the zerynthshield.microphone object zerynthshield . microphone . staticMin = 4096 zerynthshield . microphone . staticMax = - 4096 zerynthshield . microphone . resetMinMaxCounter = 0 # set 'detectSound' as the function to be applied to the object at every sampling # step zerynthshield . microphone . doEverySample ( detectSound ) # start sampling at 22 microseconds ( ~45 kHZ ) with a window length of 500 that # sets the lowest detectable frequency at ~90 Hz zerynthshield . microphone . startSampling ( 22 , 500 , \"raw\" , MICROS ) while True : print ( zerynthshield . microphone . currentSample ()) sleep ( 200 ) Temperature Sampling \u00b6 This examples use the Analog Sensors features of the Smart Sensors library for implementing a temperature logger using the Zerynth Shield integrated temperature sensor. tags: [Zerynth Shield, Touch, Button, Digital Sensor] groups:[Zerynth Shield Driver] main.py ################################################################################ # Temperature Sampling # # Created by Zerynth Team 2015 CC # Authors: L. Rizzello, G. Baldi, D. Mazzei ############################################################################### # This example is based on the Basic Analog Sensor example of the Smart Sensor Library import streams from zerynthshield import zerynthshield def out ( obj ): print ( \"----------------\" ) print ( \"last 10 minutes:\" ) print ( \"max temperature: \" , obj . maxSample ) print ( \"min temperature: \" , obj . minSample ) print ( \"average temperature: \" , obj . currentAverage ) streams . serial () zerynthshield . temperature . doEverySample ( out ) zerynthshield . temperature . setNormFunc ( zerynthshield . toCelsius ) zerynthshield . temperature . startSampling ( 30000 , 20 , \"norm\" ) Light Controlled PWM \u00b6 This examples shows how to use the Zerynth Shield Light sensors to drive a LED through a PWM implementing a light with luminosity feedback. tags: [Smart Sensors Lib, analogSensors, Zerynth Shield, sensorPool] groups:[Smart Sensors Library, Zerynth Shield Driver] main.py ################################################################################ # Light Controlled PWM # # Created by Zerynth Team 2015 CC # Authors: L. Rizzello, G. Baldi, D. Mazzei ############################################################################### import streams import pwm from zerynthshield import zerynthshield streams . serial () # define a function that takes a sensor object as parameter and changes the # modulation of the led depending on the last value read by the sensor: # as currentSample() gets higher, PWM duty cycle gets lower def changeLEDIntensity ( obj ): global led_pin percentage = 1 - obj . currentSample () print ( int ( 2040 * percentage )) #~ 490 Hz pwm . write ( led_pin , 2040 , int ( 2040 * percentage ), MICROS ) led_pin = LED0 . PWM pinMode ( led_pin , OUTPUT ) # set zerynthshield.toFloat as the normalization function for the light sensor # to get its samples as values between 0 and 1 zerynthshield . light . setNormFunc ( zerynthshield . toFloat ) # set changeLEDIntensity as the function to be executed every time a new sample # is read zerynthshield . light . doEverySample ( changeLEDIntensity ) # start sampling normalized samples zerynthshield . light . startSampling ( 200 , None , \"norm\" ) Shield Pool \u00b6 The smartSensors library is a ready to use set of functions that are very useful for managing analog and digital sensors. Common operations like calculating min, max, average and trends are completely automated by the smartSensors library. Moreover the smartSensors lib allows user to define calibration functions for analog sensors and to use callback to schedule sampling and acquisition operations. In this example a sensor pool of analog sensors is created to acquire data from the Light and Temperature sensors of the Zerynth Shield. The examples shows how to set a calibration function for the temperature sensor while leaving raw the data coming from the light sensor. Both normalized ans raw sensors are included in a sensorPool and the acquisition triggered simultaneously. tags: [Smart Sensors Lib, analogSensors, Zerynth Shield, sensorPool] groups:[Smart Sensors Library, Zerynth Shield Driver] main.py ################################################################################ # Zerynth Shield Sensor Pool # # Created by Zerynth Team 2015 CC # Authors: L. Rizzello, G. Baldi, D. Mazzei ############################################################################### import streams from zerynthshield import zerynthshield from smartsensors import sensorPool # see Pool Example for sensorPool details def out_l ( obj ): print ( \"light: \" , obj . currentSample ()) def out_t ( obj ): print ( \"temperature: \" , obj . currentSample ()) streams . serial () zerynthshield . light . doEverySample ( out_l ) # to be noticed the use of a preset normalization function 'zerynthshield.toCelsius' # included in the zerynthshield module zerynthshield . temperature . setNormFunc ( zerynthshield . toCelsius ) . doEverySample ( out_t ) pool = sensorPool . SensorPool ([ zerynthshield . light , zerynthshield . temperature ]) pool . startSampling ([ 1000 , 1000 ],[ None , None ],[ \"raw\" , \"norm\" ]) Touch Smart Detector \u00b6 The smartSensors library is a ready to use set of functions that are very useful for managing analog and digital sensors. Common operations like calculating min, max, average and trends are completely automated by the smartSensors library. Moreover the smartSensors lib allows user to define calibration functions for analog sensors and to use callback to schedule sampling and acquisition operations. The Zerynth Shield Library onDoubleTouch method allows to monitor a digital input to be considered as button or touch sensor. The methods allow the definition of a set of functions to be called when a single, a double or a long touch is detected. The functions also allow to adjust the detecting parameter s in term of time ranges and constrains. tags: [Zerynth Shield, Touch, Button, Digital Sensor] groups:[Zerynth Shield Driver] main.py ################################################################################ # Touch Smart Detector # # Created by Zerynth Team 2015 CC # Authors: L. Rizzello, G. Baldi, D. Mazzei ############################################################################### import streams # import zerynthshield module from zerynthshield import zerynthshield # define three functions that print three different messages def single (): print ( \"touch\" ) def double (): print ( \"double\" ) def loong (): print ( \"loong\" ) streams . serial () # set 'single' as the function to be executed after the first touch of the Zerynth Shield # touch sensor and 'double' after the second. To really execute these functions touch # has to respect some time constraints: first touch must be of at least 50 milliseconds # to be considered voluntary and must not be longer than 1500 milliseconds, furthermore # not more than 1000 milliseconds shall pass between the first and second touch to consider # two single touches a real double touch. # The 'loong' function is executed if the 1500 milliseconds constraint is not respected. zerynthshield . touch . onDoubleTouch ( 50 , 1500 , 1000 , single , double , loong ) ToiShield IR Basic \u00b6 main.py ################################################################################ # Zerynth Shield IR Basic # # Created: 2015-07-26 18:36:22.346367 # ################################################################################ import streams from zerynthshield import zerynthshield streams . serial () while True : print ( \"Capturing...\" ) # starts capturing from the zerynthshield IR receiver setting max_samples # number of samples (a sample represents the interval in microseconds # passed between a change from a LOW to a HIGH value on the pin or # viceversa) to be acquired and a maximum time window of time_window ms. # Values chosen for this example come from NEC IR ( used by LG ) # specification. max_samples , time_window = 67 , 68 x = zerynthshield . irreceiver . capture ( max_samples , time_window ) print ( \"Captured:\" , len ( x ), \"samples \\n \" , x )","title":"Examples"},{"location":"reference/libs/zerynth/zerynthshield/docs/examples/#examples","text":"The following are a list of examples for lib.zerynth.zerynthshield.","title":"Examples"},{"location":"reference/libs/zerynth/zerynthshield/docs/examples/#zerynth-shield-basics","text":"Zerynth Shield defines pin names in a board indipendent manner. This way you can upload the same script on different boards without changing anything. In this example raw values from sensors are read and printed to console. main.py ################################################################################ # Zerynth Shield basic # # Created by Zerynth Team 2015 CC # Authors: L. Rizzello, G. Baldi, D. Mazzei ############################################################################### import streams import adc from zerynthshield import zerynthshield streams . serial () # zerynthshield defines pin names in a device indipendent manner # let's use them to read raw sensors values while True : print ( \" Microphone:\" , adc . read ( zerynthshield . microphone_pin )) print ( \" Light:\" , adc . read ( zerynthshield . light_pin )) print ( \"Temperature:\" , adc . read ( zerynthshield . temperature_pin )) print ( \" Touch:\" , digitalRead ( zerynthshield . touch_pin )) # aux pins are also accessible! print ( \" AUX1:\" , adc . read ( zerynthshield . aux1 . ADC )) print ( \"-\" * 40 ) sleep ( 500 ) # this scripts runs on every supported device, without a single change...cool isn't it? :)","title":"Zerynth Shield Basics"},{"location":"reference/libs/zerynth/zerynthshield/docs/examples/#electrect-microphone-peak-detector","text":"The smartSensors library is a ready to use set of functions that are very useful for managing analog and digital sensors. Common operations like calculating min, max, average and trends are completely automated by the smartSensors library. Moreover the smartSensors lib allows user to define calibration functions for analog sensors and to use callback to schedule sampling and acquisition operations. In this example the analogSensors module is used to acquire data from the Electrect Microphone embedded in the Zerynth Shield but an be also used with any other analog sensor connected to an analog pin. The analogSensors integrated routines are used to calculate the min-Max difference and then trigger a function if a threshold is passed. Use this sensor to start to develop your knock triggered smart device. tags: [Smart Sensors Lib, analogSensors, Zerynth Shield, Electrect Microphone, Sound] groups:[Smart Sensors Library, Zerynth Shield Driver] main.py ################################################################################ # Electrect Microphone Peak Detector # # Created by Zerynth Team 2015 CC # Authors: L. Rizzello, G. Baldi, D. Mazzei ############################################################################### import streams # import zerynthshield module from zerynthshield import zerynthshield # define a function that takes a sensor object as parameter and checks the # maximum peak to peak extension of the signal in a preset window # if the extension is over the threshold prints a message def detectSound ( obj ): if ( obj . resetMinMaxCounter == obj . _observationWindowN ): extension = obj . staticMax - obj . staticMin if ( extension > 1000 ): print ( \"!!!\" ) obj . staticMax , obj . staticMin = - 4096 , 4096 obj . resetMinMaxCounter = 0 else : c = obj . currentSample () if ( c > obj . staticMax ): obj . staticMax = c elif ( c < obj . staticMin ): obj . staticMin = c obj . resetMinMaxCounter += 1 streams . serial () # set three new attributes to the zerynthshield.microphone object zerynthshield . microphone . staticMin = 4096 zerynthshield . microphone . staticMax = - 4096 zerynthshield . microphone . resetMinMaxCounter = 0 # set 'detectSound' as the function to be applied to the object at every sampling # step zerynthshield . microphone . doEverySample ( detectSound ) # start sampling at 22 microseconds ( ~45 kHZ ) with a window length of 500 that # sets the lowest detectable frequency at ~90 Hz zerynthshield . microphone . startSampling ( 22 , 500 , \"raw\" , MICROS ) while True : print ( zerynthshield . microphone . currentSample ()) sleep ( 200 )","title":"Electrect Microphone Peak Detector"},{"location":"reference/libs/zerynth/zerynthshield/docs/examples/#temperature-sampling","text":"This examples use the Analog Sensors features of the Smart Sensors library for implementing a temperature logger using the Zerynth Shield integrated temperature sensor. tags: [Zerynth Shield, Touch, Button, Digital Sensor] groups:[Zerynth Shield Driver] main.py ################################################################################ # Temperature Sampling # # Created by Zerynth Team 2015 CC # Authors: L. Rizzello, G. Baldi, D. Mazzei ############################################################################### # This example is based on the Basic Analog Sensor example of the Smart Sensor Library import streams from zerynthshield import zerynthshield def out ( obj ): print ( \"----------------\" ) print ( \"last 10 minutes:\" ) print ( \"max temperature: \" , obj . maxSample ) print ( \"min temperature: \" , obj . minSample ) print ( \"average temperature: \" , obj . currentAverage ) streams . serial () zerynthshield . temperature . doEverySample ( out ) zerynthshield . temperature . setNormFunc ( zerynthshield . toCelsius ) zerynthshield . temperature . startSampling ( 30000 , 20 , \"norm\" )","title":"Temperature Sampling"},{"location":"reference/libs/zerynth/zerynthshield/docs/examples/#light-controlled-pwm","text":"This examples shows how to use the Zerynth Shield Light sensors to drive a LED through a PWM implementing a light with luminosity feedback. tags: [Smart Sensors Lib, analogSensors, Zerynth Shield, sensorPool] groups:[Smart Sensors Library, Zerynth Shield Driver] main.py ################################################################################ # Light Controlled PWM # # Created by Zerynth Team 2015 CC # Authors: L. Rizzello, G. Baldi, D. Mazzei ############################################################################### import streams import pwm from zerynthshield import zerynthshield streams . serial () # define a function that takes a sensor object as parameter and changes the # modulation of the led depending on the last value read by the sensor: # as currentSample() gets higher, PWM duty cycle gets lower def changeLEDIntensity ( obj ): global led_pin percentage = 1 - obj . currentSample () print ( int ( 2040 * percentage )) #~ 490 Hz pwm . write ( led_pin , 2040 , int ( 2040 * percentage ), MICROS ) led_pin = LED0 . PWM pinMode ( led_pin , OUTPUT ) # set zerynthshield.toFloat as the normalization function for the light sensor # to get its samples as values between 0 and 1 zerynthshield . light . setNormFunc ( zerynthshield . toFloat ) # set changeLEDIntensity as the function to be executed every time a new sample # is read zerynthshield . light . doEverySample ( changeLEDIntensity ) # start sampling normalized samples zerynthshield . light . startSampling ( 200 , None , \"norm\" )","title":"Light Controlled PWM"},{"location":"reference/libs/zerynth/zerynthshield/docs/examples/#shield-pool","text":"The smartSensors library is a ready to use set of functions that are very useful for managing analog and digital sensors. Common operations like calculating min, max, average and trends are completely automated by the smartSensors library. Moreover the smartSensors lib allows user to define calibration functions for analog sensors and to use callback to schedule sampling and acquisition operations. In this example a sensor pool of analog sensors is created to acquire data from the Light and Temperature sensors of the Zerynth Shield. The examples shows how to set a calibration function for the temperature sensor while leaving raw the data coming from the light sensor. Both normalized ans raw sensors are included in a sensorPool and the acquisition triggered simultaneously. tags: [Smart Sensors Lib, analogSensors, Zerynth Shield, sensorPool] groups:[Smart Sensors Library, Zerynth Shield Driver] main.py ################################################################################ # Zerynth Shield Sensor Pool # # Created by Zerynth Team 2015 CC # Authors: L. Rizzello, G. Baldi, D. Mazzei ############################################################################### import streams from zerynthshield import zerynthshield from smartsensors import sensorPool # see Pool Example for sensorPool details def out_l ( obj ): print ( \"light: \" , obj . currentSample ()) def out_t ( obj ): print ( \"temperature: \" , obj . currentSample ()) streams . serial () zerynthshield . light . doEverySample ( out_l ) # to be noticed the use of a preset normalization function 'zerynthshield.toCelsius' # included in the zerynthshield module zerynthshield . temperature . setNormFunc ( zerynthshield . toCelsius ) . doEverySample ( out_t ) pool = sensorPool . SensorPool ([ zerynthshield . light , zerynthshield . temperature ]) pool . startSampling ([ 1000 , 1000 ],[ None , None ],[ \"raw\" , \"norm\" ])","title":"Shield Pool"},{"location":"reference/libs/zerynth/zerynthshield/docs/examples/#touch-smart-detector","text":"The smartSensors library is a ready to use set of functions that are very useful for managing analog and digital sensors. Common operations like calculating min, max, average and trends are completely automated by the smartSensors library. Moreover the smartSensors lib allows user to define calibration functions for analog sensors and to use callback to schedule sampling and acquisition operations. The Zerynth Shield Library onDoubleTouch method allows to monitor a digital input to be considered as button or touch sensor. The methods allow the definition of a set of functions to be called when a single, a double or a long touch is detected. The functions also allow to adjust the detecting parameter s in term of time ranges and constrains. tags: [Zerynth Shield, Touch, Button, Digital Sensor] groups:[Zerynth Shield Driver] main.py ################################################################################ # Touch Smart Detector # # Created by Zerynth Team 2015 CC # Authors: L. Rizzello, G. Baldi, D. Mazzei ############################################################################### import streams # import zerynthshield module from zerynthshield import zerynthshield # define three functions that print three different messages def single (): print ( \"touch\" ) def double (): print ( \"double\" ) def loong (): print ( \"loong\" ) streams . serial () # set 'single' as the function to be executed after the first touch of the Zerynth Shield # touch sensor and 'double' after the second. To really execute these functions touch # has to respect some time constraints: first touch must be of at least 50 milliseconds # to be considered voluntary and must not be longer than 1500 milliseconds, furthermore # not more than 1000 milliseconds shall pass between the first and second touch to consider # two single touches a real double touch. # The 'loong' function is executed if the 1500 milliseconds constraint is not respected. zerynthshield . touch . onDoubleTouch ( 50 , 1500 , 1000 , single , double , loong )","title":"Touch Smart Detector"},{"location":"reference/libs/zerynth/zerynthshield/docs/examples/#toishield-ir-basic","text":"main.py ################################################################################ # Zerynth Shield IR Basic # # Created: 2015-07-26 18:36:22.346367 # ################################################################################ import streams from zerynthshield import zerynthshield streams . serial () while True : print ( \"Capturing...\" ) # starts capturing from the zerynthshield IR receiver setting max_samples # number of samples (a sample represents the interval in microseconds # passed between a change from a LOW to a HIGH value on the pin or # viceversa) to be acquired and a maximum time window of time_window ms. # Values chosen for this example come from NEC IR ( used by LG ) # specification. max_samples , time_window = 67 , 68 x = zerynthshield . irreceiver . capture ( max_samples , time_window ) print ( \"Captured:\" , len ( x ), \"samples \\n \" , x )","title":"ToiShield IR Basic"},{"location":"reference/libs/zerynth/zerynthshield/docs/zerynthshield/","text":"Zerynth Shield Library \u00b6 This module contains class definitions and instances for Zerynth Shield\u2019s sensors. Furthermore it takes care of multi-device pin compatibility providing generic names for every useful pin on the shield. Every sensor of the Zerynth Shield is instanced as a child class of the Digital or the Analog Sensor class (as defined in Smart Sensors Library). Moreover, few peculiar methods are added. The class inherits the whole set of sampling methods included in the Digital or Analog Sensor Library (startSampling, doEverySample, addCheck,\u2026) Pin names: zerynthshield.temperature_pin zerynthshield.light_pin zerynthshield.microphone_pin zerynthshield.iremitter_pin zerynthshield.irreceiver_pin zerynthshield.touch_pin zerynthshield.buzzer_pin zerynthshield.led_pin Sensors: light (analogSensors): it is an instance of the analogSensor class configured for the Zerynth Shield light sensor microphone (analogSensors): it is an instance of the analogSensor class configured for the Zerynth Shield microphone temperature (analogSensors): it is an instance of the analogSensor class configured for the Zerynth Shield temperature sensor touch (digitalSensors): it is an instance of the digitalSensor class configured for the Zerynth Shield touch sensor For example, sampling the temperature in Celsius can be done with: zerynthshield . temperature . setNormFunc ( zerynthshield . toCelsius ) zerynthshield . temperature . startSampling ( 1000 , None , \"norm\" ) The smartsensors lib allows the definition of a function to be called periodically. See the smartsensors lib documentation for more details. An Arduino-like style is also supported: while True : zerynthshield . temperature . getCelsius () sleep ( 1000 ) TouchSensor class \u00b6 class TouchSensor \u00b6 class TouchSensor () This class provides simple methods for the detection of single and double touch on the Zerynth Shield integrated capacitive touch sensor. An instance of the class is available by calling the zerynthshield.touch attribute. TouchSensor.onSingleTouch \u00b6 onSingleTouch ( min_time , max_time , to_do , long_fn = None ) Sets a to_do function to be executed when a touch occurs and lasts more than min_time and less than max_time (expressed in milliseconds), if max_time limit is exceeded long_fn is called. Arguments: min_time (int): minimum touch time max_time (int): maximum touch time after that the touch is not considered anymore as a single touch but as a long touch to_do (function): function to be executed when a single-touch occurs long_fn (function, optional): function to be executed when a long touch occurs TouchSensor.onDoubleTouch \u00b6 onDoubleTouch ( min_time , max_time , to_do , long_fn = None ) Sets a first_action function to be executed when a touch occurs and lasts more than min_time and less than max_time (expressed in milliseconds), if max_time limit is exceeded long_fn is executed. When first_action constrains are respected, if a second touch occurs at most after max_interval milliseconds and the length of the touch is between min_time and max_time, then second_action function is called. Arguments: min_time (int): minimum touch time max_time (int): maximum touch time after that the touch is not considered anymore as a single touch but as a long touch max_interval (int): the maximum time span between touches to consider a double touch event instead of two separated single touches. first_action (function): function to be executed when a single-touch occurs second_action (function, optional): function to be executed when a double touch occurs long_fn (function, optional): function to be executed when a long touch occurs LightSensor class \u00b6 class LightSensor \u00b6 class LightSensor () This class provides a default getFloat() normalization method for the photoresistor integrated in the Zerynth Shield. An instance of the class is available by calling the zerynthshield.light attribute. LightSensor.getFloat \u00b6 getFloat () Returns samples normalized between 0 and 1. TemperatureSensor class \u00b6 class TemperatureSensor \u00b6 class TemperatureSensor () This class provides two default normalization method for the temperature sensor: getFloat() and getCelsius(). An instance of the class is available by calling the zerynthshield.temperature attribute. TemperatureSensor.getCelsius \u00b6 getCelsius () Returns samples directly converted in celsius degrees. TemperatureSensor.getFloat \u00b6 getFloat () Returns samples normalized between 0 and 1. MicrophoneSensor class \u00b6 class MicrophoneSensor \u00b6 class MicrophoneSensor () This class provides a default getFloat() normalization method for the microphone. An instance of the class is available by calling zerynthshield.microphone attribute. zerynthshield.microphone.skipEval (see Sensor class) is set to true because of the high sampling frequencies that may be needed by the sensor. MicrophoneSensor.getFloat \u00b6 getFloat () Returns samples normalized between 0 and 1.","title":"Zerynth Shield Library"},{"location":"reference/libs/zerynth/zerynthshield/docs/zerynthshield/#zerynth-shield-library","text":"This module contains class definitions and instances for Zerynth Shield\u2019s sensors. Furthermore it takes care of multi-device pin compatibility providing generic names for every useful pin on the shield. Every sensor of the Zerynth Shield is instanced as a child class of the Digital or the Analog Sensor class (as defined in Smart Sensors Library). Moreover, few peculiar methods are added. The class inherits the whole set of sampling methods included in the Digital or Analog Sensor Library (startSampling, doEverySample, addCheck,\u2026) Pin names: zerynthshield.temperature_pin zerynthshield.light_pin zerynthshield.microphone_pin zerynthshield.iremitter_pin zerynthshield.irreceiver_pin zerynthshield.touch_pin zerynthshield.buzzer_pin zerynthshield.led_pin Sensors: light (analogSensors): it is an instance of the analogSensor class configured for the Zerynth Shield light sensor microphone (analogSensors): it is an instance of the analogSensor class configured for the Zerynth Shield microphone temperature (analogSensors): it is an instance of the analogSensor class configured for the Zerynth Shield temperature sensor touch (digitalSensors): it is an instance of the digitalSensor class configured for the Zerynth Shield touch sensor For example, sampling the temperature in Celsius can be done with: zerynthshield . temperature . setNormFunc ( zerynthshield . toCelsius ) zerynthshield . temperature . startSampling ( 1000 , None , \"norm\" ) The smartsensors lib allows the definition of a function to be called periodically. See the smartsensors lib documentation for more details. An Arduino-like style is also supported: while True : zerynthshield . temperature . getCelsius () sleep ( 1000 )","title":"Zerynth Shield Library"},{"location":"reference/libs/zerynth/zerynthshield/docs/zerynthshield/#touchsensor-class","text":"","title":"TouchSensor class"},{"location":"reference/libs/zerynth/zerynthshield/docs/zerynthshield/#class-touchsensor","text":"class TouchSensor () This class provides simple methods for the detection of single and double touch on the Zerynth Shield integrated capacitive touch sensor. An instance of the class is available by calling the zerynthshield.touch attribute.","title":"class TouchSensor"},{"location":"reference/libs/zerynth/zerynthshield/docs/zerynthshield/#touchsensoronsingletouch","text":"onSingleTouch ( min_time , max_time , to_do , long_fn = None ) Sets a to_do function to be executed when a touch occurs and lasts more than min_time and less than max_time (expressed in milliseconds), if max_time limit is exceeded long_fn is called. Arguments: min_time (int): minimum touch time max_time (int): maximum touch time after that the touch is not considered anymore as a single touch but as a long touch to_do (function): function to be executed when a single-touch occurs long_fn (function, optional): function to be executed when a long touch occurs","title":"TouchSensor.onSingleTouch"},{"location":"reference/libs/zerynth/zerynthshield/docs/zerynthshield/#touchsensorondoubletouch","text":"onDoubleTouch ( min_time , max_time , to_do , long_fn = None ) Sets a first_action function to be executed when a touch occurs and lasts more than min_time and less than max_time (expressed in milliseconds), if max_time limit is exceeded long_fn is executed. When first_action constrains are respected, if a second touch occurs at most after max_interval milliseconds and the length of the touch is between min_time and max_time, then second_action function is called. Arguments: min_time (int): minimum touch time max_time (int): maximum touch time after that the touch is not considered anymore as a single touch but as a long touch max_interval (int): the maximum time span between touches to consider a double touch event instead of two separated single touches. first_action (function): function to be executed when a single-touch occurs second_action (function, optional): function to be executed when a double touch occurs long_fn (function, optional): function to be executed when a long touch occurs","title":"TouchSensor.onDoubleTouch"},{"location":"reference/libs/zerynth/zerynthshield/docs/zerynthshield/#lightsensor-class","text":"","title":"LightSensor class"},{"location":"reference/libs/zerynth/zerynthshield/docs/zerynthshield/#class-lightsensor","text":"class LightSensor () This class provides a default getFloat() normalization method for the photoresistor integrated in the Zerynth Shield. An instance of the class is available by calling the zerynthshield.light attribute.","title":"class LightSensor"},{"location":"reference/libs/zerynth/zerynthshield/docs/zerynthshield/#lightsensorgetfloat","text":"getFloat () Returns samples normalized between 0 and 1.","title":"LightSensor.getFloat"},{"location":"reference/libs/zerynth/zerynthshield/docs/zerynthshield/#temperaturesensor-class","text":"","title":"TemperatureSensor class"},{"location":"reference/libs/zerynth/zerynthshield/docs/zerynthshield/#class-temperaturesensor","text":"class TemperatureSensor () This class provides two default normalization method for the temperature sensor: getFloat() and getCelsius(). An instance of the class is available by calling the zerynthshield.temperature attribute.","title":"class TemperatureSensor"},{"location":"reference/libs/zerynth/zerynthshield/docs/zerynthshield/#temperaturesensorgetcelsius","text":"getCelsius () Returns samples directly converted in celsius degrees.","title":"TemperatureSensor.getCelsius"},{"location":"reference/libs/zerynth/zerynthshield/docs/zerynthshield/#temperaturesensorgetfloat","text":"getFloat () Returns samples normalized between 0 and 1.","title":"TemperatureSensor.getFloat"},{"location":"reference/libs/zerynth/zerynthshield/docs/zerynthshield/#microphonesensor-class","text":"","title":"MicrophoneSensor class"},{"location":"reference/libs/zerynth/zerynthshield/docs/zerynthshield/#class-microphonesensor","text":"class MicrophoneSensor () This class provides a default getFloat() normalization method for the microphone. An instance of the class is available by calling zerynthshield.microphone attribute. zerynthshield.microphone.skipEval (see Sensor class) is set to true because of the high sampling frequencies that may be needed by the sensor.","title":"class MicrophoneSensor"},{"location":"reference/libs/zerynth/zerynthshield/docs/zerynthshield/#microphonesensorgetfloat","text":"getFloat () Returns samples normalized between 0 and 1.","title":"MicrophoneSensor.getFloat"},{"location":"zdm/","text":"ZDM \u00b6","title":"Index"},{"location":"zdm/#zdm","text":"","title":"ZDM"},{"location":"zdm/getting-started/","text":"::: {.module} zerynthzdm ::: Getting started {#lib.zerynth.zdm} \u00b6 The Zerynth Device Manager (ZDM) Library contains many different commands that allows you to connect your devices to the ZDM. You can use ZDM lib to send data from your devices and to let them receive your remote commands (jobs). To learn how to be able to use it and call ZDM methods, see the ZDM getting started doc . The Device class \u00b6 ::: {.Device(device_id, .job_list=None, .fota_callback=None)} Creates a Device instance with uid device_id {.interpreted-text role=\"samp\"}. All other parameters are optional and have default values. endpoint {.interpreted-text role=\"samp\"} is the endpoint of the zdm. port {.interpreted-text role=\"samp\"} is the port of the zdm. job_list {.interpreted-text role=\"samp\"} is the dictionary that defines the device\\'s available jobs fota_callback {.interpreted-text role=\"samp\"}, is a function accepting one ore more arguments that will be called at different steps of the FOTA process. the fota_callback {.interpreted-text role=\"samp\"} can return a boolean value. If the return value is True, the FOTA process continues, otherwise it is stopped. ::: ::: {.method} set_password(password) Set the device password to password {.interpreted-text role=\"samp\"}. You can generate a password using the ZDM, creating a key for your device ::: ::: {.method} connect() Connect your device to the ZDM. You must set device\\'s password first. It also enable your device to receive incoming messages. ::: ::: {.method} publish(data, tag=None) Publish a message to the ZDM. data {.interpreted-text role=\"samp\"} is the message payload, represented by a dictionary tag {.interpreted-text role=\"samp\"}, is a label for the device\\'s data into your workspace. More than one device can publish message to the same tag :::","title":"Getting started"},{"location":"zdm/getting-started/#getting-started-libzerynthzdm","text":"The Zerynth Device Manager (ZDM) Library contains many different commands that allows you to connect your devices to the ZDM. You can use ZDM lib to send data from your devices and to let them receive your remote commands (jobs). To learn how to be able to use it and call ZDM methods, see the ZDM getting started doc .","title":"Getting started {#lib.zerynth.zdm}"},{"location":"zdm/getting-started/#the-device-class","text":"::: {.Device(device_id, .job_list=None, .fota_callback=None)} Creates a Device instance with uid device_id {.interpreted-text role=\"samp\"}. All other parameters are optional and have default values. endpoint {.interpreted-text role=\"samp\"} is the endpoint of the zdm. port {.interpreted-text role=\"samp\"} is the port of the zdm. job_list {.interpreted-text role=\"samp\"} is the dictionary that defines the device\\'s available jobs fota_callback {.interpreted-text role=\"samp\"}, is a function accepting one ore more arguments that will be called at different steps of the FOTA process. the fota_callback {.interpreted-text role=\"samp\"} can return a boolean value. If the return value is True, the FOTA process continues, otherwise it is stopped. ::: ::: {.method} set_password(password) Set the device password to password {.interpreted-text role=\"samp\"}. You can generate a password using the ZDM, creating a key for your device ::: ::: {.method} connect() Connect your device to the ZDM. You must set device\\'s password first. It also enable your device to receive incoming messages. ::: ::: {.method} publish(data, tag=None) Publish a message to the ZDM. data {.interpreted-text role=\"samp\"} is the message payload, represented by a dictionary tag {.interpreted-text role=\"samp\"}, is a label for the device\\'s data into your workspace. More than one device can publish message to the same tag :::","title":"The Device class"},{"location":"zerynth-os/Getting%20Started/","text":"Getting Started \u00b6 This section introduces you to the main features of Zerynth and provides you a step-by-step guide to get started with the system. Take a look at the video below to see Zerynth in action! Create a Zerynth User Account \u00b6 It is necessary to create a User Account to access Zerynth. To register a new Zerynth Account or to Log in an existing one, you can proceed manually ( email , username and password ) or you can automatically register/login with social credentials ( Facebook and Google+ ). Note \u00b6 For Manual Registration: check your email and verify your new account by clicking on the link provided in the confirmation email Warning \u00b6 The first time you create a user account or if you have sign-in issues, a restart of Zerynth Studio might be necessary Connect, Register and Virtualize your Device \u00b6 To make a device usable with Zerynth, you need to Connect , Register , and \u201cVirtualize\u201d it. According to the platform used and to the connected device, the user has to install the related driver to make the machine able to recognize and exchange data with the board. Warning \u00b6 Procedure to install drivers, if needed, is reported device by device in Supported Devices . The Registration phase is the process of retrieving the device info to allow the Zerynth backend to build its specific virtual machine. If the device has never been connected before, by clicking the \u201cZ\u201d button, the registration dialog, shown above, is displayed. To register a new device, you can follow these steps: connect your device to the machine. The \u201cDevices Management Widget\u201d notifies the devices list update with a yellow blink; select the device from the dropdown menu; click on the \u201cZerynth\u201d button. Zerynth Studio will guide you in the entire process through info messages displayed in the log console section at the bottom of the screen. Note \u00b6 \u201cPowered by Zerynth\u201d devices are accompained by a redeemable code that can be inserted in the above window and exchanged for a free virtual machine license. Warning \u00b6 Some devices require to be set in Device Firmware Update (DFU) mode in order to allow their registration and the flashing of the Zerynth Virtual Machine. Detailed guides on how to put them in DFU mode is available in the Supported Devices section of the documentation. Once registration has been performed, the user is given the option to create a Virtual Machine for the registered device by clicking again the \u201cZ\u201d button. Note \u00b6 A device can always be registered again with the dedicated dialog button. In the figure below, after clicking the \u201cCreate\u201d button, the user can select one available of different virtual machines compatible with the target device choosing the licenses (Starter/Premium), the real time operating system from those supported for the target device, and (for Premium licenses only) the features to be included in the virtual machine (FOTA, Power Saving, Secure Firmware, etc.). Note \u00b6 Some devices cannot be recognized automatically; for these devices, the dialog provides some more options to be specified before the actual registration/virtualization can take place. Warning \u00b6 The \u201cAvailable\u201d column in the table shows the possibility to create the related virtual machine according to the user asset. The created Virtual Machine can now be virtualized (i.e. burned on the device). The \u201cVirtualization\u201d is the process of installing the Zerynth Virtual Machine by flashing it on a device. By clicking the \u201cVirtualize\u201d button, the user can select the Zerynth Virtual Machine to be installed in his device choosing from those created. Note \u00b6 Zerynth Studio toolbar allows to \u201cVirtualize\u201d the selected device. Zerynth Devices \u00b6 The supported devices are grouped into Physical Devices (the ones physically connected to the local machine) and Virtual Devices (the devices usable with Zerynth). The Zerynth \u201cVirtual Devices\u201d feature allows to implement and develop the user application verifying the code for all the supported devices, without having them physically connected to the local machine. Once the desired supported device (virtual or physically connected) is selected, Zerynth Studio displays all collected info related to the chosen device in 2 different dialogs: Device Info Window ; Device Pinmap Window . The Device Info Window shows detailed information about the device, including the Flash/Ram size and the port for serial communication. Warning \u00b6 Some boards cannot be automatically recognized by Zerynth Studio and need a disambiguation. In this case the system asks you to indicate the device type. You can always revert this choice by clicking on the \u201cForget\u201d button. Finally, the Device Pinmap window provides the pinout of the selected device, along with the hardware features and peripherals available on each pin. Thanks to the Device Pinmap window it is also possible to understand how the device embedded peripherals are grouped and/or multiplexed. This allows to better understand how to use each specific hardware feature in the Zerynth Python scripts without having hardware conflicts. Clone an example and start with Zerynth Python Scripts \u00b6 Zerynth Studio includes many examples to get started: from the most basic ones to the examples related to the installed libraries. Zerynth examples cannot be edited, they are \u201cread only\u201d folders and they can be used as reference for the design of new projects. Zerynth examples can be cloned in just few clicks: open the Examples browser by clicking on the \u201clight bulb\u201d icon on the left panel of Zerynth Studio; select the example you prefer and clone it by clicking on the dedicated button; At this stage Zerynth converts the example into a new project giving you the possibility to edit the Title , the Description and the Folder of your new project project; click on \u201cCreate\u201d and you are done! Warning \u00b6 Remember that Zerynth does not allow two projects to have the same Folder Verify and Uplink a Zerynth Project \u00b6 The buttons on the upper left toolbar allow you to verify and uplink a script into a device. To verify a project click on the Verify icon to check your script for errors. The errors will be reported in the console and in the code editor with helpful tooltips. To Uplink your verified project into a Virtualized device just click the Uplink icon and follow the Zerynth Studio messages. Warning \u00b6 Some devices require to be reset during the uplink operation in order to write in flash the bytecode Develop your First Zerynth Project \u00b6 To create your First Zerynth Project from scratch you have to do just a few steps: click on the button \u201cBrowse Project\u201d; click on \u201cNew Project\u201d; Decide a project title and the project folder, and write an optional description; click on the \u201cCreate\u201d button. Once you click on the \u201cCreate\u201d button, the new Zerynth Project opens and you will be prompted with the editor of the \u201cmain.py\u201d file. The main is where the principal Zerynth code is written in Python: here is where you develop the logic of your script. If you wish to add more files to the Zerynth project you can easily do it. In Zerynth you can create html, json, txt, bin files and save them together with the bytecode on the device flash memory. You can also create more .py files where you can develop other parts of your code like modules and functions to be used in the main.py file. To add new files to a Zerynth project, follow these steps: click on \u201cBrowse Project\u201d; click on \u201cAdd file\u201d ; after naming the file click on \u201cCreate\u201d; write the code within the empty field in the editor; You can also add a new folder, delete a selected file, refresh the project folder, etc. by clicking the icon on the right of the \u201cProject view\u201d bar. Note \u00b6 When you add a .py file containing some code to be used in the main.py file (e.g. a file named helpers.py ), you have to import it by adding the line import helpers in the main.py file. Thus, you can call functions located in the helpers.py file by using the following syntax: helpers.fun_name(fun_attribute1, fun_attribute2, ...) Note \u00b6 If you want to save the template.html in the device flash as resource to be used by a specific module like the Zerynth App library, you have to use the new_resource() function defining the following code in the main.py file: new_resource(\"template.html\") Import a Zerynth Package into a Project \u00b6 Packages import syntax is very simple: Official Packages are imported with: from c import m where c is the name of the package and m is the name of a module inside the package. (e.g. from cc3000 import cc3000 or from cc3000 import cc3000_tiny ). Community Packages are imported with: from community.b.c import m where b is the namespace of the package, c is the package name and m is the name of a module (e.g. from community.floyd.rtttl import rtttl ) The import autocomplete feature of Zerynth Studio makes the task of importing modules even easier: as soon as \u201cfrom\u201d or \u201cimport\u201d is typed in the code editor, the autocomplete box lists all the matching modules. The Zerynth Programming Guide and various programming examples are also provided. For both the Official Library and the Community Library, a complete documentation is available and if the package contains usage examples, they can be found under the examples tab. Finally, if you need help with Python, here you can find a good overview on Python 3 with simple and exhaustive examples. You can always post your questions and doubts on the Zerynth Community Forum logging-in with your Zerynth Account. Zerynth Studio updates \u00b6 Zerynth Studio has two different update mechanisms: major system release rolling updates When a new major version of Zerynth is released a notification \u201cSystem Update!\u201d will appear in the footer area of Zerynth Studio. By clicking the notification, the new version will be downloaded and installed. After a restart, the new version will be selected and launched. However, the previous version is still there and can be selected during the launch phase. If a previous version is not needed anymore, it can be deleted from the \u201cPreferences\u201d menu. On the contrary, rolling updates do not change the system version but just a group of packages. Rolling updates are notified by the \u201cRolling update\u201d label in the footer area of Zerynth Studio. By clicking the notification, the list of updated packages and a detailed changelog are displayed. If accepted, a rolling update will download the selected packages only and will unpack them. After a restart, the launcher will take care of finishing the update and start Zerynth Studio. Zerynth and Git \u00b6 Zerynth Studio offers the possibility to store your projects on our backend, in a private git repository. Such feature is accessible from the Project View in the left panel by clicking the git \u201ccode-branch\u201d icon. The first time a project is pushed to our backend, the \u201cCreate repository\u201d option must be selected. From there on, the project view changes, showing a footer with information about the current remote/branch, the current tag if present, the number of modified files (identified by a bullet) and the status of the local repository with respect to the remote repository. The project git repository is automatically configured with a remote called \u201czerynth\u201d pointing to our backend. All git operations accessible from Zerynth Studio will operate on that remote. It is however possible to manually configure the project local repository to use different remotes (for example GitHub or GitLab). However, such configuration is up to the user. Git operations not featured in Zerynth Studio (for example \u201cmerge\u201d), can be performed manually using git from the command line. Search and Install Community Libraries \u00b6 Zerynth allows searching and installing libraries created by Zerynth users and hosted on GitHub. Libraries can be searched and installed from the Zerynth Library Manager Section (\u201cpuzzle\u201d icon) in the left toolbar. The latest version is displayed and options to update or downgrade the library are present. The results of the search are shown in the left column that displays a brief description of the libraries together with the available version. By clicking \u201cInstall\u201d or \u201cUpdate\u201d the library can be easily added to the system. Publishing community libraries \u00b6 Zerynth Studio allows publishing your projects as community libraries that can be installed by everyone else in the Zerynth community. To publish a project, select the \u201cPublish\u201d option for the currently opened project to fire up the publish wizard. The first step is needed to get the user permission to manage the Github repository where the library will be hosted. In order to do so, a popup window will be displayed and the Github authorization flow for Zerynth will be started. It is usually needed to login to Github with the user credentials and authorize Zerynth. Upon correct authorization the Zerynth backend will associate the Github account with the user Zerynth account. In the second step the Github repository to host the library on must be chosen from the available ones. Some information on the library must be given in this step, namely: the library title: will be displayed in the Library Manager the library description: a short text that will be displayed in the Library Manager and that will be indexed to ease searching for libraries a list of keywords to tag the library the version of the library that will be made available after publishing a descriptive text for the version (usually a list of changes, bugfixes and improvements) If the library has already been published, some of the required field will be automatically filled. The third step is a recap of what is going to happen during the publishing; read it carefully and confirm the repository, the project and the version of the library! In the last step the selected Github repository is cloned, the project to be published is copied in and the changes are committed and pushed back to the master branch. Also, a new Github release is created with version and description given in step 2. As soon as the Zerynth backend discovers the new release, the library will be made available to all the Zerynth users. Important \u00b6 In order for the users of your library to have a better programming experience, we strongly suggest to add examples and documentation. Please refer here for more details. Creating Custom Virtual Machines \u00b6 Zeryth Studio allows creating custom Virtual Machines for PCBs and devices based on supported microcontrollers (At the moment only ESP32 has the support for custom VMs, more architectures will be added soon). The customization process involves editing a template file where many settings like pin mapping and onboard peripherals can be specified. More info can be found here and here .","title":"Getting Started"},{"location":"zerynth-os/Getting%20Started/#getting-started","text":"This section introduces you to the main features of Zerynth and provides you a step-by-step guide to get started with the system. Take a look at the video below to see Zerynth in action!","title":"Getting Started"},{"location":"zerynth-os/Getting%20Started/#create-a-zerynth-user-account","text":"It is necessary to create a User Account to access Zerynth. To register a new Zerynth Account or to Log in an existing one, you can proceed manually ( email , username and password ) or you can automatically register/login with social credentials ( Facebook and Google+ ).","title":"Create a Zerynth User Account"},{"location":"zerynth-os/Getting%20Started/#note","text":"For Manual Registration: check your email and verify your new account by clicking on the link provided in the confirmation email","title":"Note"},{"location":"zerynth-os/Getting%20Started/#warning","text":"The first time you create a user account or if you have sign-in issues, a restart of Zerynth Studio might be necessary","title":"Warning"},{"location":"zerynth-os/Getting%20Started/#connect-register-and-virtualize-your-device","text":"To make a device usable with Zerynth, you need to Connect , Register , and \u201cVirtualize\u201d it. According to the platform used and to the connected device, the user has to install the related driver to make the machine able to recognize and exchange data with the board.","title":"Connect, Register and Virtualize your Device"},{"location":"zerynth-os/Getting%20Started/#warning_1","text":"Procedure to install drivers, if needed, is reported device by device in Supported Devices . The Registration phase is the process of retrieving the device info to allow the Zerynth backend to build its specific virtual machine. If the device has never been connected before, by clicking the \u201cZ\u201d button, the registration dialog, shown above, is displayed. To register a new device, you can follow these steps: connect your device to the machine. The \u201cDevices Management Widget\u201d notifies the devices list update with a yellow blink; select the device from the dropdown menu; click on the \u201cZerynth\u201d button. Zerynth Studio will guide you in the entire process through info messages displayed in the log console section at the bottom of the screen.","title":"Warning"},{"location":"zerynth-os/Getting%20Started/#note_1","text":"\u201cPowered by Zerynth\u201d devices are accompained by a redeemable code that can be inserted in the above window and exchanged for a free virtual machine license.","title":"Note"},{"location":"zerynth-os/Getting%20Started/#warning_2","text":"Some devices require to be set in Device Firmware Update (DFU) mode in order to allow their registration and the flashing of the Zerynth Virtual Machine. Detailed guides on how to put them in DFU mode is available in the Supported Devices section of the documentation. Once registration has been performed, the user is given the option to create a Virtual Machine for the registered device by clicking again the \u201cZ\u201d button.","title":"Warning"},{"location":"zerynth-os/Getting%20Started/#note_2","text":"A device can always be registered again with the dedicated dialog button. In the figure below, after clicking the \u201cCreate\u201d button, the user can select one available of different virtual machines compatible with the target device choosing the licenses (Starter/Premium), the real time operating system from those supported for the target device, and (for Premium licenses only) the features to be included in the virtual machine (FOTA, Power Saving, Secure Firmware, etc.).","title":"Note"},{"location":"zerynth-os/Getting%20Started/#note_3","text":"Some devices cannot be recognized automatically; for these devices, the dialog provides some more options to be specified before the actual registration/virtualization can take place.","title":"Note"},{"location":"zerynth-os/Getting%20Started/#warning_3","text":"The \u201cAvailable\u201d column in the table shows the possibility to create the related virtual machine according to the user asset. The created Virtual Machine can now be virtualized (i.e. burned on the device). The \u201cVirtualization\u201d is the process of installing the Zerynth Virtual Machine by flashing it on a device. By clicking the \u201cVirtualize\u201d button, the user can select the Zerynth Virtual Machine to be installed in his device choosing from those created.","title":"Warning"},{"location":"zerynth-os/Getting%20Started/#note_4","text":"Zerynth Studio toolbar allows to \u201cVirtualize\u201d the selected device.","title":"Note"},{"location":"zerynth-os/Getting%20Started/#zerynth-devices","text":"The supported devices are grouped into Physical Devices (the ones physically connected to the local machine) and Virtual Devices (the devices usable with Zerynth). The Zerynth \u201cVirtual Devices\u201d feature allows to implement and develop the user application verifying the code for all the supported devices, without having them physically connected to the local machine. Once the desired supported device (virtual or physically connected) is selected, Zerynth Studio displays all collected info related to the chosen device in 2 different dialogs: Device Info Window ; Device Pinmap Window . The Device Info Window shows detailed information about the device, including the Flash/Ram size and the port for serial communication.","title":"Zerynth Devices"},{"location":"zerynth-os/Getting%20Started/#warning_4","text":"Some boards cannot be automatically recognized by Zerynth Studio and need a disambiguation. In this case the system asks you to indicate the device type. You can always revert this choice by clicking on the \u201cForget\u201d button. Finally, the Device Pinmap window provides the pinout of the selected device, along with the hardware features and peripherals available on each pin. Thanks to the Device Pinmap window it is also possible to understand how the device embedded peripherals are grouped and/or multiplexed. This allows to better understand how to use each specific hardware feature in the Zerynth Python scripts without having hardware conflicts.","title":"Warning"},{"location":"zerynth-os/Getting%20Started/#clone-an-example-and-start-with-zerynth-python-scripts","text":"Zerynth Studio includes many examples to get started: from the most basic ones to the examples related to the installed libraries. Zerynth examples cannot be edited, they are \u201cread only\u201d folders and they can be used as reference for the design of new projects. Zerynth examples can be cloned in just few clicks: open the Examples browser by clicking on the \u201clight bulb\u201d icon on the left panel of Zerynth Studio; select the example you prefer and clone it by clicking on the dedicated button; At this stage Zerynth converts the example into a new project giving you the possibility to edit the Title , the Description and the Folder of your new project project; click on \u201cCreate\u201d and you are done!","title":"Clone an example and start with Zerynth Python Scripts"},{"location":"zerynth-os/Getting%20Started/#warning_5","text":"Remember that Zerynth does not allow two projects to have the same Folder","title":"Warning"},{"location":"zerynth-os/Getting%20Started/#verify-and-uplink-a-zerynth-project","text":"The buttons on the upper left toolbar allow you to verify and uplink a script into a device. To verify a project click on the Verify icon to check your script for errors. The errors will be reported in the console and in the code editor with helpful tooltips. To Uplink your verified project into a Virtualized device just click the Uplink icon and follow the Zerynth Studio messages.","title":"Verify and Uplink a Zerynth Project"},{"location":"zerynth-os/Getting%20Started/#warning_6","text":"Some devices require to be reset during the uplink operation in order to write in flash the bytecode","title":"Warning"},{"location":"zerynth-os/Getting%20Started/#develop-your-first-zerynth-project","text":"To create your First Zerynth Project from scratch you have to do just a few steps: click on the button \u201cBrowse Project\u201d; click on \u201cNew Project\u201d; Decide a project title and the project folder, and write an optional description; click on the \u201cCreate\u201d button. Once you click on the \u201cCreate\u201d button, the new Zerynth Project opens and you will be prompted with the editor of the \u201cmain.py\u201d file. The main is where the principal Zerynth code is written in Python: here is where you develop the logic of your script. If you wish to add more files to the Zerynth project you can easily do it. In Zerynth you can create html, json, txt, bin files and save them together with the bytecode on the device flash memory. You can also create more .py files where you can develop other parts of your code like modules and functions to be used in the main.py file. To add new files to a Zerynth project, follow these steps: click on \u201cBrowse Project\u201d; click on \u201cAdd file\u201d ; after naming the file click on \u201cCreate\u201d; write the code within the empty field in the editor; You can also add a new folder, delete a selected file, refresh the project folder, etc. by clicking the icon on the right of the \u201cProject view\u201d bar.","title":"Develop your First Zerynth Project"},{"location":"zerynth-os/Getting%20Started/#note_5","text":"When you add a .py file containing some code to be used in the main.py file (e.g. a file named helpers.py ), you have to import it by adding the line import helpers in the main.py file. Thus, you can call functions located in the helpers.py file by using the following syntax: helpers.fun_name(fun_attribute1, fun_attribute2, ...)","title":"Note"},{"location":"zerynth-os/Getting%20Started/#note_6","text":"If you want to save the template.html in the device flash as resource to be used by a specific module like the Zerynth App library, you have to use the new_resource() function defining the following code in the main.py file: new_resource(\"template.html\")","title":"Note"},{"location":"zerynth-os/Getting%20Started/#import-a-zerynth-package-into-a-project","text":"Packages import syntax is very simple: Official Packages are imported with: from c import m where c is the name of the package and m is the name of a module inside the package. (e.g. from cc3000 import cc3000 or from cc3000 import cc3000_tiny ). Community Packages are imported with: from community.b.c import m where b is the namespace of the package, c is the package name and m is the name of a module (e.g. from community.floyd.rtttl import rtttl ) The import autocomplete feature of Zerynth Studio makes the task of importing modules even easier: as soon as \u201cfrom\u201d or \u201cimport\u201d is typed in the code editor, the autocomplete box lists all the matching modules. The Zerynth Programming Guide and various programming examples are also provided. For both the Official Library and the Community Library, a complete documentation is available and if the package contains usage examples, they can be found under the examples tab. Finally, if you need help with Python, here you can find a good overview on Python 3 with simple and exhaustive examples. You can always post your questions and doubts on the Zerynth Community Forum logging-in with your Zerynth Account.","title":"Import a Zerynth Package into a Project"},{"location":"zerynth-os/Getting%20Started/#zerynth-studio-updates","text":"Zerynth Studio has two different update mechanisms: major system release rolling updates When a new major version of Zerynth is released a notification \u201cSystem Update!\u201d will appear in the footer area of Zerynth Studio. By clicking the notification, the new version will be downloaded and installed. After a restart, the new version will be selected and launched. However, the previous version is still there and can be selected during the launch phase. If a previous version is not needed anymore, it can be deleted from the \u201cPreferences\u201d menu. On the contrary, rolling updates do not change the system version but just a group of packages. Rolling updates are notified by the \u201cRolling update\u201d label in the footer area of Zerynth Studio. By clicking the notification, the list of updated packages and a detailed changelog are displayed. If accepted, a rolling update will download the selected packages only and will unpack them. After a restart, the launcher will take care of finishing the update and start Zerynth Studio.","title":"Zerynth Studio updates"},{"location":"zerynth-os/Getting%20Started/#zerynth-and-git","text":"Zerynth Studio offers the possibility to store your projects on our backend, in a private git repository. Such feature is accessible from the Project View in the left panel by clicking the git \u201ccode-branch\u201d icon. The first time a project is pushed to our backend, the \u201cCreate repository\u201d option must be selected. From there on, the project view changes, showing a footer with information about the current remote/branch, the current tag if present, the number of modified files (identified by a bullet) and the status of the local repository with respect to the remote repository. The project git repository is automatically configured with a remote called \u201czerynth\u201d pointing to our backend. All git operations accessible from Zerynth Studio will operate on that remote. It is however possible to manually configure the project local repository to use different remotes (for example GitHub or GitLab). However, such configuration is up to the user. Git operations not featured in Zerynth Studio (for example \u201cmerge\u201d), can be performed manually using git from the command line.","title":"Zerynth and Git"},{"location":"zerynth-os/Getting%20Started/#search-and-install-community-libraries","text":"Zerynth allows searching and installing libraries created by Zerynth users and hosted on GitHub. Libraries can be searched and installed from the Zerynth Library Manager Section (\u201cpuzzle\u201d icon) in the left toolbar. The latest version is displayed and options to update or downgrade the library are present. The results of the search are shown in the left column that displays a brief description of the libraries together with the available version. By clicking \u201cInstall\u201d or \u201cUpdate\u201d the library can be easily added to the system.","title":"Search and Install Community Libraries"},{"location":"zerynth-os/Getting%20Started/#publishing-community-libraries","text":"Zerynth Studio allows publishing your projects as community libraries that can be installed by everyone else in the Zerynth community. To publish a project, select the \u201cPublish\u201d option for the currently opened project to fire up the publish wizard. The first step is needed to get the user permission to manage the Github repository where the library will be hosted. In order to do so, a popup window will be displayed and the Github authorization flow for Zerynth will be started. It is usually needed to login to Github with the user credentials and authorize Zerynth. Upon correct authorization the Zerynth backend will associate the Github account with the user Zerynth account. In the second step the Github repository to host the library on must be chosen from the available ones. Some information on the library must be given in this step, namely: the library title: will be displayed in the Library Manager the library description: a short text that will be displayed in the Library Manager and that will be indexed to ease searching for libraries a list of keywords to tag the library the version of the library that will be made available after publishing a descriptive text for the version (usually a list of changes, bugfixes and improvements) If the library has already been published, some of the required field will be automatically filled. The third step is a recap of what is going to happen during the publishing; read it carefully and confirm the repository, the project and the version of the library! In the last step the selected Github repository is cloned, the project to be published is copied in and the changes are committed and pushed back to the master branch. Also, a new Github release is created with version and description given in step 2. As soon as the Zerynth backend discovers the new release, the library will be made available to all the Zerynth users.","title":"Publishing community libraries"},{"location":"zerynth-os/Getting%20Started/#important","text":"In order for the users of your library to have a better programming experience, we strongly suggest to add examples and documentation. Please refer here for more details.","title":"Important"},{"location":"zerynth-os/Getting%20Started/#creating-custom-virtual-machines","text":"Zeryth Studio allows creating custom Virtual Machines for PCBs and devices based on supported microcontrollers (At the moment only ESP32 has the support for custom VMs, more architectures will be added soon). The customization process involves editing a template file where many settings like pin mapping and onboard peripherals can be specified. More info can be found here and here .","title":"Creating Custom Virtual Machines"},{"location":"zerynth-os/Installation%20Guide/","text":"Installation Guide \u00b6 This tutorial explains how to install Zerynth Studio, the Zerynth Development environment that allows you approaching the embedded world in few clicks. Download Zerynth \u00b6 Download the latest Zerynth Studio Release according to your platform from the Zerynth Download page . Note \u00b6 Zerynth works only for 64-bit platform Start Zerynth Installation and Agree the Term of Service \u00b6 To Start the installation, according to your platform, you can: Double click on the executable file for installing Zerynth on Microsoft Windows Open and run the Disk image (.dmg) file for installing Zerynth on Mac OS Extract the \u201ctar.xz\u201d archive and run the \u201c./zerynth\u201d command from the terminal to install Zerynth on Linux Warning \u00b6 Only for Microsoft Windows platform : if the alert message for \u201callowing unknown publisher to make changes to this computer\u201d appears click on \u201cYes\u201d option Once the installation has started, the window below will appear and you are asked to agree to the \u201cLicense and Service Terms\u201d to continue the operation Note \u00b6 To read all the agreement conditions, you can click on provided links Then, after accepting the agreement conditions, you can choose between two options to complete the installation: online and offline. The online installation is recommended. The Offline Installation meets the needs of educational and training courses, workshops or places with network and internet issues. It enables you downloading an offline package repository and share it with other people, to facilitate and speed up the installation operations. If you choose the online installation, you can select which version of Zerynth Studio you want to install. By clicking the install button, the required files are downloaded from Zerynth online repository and automatically installed. If you choose the Offline Installation you need to have downloaded also the offline package repository in advance related to your platform (Windows, Mac, Linux), from the Zerynth Download page . Normal Installation and Expert mode \u00b6 To reduce the amount of files downloaded during the installation process, the installer will let you choose which of the supported architectures to install. By clicking \u201cInstall\u201d none of the available architectures will be downloaded and you will be prompted to download the needed dependencies whenever Zerynth Studio recognize a new board. By choosing the \u201cExpert Mode\u201d you will be able to select the architectures you wish to download right now, but you will still be prompted to install the needed dependencies if you connect a board with an architecture not included in the already downloaded ones. Unpack and Install all The Zerynth Packages \u00b6 Now the system unpacks and installs all the required packages creating a working instance on your local machine; you have to wait few minutes to complete the Zerynth installation. Launch Zerynth \u00b6 At the end of the process, Zerynth will be ready to work on your machine. Enjoy it! Now you can choose the programming experience you prefer by opting for an Integrated Development Environment ( Zerynth Studio ) or, alternatively, for your beloved Command Line Interface ( Zerynth Toolchain ). Zerynth Studio is a browser-based integrated development environment that runs on Windows, Linux and Mac. Through Zerynth you can manage your boards and program them in Python or hybrid C/Python. On subsequent restarts, Zerynth Studio will ask you which version you want to start (by selecting it from the available options) or will give you the possibility to install again (by clicking the Reinstall button) this or other versions of the software. In this documentation you can also find a Getting Started section that will help you to discover the features of the Zerynth. The Zerynth Toolchain (ZTC) is a command line interface (CLI) tool that allows managing all the aspects of the typical Zerynth workflow. You can find all the documentation in the Zerynth Toolchain section If you have any problem installing Zerynth Studio please tell us using our Zerynth Forum .","title":"Installation Guide"},{"location":"zerynth-os/Installation%20Guide/#installation-guide","text":"This tutorial explains how to install Zerynth Studio, the Zerynth Development environment that allows you approaching the embedded world in few clicks.","title":"Installation Guide"},{"location":"zerynth-os/Installation%20Guide/#download-zerynth","text":"Download the latest Zerynth Studio Release according to your platform from the Zerynth Download page .","title":"Download Zerynth"},{"location":"zerynth-os/Installation%20Guide/#note","text":"Zerynth works only for 64-bit platform","title":"Note"},{"location":"zerynth-os/Installation%20Guide/#start-zerynth-installation-and-agree-the-term-of-service","text":"To Start the installation, according to your platform, you can: Double click on the executable file for installing Zerynth on Microsoft Windows Open and run the Disk image (.dmg) file for installing Zerynth on Mac OS Extract the \u201ctar.xz\u201d archive and run the \u201c./zerynth\u201d command from the terminal to install Zerynth on Linux","title":"Start Zerynth Installation and Agree the Term of Service"},{"location":"zerynth-os/Installation%20Guide/#warning","text":"Only for Microsoft Windows platform : if the alert message for \u201callowing unknown publisher to make changes to this computer\u201d appears click on \u201cYes\u201d option Once the installation has started, the window below will appear and you are asked to agree to the \u201cLicense and Service Terms\u201d to continue the operation","title":"Warning"},{"location":"zerynth-os/Installation%20Guide/#note_1","text":"To read all the agreement conditions, you can click on provided links Then, after accepting the agreement conditions, you can choose between two options to complete the installation: online and offline. The online installation is recommended. The Offline Installation meets the needs of educational and training courses, workshops or places with network and internet issues. It enables you downloading an offline package repository and share it with other people, to facilitate and speed up the installation operations. If you choose the online installation, you can select which version of Zerynth Studio you want to install. By clicking the install button, the required files are downloaded from Zerynth online repository and automatically installed. If you choose the Offline Installation you need to have downloaded also the offline package repository in advance related to your platform (Windows, Mac, Linux), from the Zerynth Download page .","title":"Note"},{"location":"zerynth-os/Installation%20Guide/#normal-installation-and-expert-mode","text":"To reduce the amount of files downloaded during the installation process, the installer will let you choose which of the supported architectures to install. By clicking \u201cInstall\u201d none of the available architectures will be downloaded and you will be prompted to download the needed dependencies whenever Zerynth Studio recognize a new board. By choosing the \u201cExpert Mode\u201d you will be able to select the architectures you wish to download right now, but you will still be prompted to install the needed dependencies if you connect a board with an architecture not included in the already downloaded ones.","title":"Normal Installation and Expert mode"},{"location":"zerynth-os/Installation%20Guide/#unpack-and-install-all-the-zerynth-packages","text":"Now the system unpacks and installs all the required packages creating a working instance on your local machine; you have to wait few minutes to complete the Zerynth installation.","title":"Unpack and Install all The Zerynth Packages"},{"location":"zerynth-os/Installation%20Guide/#launch-zerynth","text":"At the end of the process, Zerynth will be ready to work on your machine. Enjoy it! Now you can choose the programming experience you prefer by opting for an Integrated Development Environment ( Zerynth Studio ) or, alternatively, for your beloved Command Line Interface ( Zerynth Toolchain ). Zerynth Studio is a browser-based integrated development environment that runs on Windows, Linux and Mac. Through Zerynth you can manage your boards and program them in Python or hybrid C/Python. On subsequent restarts, Zerynth Studio will ask you which version you want to start (by selecting it from the available options) or will give you the possibility to install again (by clicking the Reinstall button) this or other versions of the software. In this documentation you can also find a Getting Started section that will help you to discover the features of the Zerynth. The Zerynth Toolchain (ZTC) is a command line interface (CLI) tool that allows managing all the aspects of the typical Zerynth workflow. You can find all the documentation in the Zerynth Toolchain section If you have any problem installing Zerynth Studio please tell us using our Zerynth Forum .","title":"Launch Zerynth"},{"location":"zerynth-os/demo-projects/Demo%20Projects/","text":"Written with StackEdit .","title":"Demo Projects"},{"location":"zsdk/","text":"ZSDK \u00b6","title":"Index"},{"location":"zsdk/#zsdk","text":"","title":"ZSDK"}]}